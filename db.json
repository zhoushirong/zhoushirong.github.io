{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/analytics","path":"js/analytics","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner2.jpg","path":"css/images/banner2.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner@3x2.jpg","path":"css/images/banner@3x2.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner@3x2.png","path":"css/images/banner@3x2.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"06af8c456d0b28236669ddfffd0a0353f1d67810","modified":1617067920314},{"_id":"source/_draft/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1617067920314},{"_id":"source/favicon.ico","hash":"182d666465c598213c3239906fdc7508bf91c40d","modified":1617067920328},{"_id":"source/_draft/koa.md","hash":"18e0a83e2b418e845dc10b26d22a52195a81cf35","modified":1617067920315},{"_id":"source/_draft/jsBridge.md","hash":"aae0a4a23bf1c2d5dc22b95141c918011a3b8bd9","modified":1617067920315},{"_id":"source/_draft/tcp-ip.md","hash":"5d36ad7693ec353c07d310a593da2e5d84904364","modified":1617067920315},{"_id":"source/_draft/mysql3.md","hash":"ee632a4e6dd0438a041b0b3cc299c41f39b12d01","modified":1617067920315},{"_id":"source/_posts/cdn.md","hash":"532c1839c6080cb5ffa1c0c7ba09a0d00ea5adf5","modified":1617497429279},{"_id":"source/_posts/browser-progress.md","hash":"b9bca9ec0c2712bc5596931a6eec052044bf7643","modified":1617067920315},{"_id":"source/_posts/brew.md","hash":"25b2f3077708678fcfdab13e6b72c9a3036d3976","modified":1617067920315},{"_id":"source/_posts/cmd.md","hash":"0549e9dbf2ad4dcf1ad4e187420fb6796adc39f0","modified":1617067920316},{"_id":"source/_posts/code1.md","hash":"45dd8d749e0ce147856ce3e3826f0ccdea082e5f","modified":1617067920316},{"_id":"source/_posts/compile.md","hash":"4c2dc1bc6c5cf2db6e22b136bdad6d902c35fd32","modified":1617067920316},{"_id":"source/_posts/csrf.md","hash":"ee04def666d1d4d153b0462b9cd35f46d0e3ad85","modified":1617067920316},{"_id":"source/_posts/defer.md","hash":"561e59c3f4bbd7ec1cb6af3ff493d1e331602647","modified":1617067920316},{"_id":"source/_posts/data-bind.md","hash":"550117e917352806df484e03b860c209ab7d84bf","modified":1617067920316},{"_id":"source/_draft/website.md","hash":"1ac896d493744b9637faa1793427d25e9d35413c","modified":1617433767271},{"_id":"source/_posts/event.md","hash":"2ad8161de1cc650056bb4957ec15dbfd1e9d549b","modified":1617067920317},{"_id":"source/_posts/dynamic.md","hash":"92bbf28154bc72c7d9daa37d2df25c07d722b407","modified":1617067920317},{"_id":"source/_posts/dns.md","hash":"9f652f5ff81862d4a225375e27be7d4a9635e26f","modified":1617067920316},{"_id":"source/_posts/getrect.md","hash":"d8e5465dc5fec2951dcce1376dc37fe792756b51","modified":1617067920317},{"_id":"source/_posts/git.md","hash":"36f9ef7fa40ee0171c6525f91eb469991848030c","modified":1617067920317},{"_id":"source/_posts/gulp.md","hash":"7f96f23c17125445b982cf09948757281907db8c","modified":1617067920317},{"_id":"source/_posts/host-ip.md","hash":"83879336ba46abf071adcdd15cc3a25121b369bb","modified":1617067920317},{"_id":"source/_posts/http-headers.md","hash":"2e7bbe4485c16a2700edc8cd699d50490d31e87e","modified":1617067920318},{"_id":"source/_posts/http.md","hash":"94798a0d0098982a8b4869e0307a1d467e79469f","modified":1617067920318},{"_id":"source/_posts/http2.md","hash":"1bb46d0a5693554fe4c50887d2f6fbf24e9a49e7","modified":1617067920318},{"_id":"source/_posts/http3.md","hash":"2e49d7dccde5e8561abcbe99a78c73a6bee01523","modified":1617067920318},{"_id":"source/_posts/iphonex.md","hash":"24499601a76e7f4f6215ae451f930037d9eb7ca7","modified":1617067920319},{"_id":"source/_posts/https.md","hash":"ef3d6c4cb2f0d6c6f28c2152d0d0ae34e455936c","modified":1617067920318},{"_id":"source/_posts/item2.md","hash":"6c13754d09e49cdfd553d9b709162b87597ba8b5","modified":1617067920319},{"_id":"source/_posts/js1.md","hash":"493854d2b22cb10a389428fa37d7f70d52cc47b7","modified":1617067920319},{"_id":"source/_posts/javapath.md","hash":"f8889b4fb02dab0f1098d3a61fde4ba0571d9dd1","modified":1617067920319},{"_id":"source/_posts/js2.md","hash":"d5a5fdcd16f353e3037a5a0d6f4b5c0e97c93ba1","modified":1617067920319},{"_id":"source/_posts/jsencrypt.md","hash":"adfc3e77b1619d6aa426c24c993b2b9f8d432128","modified":1617067920319},{"_id":"source/_posts/linux.md","hash":"bc4ad01512e5ef7713376026fe78afabfbe4f4b6","modified":1617067920319},{"_id":"source/_posts/linux1.md","hash":"4fd2ac0e4fa6208ae19204a63308be58b9256c93","modified":1617067920320},{"_id":"source/_posts/linux2.md","hash":"2ea02248179e4b9f942786cc0b8053c96f39983d","modified":1617067920320},{"_id":"source/_posts/linux3.md","hash":"83801e2d2bd8d6a77029bf4f7957677a212e2588","modified":1617067920320},{"_id":"source/_posts/linux4.md","hash":"63c3681cfce9d42d182a7404f8a4987400dae457","modified":1617067920320},{"_id":"source/_posts/long-connect.md","hash":"8953178f8d6a8b8bb82944144bb36b35d431c705","modified":1617067920320},{"_id":"source/_posts/mac-terminal.md","hash":"9241d90120c7128598c4c5574c7830e6682d1629","modified":1617067920321},{"_id":"source/_posts/micro-front.md","hash":"c0668afe42c97bab24129ce39f850b5b0854b0d9","modified":1617067920321},{"_id":"source/_posts/mysql.md","hash":"a7b66b35806cc9e9e103822f6320546356970e55","modified":1617067920321},{"_id":"source/_posts/nginx.md","hash":"1c491be26fb060fa6c4896dbcac2cce2d4fbf608","modified":1617067920321},{"_id":"source/_posts/node-progress.md","hash":"955995b03a40683fa36e8ae984fb445717d97631","modified":1617067920321},{"_id":"source/_posts/mysql2.md","hash":"25df0064b93895955a76cfe0d499b6b56b9d69c8","modified":1617067920321},{"_id":"source/_posts/nodejs.md","hash":"9a5acd6cfaaab0a3b389d427f1527fc6e2cf5728","modified":1617067920322},{"_id":"source/_posts/nodejs2.md","hash":"bbe309b8c9d9c44572c34ce15e8e441cfb1352ff","modified":1617067920322},{"_id":"source/_posts/nodejs3.md","hash":"88f446b6b93a714dfd93936bd3b2c7f8c538452e","modified":1617067920322},{"_id":"source/_posts/npm-lock.md","hash":"170b04cb8f2de61f1e6c3d784be5b881d063f6ca","modified":1617067920322},{"_id":"source/_posts/palindrome.md","hash":"0ad5da3126469be5dc046b66d258feef312fba19","modified":1617067920323},{"_id":"source/_posts/object.md","hash":"b3526e0c34c44752abefab9dcad425362998c1a9","modified":1617067920322},{"_id":"source/_posts/object2.md","hash":"8e8ca969f7722a88252561b89f4f4db92bb63ce9","modified":1617067920323},{"_id":"source/_posts/oracle.md","hash":"8fbd9a772eabfd34da2bd36adf6c64041d0af392","modified":1617067920323},{"_id":"source/_posts/performance.md","hash":"c95c2bed57e497c3a270c94345d0c18ad7929114","modified":1617067920323},{"_id":"source/_posts/pm2.md","hash":"392a3dc4818f829c21531c6581bf4eb620277aae","modified":1617067920323},{"_id":"source/_posts/proxy-error.md","hash":"5ddc592bd4d659a677c7f3f0673a5789606bfa93","modified":1617067920323},{"_id":"source/_posts/qa1.md","hash":"b4b4b1bdb8f95943ee7d9a0667d23b1b5aebb031","modified":1617067920324},{"_id":"source/_posts/qa2.md","hash":"0040b615404523b41517e18c9e9ed95668a462ab","modified":1617067920324},{"_id":"source/_posts/qa3.md","hash":"9c4addf20c282830f39564a511f3f2dcf66aa3b3","modified":1617067920324},{"_id":"source/_posts/qa4.md","hash":"de80f4a14d1ca9ea512454ba4652d6bd2cd6e262","modified":1617067920324},{"_id":"source/_posts/qa5.md","hash":"d2e18df902139d75fbec732658354799fdc9f280","modified":1617067920324},{"_id":"source/_posts/qa6.md","hash":"e81f9930069f992517dfc4d10836f99ef5c1d4be","modified":1617067920324},{"_id":"source/_posts/qa7.md","hash":"3ae6f513250f973f4b1f90b5877b54761469ca5e","modified":1617067920325},{"_id":"source/_posts/react.md","hash":"58c2c8c7512ade9dd7dd56fc0fd41908f971d774","modified":1617067920325},{"_id":"source/_posts/shell1.md","hash":"cc19bc010ff3cddfc2cf04d699f6d42db1bf2b11","modified":1617067920326},{"_id":"source/_posts/redis.md","hash":"bed2b307c9fb7c73235fed96ca80b17e1de43f1b","modified":1617067920325},{"_id":"source/_posts/rpc.md","hash":"61f4ae873c9a59f94ec89cf9b1d694a72b5d1b8d","modified":1617067920325},{"_id":"source/_posts/react16.md","hash":"7f9377900a6e4ca4e2cf44f9ff39aa1280f8474d","modified":1617067920325},{"_id":"source/_posts/svn.md","hash":"826e430c7cb959082ee4f2db497b09a5692391e6","modified":1617067920326},{"_id":"source/_posts/ssh.md","hash":"ef9c9b4ad7036e54925e47f351f516e60db6afad","modified":1617067920326},{"_id":"source/_posts/vim.md","hash":"0d75c268eead6496f8847f8ece5fb8e29654a5af","modified":1617067920326},{"_id":"source/_posts/virtual-dom.md","hash":"4b7911bd8b8280641c8059db819de806396680d7","modified":1617067920326},{"_id":"source/_posts/vue-ssr.md","hash":"722c96c85847d86ee590773018827674a116d31c","modified":1617067920326},{"_id":"source/_posts/vue1.md","hash":"d59f3568dd4e3459c7fe86906d0c665624e68285","modified":1617067920327},{"_id":"source/_posts/vue2.md","hash":"7d6ce56f57ec86f4272146c1dc31f0e89f391179","modified":1617067920327},{"_id":"source/_posts/vue3.md","hash":"227879e8147518e238d0ca1b80469890ae73d019","modified":1617067920327},{"_id":"source/_posts/weakSet.md","hash":"329ec91643fd68be7e08eaa5d159013c200bec2b","modified":1617067920327},{"_id":"source/_posts/webpack.md","hash":"e1bc49761ad82a4460a0a40fae88d526e7d47142","modified":1617067920327},{"_id":"source/_posts/xcode.md","hash":"112d22719d65d222bcb872d30f8394288fa281a7","modified":1617067920327},{"_id":"source/_posts/xcx.md","hash":"f87ba557cbea4e2699eec626733b8865e35fe0c0","modified":1617067920328},{"_id":"source/_posts/xcx2.md","hash":"f5c0c732564a61508d6cbe78d96f48e13032f228","modified":1617067920328},{"_id":"source/_posts/xss.md","hash":"e033a44afbe61d4aef55be033d55669b21a5a95f","modified":1617067920328},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1617067920329},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1617067920329},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1617067920329},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1617067920329},{"_id":"themes/landscape/_config.yml","hash":"05840948503d7a1eee80e30b809a7fe9ca523ca8","modified":1617067920329},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1617067920330},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1617067920335},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1617067920330},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1617067920330},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1617067920330},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1617067920330},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1617067920330},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1617067920330},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1617067920330},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1617067920331},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1617067920331},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1617067920331},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"c9fe5d6ee9612095a6b7c6d4f38faaaf8153d0e2","modified":1617067920331},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1617067920334},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1617067920334},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1617067920335},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1617067920335},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1617067920335},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1617067920335},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1617067920335},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1617067920335},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1617067920331},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"45bcfd495c5688e45cebe4d1006e4e9d846332f0","modified":1617067920331},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1617067920331},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1617067920332},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"9c4c6a9196000213d5a96c9faf6ea88da00f6ca8","modified":1617067920332},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1617067920332},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"95fe34d55d4a7ce4587359c17d86820f29a07618","modified":1617067920332},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1617067920332},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"961751ed6bd22d3c9ba3147e9907a1e060b7b7a1","modified":1617067920332},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"88047b2e5af151a1e42e683e00456ffdedf99bd9","modified":1617067920332},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1617067920334},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1617067920333},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1617067920334},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"3baa5aa402d4547b98c90e312a62be5837dc93a0","modified":1617067920334},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1617067920334},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1617067920334},{"_id":"themes/landscape/source/css/_extend.styl","hash":"64cdff37714fc89ca112389f1cac6b7fb8bd0eb4","modified":1617067920336},{"_id":"themes/landscape/source/css/_variables.styl","hash":"96c4a8a6c2f68fa21e17bb06fb5139223d450c62","modified":1617067920338},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1617067920371},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1617067920371},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1617067920371},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1617067920371},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1617067920371},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1617067920371},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1617067920373},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1617067920372},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1617067920373},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1617067920373},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1617067920333},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1617067920333},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1617067920374},{"_id":"themes/landscape/source/js/analytics","hash":"a58355dd8102d9e984050695a1c31445b530b5af","modified":1617067920374},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1617067920333},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1617067920333},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1617067920333},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1617067920333},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1617067920336},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"b871be0ad270d3d6736c2c4247f18360501887ad","modified":1617067920336},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"a6cc2f53ecd236f7e11f8d5e7b279d1471c0a29e","modified":1617067920336},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"c8e8df20293ad0819f9e8b735d6457735d5aa35b","modified":1617067920336},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"922817bfedb2386c4c9cdc1a24f04bfcabd3b33a","modified":1617067920336},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"b04b9d3a82f3eeb6766269d6dd9ffb7ba6b99031","modified":1617067920337},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"fa58ac79d5bfe414e0f7ad756e4f72069df44cac","modified":1617067920337},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1617067920337},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"39fe2921bca0e399946436c0ccab9d61414b0d86","modified":1617067920337},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1617067920337},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1617067920337},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1617067920337},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1617067920338},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1617067920338},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1617067920372},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1617067920372},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1617067920372},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1617067920372},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1617067920372},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1617067920373},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1617067920341},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1617067920340},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1617067920340},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1617067920342},{"_id":"themes/landscape/source/css/images/banner2.jpg","hash":"7391bbe277fcd97b90d405b3d7eb86c328cd54c0","modified":1617067920344},{"_id":"themes/landscape/source/css/images/banner@3x2.jpg","hash":"02bdbbb34a90c62e8590c5a72597995e38e08eb1","modified":1617067920355},{"_id":"themes/landscape/source/css/images/banner@3x2.png","hash":"a6860aba9fc579e215e9a51690a48ee8464f78f1","modified":1617067920370},{"_id":"public/archives/2016/03/index.html","hash":"09af5a6fdbfc0fbd57d7b0667fa9e61e02d7dcd8","modified":1617497447512},{"_id":"public/archives/2016/10/index.html","hash":"a51dad1bf506d8283bf17dcce8cef55bcc71d91e","modified":1617497447512},{"_id":"public/archives/2017/02/index.html","hash":"cff4789942de5c0d18d18c296d5844920a6e433f","modified":1617497447512},{"_id":"public/archives/2017/04/index.html","hash":"74e1549ac6696321e2f5f87baf77de5ac7dff8ea","modified":1617497447512},{"_id":"public/archives/2017/11/index.html","hash":"d417fb7841963f77c32fe1dfc664bd4418f66d7c","modified":1617497447512},{"_id":"public/archives/2017/12/index.html","hash":"48b923ceb1dfb755f8720f88dcaa3af295e9eb3b","modified":1617497447512},{"_id":"public/archives/2018/page/3/index.html","hash":"a3c6e68b9df723704d8acda8ca4c398aad06f8df","modified":1617497447512},{"_id":"public/archives/2018/01/index.html","hash":"b265f81644a08a072dc7b29e5f76399049cde975","modified":1617497447512},{"_id":"public/archives/2018/03/index.html","hash":"16a27f2eb230545e635cec23894bf4bf585787bf","modified":1617497447512},{"_id":"public/archives/2018/04/index.html","hash":"d2a9ea0c44b10a70d21c5ae99626f56e3b796e17","modified":1617497447512},{"_id":"public/archives/2018/05/index.html","hash":"e796ac610d6395a10226ec241654effec6d1558f","modified":1617497447512},{"_id":"public/archives/2018/06/index.html","hash":"18ffb70763cbdc01a6744d44d06603d5c6bfffe7","modified":1617497447512},{"_id":"public/archives/2018/07/index.html","hash":"4706eb974230e4b74f3db5432315645c014c93d4","modified":1617497447512},{"_id":"public/archives/2018/08/index.html","hash":"367d8f10b85fd7f70741dde432c211c4029029f2","modified":1617497447512},{"_id":"public/archives/2019/02/index.html","hash":"175824b2e5a6a93184053eb5f10546c83eb3133d","modified":1617497447512},{"_id":"public/archives/2019/03/index.html","hash":"4e4aa5b4414f5e1229499fde5881a420904df866","modified":1617497447512},{"_id":"public/archives/2019/04/index.html","hash":"6091538fef7379397437389d063360371d268618","modified":1617497447512},{"_id":"public/archives/2019/09/index.html","hash":"a6cbd1649b9df988460a13cd1e69d4152090f775","modified":1617497447512},{"_id":"public/archives/2020/page/2/index.html","hash":"f24131ecc259ff17b9d3d88d7428a24ed6060d02","modified":1617497447512},{"_id":"public/archives/2020/07/index.html","hash":"8a7c6e978bd43e1d424fabcb1630e4dbbd7a222c","modified":1617497447512},{"_id":"public/archives/2020/09/index.html","hash":"4681c62d4096d3d1040a00c03c90076ed18cfa73","modified":1617497447512},{"_id":"public/archives/2021/01/page/2/index.html","hash":"fcaab613ddc2aeca89aabde439646972cec8aa2a","modified":1617497447512},{"_id":"public/archives/2021/02/index.html","hash":"5b6eaae6a828402e5b6a5c743bd6677f58466c49","modified":1617497447512},{"_id":"public/archives/2021/04/index.html","hash":"8065d2a68ce94676a8c8352fa27b044a79639de5","modified":1617497447512},{"_id":"public/categories/笔记/page/3/index.html","hash":"e86e544686bff9cfb717de1de4bf7612ac141a87","modified":1617497447512},{"_id":"public/tags/brew/index.html","hash":"7a70b89942e3b6f78f99602f361bbd62fcecab7d","modified":1617497447512},{"_id":"public/tags/浏览器/index.html","hash":"0f77c36dde037a7c0f64a5f9c9d1de4681e1da39","modified":1617497447512},{"_id":"public/tags/browser/index.html","hash":"155b5f7ec87e2cb74e5b9e7ae70bfb192ae2e5ad","modified":1617497447512},{"_id":"public/tags/线程/index.html","hash":"db630e52a887d8d2e37b5e378a2807ea29bed610","modified":1617497447512},{"_id":"public/tags/进程/index.html","hash":"08547bf9f8ab7bc3a0b9cf9301383a5a528f4f82","modified":1617497447512},{"_id":"public/tags/事件循环/index.html","hash":"ca7da2ea0e204b70faa4d5e57f4f37a5c019925e","modified":1617497447512},{"_id":"public/tags/硬件加速/index.html","hash":"ee6838fad43171ef0c8e4ed3edbd0d26cb027c4c","modified":1617497447512},{"_id":"public/tags/cdn/index.html","hash":"7366782aac3de28451ab1b3a7fe4d96b8649461f","modified":1617497447512},{"_id":"public/tags/dns/index.html","hash":"317d0deb64f36fa8aa3508d7a53af01fd8c71b2a","modified":1617497447512},{"_id":"public/tags/cname/index.html","hash":"652c1f8c53a1bc837e06e2fdbd5b98e3eafeebae","modified":1617497447512},{"_id":"public/tags/面试/index.html","hash":"e740491f4c4a8524aeb08fab3e14b2029af25c9d","modified":1617497447512},{"_id":"public/tags/试题/index.html","hash":"743afe5b2dbcc981135e1a57c9dab4905462fddd","modified":1617497447512},{"_id":"public/tags/commonjs/index.html","hash":"115a64a8e586c36d8ecec39caa9522ce9ad95914","modified":1617497447512},{"_id":"public/tags/es6Module/index.html","hash":"4dc1f9e08fe1442bd555a67a9173be861e2f7359","modified":1617497447512},{"_id":"public/tags/函数式编程/index.html","hash":"e5134175e768317b090795ccd000edf52accaf4f","modified":1617497447512},{"_id":"public/tags/前端编译/index.html","hash":"4cd66239d0ebd836ea72548b26ae1ed8732da20b","modified":1617497447512},{"_id":"public/tags/compile/index.html","hash":"f4e769933976dea52f9356f46dd71cd603918b43","modified":1617497447512},{"_id":"public/tags/csrf/index.html","hash":"b13fc61d794f4dd0e1f4dde061498d31a9fb7bd1","modified":1617497447512},{"_id":"public/tags/web安全/index.html","hash":"e987ed7280532100972571625c23197f92ed1502","modified":1617497447512},{"_id":"public/tags/proxy/index.html","hash":"a9cd8cd5b8fbed4ed62b8ec46d508cb2580cdd99","modified":1617497447512},{"_id":"public/tags/响应式/index.html","hash":"d721e8c8e64bdfa3468746e8cc6b3d04414319b5","modified":1617497447512},{"_id":"public/tags/defer/index.html","hash":"07d181c7b3208de574a0b0390622827524275026","modified":1617497447512},{"_id":"public/tags/async/index.html","hash":"34cc032a95117831ccb0bcbdee8e520dabf62eb6","modified":1617497447512},{"_id":"public/tags/动态规划/index.html","hash":"675839922316f0e6c50a67149f8b401bfd905eba","modified":1617497447512},{"_id":"public/tags/算法/index.html","hash":"54fa21d2023884569f5bac4aaaa3c8779b5b8e2b","modified":1617497447512},{"_id":"public/tags/event/index.html","hash":"a297d0907daccf8567709d2b6af2f41ae316a9f9","modified":1617497447512},{"_id":"public/tags/事件冒泡/index.html","hash":"a2752f37b39756f1077147d0e116a348f14a7869","modified":1617497447512},{"_id":"public/tags/事件捕获/index.html","hash":"67cd036ede40a965c85cec9ba9b3082ab9a94487","modified":1617497447512},{"_id":"public/tags/git/index.html","hash":"d07a953664477002f922d36b14a37f8b16893bcc","modified":1617497447512},{"_id":"public/tags/gulp/index.html","hash":"fdeeb03b9a7939e981639afb15cda32d07a8ceec","modified":1617497447512},{"_id":"public/tags/nginx/index.html","hash":"c41df8a538427237606be7ae89548c9709cbef1d","modified":1617497447512},{"_id":"public/tags/MIMETYPE/index.html","hash":"917981a2f23c8e6d379d929c869f1bc36916ab0f","modified":1617497447512},{"_id":"public/tags/CONTENTTYPE/index.html","hash":"135a652c7067870518536910b0e4a06733d9d02c","modified":1617497447512},{"_id":"public/tags/请求头/index.html","hash":"f573deccf3c737695f6cba8155e09f041f16f9af","modified":1617497447512},{"_id":"public/tags/http/index.html","hash":"f49bb0293acc513be58437f7f403e9c4fd81d597","modified":1617497447512},{"_id":"public/tags/cache/index.html","hash":"0e1b03c7e8ba8d1b80af2b1238d537fbbca7eaa3","modified":1617497447512},{"_id":"public/tags/缓存/index.html","hash":"523226f0352be513705c8f0da514917748b78d36","modified":1617497447512},{"_id":"public/tags/http2/index.html","hash":"996ce3173fb4a5409aab08cda576e13789785062","modified":1617497447512},{"_id":"public/tags/http3/index.html","hash":"43ca87889e3bb66f402c5349b2e359e9d574ec3a","modified":1617497447512},{"_id":"public/tags/https/index.html","hash":"938624121a262750ffe31c3f1e951a4b5fa0a4f2","modified":1617497447512},{"_id":"public/tags/iphonex/index.html","hash":"205a04d86e6940d070b62aeabf13823b6d41b67b","modified":1617497447512},{"_id":"public/tags/齐刘海/index.html","hash":"4c870a250d4668fd465c41048eb34482f9d7f8ea","modified":1617497447512},{"_id":"public/tags/css/index.html","hash":"22b32ff8766e6c85dde7ac0900369790c81c0301","modified":1617497447512},{"_id":"public/tags/item2/index.html","hash":"142d5d62e55cacc85722ed67021c45785ed5ed3b","modified":1617497447512},{"_id":"public/tags/java/index.html","hash":"210405b06ae12e652524a82111ab489148b7ad60","modified":1617497447512},{"_id":"public/tags/apache/index.html","hash":"f45bd1bb8ad43dfa8917c7e381191868a8ad4e45","modified":1617497447512},{"_id":"public/tags/jdk/index.html","hash":"6369932039088b34d353f5afe9ace1baa272dbf4","modified":1617497447512},{"_id":"public/tags/AES/index.html","hash":"4b1999a4b1555eba80b9922bd9c3fa6a2bdc0c54","modified":1617497447512},{"_id":"public/tags/RSA/index.html","hash":"f68f5bb21043f6586e441596fee2fb12d4a8a8ef","modified":1617497447512},{"_id":"public/tags/加密/index.html","hash":"f07a3f8f893597c91f255a0a318b98e6374bc6d1","modified":1617497447512},{"_id":"public/tags/安全/index.html","hash":"3f6f75fa767aa1e5693d43ffbbcfd07c118f6e9c","modified":1617497447512},{"_id":"public/tags/长连接/index.html","hash":"b416825223042c0d7d92349526d29a0211b0b3fa","modified":1617497447512},{"_id":"public/tags/mac/index.html","hash":"332917490ef45746ddba1fd567630320bfc43913","modified":1617497447512},{"_id":"public/tags/terminal/index.html","hash":"394b6c6ab2d52140d4d8bddd98455856cfc85956","modified":1617497447512},{"_id":"public/tags/微前端/index.html","hash":"d71687dfd841cce54a074185b101508c05ea93c2","modified":1617497447512},{"_id":"public/tags/mysql/index.html","hash":"ae85c3e814fd1f33461f333982cfa1947cd48dc4","modified":1617497447512},{"_id":"public/tags/数据库/index.html","hash":"566c10ba63c3b92cdc85ebf7fae7eb766e96d4ef","modified":1617497447512},{"_id":"public/tags/sql/index.html","hash":"0a341cd15ed9ec1b64dedc42e3f1408697d4b1ab","modified":1617497447512},{"_id":"public/tags/child-process/index.html","hash":"44a9b2708b4663558b1231e84946d648d70716b7","modified":1617497447512},{"_id":"public/tags/cluster/index.html","hash":"a6c0af4d0e1da59ab9e3de2cfabb6cf6243315dc","modified":1617497447512},{"_id":"public/tags/服务端/index.html","hash":"785dadefcbdf967d63cb434aa72da212fc3d00dd","modified":1617497447512},{"_id":"public/tags/dubbo/index.html","hash":"79d7634918da6450764cf2687c8fa1c1ddd305b2","modified":1617497447512},{"_id":"public/tags/npm/index.html","hash":"e05bbecc3ab73c8fe3569cacf8239893add93a88","modified":1617497447512},{"_id":"public/tags/npm-lock/index.html","hash":"493ec90bf8367bf90af475d848f05b9c6d990658","modified":1617497447512},{"_id":"public/tags/object/index.html","hash":"6c70ca3b1127c8488a40dfcde45e1e0052587e9d","modified":1617497447512},{"_id":"public/tags/对象/index.html","hash":"5cf8a1510f1b9d8ab69b4c2149b38c31ca4c3642","modified":1617497447512},{"_id":"public/tags/回文/index.html","hash":"98c640bcee432781520cedc4e34379c64bf31446","modified":1617497447512},{"_id":"public/tags/oracle/index.html","hash":"618252f918ac672fb7fd62c80f0a0cfac092f46f","modified":1617497447512},{"_id":"public/tags/性能/index.html","hash":"547473d3680750121bf46f7fc9081f88d963ea97","modified":1617497447512},{"_id":"public/tags/chrome/index.html","hash":"aaf60ffa06c42eb473390bcdb67b7fc1a05eb2bc","modified":1617497447512},{"_id":"public/tags/performance/index.html","hash":"5391bb06625be139f4751c88288d4ea722551728","modified":1617497447512},{"_id":"public/tags/pm2/index.html","hash":"31789fe2e10d0c5819136c8a589c837da0479770","modified":1617497447512},{"_id":"public/tags/apply/index.html","hash":"aadfebb83b5ba6f4fc8d4b586051c921360aed63","modified":1617497447512},{"_id":"public/tags/call/index.html","hash":"83e29879beac68a5134a6c47789a3b6520c6cb1c","modified":1617497447512},{"_id":"public/tags/bind/index.html","hash":"c21acf7c96b33e2462bc980a96b0889636ed7992","modified":1617497447512},{"_id":"public/tags/new/index.html","hash":"2773850516e715edd1f85e6a2af025ce1e49af66","modified":1617497447512},{"_id":"public/tags/instance/index.html","hash":"5f729a7702997e7a7f5fea07fa07c240709af829","modified":1617497447512},{"_id":"public/tags/create/index.html","hash":"9333455e634a1e58df73bc813eea06b6b2f8b3c3","modified":1617497447512},{"_id":"public/tags/冒泡算法/index.html","hash":"f4a505b404756b8d66e821f9babc3210fc76f078","modified":1617497447512},{"_id":"public/tags/选择算法/index.html","hash":"97afbb55c3a6b7665a600f0f4df774269a0b69bc","modified":1617497447512},{"_id":"public/tags/快速算法/index.html","hash":"a81b4e3a5728240f6c9a0fed0b682d50aa99c323","modified":1617497447512},{"_id":"public/tags/插入算法/index.html","hash":"e9ecb2d95f42ec8ef7efad81a23a71e805a2bcd1","modified":1617497447512},{"_id":"public/tags/二叉树/index.html","hash":"f8bb25dce948f2b4d4a0feacd45998aeda5946f4","modified":1617497447512},{"_id":"public/tags/数组/index.html","hash":"db8322db101bc6965d831ab0e7d04eeb1f4ea105","modified":1617497447512},{"_id":"public/tags/react/index.html","hash":"2522acda44eb36b07da12158d78e62025ab56d2c","modified":1617497447512},{"_id":"public/tags/flux/index.html","hash":"7faeabefdb9e14d24f5631d7a09b81edcf58096e","modified":1617497447512},{"_id":"public/tags/redux/index.html","hash":"9a78933b5dd4c419bfe2cc6a4909adb90a3fe85c","modified":1617497447512},{"_id":"public/tags/fiber/index.html","hash":"7a1f58fe423df90b6447881e8d0558ba8593d1b9","modified":1617497447512},{"_id":"public/tags/redis/index.html","hash":"663d91e0d4d6f0421caad7eca593151dd6474a19","modified":1617497447512},{"_id":"public/tags/sentinel/index.html","hash":"1d67f973b4e6a9aa696555901ce3c93aaa467591","modified":1617497447512},{"_id":"public/tags/rpc/index.html","hash":"413e869f61409b8d34d607f58af8a47ca0981f3e","modified":1617497447512},{"_id":"public/tags/thrift/index.html","hash":"2d170a14e698f4cda8de8bd45cfc418336cb3851","modified":1617497447512},{"_id":"public/tags/软件安装/index.html","hash":"92a0499b0df8cc7f0c8e18731a05583de7d99b91","modified":1617497447512},{"_id":"public/tags/ssh/index.html","hash":"068dbdca614ed07135e1a237cc1e203948ce9507","modified":1617497447512},{"_id":"public/tags/scp/index.html","hash":"82ad977e7837730a0a37e8285895b3f3dd8babde","modified":1617497447512},{"_id":"public/tags/rsync/index.html","hash":"5b0b3341dd6e381bdce40b05ff3f0590489dd013","modified":1617497447512},{"_id":"public/tags/svn/index.html","hash":"bccf3f54286ce40cfa2f67a91ff7b65ee9e8ffee","modified":1617497447512},{"_id":"public/tags/vim/index.html","hash":"cde6deb72beda8e030678b25fb72d73aeed9680c","modified":1617497447512},{"_id":"public/tags/virtualDom/index.html","hash":"f0f2e072a4603c853e1d8770119418ca3f6c808e","modified":1617497447512},{"_id":"public/tags/虚拟DOM/index.html","hash":"10747213b85fbd67d4d1b8e5871273bdc0852774","modified":1617497447512},{"_id":"public/tags/Vue/index.html","hash":"909c906197f8a48bbd13ccd74b42ced72216f65d","modified":1617497447512},{"_id":"public/tags/vue/index.html","hash":"a91d1e82fd5c5415c3ea7ccdc5a5eb366efe4d02","modified":1617497447512},{"_id":"public/tags/ssr/index.html","hash":"11680cd56e207575f7ab47dc7a6392b70eb720d3","modified":1617497447512},{"_id":"public/tags/服务端渲染/index.html","hash":"d912cbed2ffaaacdba49d335d59827c5a08c3d32","modified":1617497447512},{"_id":"public/tags/vue-vuex/index.html","hash":"153110e44790d729c75376212ff36d83491f1722","modified":1617497447512},{"_id":"public/tags/vue3/index.html","hash":"e1b0a2ebe0f894cadf014f1fc645afcaf28a0f32","modified":1617497447512},{"_id":"public/tags/set/index.html","hash":"dcd6dedef39c81353efdd6d94c87f05873c24696","modified":1617497447512},{"_id":"public/tags/weakSet/index.html","hash":"7095cf1d832252a5313e7119d475988a3979ba44","modified":1617497447512},{"_id":"public/tags/webpack/index.html","hash":"24343cd3e46d7cb7ba590bbab9dc0aab3f3ef81d","modified":1617497447512},{"_id":"public/tags/babel/index.html","hash":"0f9d6c84a2b7809bca328529775286d73f230c61","modified":1617497447512},{"_id":"public/tags/ios模拟器/index.html","hash":"0c273f3f5d322e35703b5075da6e7d2243c8f71b","modified":1617497447512},{"_id":"public/tags/xcode/index.html","hash":"a1033bb99457351d4c2a676032f6564fc8089761","modified":1617497447512},{"_id":"public/tags/simulator/index.html","hash":"49496e5658286ece3b4c101133c003b2cdd3b386","modified":1617497447512},{"_id":"public/tags/小程序/index.html","hash":"b55c12b99c0363f86bc0bab134e96ae2327889d6","modified":1617497447512},{"_id":"public/tags/微信开发/index.html","hash":"c4492eaeac79e885ba88282828ca8111f75baf32","modified":1617497447512},{"_id":"public/tags/xss/index.html","hash":"15af6bffb901fa8fa972ce77ed71899311243d0d","modified":1617497447512},{"_id":"public/2021/04/03/cdn/index.html","hash":"269b22df9aee6b808f27e40a4d69b451207558f1","modified":1617497447512},{"_id":"public/2021/02/26/compile/index.html","hash":"5c0b3966b73d0b089dea7ad3a5b0687863696210","modified":1617497447512},{"_id":"public/2021/02/24/weakSet/index.html","hash":"e7a6e5ef4ed7c181053dff87e4dc0d0f74f1cb05","modified":1617497447512},{"_id":"public/2021/02/08/react16/index.html","hash":"9b384a0256fba57ddd8f76c36758678e23f99101","modified":1617497447512},{"_id":"public/2021/02/04/vue3/index.html","hash":"faf57a82cc55dcc298f449d061fce2bb4b6d36cf","modified":1617497447512},{"_id":"public/2021/01/30/dynamic/index.html","hash":"91c3ef7d693b37c2c605da32b9a11d268e81debd","modified":1617497447512},{"_id":"public/2021/01/25/palindrome/index.html","hash":"28964deb14ea38665c8d7be34a876309373c606b","modified":1617497447512},{"_id":"public/2021/01/18/defer/index.html","hash":"01e14ac3f27515b5bbaaf61d6491b98382fa824d","modified":1617497447512},{"_id":"public/2021/01/13/http3/index.html","hash":"ad3267c7e1e3d2e1cbf18d4387b1881064784072","modified":1617497447512},{"_id":"public/2021/01/12/http-headers/index.html","hash":"4a6ef5981529ddb8fff06028fffd3033a794f152","modified":1617497447512},{"_id":"public/2021/01/11/data-bind/index.html","hash":"8d5c04260eb13328df248ee0a29f41ded30cb7be","modified":1617497447512},{"_id":"public/2021/01/09/micro-front/index.html","hash":"c2c25379e27be58ba981f0ce0eeef653ef266b28","modified":1617497447512},{"_id":"public/2021/01/06/long-connect/index.html","hash":"cdb143427687692f7a06ddfd8a557bb5e418b573","modified":1617497447512},{"_id":"public/2021/01/05/code1/index.html","hash":"5e0110b8898ec64a7e383a97d6f819f21afbd591","modified":1617497447512},{"_id":"public/2021/01/04/virtual-dom/index.html","hash":"deeefe9352ffb66471de9b759f40bb3710f5a601","modified":1617497447512},{"_id":"public/2021/01/01/object2/index.html","hash":"a03f51113117c42e099d58ad77062b5f70c701e7","modified":1617497447512},{"_id":"public/2020/12/31/xcx2/index.html","hash":"40adb3df59af028c92dd32f415a7b85ec539fa6e","modified":1617497447512},{"_id":"public/2020/12/30/node-progress/index.html","hash":"bc3a9bf6c46768c92a05f29b0eb40153f6e22043","modified":1617497447512},{"_id":"public/2020/12/29/browser-progress/index.html","hash":"b564e3c28467d51913100423c510cb2435507dcd","modified":1617497447512},{"_id":"public/2020/12/15/qa7/index.html","hash":"ea226688be603d471c3d454b481e1442de97de65","modified":1617497447512},{"_id":"public/2020/12/14/qa6/index.html","hash":"9a7cd8336e20daf997cfdbdb2398cb7db6964488","modified":1617497447512},{"_id":"public/2020/10/21/cmd/index.html","hash":"50af5e8522b2021d36be0b26aed91f9011b60539","modified":1617497447512},{"_id":"public/2020/10/19/qa5/index.html","hash":"922a4e54d1460123cc6805a546415bf9a9052e9c","modified":1617497447512},{"_id":"public/2020/10/14/qa4/index.html","hash":"b087e64b2dea8a1278b62e24a4c3e281fadc05b4","modified":1617497447512},{"_id":"public/2020/10/13/qa3/index.html","hash":"b206616986d8110863736c5e14f0c4ca61458a49","modified":1617497447512},{"_id":"public/2020/10/12/brew/index.html","hash":"aa179ec69a889fab48597b440c28a1bd1df22d7c","modified":1617497447512},{"_id":"public/2020/10/11/ssh/index.html","hash":"130f97c44520da4b9cdf8f612934981de458ba32","modified":1617497447512},{"_id":"public/2020/10/01/qa2/index.html","hash":"e9f59fddb056c49a07a90a20f4884628013d60bf","modified":1617497447512},{"_id":"public/2020/09/30/qa1/index.html","hash":"386dd704d7e9e1873c53285a64810f3ba62ea322","modified":1617497447512},{"_id":"public/2020/07/24/item2/index.html","hash":"a42091896b8c48cce7d2ae2cf07f48ce1088a173","modified":1617497447512},{"_id":"public/2019/09/05/performance/index.html","hash":"db200455d5695b06efe2a1174d537a68664418fa","modified":1617497447512},{"_id":"public/2019/04/03/vue-ssr/index.html","hash":"d78de4818acf7616f6658d594459e06385442718","modified":1617497447512},{"_id":"public/2019/03/25/oracle/index.html","hash":"b70d9a9d0bfdf6b6ef859c372bcb2bc7d41c689f","modified":1617497447512},{"_id":"public/2019/02/13/mysql2/index.html","hash":"97c1ac80fa85c0cbf2fedf610acea49a3e87b11a","modified":1617497447512},{"_id":"public/2019/01/17/webpack/index.html","hash":"c5b8c28d593d32987eb6fba4b5f0c3f5009e17bf","modified":1617497447512},{"_id":"public/2019/01/16/nodejs3/index.html","hash":"f5c2389685b3b4ea3837d4823b2ae9aca0abdb1c","modified":1617497447512},{"_id":"public/2019/01/15/nodejs2/index.html","hash":"c21fbd6471b64c7b3b1b3c85c9e58b46e57d54dc","modified":1617497447512},{"_id":"public/2019/01/09/event/index.html","hash":"cb5b63576166541cdf1469b5ac5f55b8cba324e8","modified":1617497447512},{"_id":"public/2019/01/08/iphonex/index.html","hash":"e9b4e9efd1524dc3bb86cdad5eee8ddd5e10a212","modified":1617497447512},{"_id":"public/2019/01/08/xcx/index.html","hash":"b94dd500d9c3f5152dd5fe13444a7b89e94607a7","modified":1617497447512},{"_id":"public/2018/11/24/csrf/index.html","hash":"e707d98e303c488d9adee15f0ea3a64af96ebbc2","modified":1617497447512},{"_id":"public/2018/11/23/xss/index.html","hash":"e006175d07964268f40804fb3b91ddbe14bea1dc","modified":1617497447512},{"_id":"public/2018/11/05/shell1/index.html","hash":"62152699f2c41db67b0c8c0c5e7740be02b692d9","modified":1617497447512},{"_id":"public/2018/11/05/xcode/index.html","hash":"531ebcde8f6ff79ac885c372f975e05b39e453e4","modified":1617497447512},{"_id":"public/2018/11/01/redis/index.html","hash":"8ec3bf7f01fd069a6932c62d1552597fca009157","modified":1617497447512},{"_id":"public/2018/08/07/vue2/index.html","hash":"15a78ef295721b4803a1ae6f5dcbce3580bea065","modified":1617497447512},{"_id":"public/2018/08/02/vue1/index.html","hash":"0d8dbd137ed75580e0a1d4840f7217cbc332b73e","modified":1617497447512},{"_id":"public/2018/07/31/rpc/index.html","hash":"9aa0f2da18aa598793e12cc3de2b31c830b54a13","modified":1617497447512},{"_id":"public/2018/06/14/linux4/index.html","hash":"25a7a916726462a2781c24e5a969054fa6bd598f","modified":1617497447512},{"_id":"public/2018/06/10/linux3/index.html","hash":"b2e72975f07fd4784ada1c240249694ea9991b9a","modified":1617497447512},{"_id":"public/2018/06/05/linux1/index.html","hash":"3ab5737b2a88ef4bb8d0daf98fc8748633aff2de","modified":1617497447512},{"_id":"public/2018/06/05/linux2/index.html","hash":"ca24315037d8870cfa98806390d4a2b2c1d674ae","modified":1617497447512},{"_id":"public/2018/05/22/npm-lock/index.html","hash":"52bf188566499be55839ca2f575044940f98caf8","modified":1617497447512},{"_id":"public/2018/05/21/proxy-error/index.html","hash":"67dccdcb11872de5170b8e3c28190a81cd5d8e39","modified":1617497447512},{"_id":"public/2018/04/10/react/index.html","hash":"1baa3e879f8cd5edebe9222682aa0fa07c909ad9","modified":1617497447512},{"_id":"public/2018/03/20/getrect/index.html","hash":"66da20a35dbf9d08c951f43240e8098cf138b61a","modified":1617497447512},{"_id":"public/2018/03/20/jsencrypt/index.html","hash":"2df2b3bd6bfadb0060eca17173f0844ba66da40f","modified":1617497447512},{"_id":"public/2018/01/15/js2/index.html","hash":"fff91bf456fe9813a034bedb0509e4e990ed9297","modified":1617497447512},{"_id":"public/2018/01/14/js1/index.html","hash":"92e3ed0075163a02c671004feafbd6c77451a876","modified":1617497447512},{"_id":"public/2018/01/10/git/index.html","hash":"1bd0ea177b241ef63d3695fe01ea95e9a24b3faa","modified":1617497447512},{"_id":"public/2018/01/08/nodejs/index.html","hash":"1905921a4a2f152bb88cb62d3e60b6ce4cf00ded","modified":1617497447512},{"_id":"public/2017/12/12/https/index.html","hash":"e71c91d6df416b5bc94bdf5f58bf74dfa4fdad6f","modified":1617497447512},{"_id":"public/2017/11/08/javapath/index.html","hash":"2633da777f1549fc8f052b81ab13d0e2bc4e703f","modified":1617497447512},{"_id":"public/2017/04/11/svn/index.html","hash":"b67cb91b23bf1f7dddc9ebbed7d763a7912126bb","modified":1617497447512},{"_id":"public/2017/02/27/http/index.html","hash":"1688294723db23550229b304b382691e5f26259b","modified":1617497447512},{"_id":"public/2017/02/23/host-ip/index.html","hash":"a2c09d09378552987b48cf4a71d15dade1866e16","modified":1617497447512},{"_id":"public/2016/12/31/vim/index.html","hash":"a10530a103f94d450fd3422f5da220a1871aaea9","modified":1617497447512},{"_id":"public/2016/12/30/linux/index.html","hash":"d6b614f30389b9a813d625d3fcaa38227a99c674","modified":1617497447512},{"_id":"public/2016/12/29/http2/index.html","hash":"66189c94def7ab029a6783079ff244ed4082e018","modified":1617497447512},{"_id":"public/2016/12/26/dns/index.html","hash":"4e6b58eb6aff76b63c3aa9a5bf4980ff1bfbecea","modified":1617497447512},{"_id":"public/2016/12/25/mysql/index.html","hash":"5e0934dff172203ddb917445cb2d98a3320ddd21","modified":1617497447512},{"_id":"public/2016/12/25/nginx/index.html","hash":"efe6c377e507ba0e038e347699f7497c76bf4f6d","modified":1617497447512},{"_id":"public/2016/12/20/gulp/index.html","hash":"7e26749068e165c127d2d44fe24930fe0eaf12d8","modified":1617497447512},{"_id":"public/2016/12/05/mac-terminal/index.html","hash":"fc0131d1ffe8f2f522cf530c83447af3d8e5e7d2","modified":1617497447512},{"_id":"public/2016/10/11/object/index.html","hash":"ecee0862442dfe6db1adf35adf2d0d0eef12e5b9","modified":1617497447512},{"_id":"public/2016/03/29/pm2/index.html","hash":"b941c98a1fa8c51d30b0a43eb4dc9767796b09a3","modified":1617497447512},{"_id":"public/archives/index.html","hash":"0416920112192bfcfa04d2ba3370692c329c3119","modified":1617497447512},{"_id":"public/archives/page/2/index.html","hash":"d949ff61c08ed27a93940664f4f71472cd0a4021","modified":1617497447512},{"_id":"public/archives/page/3/index.html","hash":"5df8fef6951b2f24fb409649ebb174e670d1a83b","modified":1617497447512},{"_id":"public/archives/page/4/index.html","hash":"e4c516522795d84b4ae168a0f977e7219df3b083","modified":1617497447512},{"_id":"public/archives/page/5/index.html","hash":"811680196f35703518757dc9f30076cadf1565b5","modified":1617497447512},{"_id":"public/archives/page/6/index.html","hash":"28f34483c4a5608b84af41e3917aebb818434303","modified":1617497447512},{"_id":"public/archives/page/7/index.html","hash":"ffca7330ba671f8fb811ed23705c3d0794ea595c","modified":1617497447512},{"_id":"public/archives/page/8/index.html","hash":"e4476acc6fb8eb222d4eb06a8025434f21c83823","modified":1617497447512},{"_id":"public/archives/2016/index.html","hash":"4f2d2dc33f3e4e043eb7f0bb945c7a7ff1b990c4","modified":1617497447512},{"_id":"public/archives/2016/12/index.html","hash":"07b49808a86b5c55923a905135b17a8ca09bdf0e","modified":1617497447512},{"_id":"public/archives/2017/index.html","hash":"3f2f9b77db92ad9243febc87cde3c15f028397ab","modified":1617497447512},{"_id":"public/archives/2018/index.html","hash":"b539ed85b15adb5a0fd41cde2226822a9180cea1","modified":1617497447512},{"_id":"public/archives/2018/page/2/index.html","hash":"8b2911a197ebc7f81af8bc6db1fc286c3eda0e30","modified":1617497447512},{"_id":"public/archives/2018/11/index.html","hash":"335c5987f5cae21e678538afed4c927814a53b19","modified":1617497447512},{"_id":"public/archives/2019/index.html","hash":"f16a528e5e83e804ba1c64a27429447adfa28962","modified":1617497447512},{"_id":"public/archives/2019/01/index.html","hash":"b9df4ce8bfb8fa715a4af790aab28decc4fe1142","modified":1617497447512},{"_id":"public/archives/2020/index.html","hash":"744103313abae70496b75ae4f5a55d4893dfa011","modified":1617497447512},{"_id":"public/archives/2020/10/index.html","hash":"0aba114cfcafa1016ef2a8327429c23699e51cab","modified":1617497447512},{"_id":"public/archives/2020/12/index.html","hash":"62f308f7cd8550812924cb4ddd23bfcd2eb18c12","modified":1617497447512},{"_id":"public/archives/2021/index.html","hash":"fc1c204e5f0347a18b72304756f7c1601b4b4e83","modified":1617497447512},{"_id":"public/archives/2021/page/2/index.html","hash":"6ce56d4897e29318366e3728d82b2f61e47e5f97","modified":1617497447512},{"_id":"public/archives/2021/01/index.html","hash":"ff2e9c57b0f112acad27f001cc31040379ba647d","modified":1617497447512},{"_id":"public/categories/笔记/index.html","hash":"fc59db703cc6866a79ae5d63d73807791cb6f362","modified":1617497447512},{"_id":"public/categories/笔记/page/2/index.html","hash":"19d1c54b4e65e8d93c0a1913cf6e94704cd10e92","modified":1617497447512},{"_id":"public/categories/技术/index.html","hash":"6069b6885113096167a733b780d4e6d419e03631","modified":1617497447512},{"_id":"public/categories/技术/page/2/index.html","hash":"5fa0b72f0a8ceff962002f0eb223938723a94e4e","modified":1617497447512},{"_id":"public/categories/技术/page/3/index.html","hash":"c789d2080dfc01e1666e6d14152b0e7a05525987","modified":1617497447512},{"_id":"public/categories/技术/page/4/index.html","hash":"5fd5f2267d98c086faba3a888abaac554f226a4e","modified":1617497447512},{"_id":"public/categories/技术/page/5/index.html","hash":"8d49266fd42d4100adef78d8b2288319d1c1a314","modified":1617497447512},{"_id":"public/index.html","hash":"04a57d2e7a19bb0d8b4bb371e08af86308df49e8","modified":1617497447512},{"_id":"public/page/2/index.html","hash":"9846de2e55f66345a4f79ec8dddce72a2fff465d","modified":1617497447512},{"_id":"public/page/3/index.html","hash":"5ec06327e382aa7abb20ce418174a09ae57d2096","modified":1617497447512},{"_id":"public/page/4/index.html","hash":"8d50e520aeee0db1a79390e047643e12046b4662","modified":1617497447512},{"_id":"public/page/5/index.html","hash":"13daee14f3cad6b4c745e67a6c04437405a2d46c","modified":1617497447512},{"_id":"public/page/6/index.html","hash":"9bdde76e6cfebfc54574001d891187a64870c1b4","modified":1617497447512},{"_id":"public/page/7/index.html","hash":"3c3caf1c26d633b3b54b1d7d3eec4021f65ba483","modified":1617497447512},{"_id":"public/page/8/index.html","hash":"b685c556e6be6a9526126038fd96739da99021a8","modified":1617497447512},{"_id":"public/tags/基础/index.html","hash":"e39cc2c9c1be35650611048029c0bd759532dbb1","modified":1617497447512},{"_id":"public/tags/js/index.html","hash":"91695184909ff34c458147abc2ef04aac85616bd","modified":1617497447512},{"_id":"public/tags/linux/index.html","hash":"1d34c90f8b30c84ee8ec2135ea9a76264a755cce","modified":1617497447512},{"_id":"public/tags/shell/index.html","hash":"bc7a68cc8600879528fee5cbe638e13ee3992ba8","modified":1617497447512},{"_id":"public/tags/nodejs/index.html","hash":"61431ed77414aeca226541cb3ed2c01c7d45fa3d","modified":1617497447512},{"_id":"public/CNAME","hash":"06af8c456d0b28236669ddfffd0a0353f1d67810","modified":1617497447512},{"_id":"public/favicon.ico","hash":"182d666465c598213c3239906fdc7508bf91c40d","modified":1617497447512},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1617497447512},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1617497447512},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1617497447512},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1617497447512},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1617497447512},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1617497447512},{"_id":"public/js/analytics","hash":"a58355dd8102d9e984050695a1c31445b530b5af","modified":1617497447512},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1617497447512},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1617497447512},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1617497447512},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1617497447512},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1617497447512},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1617497447512},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1617497447512},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1617497447512},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1617497447512},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1617497447512},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1617497447512},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1617497447512},{"_id":"public/css/style.css","hash":"a3d61384b4177a58aede5fba65e23f9283da1dce","modified":1617497447512},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1617497447512},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1617497447512},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1617497447512},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1617497447512},{"_id":"public/css/images/banner2.jpg","hash":"7391bbe277fcd97b90d405b3d7eb86c328cd54c0","modified":1617497447512},{"_id":"public/css/images/banner@3x2.jpg","hash":"02bdbbb34a90c62e8590c5a72597995e38e08eb1","modified":1617497447512},{"_id":"public/css/images/banner@3x2.png","hash":"a6860aba9fc579e215e9a51690a48ee8464f78f1","modified":1617497447512}],"Category":[{"name":"笔记","_id":"ckn2g7uh20024a0vzhx8i5554"},{"name":"技术","_id":"ckn2g7uhe0026a0vz5wve6zxa"}],"Data":[],"Page":[],"Post":[{"layout":"default","title":"brew使用文档","date":"2020-10-11T16:00:00.000Z","_content":"\nbrew 官网: (https://brew.sh/index_zh-cn)[https://brew.sh/index_zh-cn]\n\n```shell\n# brew 安装，如果安装速度慢或者被墙，可自行网上找镜像链接安装\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n```\n\n```shell\nbrew -v # 查看brew版本号\nbrew install xxx # 安装包\nbrew search xxx # 搜索包\nbrew info xxx # 查看包信息\nbrew uninstall xxx # 卸载包\nbrew list # 显示已安装的包\nbrew update # 更新包，此命令更新 Homebrew自己\nbrew outdated # 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级\nbrew outdated xxx # 检查包\nbrew upgrade # 升级所有可以升级的软件们\nbrew upgrade xxx # 升级某个包\nbrew cleanup # 清理不需要的版本极其安装包缓存\nbrew cleanup xxx # 清理包\nbrew –help # 查看brew的帮助\nbrew pin xxx # 禁止指定软件升级\nbrew unpin # 取消禁止指定软件升级\n```\n\n服务相关命令\n```shell\nbrew services list # 查看 services 列表\nbrew services run mysql # 启动 mysql 服务\nbrew services start mysql # 启动 mysql 服务，并注册开机自启\nbrew services stop mysql # 停止 mysql 服务，并取消开机自启\nbrew services restart mysql # 重启 mysql 服务，并注册开机自启\nbrew services cleanup # 清除已卸载应用的无用配置\n```","source":"_posts/brew.md","raw":"---\nlayout: default\ntitle: brew使用文档\ndate: 2020-10-12\ntag: brew\ncategory: 笔记\n---\n\nbrew 官网: (https://brew.sh/index_zh-cn)[https://brew.sh/index_zh-cn]\n\n```shell\n# brew 安装，如果安装速度慢或者被墙，可自行网上找镜像链接安装\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n```\n\n```shell\nbrew -v # 查看brew版本号\nbrew install xxx # 安装包\nbrew search xxx # 搜索包\nbrew info xxx # 查看包信息\nbrew uninstall xxx # 卸载包\nbrew list # 显示已安装的包\nbrew update # 更新包，此命令更新 Homebrew自己\nbrew outdated # 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级\nbrew outdated xxx # 检查包\nbrew upgrade # 升级所有可以升级的软件们\nbrew upgrade xxx # 升级某个包\nbrew cleanup # 清理不需要的版本极其安装包缓存\nbrew cleanup xxx # 清理包\nbrew –help # 查看brew的帮助\nbrew pin xxx # 禁止指定软件升级\nbrew unpin # 取消禁止指定软件升级\n```\n\n服务相关命令\n```shell\nbrew services list # 查看 services 列表\nbrew services run mysql # 启动 mysql 服务\nbrew services start mysql # 启动 mysql 服务，并注册开机自启\nbrew services stop mysql # 停止 mysql 服务，并取消开机自启\nbrew services restart mysql # 重启 mysql 服务，并注册开机自启\nbrew services cleanup # 清除已卸载应用的无用配置\n```","slug":"brew","published":1,"updated":"2021-03-30T01:32:00.315Z","comments":1,"photos":[],"link":"","_id":"ckn2g7uez0000a0vz2cp9fpt4","content":"<p>brew 官网: (<a href=\"https://brew.sh/index_zh-cn)[https://brew.sh/index_zh-cn]\">https://brew.sh/index_zh-cn)[https://brew.sh/index_zh-cn]</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> brew 安装，如果安装速度慢或者被墙，可自行网上找镜像链接安装</span></span><br><span class=\"line\">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew -v # 查看brew版本号</span><br><span class=\"line\">brew install xxx # 安装包</span><br><span class=\"line\">brew search xxx # 搜索包</span><br><span class=\"line\">brew info xxx # 查看包信息</span><br><span class=\"line\">brew uninstall xxx # 卸载包</span><br><span class=\"line\">brew list # 显示已安装的包</span><br><span class=\"line\">brew update # 更新包，此命令更新 Homebrew自己</span><br><span class=\"line\">brew outdated # 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级</span><br><span class=\"line\">brew outdated xxx # 检查包</span><br><span class=\"line\">brew upgrade # 升级所有可以升级的软件们</span><br><span class=\"line\">brew upgrade xxx # 升级某个包</span><br><span class=\"line\">brew cleanup # 清理不需要的版本极其安装包缓存</span><br><span class=\"line\">brew cleanup xxx # 清理包</span><br><span class=\"line\">brew –help # 查看brew的帮助</span><br><span class=\"line\">brew pin xxx # 禁止指定软件升级</span><br><span class=\"line\">brew unpin # 取消禁止指定软件升级</span><br></pre></td></tr></table></figure>\n<p>服务相关命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew services list # 查看 services 列表</span><br><span class=\"line\">brew services run mysql # 启动 mysql 服务</span><br><span class=\"line\">brew services start mysql # 启动 mysql 服务，并注册开机自启</span><br><span class=\"line\">brew services stop mysql # 停止 mysql 服务，并取消开机自启</span><br><span class=\"line\">brew services restart mysql # 重启 mysql 服务，并注册开机自启</span><br><span class=\"line\">brew services cleanup # 清除已卸载应用的无用配置</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>brew 官网: (<a href=\"https://brew.sh/index_zh-cn)[https://brew.sh/index_zh-cn]\">https://brew.sh/index_zh-cn)[https://brew.sh/index_zh-cn]</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> brew 安装，如果安装速度慢或者被墙，可自行网上找镜像链接安装</span></span><br><span class=\"line\">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew -v # 查看brew版本号</span><br><span class=\"line\">brew install xxx # 安装包</span><br><span class=\"line\">brew search xxx # 搜索包</span><br><span class=\"line\">brew info xxx # 查看包信息</span><br><span class=\"line\">brew uninstall xxx # 卸载包</span><br><span class=\"line\">brew list # 显示已安装的包</span><br><span class=\"line\">brew update # 更新包，此命令更新 Homebrew自己</span><br><span class=\"line\">brew outdated # 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级</span><br><span class=\"line\">brew outdated xxx # 检查包</span><br><span class=\"line\">brew upgrade # 升级所有可以升级的软件们</span><br><span class=\"line\">brew upgrade xxx # 升级某个包</span><br><span class=\"line\">brew cleanup # 清理不需要的版本极其安装包缓存</span><br><span class=\"line\">brew cleanup xxx # 清理包</span><br><span class=\"line\">brew –help # 查看brew的帮助</span><br><span class=\"line\">brew pin xxx # 禁止指定软件升级</span><br><span class=\"line\">brew unpin # 取消禁止指定软件升级</span><br></pre></td></tr></table></figure>\n<p>服务相关命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew services list # 查看 services 列表</span><br><span class=\"line\">brew services run mysql # 启动 mysql 服务</span><br><span class=\"line\">brew services start mysql # 启动 mysql 服务，并注册开机自启</span><br><span class=\"line\">brew services stop mysql # 停止 mysql 服务，并取消开机自启</span><br><span class=\"line\">brew services restart mysql # 重启 mysql 服务，并注册开机自启</span><br><span class=\"line\">brew services cleanup # 清除已卸载应用的无用配置</span><br></pre></td></tr></table></figure></p>\n"},{"title":"浏览器线程与进程","date":"2020-12-28T16:00:00.000Z","_content":"\n进程是CPU分配资源的最小单位，分配独立内存，进程之间可通信，但是必须通过内核，使用IPC接口来做，代价比较大\n线程是CPU调度的最小单位，同一个进程下面可以有多个线程。\n\n浏览器是作为前端开发者绕不开的话题，理解浏览器的运行原理是每个前端开发者进阶的必经之路。\njavascript 语言本身当初被发明出来就是为浏览器服务的，只是后面Nodejs的出现为它赋予了更大的能力。\n\n### 浏览器进程\n1.browser主进程：负责浏览器界面显示、用户交互、资源管理。\n2.第三方插件进程：每一个插件对应一个进程\n3.GPU进程：只有一个，负责3D绘制\n4.浏览器渲染进程：每个tab都有一个渲染进程，负责页面渲染，脚本执行，事件处理\n\n浏览器多进程优势：充分利用多核优势、方便沙盒隔离插件等进程、防止单页面或者单插件crash影响其他页面。\n\n#### 浏览器渲染进程：包含多个线程\n1.GUI线程：负责渲染浏览器界面，解析html、js、css，构建DOM树、CSS树，完成布局和绘制、回流、重绘等。\n2.JS引擎线程：JS内核，负责处理Javascript脚本，解析和运行JS代码（如V8引擎），一个TAB页中仅有一个JS线程在运行JS程序。\n注意：GUI线程和JS引擎线程是互斥的，当JS引擎线程执行的时候，GUI线程会被挂起，阻塞页面渲染。待JS引擎空闲的时候才会继续执行。\n3.事件触发线程：归属于浏览器而不是JS引擎，用来控制事件循环。当执行setTimeout/鼠标点击/Ajax请求等事件时，会将对应异步任务添加到事件线程中。当事件符合触发条件时，该线程会将其添加到事件队列的队尾，等待JS引擎线程处理。由于JS是单线程的，所以一定得等到JS引擎空闲的时候才会依次处理这些队列中的事件。\n4.定时触发器线程：比如setTimeout、setInterval\n5.异步http请求线程：在XMLHttpRequest在连接后是通过浏览器新开一个线程进行请求的，检测到状态变更后，如果设置了回调，则会产生状态变更事件，放入事件队列中，最后由Js线程执行。\n\n#### GUI线程和JS引擎线程互斥的原因\n浏览器刻意如此设计的，因为JS是可能操作DOM的，如果GUI正在渲染的时候，JS操作了DOM，就会可能出现JS获取的DOM在GUI渲染前后获取的不一致，导致最终渲染的结果与期待的结果不一致。\n\n#### WebWorker 与 ShareWorker\nWebWorker是JS引擎向浏览器申请的一个子线程，可在浏览器端实现密集运算，为Web内容在一个独立的后台线程中允许脚本提供了一种简单的方法，不能操作DOM。\nJS引擎和Worker通过postMassage API通信。\n这个和JS引擎是单线程的说法并不冲突。\nShareWorder是浏览器单独为其开了一个进程来运行Javascript，所有的GUI线程共享同一个ShareWorder。\n\n#### 浏览器渲染过程\n1.浏览器输入url，Browser主进程开启一个下载线程，下载网站内容，下载完成之后通过RenderHost接口转交给Renderer进程。\n2.GUI线程解析DOM树、CSS树、合并DOM树和CSS树，计算元素尺寸位置完成Render布局，绘制页面像素信息，发送给GPU，GPU将各层合成(composite)生成图像，显示在屏幕上。此时触发页面load事件。\n\n#### 渲染和性能、硬件加速\n1.css不会阻塞DOM加载和解析，但是会阻塞Render树渲染。\n2.GPU中各个复合图层是单独绘制的。\n3.元素开启硬件加速之后会变成独立的复合层，此后改变改元素只会影响当前复合层，不会影响别的复合层。能够避免整个页面重绘。\n4.硬件加速原理就是将元素变成复合图层，通过为复合层单独分配资源来渲染而实现渲染加速。（如果复合层过多会导致大量资源的消耗，同样影响性能）\n5.webkit css3中，如果元素加了硬件加速，且设置了index层级，那么在这个元素后面 层级高于或等于该元素层级的元素会被隐式转换未复合图层。\n注意：position-absolute虽然脱离普通文档流，但是未脱离复合层，因此，即使设置了absolute，也还是在同一个复合层当中。\n\n开启GPU加速的方法有 transform动画、opacity动画、translateZ()/translate3D、will-change等\n```css\n.example1 {\n  transform: translateZ(0);\n}\n.example2 {\n  transform: rotateZ(360deg);\n}\n```\n\n#### JS EventLoop\n1.JS引擎为单线程执行的，浏览器中js执行任务分为同步任务和异步任务，同步任务在主线程中执行，形成一个执行栈。主线程之外，事件触发线程管理着任务队列，异步任务有了结果之后就会进入此队列中，当主线程中的同步任务执行完毕之后就会读取异步任务队列，将可执行的任务放入执行栈中执行。\n\n#### 定时器线程\njs中跑的setTimeout、setInterval等定时器，是一个单独的线程管理的控制的，当计时完成就会将特定的事件推送到事件队列中。等待主线程执行。\n由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行，所以，setTimeout会早于setImmediate完成。但是，setTimeout 定时时间默认可能不是0ms，而是3ms或者更多，所以，setImeediate 也可能在 setTimeout 之前执行。\n\n#### microTask\nmicroTask是当前task执行结束之后，下一个task之前，渲染之前立即执行的任务。（如：promise、process.nextTick等，mutationobserver 可用来实现微任务）\nprocess.nextTick() 的回调将在事件循环继续之前解析，所以微任务里面，process.nextTick 会在 promise 等其他微任务之前执行。\n\n\n### 传送门\n[https://segmentfault.com/a/1190000012925872](https://segmentfault.com/a/1190000012925872)\n","source":"_posts/browser-progress.md","raw":"---\ntitle: 浏览器线程与进程\ndate: 2020/12/29\ntag: [浏览器,browser,线程,进程,事件循环,硬件加速]\ncategory: 技术\n---\n\n进程是CPU分配资源的最小单位，分配独立内存，进程之间可通信，但是必须通过内核，使用IPC接口来做，代价比较大\n线程是CPU调度的最小单位，同一个进程下面可以有多个线程。\n\n浏览器是作为前端开发者绕不开的话题，理解浏览器的运行原理是每个前端开发者进阶的必经之路。\njavascript 语言本身当初被发明出来就是为浏览器服务的，只是后面Nodejs的出现为它赋予了更大的能力。\n\n### 浏览器进程\n1.browser主进程：负责浏览器界面显示、用户交互、资源管理。\n2.第三方插件进程：每一个插件对应一个进程\n3.GPU进程：只有一个，负责3D绘制\n4.浏览器渲染进程：每个tab都有一个渲染进程，负责页面渲染，脚本执行，事件处理\n\n浏览器多进程优势：充分利用多核优势、方便沙盒隔离插件等进程、防止单页面或者单插件crash影响其他页面。\n\n#### 浏览器渲染进程：包含多个线程\n1.GUI线程：负责渲染浏览器界面，解析html、js、css，构建DOM树、CSS树，完成布局和绘制、回流、重绘等。\n2.JS引擎线程：JS内核，负责处理Javascript脚本，解析和运行JS代码（如V8引擎），一个TAB页中仅有一个JS线程在运行JS程序。\n注意：GUI线程和JS引擎线程是互斥的，当JS引擎线程执行的时候，GUI线程会被挂起，阻塞页面渲染。待JS引擎空闲的时候才会继续执行。\n3.事件触发线程：归属于浏览器而不是JS引擎，用来控制事件循环。当执行setTimeout/鼠标点击/Ajax请求等事件时，会将对应异步任务添加到事件线程中。当事件符合触发条件时，该线程会将其添加到事件队列的队尾，等待JS引擎线程处理。由于JS是单线程的，所以一定得等到JS引擎空闲的时候才会依次处理这些队列中的事件。\n4.定时触发器线程：比如setTimeout、setInterval\n5.异步http请求线程：在XMLHttpRequest在连接后是通过浏览器新开一个线程进行请求的，检测到状态变更后，如果设置了回调，则会产生状态变更事件，放入事件队列中，最后由Js线程执行。\n\n#### GUI线程和JS引擎线程互斥的原因\n浏览器刻意如此设计的，因为JS是可能操作DOM的，如果GUI正在渲染的时候，JS操作了DOM，就会可能出现JS获取的DOM在GUI渲染前后获取的不一致，导致最终渲染的结果与期待的结果不一致。\n\n#### WebWorker 与 ShareWorker\nWebWorker是JS引擎向浏览器申请的一个子线程，可在浏览器端实现密集运算，为Web内容在一个独立的后台线程中允许脚本提供了一种简单的方法，不能操作DOM。\nJS引擎和Worker通过postMassage API通信。\n这个和JS引擎是单线程的说法并不冲突。\nShareWorder是浏览器单独为其开了一个进程来运行Javascript，所有的GUI线程共享同一个ShareWorder。\n\n#### 浏览器渲染过程\n1.浏览器输入url，Browser主进程开启一个下载线程，下载网站内容，下载完成之后通过RenderHost接口转交给Renderer进程。\n2.GUI线程解析DOM树、CSS树、合并DOM树和CSS树，计算元素尺寸位置完成Render布局，绘制页面像素信息，发送给GPU，GPU将各层合成(composite)生成图像，显示在屏幕上。此时触发页面load事件。\n\n#### 渲染和性能、硬件加速\n1.css不会阻塞DOM加载和解析，但是会阻塞Render树渲染。\n2.GPU中各个复合图层是单独绘制的。\n3.元素开启硬件加速之后会变成独立的复合层，此后改变改元素只会影响当前复合层，不会影响别的复合层。能够避免整个页面重绘。\n4.硬件加速原理就是将元素变成复合图层，通过为复合层单独分配资源来渲染而实现渲染加速。（如果复合层过多会导致大量资源的消耗，同样影响性能）\n5.webkit css3中，如果元素加了硬件加速，且设置了index层级，那么在这个元素后面 层级高于或等于该元素层级的元素会被隐式转换未复合图层。\n注意：position-absolute虽然脱离普通文档流，但是未脱离复合层，因此，即使设置了absolute，也还是在同一个复合层当中。\n\n开启GPU加速的方法有 transform动画、opacity动画、translateZ()/translate3D、will-change等\n```css\n.example1 {\n  transform: translateZ(0);\n}\n.example2 {\n  transform: rotateZ(360deg);\n}\n```\n\n#### JS EventLoop\n1.JS引擎为单线程执行的，浏览器中js执行任务分为同步任务和异步任务，同步任务在主线程中执行，形成一个执行栈。主线程之外，事件触发线程管理着任务队列，异步任务有了结果之后就会进入此队列中，当主线程中的同步任务执行完毕之后就会读取异步任务队列，将可执行的任务放入执行栈中执行。\n\n#### 定时器线程\njs中跑的setTimeout、setInterval等定时器，是一个单独的线程管理的控制的，当计时完成就会将特定的事件推送到事件队列中。等待主线程执行。\n由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行，所以，setTimeout会早于setImmediate完成。但是，setTimeout 定时时间默认可能不是0ms，而是3ms或者更多，所以，setImeediate 也可能在 setTimeout 之前执行。\n\n#### microTask\nmicroTask是当前task执行结束之后，下一个task之前，渲染之前立即执行的任务。（如：promise、process.nextTick等，mutationobserver 可用来实现微任务）\nprocess.nextTick() 的回调将在事件循环继续之前解析，所以微任务里面，process.nextTick 会在 promise 等其他微任务之前执行。\n\n\n### 传送门\n[https://segmentfault.com/a/1190000012925872](https://segmentfault.com/a/1190000012925872)\n","slug":"browser-progress","published":1,"updated":"2021-03-30T01:32:00.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7uf50001a0vz2n8g41bb","content":"<p>进程是CPU分配资源的最小单位，分配独立内存，进程之间可通信，但是必须通过内核，使用IPC接口来做，代价比较大<br>线程是CPU调度的最小单位，同一个进程下面可以有多个线程。</p>\n<p>浏览器是作为前端开发者绕不开的话题，理解浏览器的运行原理是每个前端开发者进阶的必经之路。<br>javascript 语言本身当初被发明出来就是为浏览器服务的，只是后面Nodejs的出现为它赋予了更大的能力。</p>\n<h3 id=\"浏览器进程\"><a href=\"#浏览器进程\" class=\"headerlink\" title=\"浏览器进程\"></a>浏览器进程</h3><p>1.browser主进程：负责浏览器界面显示、用户交互、资源管理。<br>2.第三方插件进程：每一个插件对应一个进程<br>3.GPU进程：只有一个，负责3D绘制<br>4.浏览器渲染进程：每个tab都有一个渲染进程，负责页面渲染，脚本执行，事件处理</p>\n<p>浏览器多进程优势：充分利用多核优势、方便沙盒隔离插件等进程、防止单页面或者单插件crash影响其他页面。</p>\n<h4 id=\"浏览器渲染进程：包含多个线程\"><a href=\"#浏览器渲染进程：包含多个线程\" class=\"headerlink\" title=\"浏览器渲染进程：包含多个线程\"></a>浏览器渲染进程：包含多个线程</h4><p>1.GUI线程：负责渲染浏览器界面，解析html、js、css，构建DOM树、CSS树，完成布局和绘制、回流、重绘等。<br>2.JS引擎线程：JS内核，负责处理Javascript脚本，解析和运行JS代码（如V8引擎），一个TAB页中仅有一个JS线程在运行JS程序。<br>注意：GUI线程和JS引擎线程是互斥的，当JS引擎线程执行的时候，GUI线程会被挂起，阻塞页面渲染。待JS引擎空闲的时候才会继续执行。<br>3.事件触发线程：归属于浏览器而不是JS引擎，用来控制事件循环。当执行setTimeout/鼠标点击/Ajax请求等事件时，会将对应异步任务添加到事件线程中。当事件符合触发条件时，该线程会将其添加到事件队列的队尾，等待JS引擎线程处理。由于JS是单线程的，所以一定得等到JS引擎空闲的时候才会依次处理这些队列中的事件。<br>4.定时触发器线程：比如setTimeout、setInterval<br>5.异步http请求线程：在XMLHttpRequest在连接后是通过浏览器新开一个线程进行请求的，检测到状态变更后，如果设置了回调，则会产生状态变更事件，放入事件队列中，最后由Js线程执行。</p>\n<h4 id=\"GUI线程和JS引擎线程互斥的原因\"><a href=\"#GUI线程和JS引擎线程互斥的原因\" class=\"headerlink\" title=\"GUI线程和JS引擎线程互斥的原因\"></a>GUI线程和JS引擎线程互斥的原因</h4><p>浏览器刻意如此设计的，因为JS是可能操作DOM的，如果GUI正在渲染的时候，JS操作了DOM，就会可能出现JS获取的DOM在GUI渲染前后获取的不一致，导致最终渲染的结果与期待的结果不一致。</p>\n<h4 id=\"WebWorker-与-ShareWorker\"><a href=\"#WebWorker-与-ShareWorker\" class=\"headerlink\" title=\"WebWorker 与 ShareWorker\"></a>WebWorker 与 ShareWorker</h4><p>WebWorker是JS引擎向浏览器申请的一个子线程，可在浏览器端实现密集运算，为Web内容在一个独立的后台线程中允许脚本提供了一种简单的方法，不能操作DOM。<br>JS引擎和Worker通过postMassage API通信。<br>这个和JS引擎是单线程的说法并不冲突。<br>ShareWorder是浏览器单独为其开了一个进程来运行Javascript，所有的GUI线程共享同一个ShareWorder。</p>\n<h4 id=\"浏览器渲染过程\"><a href=\"#浏览器渲染过程\" class=\"headerlink\" title=\"浏览器渲染过程\"></a>浏览器渲染过程</h4><p>1.浏览器输入url，Browser主进程开启一个下载线程，下载网站内容，下载完成之后通过RenderHost接口转交给Renderer进程。<br>2.GUI线程解析DOM树、CSS树、合并DOM树和CSS树，计算元素尺寸位置完成Render布局，绘制页面像素信息，发送给GPU，GPU将各层合成(composite)生成图像，显示在屏幕上。此时触发页面load事件。</p>\n<h4 id=\"渲染和性能、硬件加速\"><a href=\"#渲染和性能、硬件加速\" class=\"headerlink\" title=\"渲染和性能、硬件加速\"></a>渲染和性能、硬件加速</h4><p>1.css不会阻塞DOM加载和解析，但是会阻塞Render树渲染。<br>2.GPU中各个复合图层是单独绘制的。<br>3.元素开启硬件加速之后会变成独立的复合层，此后改变改元素只会影响当前复合层，不会影响别的复合层。能够避免整个页面重绘。<br>4.硬件加速原理就是将元素变成复合图层，通过为复合层单独分配资源来渲染而实现渲染加速。（如果复合层过多会导致大量资源的消耗，同样影响性能）<br>5.webkit css3中，如果元素加了硬件加速，且设置了index层级，那么在这个元素后面 层级高于或等于该元素层级的元素会被隐式转换未复合图层。<br>注意：position-absolute虽然脱离普通文档流，但是未脱离复合层，因此，即使设置了absolute，也还是在同一个复合层当中。</p>\n<p>开启GPU加速的方法有 transform动画、opacity动画、translateZ()/translate3D、will-change等<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.example1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateZ</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.example2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotateZ</span>(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JS-EventLoop\"><a href=\"#JS-EventLoop\" class=\"headerlink\" title=\"JS EventLoop\"></a>JS EventLoop</h4><p>1.JS引擎为单线程执行的，浏览器中js执行任务分为同步任务和异步任务，同步任务在主线程中执行，形成一个执行栈。主线程之外，事件触发线程管理着任务队列，异步任务有了结果之后就会进入此队列中，当主线程中的同步任务执行完毕之后就会读取异步任务队列，将可执行的任务放入执行栈中执行。</p>\n<h4 id=\"定时器线程\"><a href=\"#定时器线程\" class=\"headerlink\" title=\"定时器线程\"></a>定时器线程</h4><p>js中跑的setTimeout、setInterval等定时器，是一个单独的线程管理的控制的，当计时完成就会将特定的事件推送到事件队列中。等待主线程执行。<br>由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行，所以，setTimeout会早于setImmediate完成。但是，setTimeout 定时时间默认可能不是0ms，而是3ms或者更多，所以，setImeediate 也可能在 setTimeout 之前执行。</p>\n<h4 id=\"microTask\"><a href=\"#microTask\" class=\"headerlink\" title=\"microTask\"></a>microTask</h4><p>microTask是当前task执行结束之后，下一个task之前，渲染之前立即执行的任务。（如：promise、process.nextTick等，mutationobserver 可用来实现微任务）<br>process.nextTick() 的回调将在事件循环继续之前解析，所以微任务里面，process.nextTick 会在 promise 等其他微任务之前执行。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://segmentfault.com/a/1190000012925872\">https://segmentfault.com/a/1190000012925872</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>进程是CPU分配资源的最小单位，分配独立内存，进程之间可通信，但是必须通过内核，使用IPC接口来做，代价比较大<br>线程是CPU调度的最小单位，同一个进程下面可以有多个线程。</p>\n<p>浏览器是作为前端开发者绕不开的话题，理解浏览器的运行原理是每个前端开发者进阶的必经之路。<br>javascript 语言本身当初被发明出来就是为浏览器服务的，只是后面Nodejs的出现为它赋予了更大的能力。</p>\n<h3 id=\"浏览器进程\"><a href=\"#浏览器进程\" class=\"headerlink\" title=\"浏览器进程\"></a>浏览器进程</h3><p>1.browser主进程：负责浏览器界面显示、用户交互、资源管理。<br>2.第三方插件进程：每一个插件对应一个进程<br>3.GPU进程：只有一个，负责3D绘制<br>4.浏览器渲染进程：每个tab都有一个渲染进程，负责页面渲染，脚本执行，事件处理</p>\n<p>浏览器多进程优势：充分利用多核优势、方便沙盒隔离插件等进程、防止单页面或者单插件crash影响其他页面。</p>\n<h4 id=\"浏览器渲染进程：包含多个线程\"><a href=\"#浏览器渲染进程：包含多个线程\" class=\"headerlink\" title=\"浏览器渲染进程：包含多个线程\"></a>浏览器渲染进程：包含多个线程</h4><p>1.GUI线程：负责渲染浏览器界面，解析html、js、css，构建DOM树、CSS树，完成布局和绘制、回流、重绘等。<br>2.JS引擎线程：JS内核，负责处理Javascript脚本，解析和运行JS代码（如V8引擎），一个TAB页中仅有一个JS线程在运行JS程序。<br>注意：GUI线程和JS引擎线程是互斥的，当JS引擎线程执行的时候，GUI线程会被挂起，阻塞页面渲染。待JS引擎空闲的时候才会继续执行。<br>3.事件触发线程：归属于浏览器而不是JS引擎，用来控制事件循环。当执行setTimeout/鼠标点击/Ajax请求等事件时，会将对应异步任务添加到事件线程中。当事件符合触发条件时，该线程会将其添加到事件队列的队尾，等待JS引擎线程处理。由于JS是单线程的，所以一定得等到JS引擎空闲的时候才会依次处理这些队列中的事件。<br>4.定时触发器线程：比如setTimeout、setInterval<br>5.异步http请求线程：在XMLHttpRequest在连接后是通过浏览器新开一个线程进行请求的，检测到状态变更后，如果设置了回调，则会产生状态变更事件，放入事件队列中，最后由Js线程执行。</p>\n<h4 id=\"GUI线程和JS引擎线程互斥的原因\"><a href=\"#GUI线程和JS引擎线程互斥的原因\" class=\"headerlink\" title=\"GUI线程和JS引擎线程互斥的原因\"></a>GUI线程和JS引擎线程互斥的原因</h4><p>浏览器刻意如此设计的，因为JS是可能操作DOM的，如果GUI正在渲染的时候，JS操作了DOM，就会可能出现JS获取的DOM在GUI渲染前后获取的不一致，导致最终渲染的结果与期待的结果不一致。</p>\n<h4 id=\"WebWorker-与-ShareWorker\"><a href=\"#WebWorker-与-ShareWorker\" class=\"headerlink\" title=\"WebWorker 与 ShareWorker\"></a>WebWorker 与 ShareWorker</h4><p>WebWorker是JS引擎向浏览器申请的一个子线程，可在浏览器端实现密集运算，为Web内容在一个独立的后台线程中允许脚本提供了一种简单的方法，不能操作DOM。<br>JS引擎和Worker通过postMassage API通信。<br>这个和JS引擎是单线程的说法并不冲突。<br>ShareWorder是浏览器单独为其开了一个进程来运行Javascript，所有的GUI线程共享同一个ShareWorder。</p>\n<h4 id=\"浏览器渲染过程\"><a href=\"#浏览器渲染过程\" class=\"headerlink\" title=\"浏览器渲染过程\"></a>浏览器渲染过程</h4><p>1.浏览器输入url，Browser主进程开启一个下载线程，下载网站内容，下载完成之后通过RenderHost接口转交给Renderer进程。<br>2.GUI线程解析DOM树、CSS树、合并DOM树和CSS树，计算元素尺寸位置完成Render布局，绘制页面像素信息，发送给GPU，GPU将各层合成(composite)生成图像，显示在屏幕上。此时触发页面load事件。</p>\n<h4 id=\"渲染和性能、硬件加速\"><a href=\"#渲染和性能、硬件加速\" class=\"headerlink\" title=\"渲染和性能、硬件加速\"></a>渲染和性能、硬件加速</h4><p>1.css不会阻塞DOM加载和解析，但是会阻塞Render树渲染。<br>2.GPU中各个复合图层是单独绘制的。<br>3.元素开启硬件加速之后会变成独立的复合层，此后改变改元素只会影响当前复合层，不会影响别的复合层。能够避免整个页面重绘。<br>4.硬件加速原理就是将元素变成复合图层，通过为复合层单独分配资源来渲染而实现渲染加速。（如果复合层过多会导致大量资源的消耗，同样影响性能）<br>5.webkit css3中，如果元素加了硬件加速，且设置了index层级，那么在这个元素后面 层级高于或等于该元素层级的元素会被隐式转换未复合图层。<br>注意：position-absolute虽然脱离普通文档流，但是未脱离复合层，因此，即使设置了absolute，也还是在同一个复合层当中。</p>\n<p>开启GPU加速的方法有 transform动画、opacity动画、translateZ()/translate3D、will-change等<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.example1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateZ</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.example2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotateZ</span>(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JS-EventLoop\"><a href=\"#JS-EventLoop\" class=\"headerlink\" title=\"JS EventLoop\"></a>JS EventLoop</h4><p>1.JS引擎为单线程执行的，浏览器中js执行任务分为同步任务和异步任务，同步任务在主线程中执行，形成一个执行栈。主线程之外，事件触发线程管理着任务队列，异步任务有了结果之后就会进入此队列中，当主线程中的同步任务执行完毕之后就会读取异步任务队列，将可执行的任务放入执行栈中执行。</p>\n<h4 id=\"定时器线程\"><a href=\"#定时器线程\" class=\"headerlink\" title=\"定时器线程\"></a>定时器线程</h4><p>js中跑的setTimeout、setInterval等定时器，是一个单独的线程管理的控制的，当计时完成就会将特定的事件推送到事件队列中。等待主线程执行。<br>由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行，所以，setTimeout会早于setImmediate完成。但是，setTimeout 定时时间默认可能不是0ms，而是3ms或者更多，所以，setImeediate 也可能在 setTimeout 之前执行。</p>\n<h4 id=\"microTask\"><a href=\"#microTask\" class=\"headerlink\" title=\"microTask\"></a>microTask</h4><p>microTask是当前task执行结束之后，下一个task之前，渲染之前立即执行的任务。（如：promise、process.nextTick等，mutationobserver 可用来实现微任务）<br>process.nextTick() 的回调将在事件循环继续之前解析，所以微任务里面，process.nextTick 会在 promise 等其他微任务之前执行。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://segmentfault.com/a/1190000012925872\">https://segmentfault.com/a/1190000012925872</a></p>\n"},{"title":"cdn 简介","date":"2021-04-02T16:00:00.000Z","_content":"\n\n本文简单介绍 CDN 的缓存策略 以及 附带其关联名词解释\n\n\n## CDN（Content Delivery Network，内容分发网络）\n当下的互联网产品中 CDN 几乎已经成了标配，使用 CDN 能够加速网站资源的下载，能够避免浏览器对请求并发的限制。\n那么它为什么能够实现加速资源下载呢？\n\nCDN，中文意思为“内容分发网络”，从字面解释可以得知，是做内容分发的，也就是说将用户的内容分发到各个地方，即在各个地方都部署“CDN节点服务器”。\n\n因此 ***CDN加速原因***总结一句话就是：通过在全国各地部署的节点服务器，为各个地方发起的请求分配最优的资源数据源。\n\n那么，如何才能做到为个区域发起的请求分配最优的资源数据源呢？\n\n这个跟 DNS 有关。\n\n当用户访问使用 CDN 资源服务的网站时，请求首次发起之后，域名解析请求会被流转到预先授权的 DNS 服务器。\nDNS 服务器解析的时候会发现域名已经配置了 CNAME 记录（需要用户提前配置好），到了 CDN 服务商的某个域名。\n然后域名解析请求会被发送至 CDN 服务商的 DNS 调度系统，该系统通过一组预先定义好的策略(如内容类型、地理区域、入网类型、网络负载状况等)，将最优的 CDN 节点 IP 地址提供给用户。\n使用户通过该 IP 即可以最快的速度获得请求内容。\n\n如下图所示。\n\n### 假设用户访问 qcloud.com\n#### 1.没有cdn，发起请求过程\n\n<img src=\"http://zhoushirong.github.io/img/cdn1.png\" alt=\"无CDN请求场景\" width=\"85%\">\n\n由于服务器部署在广州，而北京、新疆距离广州距离不一样，因此会有**不同程度的延迟**。\n\n此时的域名解析：\n<img src=\"http://zhoushirong.github.io/img/cdn2.png\" alt=\"无CDN域名解析场景\" width=\"85%\">\n\n1) 本地DNS对域名进行解析,本地DNS经过 本地缓存识别 —— 路由缓存识别 —— 电信服务商缓存识别 —— DNS服务商解析等一系列解析\n2) 之后得到服务器 IP 地址\n3) 根据IP地址定向从服务器获取数据。\n\n#### 2.cdn的请求，发起过程\n\n<img src=\"http://zhoushirong.github.io/img/cdn4.png\" alt=\"有CDN请求场景\" width=\"85%\">\n\n一般来说 CDN 厂商会在全国各个大的区域部署一些服务器来作为 CDN 节点，这些节点可以用来缓存请求数据，以最快、最近、最优的方式返回请求数据\n\n接入 CDN 以后，需要先给域名配置一个 CNAME 记录，当域名解析该域名的时候，此时的域名解析会被指向 CNAME 记录的值。\n如下图所示。\n\n<img src=\"http://zhoushirong.github.io/img/cdn3.png\" alt=\"有CDN域名解析场景\" width=\"85%\">\n\n0）用户接入 CDN 时候需要给域名配置一个 CNAME 记录到 CDN 厂商的某个域名(如：XX)，而 CDN 厂商则会对针对 XX 域名做相应的处理。\n1) 访问 qcloud.com 域名\n2) 本地 DNS 对域名进行解析，本地 DNS 经过本地缓存识别 ——> 路由缓存识别 ——> 电信服务商缓存识别 ——> DNS服务商解析... 等一系列解析\n3) 解析之后得到 CNAME 记录的 CDN 域名(如：XX) \n4) 请求到达 CDN 域名 XX 对应的服务器，在该服务器上通过一系列算法选出当前最优节点。\n5/6) 将最优节点的 IP 返回给用户\n7/8) 用户通过该 IP 即可得到改 IP 对应节点上的数据了。\n\n\n--- \n\n## 名词解释\n### DNS (域名系统)\nDNS 系统是一个分布式分层数据库，用于存储 IP 地址和其它数据，并按照名称进行查询，他用于将人类可读的域名转换为机器可读的 IP 地址。\nDNS 目录存储于全球范围内分布的域名服务器上，定期更新。\n\n#### DNS 服务器类型\nDNS 服务器存储域名数据库，并根据来自网络中客户端的 DNS查询 来处理域名。\n权威服务器 —— 保存 DNS 名称记录（包括 A、AAAA 和 CNAME）的服务器。\n非权威服务器—— 根据以前的域名查询来构建缓存文件。它不存放原始名称记录。\n\n```shell\n$ nslookup epoos.com\n\nServer:\t\t10.11.56.23\nAddress:\t10.11.56.23#53\nNon-authoritative answer:\nName:\tepoos.com\nAddress: 111.230.220.62\n```\n通过 nslookup 命令查询得知，当前查询 epoos.com 域名是由 dns 服务器 10.11.56.23 返回的，其结果并不是权威服务器的结果。\n该 dns 服务器应该是[dnspod](https://docs.dnspod.cn/dns/5f471dbc8ae73e11c5b01986/)(国内的 DNS 服务商) 提供的。\n\n```html\nNslookup 是一个监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。\n```\n\n### CNAME (Canonical Name Record)\nCNAME 是域名 DNS 的一种记录，用于解析域名到另外一个域名。\n域名解析服务器遇到CNAME记录会以映射到的目标重新开始查询，这对于需要在同一个IP地址上运行多个服务的情况来说非常方便。\n\n对于多个域名共用同一个IP的情况尤其有用，如将ftp.example.com 和 www.example.com 都指向DNS记录 example.com，而后者则有一个指向IP地址的A记录。\n如此一来，若服务器 IP 地址改变，则只需修改 example.com 的A记录即可。\n\nCNAME 多用在 CDN 加速上。\n\n### A 记录\nA (Address) 记录是用来指定主机名（或域名）对应的IP地址记录\n\n### CDN 缓存穿透\nCDN 如果没有缓存，则回源进行查找，如果请求资源每次都带有随机数，则每次都会回源，这就是缓存穿透。\n","source":"_posts/cdn.md","raw":"\n---\ntitle: cdn 简介\ndate: 2021/04/03\ntag: [cdn,dns,cname]\ncategory: 笔记\n---\n\n\n本文简单介绍 CDN 的缓存策略 以及 附带其关联名词解释\n\n\n## CDN（Content Delivery Network，内容分发网络）\n当下的互联网产品中 CDN 几乎已经成了标配，使用 CDN 能够加速网站资源的下载，能够避免浏览器对请求并发的限制。\n那么它为什么能够实现加速资源下载呢？\n\nCDN，中文意思为“内容分发网络”，从字面解释可以得知，是做内容分发的，也就是说将用户的内容分发到各个地方，即在各个地方都部署“CDN节点服务器”。\n\n因此 ***CDN加速原因***总结一句话就是：通过在全国各地部署的节点服务器，为各个地方发起的请求分配最优的资源数据源。\n\n那么，如何才能做到为个区域发起的请求分配最优的资源数据源呢？\n\n这个跟 DNS 有关。\n\n当用户访问使用 CDN 资源服务的网站时，请求首次发起之后，域名解析请求会被流转到预先授权的 DNS 服务器。\nDNS 服务器解析的时候会发现域名已经配置了 CNAME 记录（需要用户提前配置好），到了 CDN 服务商的某个域名。\n然后域名解析请求会被发送至 CDN 服务商的 DNS 调度系统，该系统通过一组预先定义好的策略(如内容类型、地理区域、入网类型、网络负载状况等)，将最优的 CDN 节点 IP 地址提供给用户。\n使用户通过该 IP 即可以最快的速度获得请求内容。\n\n如下图所示。\n\n### 假设用户访问 qcloud.com\n#### 1.没有cdn，发起请求过程\n\n<img src=\"http://zhoushirong.github.io/img/cdn1.png\" alt=\"无CDN请求场景\" width=\"85%\">\n\n由于服务器部署在广州，而北京、新疆距离广州距离不一样，因此会有**不同程度的延迟**。\n\n此时的域名解析：\n<img src=\"http://zhoushirong.github.io/img/cdn2.png\" alt=\"无CDN域名解析场景\" width=\"85%\">\n\n1) 本地DNS对域名进行解析,本地DNS经过 本地缓存识别 —— 路由缓存识别 —— 电信服务商缓存识别 —— DNS服务商解析等一系列解析\n2) 之后得到服务器 IP 地址\n3) 根据IP地址定向从服务器获取数据。\n\n#### 2.cdn的请求，发起过程\n\n<img src=\"http://zhoushirong.github.io/img/cdn4.png\" alt=\"有CDN请求场景\" width=\"85%\">\n\n一般来说 CDN 厂商会在全国各个大的区域部署一些服务器来作为 CDN 节点，这些节点可以用来缓存请求数据，以最快、最近、最优的方式返回请求数据\n\n接入 CDN 以后，需要先给域名配置一个 CNAME 记录，当域名解析该域名的时候，此时的域名解析会被指向 CNAME 记录的值。\n如下图所示。\n\n<img src=\"http://zhoushirong.github.io/img/cdn3.png\" alt=\"有CDN域名解析场景\" width=\"85%\">\n\n0）用户接入 CDN 时候需要给域名配置一个 CNAME 记录到 CDN 厂商的某个域名(如：XX)，而 CDN 厂商则会对针对 XX 域名做相应的处理。\n1) 访问 qcloud.com 域名\n2) 本地 DNS 对域名进行解析，本地 DNS 经过本地缓存识别 ——> 路由缓存识别 ——> 电信服务商缓存识别 ——> DNS服务商解析... 等一系列解析\n3) 解析之后得到 CNAME 记录的 CDN 域名(如：XX) \n4) 请求到达 CDN 域名 XX 对应的服务器，在该服务器上通过一系列算法选出当前最优节点。\n5/6) 将最优节点的 IP 返回给用户\n7/8) 用户通过该 IP 即可得到改 IP 对应节点上的数据了。\n\n\n--- \n\n## 名词解释\n### DNS (域名系统)\nDNS 系统是一个分布式分层数据库，用于存储 IP 地址和其它数据，并按照名称进行查询，他用于将人类可读的域名转换为机器可读的 IP 地址。\nDNS 目录存储于全球范围内分布的域名服务器上，定期更新。\n\n#### DNS 服务器类型\nDNS 服务器存储域名数据库，并根据来自网络中客户端的 DNS查询 来处理域名。\n权威服务器 —— 保存 DNS 名称记录（包括 A、AAAA 和 CNAME）的服务器。\n非权威服务器—— 根据以前的域名查询来构建缓存文件。它不存放原始名称记录。\n\n```shell\n$ nslookup epoos.com\n\nServer:\t\t10.11.56.23\nAddress:\t10.11.56.23#53\nNon-authoritative answer:\nName:\tepoos.com\nAddress: 111.230.220.62\n```\n通过 nslookup 命令查询得知，当前查询 epoos.com 域名是由 dns 服务器 10.11.56.23 返回的，其结果并不是权威服务器的结果。\n该 dns 服务器应该是[dnspod](https://docs.dnspod.cn/dns/5f471dbc8ae73e11c5b01986/)(国内的 DNS 服务商) 提供的。\n\n```html\nNslookup 是一个监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。\n```\n\n### CNAME (Canonical Name Record)\nCNAME 是域名 DNS 的一种记录，用于解析域名到另外一个域名。\n域名解析服务器遇到CNAME记录会以映射到的目标重新开始查询，这对于需要在同一个IP地址上运行多个服务的情况来说非常方便。\n\n对于多个域名共用同一个IP的情况尤其有用，如将ftp.example.com 和 www.example.com 都指向DNS记录 example.com，而后者则有一个指向IP地址的A记录。\n如此一来，若服务器 IP 地址改变，则只需修改 example.com 的A记录即可。\n\nCNAME 多用在 CDN 加速上。\n\n### A 记录\nA (Address) 记录是用来指定主机名（或域名）对应的IP地址记录\n\n### CDN 缓存穿透\nCDN 如果没有缓存，则回源进行查找，如果请求资源每次都带有随机数，则每次都会回源，这就是缓存穿透。\n","slug":"cdn","published":1,"updated":"2021-04-04T00:50:29.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7uf60002a0vzdod9958w","content":"<p>本文简单介绍 CDN 的缓存策略 以及 附带其关联名词解释</p>\n<h2 id=\"CDN（Content-Delivery-Network，内容分发网络）\"><a href=\"#CDN（Content-Delivery-Network，内容分发网络）\" class=\"headerlink\" title=\"CDN（Content Delivery Network，内容分发网络）\"></a>CDN（Content Delivery Network，内容分发网络）</h2><p>当下的互联网产品中 CDN 几乎已经成了标配，使用 CDN 能够加速网站资源的下载，能够避免浏览器对请求并发的限制。<br>那么它为什么能够实现加速资源下载呢？</p>\n<p>CDN，中文意思为“内容分发网络”，从字面解释可以得知，是做内容分发的，也就是说将用户的内容分发到各个地方，即在各个地方都部署“CDN节点服务器”。</p>\n<p>因此 <strong><em>CDN加速原因</em></strong>总结一句话就是：通过在全国各地部署的节点服务器，为各个地方发起的请求分配最优的资源数据源。</p>\n<p>那么，如何才能做到为个区域发起的请求分配最优的资源数据源呢？</p>\n<p>这个跟 DNS 有关。</p>\n<p>当用户访问使用 CDN 资源服务的网站时，请求首次发起之后，域名解析请求会被流转到预先授权的 DNS 服务器。<br>DNS 服务器解析的时候会发现域名已经配置了 CNAME 记录（需要用户提前配置好），到了 CDN 服务商的某个域名。<br>然后域名解析请求会被发送至 CDN 服务商的 DNS 调度系统，该系统通过一组预先定义好的策略(如内容类型、地理区域、入网类型、网络负载状况等)，将最优的 CDN 节点 IP 地址提供给用户。<br>使用户通过该 IP 即可以最快的速度获得请求内容。</p>\n<p>如下图所示。</p>\n<h3 id=\"假设用户访问-qcloud-com\"><a href=\"#假设用户访问-qcloud-com\" class=\"headerlink\" title=\"假设用户访问 qcloud.com\"></a>假设用户访问 qcloud.com</h3><h4 id=\"1-没有cdn，发起请求过程\"><a href=\"#1-没有cdn，发起请求过程\" class=\"headerlink\" title=\"1.没有cdn，发起请求过程\"></a>1.没有cdn，发起请求过程</h4><p><img src=\"http://zhoushirong.github.io/img/cdn1.png\" alt=\"无CDN请求场景\" width=\"85%\"></p>\n<p>由于服务器部署在广州，而北京、新疆距离广州距离不一样，因此会有<strong>不同程度的延迟</strong>。</p>\n<p>此时的域名解析：<br><img src=\"http://zhoushirong.github.io/img/cdn2.png\" alt=\"无CDN域名解析场景\" width=\"85%\"></p>\n<p>1) 本地DNS对域名进行解析,本地DNS经过 本地缓存识别 —— 路由缓存识别 —— 电信服务商缓存识别 —— DNS服务商解析等一系列解析<br>2) 之后得到服务器 IP 地址<br>3) 根据IP地址定向从服务器获取数据。</p>\n<h4 id=\"2-cdn的请求，发起过程\"><a href=\"#2-cdn的请求，发起过程\" class=\"headerlink\" title=\"2.cdn的请求，发起过程\"></a>2.cdn的请求，发起过程</h4><p><img src=\"http://zhoushirong.github.io/img/cdn4.png\" alt=\"有CDN请求场景\" width=\"85%\"></p>\n<p>一般来说 CDN 厂商会在全国各个大的区域部署一些服务器来作为 CDN 节点，这些节点可以用来缓存请求数据，以最快、最近、最优的方式返回请求数据</p>\n<p>接入 CDN 以后，需要先给域名配置一个 CNAME 记录，当域名解析该域名的时候，此时的域名解析会被指向 CNAME 记录的值。<br>如下图所示。</p>\n<p><img src=\"http://zhoushirong.github.io/img/cdn3.png\" alt=\"有CDN域名解析场景\" width=\"85%\"></p>\n<p>0）用户接入 CDN 时候需要给域名配置一个 CNAME 记录到 CDN 厂商的某个域名(如：XX)，而 CDN 厂商则会对针对 XX 域名做相应的处理。<br>1) 访问 qcloud.com 域名<br>2) 本地 DNS 对域名进行解析，本地 DNS 经过本地缓存识别 ——&gt; 路由缓存识别 ——&gt; 电信服务商缓存识别 ——&gt; DNS服务商解析… 等一系列解析<br>3) 解析之后得到 CNAME 记录的 CDN 域名(如：XX)<br>4) 请求到达 CDN 域名 XX 对应的服务器，在该服务器上通过一系列算法选出当前最优节点。<br>5/6) 将最优节点的 IP 返回给用户<br>7/8) 用户通过该 IP 即可得到改 IP 对应节点上的数据了。</p>\n<hr>\n<h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><h3 id=\"DNS-域名系统\"><a href=\"#DNS-域名系统\" class=\"headerlink\" title=\"DNS (域名系统)\"></a>DNS (域名系统)</h3><p>DNS 系统是一个分布式分层数据库，用于存储 IP 地址和其它数据，并按照名称进行查询，他用于将人类可读的域名转换为机器可读的 IP 地址。<br>DNS 目录存储于全球范围内分布的域名服务器上，定期更新。</p>\n<h4 id=\"DNS-服务器类型\"><a href=\"#DNS-服务器类型\" class=\"headerlink\" title=\"DNS 服务器类型\"></a>DNS 服务器类型</h4><p>DNS 服务器存储域名数据库，并根据来自网络中客户端的 DNS查询 来处理域名。<br>权威服务器 —— 保存 DNS 名称记录（包括 A、AAAA 和 CNAME）的服务器。<br>非权威服务器—— 根据以前的域名查询来构建缓存文件。它不存放原始名称记录。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nslookup epoos.com</span></span><br><span class=\"line\"></span><br><span class=\"line\">Server:\t\t10.11.56.23</span><br><span class=\"line\">Address:\t10.11.56.23#53</span><br><span class=\"line\">Non-authoritative answer:</span><br><span class=\"line\">Name:\tepoos.com</span><br><span class=\"line\">Address: 111.230.220.62</span><br></pre></td></tr></table></figure>\n<p>通过 nslookup 命令查询得知，当前查询 epoos.com 域名是由 dns 服务器 10.11.56.23 返回的，其结果并不是权威服务器的结果。<br>该 dns 服务器应该是<a href=\"https://docs.dnspod.cn/dns/5f471dbc8ae73e11c5b01986/\">dnspod</a>(国内的 DNS 服务商) 提供的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Nslookup 是一个监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。</span><br></pre></td></tr></table></figure>\n<h3 id=\"CNAME-Canonical-Name-Record\"><a href=\"#CNAME-Canonical-Name-Record\" class=\"headerlink\" title=\"CNAME (Canonical Name Record)\"></a>CNAME (Canonical Name Record)</h3><p>CNAME 是域名 DNS 的一种记录，用于解析域名到另外一个域名。<br>域名解析服务器遇到CNAME记录会以映射到的目标重新开始查询，这对于需要在同一个IP地址上运行多个服务的情况来说非常方便。</p>\n<p>对于多个域名共用同一个IP的情况尤其有用，如将ftp.example.com 和 <a href=\"http://www.example.com\">www.example.com</a> 都指向DNS记录 example.com，而后者则有一个指向IP地址的A记录。<br>如此一来，若服务器 IP 地址改变，则只需修改 example.com 的A记录即可。</p>\n<p>CNAME 多用在 CDN 加速上。</p>\n<h3 id=\"A-记录\"><a href=\"#A-记录\" class=\"headerlink\" title=\"A 记录\"></a>A 记录</h3><p>A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录</p>\n<h3 id=\"CDN-缓存穿透\"><a href=\"#CDN-缓存穿透\" class=\"headerlink\" title=\"CDN 缓存穿透\"></a>CDN 缓存穿透</h3><p>CDN 如果没有缓存，则回源进行查找，如果请求资源每次都带有随机数，则每次都会回源，这就是缓存穿透。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文简单介绍 CDN 的缓存策略 以及 附带其关联名词解释</p>\n<h2 id=\"CDN（Content-Delivery-Network，内容分发网络）\"><a href=\"#CDN（Content-Delivery-Network，内容分发网络）\" class=\"headerlink\" title=\"CDN（Content Delivery Network，内容分发网络）\"></a>CDN（Content Delivery Network，内容分发网络）</h2><p>当下的互联网产品中 CDN 几乎已经成了标配，使用 CDN 能够加速网站资源的下载，能够避免浏览器对请求并发的限制。<br>那么它为什么能够实现加速资源下载呢？</p>\n<p>CDN，中文意思为“内容分发网络”，从字面解释可以得知，是做内容分发的，也就是说将用户的内容分发到各个地方，即在各个地方都部署“CDN节点服务器”。</p>\n<p>因此 <strong><em>CDN加速原因</em></strong>总结一句话就是：通过在全国各地部署的节点服务器，为各个地方发起的请求分配最优的资源数据源。</p>\n<p>那么，如何才能做到为个区域发起的请求分配最优的资源数据源呢？</p>\n<p>这个跟 DNS 有关。</p>\n<p>当用户访问使用 CDN 资源服务的网站时，请求首次发起之后，域名解析请求会被流转到预先授权的 DNS 服务器。<br>DNS 服务器解析的时候会发现域名已经配置了 CNAME 记录（需要用户提前配置好），到了 CDN 服务商的某个域名。<br>然后域名解析请求会被发送至 CDN 服务商的 DNS 调度系统，该系统通过一组预先定义好的策略(如内容类型、地理区域、入网类型、网络负载状况等)，将最优的 CDN 节点 IP 地址提供给用户。<br>使用户通过该 IP 即可以最快的速度获得请求内容。</p>\n<p>如下图所示。</p>\n<h3 id=\"假设用户访问-qcloud-com\"><a href=\"#假设用户访问-qcloud-com\" class=\"headerlink\" title=\"假设用户访问 qcloud.com\"></a>假设用户访问 qcloud.com</h3><h4 id=\"1-没有cdn，发起请求过程\"><a href=\"#1-没有cdn，发起请求过程\" class=\"headerlink\" title=\"1.没有cdn，发起请求过程\"></a>1.没有cdn，发起请求过程</h4><p><img src=\"http://zhoushirong.github.io/img/cdn1.png\" alt=\"无CDN请求场景\" width=\"85%\"></p>\n<p>由于服务器部署在广州，而北京、新疆距离广州距离不一样，因此会有<strong>不同程度的延迟</strong>。</p>\n<p>此时的域名解析：<br><img src=\"http://zhoushirong.github.io/img/cdn2.png\" alt=\"无CDN域名解析场景\" width=\"85%\"></p>\n<p>1) 本地DNS对域名进行解析,本地DNS经过 本地缓存识别 —— 路由缓存识别 —— 电信服务商缓存识别 —— DNS服务商解析等一系列解析<br>2) 之后得到服务器 IP 地址<br>3) 根据IP地址定向从服务器获取数据。</p>\n<h4 id=\"2-cdn的请求，发起过程\"><a href=\"#2-cdn的请求，发起过程\" class=\"headerlink\" title=\"2.cdn的请求，发起过程\"></a>2.cdn的请求，发起过程</h4><p><img src=\"http://zhoushirong.github.io/img/cdn4.png\" alt=\"有CDN请求场景\" width=\"85%\"></p>\n<p>一般来说 CDN 厂商会在全国各个大的区域部署一些服务器来作为 CDN 节点，这些节点可以用来缓存请求数据，以最快、最近、最优的方式返回请求数据</p>\n<p>接入 CDN 以后，需要先给域名配置一个 CNAME 记录，当域名解析该域名的时候，此时的域名解析会被指向 CNAME 记录的值。<br>如下图所示。</p>\n<p><img src=\"http://zhoushirong.github.io/img/cdn3.png\" alt=\"有CDN域名解析场景\" width=\"85%\"></p>\n<p>0）用户接入 CDN 时候需要给域名配置一个 CNAME 记录到 CDN 厂商的某个域名(如：XX)，而 CDN 厂商则会对针对 XX 域名做相应的处理。<br>1) 访问 qcloud.com 域名<br>2) 本地 DNS 对域名进行解析，本地 DNS 经过本地缓存识别 ——&gt; 路由缓存识别 ——&gt; 电信服务商缓存识别 ——&gt; DNS服务商解析… 等一系列解析<br>3) 解析之后得到 CNAME 记录的 CDN 域名(如：XX)<br>4) 请求到达 CDN 域名 XX 对应的服务器，在该服务器上通过一系列算法选出当前最优节点。<br>5/6) 将最优节点的 IP 返回给用户<br>7/8) 用户通过该 IP 即可得到改 IP 对应节点上的数据了。</p>\n<hr>\n<h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><h3 id=\"DNS-域名系统\"><a href=\"#DNS-域名系统\" class=\"headerlink\" title=\"DNS (域名系统)\"></a>DNS (域名系统)</h3><p>DNS 系统是一个分布式分层数据库，用于存储 IP 地址和其它数据，并按照名称进行查询，他用于将人类可读的域名转换为机器可读的 IP 地址。<br>DNS 目录存储于全球范围内分布的域名服务器上，定期更新。</p>\n<h4 id=\"DNS-服务器类型\"><a href=\"#DNS-服务器类型\" class=\"headerlink\" title=\"DNS 服务器类型\"></a>DNS 服务器类型</h4><p>DNS 服务器存储域名数据库，并根据来自网络中客户端的 DNS查询 来处理域名。<br>权威服务器 —— 保存 DNS 名称记录（包括 A、AAAA 和 CNAME）的服务器。<br>非权威服务器—— 根据以前的域名查询来构建缓存文件。它不存放原始名称记录。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nslookup epoos.com</span></span><br><span class=\"line\"></span><br><span class=\"line\">Server:\t\t10.11.56.23</span><br><span class=\"line\">Address:\t10.11.56.23#53</span><br><span class=\"line\">Non-authoritative answer:</span><br><span class=\"line\">Name:\tepoos.com</span><br><span class=\"line\">Address: 111.230.220.62</span><br></pre></td></tr></table></figure>\n<p>通过 nslookup 命令查询得知，当前查询 epoos.com 域名是由 dns 服务器 10.11.56.23 返回的，其结果并不是权威服务器的结果。<br>该 dns 服务器应该是<a href=\"https://docs.dnspod.cn/dns/5f471dbc8ae73e11c5b01986/\">dnspod</a>(国内的 DNS 服务商) 提供的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Nslookup 是一个监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。</span><br></pre></td></tr></table></figure>\n<h3 id=\"CNAME-Canonical-Name-Record\"><a href=\"#CNAME-Canonical-Name-Record\" class=\"headerlink\" title=\"CNAME (Canonical Name Record)\"></a>CNAME (Canonical Name Record)</h3><p>CNAME 是域名 DNS 的一种记录，用于解析域名到另外一个域名。<br>域名解析服务器遇到CNAME记录会以映射到的目标重新开始查询，这对于需要在同一个IP地址上运行多个服务的情况来说非常方便。</p>\n<p>对于多个域名共用同一个IP的情况尤其有用，如将ftp.example.com 和 <a href=\"http://www.example.com\">www.example.com</a> 都指向DNS记录 example.com，而后者则有一个指向IP地址的A记录。<br>如此一来，若服务器 IP 地址改变，则只需修改 example.com 的A记录即可。</p>\n<p>CNAME 多用在 CDN 加速上。</p>\n<h3 id=\"A-记录\"><a href=\"#A-记录\" class=\"headerlink\" title=\"A 记录\"></a>A 记录</h3><p>A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录</p>\n<h3 id=\"CDN-缓存穿透\"><a href=\"#CDN-缓存穿透\" class=\"headerlink\" title=\"CDN 缓存穿透\"></a>CDN 缓存穿透</h3><p>CDN 如果没有缓存，则回源进行查找，如果请求资源每次都带有随机数，则每次都会回源，这就是缓存穿透。</p>\n"},{"title":"commonjs与es6 module","date":"2020-10-20T16:00:00.000Z","_content":"\n当前最主流的两个模块化方案：nodejs使用的是commonjs规范、前台浏览器端主要使用的是es6 Module\nnodejs当前就是commonjs规范的代表实践者，因此用的是require。\nimport是es6新增的api，在语言标准层面上，实现了模块功能。旨在成为浏览器和服务器端的通用模块解决方案。\n\n用法如下：\n\nES6 Module\n```javascript\nexport a = 1\nexport default b = 2\n```\n```javascript\nimport { a } from x.js\nimport b from x.js\n```\n\ncommonjs require\n```javascript\nmodule.exports = {\n  a: 1,\n  b: 2\n}\n```\n当然，Nodejs为每个模块提供了一个 exports变量，指向module.exports，相当于\n```javascript\nvar exports = module.exports\n```\n因此可以直接使用\n```javascript\nexports.a = {} // 不能重写 exports,比如：exports = { a: {} }\n```\n调用方法\n```javascript\nvar x = require('x.js')\nconsole.log(x.a, x.b)\n```\n\n\n### commonjs和es6 module对比\n1.commonjs输出的是值的拷贝、es6 输出的是值的引用\n2.commonjs是运行时加载，es6 是编译时输出接口\n\n对待循环引用的区别：\nes6模块，遇到模块加载命令import时，不会去执行模块，而是只生成一个引用。等到真的需要用到时，再到模块里面去取值。\n因此遇到循环引用的时候会抛出一个错误。\nCommonJS模块，的特性是加载时执行，在首次加载的时候就已经执行出结果了，此结果会一直缓存在内存中，等需要用到的时候直接取用缓存结果，因此，如果出现循环引用，只会输出已经执行的部分\n\n\n### 其它，amd、cmd\namd和cmd是早期社区提出的标准，曾经流行过一段时间。这两个标准都是直接在前端浏览器端使用的。\namd标准的代表是requirejs，它推崇依赖前置，提前执行\ncmd标准的代表是seajs，它推崇依赖就近，延迟执行；requirejs后期版本也支持延迟执行\n\n\n### 传送门\n[https://juejin.im/post/6844903576309858318](https://juejin.im/post/6844903576309858318)\n[https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html](https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html)\n[https://es6.ruanyifeng.com/#docs/module-loader](https://es6.ruanyifeng.com/#docs/module-loader)\n","source":"_posts/cmd.md","raw":"---\ntitle: commonjs与es6 module\ndate: 2020/10/21\ntag: [基础,面试,试题,commonjs,es6Module]\ncategory: 技术\n---\n\n当前最主流的两个模块化方案：nodejs使用的是commonjs规范、前台浏览器端主要使用的是es6 Module\nnodejs当前就是commonjs规范的代表实践者，因此用的是require。\nimport是es6新增的api，在语言标准层面上，实现了模块功能。旨在成为浏览器和服务器端的通用模块解决方案。\n\n用法如下：\n\nES6 Module\n```javascript\nexport a = 1\nexport default b = 2\n```\n```javascript\nimport { a } from x.js\nimport b from x.js\n```\n\ncommonjs require\n```javascript\nmodule.exports = {\n  a: 1,\n  b: 2\n}\n```\n当然，Nodejs为每个模块提供了一个 exports变量，指向module.exports，相当于\n```javascript\nvar exports = module.exports\n```\n因此可以直接使用\n```javascript\nexports.a = {} // 不能重写 exports,比如：exports = { a: {} }\n```\n调用方法\n```javascript\nvar x = require('x.js')\nconsole.log(x.a, x.b)\n```\n\n\n### commonjs和es6 module对比\n1.commonjs输出的是值的拷贝、es6 输出的是值的引用\n2.commonjs是运行时加载，es6 是编译时输出接口\n\n对待循环引用的区别：\nes6模块，遇到模块加载命令import时，不会去执行模块，而是只生成一个引用。等到真的需要用到时，再到模块里面去取值。\n因此遇到循环引用的时候会抛出一个错误。\nCommonJS模块，的特性是加载时执行，在首次加载的时候就已经执行出结果了，此结果会一直缓存在内存中，等需要用到的时候直接取用缓存结果，因此，如果出现循环引用，只会输出已经执行的部分\n\n\n### 其它，amd、cmd\namd和cmd是早期社区提出的标准，曾经流行过一段时间。这两个标准都是直接在前端浏览器端使用的。\namd标准的代表是requirejs，它推崇依赖前置，提前执行\ncmd标准的代表是seajs，它推崇依赖就近，延迟执行；requirejs后期版本也支持延迟执行\n\n\n### 传送门\n[https://juejin.im/post/6844903576309858318](https://juejin.im/post/6844903576309858318)\n[https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html](https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html)\n[https://es6.ruanyifeng.com/#docs/module-loader](https://es6.ruanyifeng.com/#docs/module-loader)\n","slug":"cmd","published":1,"updated":"2021-03-30T01:32:00.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7uf70003a0vza91l75ih","content":"<p>当前最主流的两个模块化方案：nodejs使用的是commonjs规范、前台浏览器端主要使用的是es6 Module<br>nodejs当前就是commonjs规范的代表实践者，因此用的是require。<br>import是es6新增的api，在语言标准层面上，实现了模块功能。旨在成为浏览器和服务器端的通用模块解决方案。</p>\n<p>用法如下：</p>\n<p>ES6 Module<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> b = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; a &#125; <span class=\"keyword\">from</span> x.js</span><br><span class=\"line\"><span class=\"keyword\">import</span> b <span class=\"keyword\">from</span> x.js</span><br></pre></td></tr></table></figure></p>\n<p>commonjs require<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>当然，Nodejs为每个模块提供了一个 exports变量，指向module.exports，相当于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">exports</span> = <span class=\"built_in\">module</span>.exports</span><br></pre></td></tr></table></figure><br>因此可以直接使用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">exports</span>.a = &#123;&#125; <span class=\"comment\">// 不能重写 exports,比如：exports = &#123; a: &#123;&#125; &#125;</span></span><br></pre></td></tr></table></figure><br>调用方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;x.js&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x.a, x.b)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"commonjs和es6-module对比\"><a href=\"#commonjs和es6-module对比\" class=\"headerlink\" title=\"commonjs和es6 module对比\"></a>commonjs和es6 module对比</h3><p>1.commonjs输出的是值的拷贝、es6 输出的是值的引用<br>2.commonjs是运行时加载，es6 是编译时输出接口</p>\n<p>对待循环引用的区别：<br>es6模块，遇到模块加载命令import时，不会去执行模块，而是只生成一个引用。等到真的需要用到时，再到模块里面去取值。<br>因此遇到循环引用的时候会抛出一个错误。<br>CommonJS模块，的特性是加载时执行，在首次加载的时候就已经执行出结果了，此结果会一直缓存在内存中，等需要用到的时候直接取用缓存结果，因此，如果出现循环引用，只会输出已经执行的部分</p>\n<h3 id=\"其它，amd、cmd\"><a href=\"#其它，amd、cmd\" class=\"headerlink\" title=\"其它，amd、cmd\"></a>其它，amd、cmd</h3><p>amd和cmd是早期社区提出的标准，曾经流行过一段时间。这两个标准都是直接在前端浏览器端使用的。<br>amd标准的代表是requirejs，它推崇依赖前置，提前执行<br>cmd标准的代表是seajs，它推崇依赖就近，延迟执行；requirejs后期版本也支持延迟执行</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://juejin.im/post/6844903576309858318\">https://juejin.im/post/6844903576309858318</a><br><a href=\"https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html\">https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html</a><br><a href=\"https://es6.ruanyifeng.com/#docs/module-loader\">https://es6.ruanyifeng.com/#docs/module-loader</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>当前最主流的两个模块化方案：nodejs使用的是commonjs规范、前台浏览器端主要使用的是es6 Module<br>nodejs当前就是commonjs规范的代表实践者，因此用的是require。<br>import是es6新增的api，在语言标准层面上，实现了模块功能。旨在成为浏览器和服务器端的通用模块解决方案。</p>\n<p>用法如下：</p>\n<p>ES6 Module<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> b = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; a &#125; <span class=\"keyword\">from</span> x.js</span><br><span class=\"line\"><span class=\"keyword\">import</span> b <span class=\"keyword\">from</span> x.js</span><br></pre></td></tr></table></figure></p>\n<p>commonjs require<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>当然，Nodejs为每个模块提供了一个 exports变量，指向module.exports，相当于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">exports</span> = <span class=\"built_in\">module</span>.exports</span><br></pre></td></tr></table></figure><br>因此可以直接使用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">exports</span>.a = &#123;&#125; <span class=\"comment\">// 不能重写 exports,比如：exports = &#123; a: &#123;&#125; &#125;</span></span><br></pre></td></tr></table></figure><br>调用方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;x.js&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x.a, x.b)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"commonjs和es6-module对比\"><a href=\"#commonjs和es6-module对比\" class=\"headerlink\" title=\"commonjs和es6 module对比\"></a>commonjs和es6 module对比</h3><p>1.commonjs输出的是值的拷贝、es6 输出的是值的引用<br>2.commonjs是运行时加载，es6 是编译时输出接口</p>\n<p>对待循环引用的区别：<br>es6模块，遇到模块加载命令import时，不会去执行模块，而是只生成一个引用。等到真的需要用到时，再到模块里面去取值。<br>因此遇到循环引用的时候会抛出一个错误。<br>CommonJS模块，的特性是加载时执行，在首次加载的时候就已经执行出结果了，此结果会一直缓存在内存中，等需要用到的时候直接取用缓存结果，因此，如果出现循环引用，只会输出已经执行的部分</p>\n<h3 id=\"其它，amd、cmd\"><a href=\"#其它，amd、cmd\" class=\"headerlink\" title=\"其它，amd、cmd\"></a>其它，amd、cmd</h3><p>amd和cmd是早期社区提出的标准，曾经流行过一段时间。这两个标准都是直接在前端浏览器端使用的。<br>amd标准的代表是requirejs，它推崇依赖前置，提前执行<br>cmd标准的代表是seajs，它推崇依赖就近，延迟执行；requirejs后期版本也支持延迟执行</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://juejin.im/post/6844903576309858318\">https://juejin.im/post/6844903576309858318</a><br><a href=\"https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html\">https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html</a><br><a href=\"https://es6.ruanyifeng.com/#docs/module-loader\">https://es6.ruanyifeng.com/#docs/module-loader</a></p>\n"},{"title":"函数式编程简介","date":"2021-01-04T16:00:00.000Z","_content":"\n#### 什么是函数式编程\n```html\n函数式编程（英语：functional programming）或称函数程序设计、泛函编程，是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算（lambda calculus）为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。\n比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。\n在函数式编程中，函数是第一类对象，意思是说一个函数，既可以作为其它函数的参数（输入值），也可以从函数中返回（输入值），被修改或者被分配给一个变量。 ———— 维基百科\n```\n函数式编程是如何编写程序的方法论，主要思想是把运算过程尽量写成一些列嵌套函数的调用。\n可以归结为面向过程编程，把复杂任务分解成简单的任务\n\n\n如下面一个计算\n```javascript\n(1 + 2) * 3 - 4\n```\n使用传统的编程方式\n```javascript\nvar a = 1 + 2;\nvar b = a * 3;\nvar c = b - 4;\n```\n使用函数式编程方式\n```javascript\nconst result = subtract(multiply(add(1+2), 3), 4)\n```\n区别在于把运算过程定义成了纯函数，而纯函数的特点在于在相同输入的时候，输出结果一定相同，与输入之外的其它隐藏信息无关或状态无关\n纯函数可以有多个输出值，但是同样输入条件下输出一定得相同。\n\n#### 函数式编程的特点\n1.函数是一等公民，和其它数据类型一样，可以作为变量，也可以赋值给其它变量，也可以作为其它函数的参数\n2.只使用表达式（只涉及纯运算，总有返回值），不使用语句（执行某种操作，没有返回值）\n3.没有副作用，不修改外部变量的值，仅仅返回一个新的值，无其它行为\n4.不修改状态，不修改系统变量，状态不能保存在变量中，函数式编程使用参数来保存状态，比如递归。\n5.引用透明，输入参数一样，输出结果一定相同。\n \n#### 函数式编程的意义和好处\n1.代码简洁，开发快速，大量使用函数，减少重复代码，程序短小，开发较快\n2.接近自然语言，易于理解\n3.更方便代码管理，不依赖不改变外部状态，结果只依赖输入，方便单元测试、debug、以及模块化\n4.易于并发编程，状态间没有依赖，可以开多个线程计算。\n5.代码热升级，无副作用，只要保证接口不变内部实现和外部无关，可以在运行状态下更新代码。\n\n#### 函数式编程的缺点\n抽象了一层，越抽象的，执行效率越低；与硬件和大多数命令式语言不匹配，他能表达你想要做的，而不是你想要电脑要做的\n\n\n#### 相关术语\n***高阶函数 (Higher order function)*** 如果一个函数接受函数作为参数，或者返回值为函数，那么该函数就是高阶函数。\n***闭包 (Closure)***如果一个函数引用了自由变量，那么该函数就是一个闭包。何谓自由变量？自由变量是指不属于该函数作用域的变量(所有全局变量都是自由变量，严格来说引用了全局变量的函数都是闭包，但这种闭包并没有什么用，通常情况下我们说的闭包是指函数内部的函数)。\n***函数组合 (Composition)*** 函数式编程的一个特点是通过串联函数来求值。然而，随着串联函数数量的增多，代码的可读性就会不断下降。函数组合就是用来解决这个问题的方法。假设有一个 compose 函数，它可以接受多个函数作为参数，然后返回一个新的函数。当我们为这个新函数传递参数时，该参数就会「流」过其中的函数，最后返回结果。\n***柯里化 (Currying)***柯里化是对函数的封装，当调用函数时传递参数数量不足时，会返回一个新的函数，直到参数数量足够时才进行求值。\n***模式匹配 (Pattern matching)***模式匹配是指可以为一个函数定义多个版本，通过传入不同参数来调用对应的函数。形式上有点像「方法重载」，但方法重载是通过传入*参数类型*不同来区分的，模式匹配没有这个限制。利用模式匹配，我们可以去掉函数中的「分支」(最常见的是 if)，写出非常简洁的代码。\n\n\n### 传送门\nhttps://www.ruanyifeng.com/blog/2012/04/functional_programming.html\nhttps://scarletsky.github.io/2017/06/30/functional-programming-i-have-learned/","source":"_posts/code1.md","raw":"\n---\ntitle: 函数式编程简介\ndate: 2021/01/05\ntag: [函数式编程]\ncategory: 技术\n---\n\n#### 什么是函数式编程\n```html\n函数式编程（英语：functional programming）或称函数程序设计、泛函编程，是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算（lambda calculus）为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。\n比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。\n在函数式编程中，函数是第一类对象，意思是说一个函数，既可以作为其它函数的参数（输入值），也可以从函数中返回（输入值），被修改或者被分配给一个变量。 ———— 维基百科\n```\n函数式编程是如何编写程序的方法论，主要思想是把运算过程尽量写成一些列嵌套函数的调用。\n可以归结为面向过程编程，把复杂任务分解成简单的任务\n\n\n如下面一个计算\n```javascript\n(1 + 2) * 3 - 4\n```\n使用传统的编程方式\n```javascript\nvar a = 1 + 2;\nvar b = a * 3;\nvar c = b - 4;\n```\n使用函数式编程方式\n```javascript\nconst result = subtract(multiply(add(1+2), 3), 4)\n```\n区别在于把运算过程定义成了纯函数，而纯函数的特点在于在相同输入的时候，输出结果一定相同，与输入之外的其它隐藏信息无关或状态无关\n纯函数可以有多个输出值，但是同样输入条件下输出一定得相同。\n\n#### 函数式编程的特点\n1.函数是一等公民，和其它数据类型一样，可以作为变量，也可以赋值给其它变量，也可以作为其它函数的参数\n2.只使用表达式（只涉及纯运算，总有返回值），不使用语句（执行某种操作，没有返回值）\n3.没有副作用，不修改外部变量的值，仅仅返回一个新的值，无其它行为\n4.不修改状态，不修改系统变量，状态不能保存在变量中，函数式编程使用参数来保存状态，比如递归。\n5.引用透明，输入参数一样，输出结果一定相同。\n \n#### 函数式编程的意义和好处\n1.代码简洁，开发快速，大量使用函数，减少重复代码，程序短小，开发较快\n2.接近自然语言，易于理解\n3.更方便代码管理，不依赖不改变外部状态，结果只依赖输入，方便单元测试、debug、以及模块化\n4.易于并发编程，状态间没有依赖，可以开多个线程计算。\n5.代码热升级，无副作用，只要保证接口不变内部实现和外部无关，可以在运行状态下更新代码。\n\n#### 函数式编程的缺点\n抽象了一层，越抽象的，执行效率越低；与硬件和大多数命令式语言不匹配，他能表达你想要做的，而不是你想要电脑要做的\n\n\n#### 相关术语\n***高阶函数 (Higher order function)*** 如果一个函数接受函数作为参数，或者返回值为函数，那么该函数就是高阶函数。\n***闭包 (Closure)***如果一个函数引用了自由变量，那么该函数就是一个闭包。何谓自由变量？自由变量是指不属于该函数作用域的变量(所有全局变量都是自由变量，严格来说引用了全局变量的函数都是闭包，但这种闭包并没有什么用，通常情况下我们说的闭包是指函数内部的函数)。\n***函数组合 (Composition)*** 函数式编程的一个特点是通过串联函数来求值。然而，随着串联函数数量的增多，代码的可读性就会不断下降。函数组合就是用来解决这个问题的方法。假设有一个 compose 函数，它可以接受多个函数作为参数，然后返回一个新的函数。当我们为这个新函数传递参数时，该参数就会「流」过其中的函数，最后返回结果。\n***柯里化 (Currying)***柯里化是对函数的封装，当调用函数时传递参数数量不足时，会返回一个新的函数，直到参数数量足够时才进行求值。\n***模式匹配 (Pattern matching)***模式匹配是指可以为一个函数定义多个版本，通过传入不同参数来调用对应的函数。形式上有点像「方法重载」，但方法重载是通过传入*参数类型*不同来区分的，模式匹配没有这个限制。利用模式匹配，我们可以去掉函数中的「分支」(最常见的是 if)，写出非常简洁的代码。\n\n\n### 传送门\nhttps://www.ruanyifeng.com/blog/2012/04/functional_programming.html\nhttps://scarletsky.github.io/2017/06/30/functional-programming-i-have-learned/","slug":"code1","published":1,"updated":"2021-03-30T01:32:00.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7uf70004a0vzfv6xb9fn","content":"<h4 id=\"什么是函数式编程\"><a href=\"#什么是函数式编程\" class=\"headerlink\" title=\"什么是函数式编程\"></a>什么是函数式编程</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数式编程（英语：functional programming）或称函数程序设计、泛函编程，是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算（lambda calculus）为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。</span><br><span class=\"line\">比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。</span><br><span class=\"line\">在函数式编程中，函数是第一类对象，意思是说一个函数，既可以作为其它函数的参数（输入值），也可以从函数中返回（输入值），被修改或者被分配给一个变量。 ———— 维基百科</span><br></pre></td></tr></table></figure>\n<p>函数式编程是如何编写程序的方法论，主要思想是把运算过程尽量写成一些列嵌套函数的调用。<br>可以归结为面向过程编程，把复杂任务分解成简单的任务</p>\n<p>如下面一个计算<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span> + <span class=\"number\">2</span>) * <span class=\"number\">3</span> - <span class=\"number\">4</span></span><br></pre></td></tr></table></figure><br>使用传统的编程方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a * <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = b - <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure><br>使用函数式编程方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> result = subtract(multiply(add(<span class=\"number\">1</span>+<span class=\"number\">2</span>), <span class=\"number\">3</span>), <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure><br>区别在于把运算过程定义成了纯函数，而纯函数的特点在于在相同输入的时候，输出结果一定相同，与输入之外的其它隐藏信息无关或状态无关<br>纯函数可以有多个输出值，但是同样输入条件下输出一定得相同。</p>\n<h4 id=\"函数式编程的特点\"><a href=\"#函数式编程的特点\" class=\"headerlink\" title=\"函数式编程的特点\"></a>函数式编程的特点</h4><p>1.函数是一等公民，和其它数据类型一样，可以作为变量，也可以赋值给其它变量，也可以作为其它函数的参数<br>2.只使用表达式（只涉及纯运算，总有返回值），不使用语句（执行某种操作，没有返回值）<br>3.没有副作用，不修改外部变量的值，仅仅返回一个新的值，无其它行为<br>4.不修改状态，不修改系统变量，状态不能保存在变量中，函数式编程使用参数来保存状态，比如递归。<br>5.引用透明，输入参数一样，输出结果一定相同。</p>\n<h4 id=\"函数式编程的意义和好处\"><a href=\"#函数式编程的意义和好处\" class=\"headerlink\" title=\"函数式编程的意义和好处\"></a>函数式编程的意义和好处</h4><p>1.代码简洁，开发快速，大量使用函数，减少重复代码，程序短小，开发较快<br>2.接近自然语言，易于理解<br>3.更方便代码管理，不依赖不改变外部状态，结果只依赖输入，方便单元测试、debug、以及模块化<br>4.易于并发编程，状态间没有依赖，可以开多个线程计算。<br>5.代码热升级，无副作用，只要保证接口不变内部实现和外部无关，可以在运行状态下更新代码。</p>\n<h4 id=\"函数式编程的缺点\"><a href=\"#函数式编程的缺点\" class=\"headerlink\" title=\"函数式编程的缺点\"></a>函数式编程的缺点</h4><p>抽象了一层，越抽象的，执行效率越低；与硬件和大多数命令式语言不匹配，他能表达你想要做的，而不是你想要电脑要做的</p>\n<h4 id=\"相关术语\"><a href=\"#相关术语\" class=\"headerlink\" title=\"相关术语\"></a>相关术语</h4><p><strong><em>高阶函数 (Higher order function)</em></strong> 如果一个函数接受函数作为参数，或者返回值为函数，那么该函数就是高阶函数。<br><strong><em>闭包 (Closure)</em></strong>如果一个函数引用了自由变量，那么该函数就是一个闭包。何谓自由变量？自由变量是指不属于该函数作用域的变量(所有全局变量都是自由变量，严格来说引用了全局变量的函数都是闭包，但这种闭包并没有什么用，通常情况下我们说的闭包是指函数内部的函数)。<br><strong><em>函数组合 (Composition)</em></strong> 函数式编程的一个特点是通过串联函数来求值。然而，随着串联函数数量的增多，代码的可读性就会不断下降。函数组合就是用来解决这个问题的方法。假设有一个 compose 函数，它可以接受多个函数作为参数，然后返回一个新的函数。当我们为这个新函数传递参数时，该参数就会「流」过其中的函数，最后返回结果。<br><strong><em>柯里化 (Currying)</em></strong>柯里化是对函数的封装，当调用函数时传递参数数量不足时，会返回一个新的函数，直到参数数量足够时才进行求值。<br><strong><em>模式匹配 (Pattern matching)</em></strong>模式匹配是指可以为一个函数定义多个版本，通过传入不同参数来调用对应的函数。形式上有点像「方法重载」，但方法重载是通过传入<em>参数类型</em>不同来区分的，模式匹配没有这个限制。利用模式匹配，我们可以去掉函数中的「分支」(最常见的是 if)，写出非常简洁的代码。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://www.ruanyifeng.com/blog/2012/04/functional_programming.html\">https://www.ruanyifeng.com/blog/2012/04/functional_programming.html</a><br><a href=\"https://scarletsky.github.io/2017/06/30/functional-programming-i-have-learned/\">https://scarletsky.github.io/2017/06/30/functional-programming-i-have-learned/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是函数式编程\"><a href=\"#什么是函数式编程\" class=\"headerlink\" title=\"什么是函数式编程\"></a>什么是函数式编程</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数式编程（英语：functional programming）或称函数程序设计、泛函编程，是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算（lambda calculus）为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。</span><br><span class=\"line\">比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。</span><br><span class=\"line\">在函数式编程中，函数是第一类对象，意思是说一个函数，既可以作为其它函数的参数（输入值），也可以从函数中返回（输入值），被修改或者被分配给一个变量。 ———— 维基百科</span><br></pre></td></tr></table></figure>\n<p>函数式编程是如何编写程序的方法论，主要思想是把运算过程尽量写成一些列嵌套函数的调用。<br>可以归结为面向过程编程，把复杂任务分解成简单的任务</p>\n<p>如下面一个计算<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span> + <span class=\"number\">2</span>) * <span class=\"number\">3</span> - <span class=\"number\">4</span></span><br></pre></td></tr></table></figure><br>使用传统的编程方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a * <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = b - <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure><br>使用函数式编程方式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> result = subtract(multiply(add(<span class=\"number\">1</span>+<span class=\"number\">2</span>), <span class=\"number\">3</span>), <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure><br>区别在于把运算过程定义成了纯函数，而纯函数的特点在于在相同输入的时候，输出结果一定相同，与输入之外的其它隐藏信息无关或状态无关<br>纯函数可以有多个输出值，但是同样输入条件下输出一定得相同。</p>\n<h4 id=\"函数式编程的特点\"><a href=\"#函数式编程的特点\" class=\"headerlink\" title=\"函数式编程的特点\"></a>函数式编程的特点</h4><p>1.函数是一等公民，和其它数据类型一样，可以作为变量，也可以赋值给其它变量，也可以作为其它函数的参数<br>2.只使用表达式（只涉及纯运算，总有返回值），不使用语句（执行某种操作，没有返回值）<br>3.没有副作用，不修改外部变量的值，仅仅返回一个新的值，无其它行为<br>4.不修改状态，不修改系统变量，状态不能保存在变量中，函数式编程使用参数来保存状态，比如递归。<br>5.引用透明，输入参数一样，输出结果一定相同。</p>\n<h4 id=\"函数式编程的意义和好处\"><a href=\"#函数式编程的意义和好处\" class=\"headerlink\" title=\"函数式编程的意义和好处\"></a>函数式编程的意义和好处</h4><p>1.代码简洁，开发快速，大量使用函数，减少重复代码，程序短小，开发较快<br>2.接近自然语言，易于理解<br>3.更方便代码管理，不依赖不改变外部状态，结果只依赖输入，方便单元测试、debug、以及模块化<br>4.易于并发编程，状态间没有依赖，可以开多个线程计算。<br>5.代码热升级，无副作用，只要保证接口不变内部实现和外部无关，可以在运行状态下更新代码。</p>\n<h4 id=\"函数式编程的缺点\"><a href=\"#函数式编程的缺点\" class=\"headerlink\" title=\"函数式编程的缺点\"></a>函数式编程的缺点</h4><p>抽象了一层，越抽象的，执行效率越低；与硬件和大多数命令式语言不匹配，他能表达你想要做的，而不是你想要电脑要做的</p>\n<h4 id=\"相关术语\"><a href=\"#相关术语\" class=\"headerlink\" title=\"相关术语\"></a>相关术语</h4><p><strong><em>高阶函数 (Higher order function)</em></strong> 如果一个函数接受函数作为参数，或者返回值为函数，那么该函数就是高阶函数。<br><strong><em>闭包 (Closure)</em></strong>如果一个函数引用了自由变量，那么该函数就是一个闭包。何谓自由变量？自由变量是指不属于该函数作用域的变量(所有全局变量都是自由变量，严格来说引用了全局变量的函数都是闭包，但这种闭包并没有什么用，通常情况下我们说的闭包是指函数内部的函数)。<br><strong><em>函数组合 (Composition)</em></strong> 函数式编程的一个特点是通过串联函数来求值。然而，随着串联函数数量的增多，代码的可读性就会不断下降。函数组合就是用来解决这个问题的方法。假设有一个 compose 函数，它可以接受多个函数作为参数，然后返回一个新的函数。当我们为这个新函数传递参数时，该参数就会「流」过其中的函数，最后返回结果。<br><strong><em>柯里化 (Currying)</em></strong>柯里化是对函数的封装，当调用函数时传递参数数量不足时，会返回一个新的函数，直到参数数量足够时才进行求值。<br><strong><em>模式匹配 (Pattern matching)</em></strong>模式匹配是指可以为一个函数定义多个版本，通过传入不同参数来调用对应的函数。形式上有点像「方法重载」，但方法重载是通过传入<em>参数类型</em>不同来区分的，模式匹配没有这个限制。利用模式匹配，我们可以去掉函数中的「分支」(最常见的是 if)，写出非常简洁的代码。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://www.ruanyifeng.com/blog/2012/04/functional_programming.html\">https://www.ruanyifeng.com/blog/2012/04/functional_programming.html</a><br><a href=\"https://scarletsky.github.io/2017/06/30/functional-programming-i-have-learned/\">https://scarletsky.github.io/2017/06/30/functional-programming-i-have-learned/</a></p>\n"},{"title":"前端编译","date":"2021-02-25T16:00:00.000Z","_content":"\n计算机只能执行二进制文件，但是如果人工使用二进制编写代码，无疑是非常困难的，需要付出巨大的成本。\n学过 C++ 或者 Java 的都知道，使用这两种预约编写的源码文件要运行，必须先进行编译，编译就是将源码转成二进制的机器码的过程。\n执行编译的工具是一个特殊的软件，我们叫它为编译器（Compiler）。\n编译器识别代码中的词汇、句子以及各种特定的格式，并将他们转换成计算机能够识别的二进制形式，这个过程就是编译（Compile）。\n\n#### 编译型语言 VS 解释型语言\n当然并不是所有的编程语言都需要编译才能执行\n需要编译才能执行的语言（如：C、C++、Java）被称为编译型语言。\n不需要编译即可执行的语言（如:Python、JavaScript、Perl、Shell）被称为解释型语言。\n\n当然，解释型语言执行的时候也是需要转换成机器码才能执行的，只不过它们是在运行时才翻译成机器语言的，每执行一次都要翻译一次。因此效率比较低。\n而编译型语言编写的应用在编译后能直接运行，效率相对更高。\n\n#### 前端编译的转变\n前端开的主要编程语言是Javascript，Javascript是解释型语言，是不需要提前编译的，所谓开箱即用，因此前端行业（在很早之前）没有编译这回事。\n而随着前端越来越复杂，开发前端时一些新手段新特性越来越多，Vue、React、NodeJS、ES6新语法等变成了基本手段。\n甚至 CSS 也可以使用 Sass/Less语法来进行编写。而这些新特性大多数都是不能“开箱即用”的，都需要进行预先转换转换才能使用。\n因此，现在 Javascript 开发或者说前端开发逐渐变成了“非开箱即用”了。\n\n编译是一个语言到另一个语言表达的转变，这里面不仅仅是功能上的应用，还可以给程序带来性能上的优化。\n而前端的 ES6 转化到 ES5，Less/Sass 转换为 css，require依赖打包，代码压缩混淆都可以看做是语言的转换，更是提升了应用程序的性能。\n因此，这些操作是 ***“编译”***。\n\n#### 前端编译\n前端编译主要功能\n```html\n将框架(如 vue/react) 根据其特性语法进行模板解析、语法转换为常规 js。\n将 es6、es7 等高版本 js 转换为所需要版本(如es5)的js语法\n将 less、sass、css3 转换为 css\n将图片压缩转换(如雪碧图、base64等)\n将字体文件合并\n将 js/css 依赖合并，抽离公共部分\n```\n进行上述操作当前前端最常用的编译工具就是 Webpack，通过引用不同的 loader 和插件即可实现。\n比如使用 babel-loader 转换高级语法、使用 sass-loader 转换 sass 等等。\n\n#### 前端编译原理\n目前大多数编译过程都是先将源代码 Parser 成AST（抽象语法树），然后对 AST 进行分析，在这个分析过程中进行各种优化。\nAST 是源代码语法结构的一种抽象表示。\nBabel,Webpack，vue-cli和esLint等很多的工具和库的核心都是通过 AST 抽象语法树这个概念来实现对代码的检查、分析等操作的。\n在前端当中AST的使用场景非常广，比如在 vue.js 当中，我们在代码中编写的 template 转化成 render function 的过程当中第一步就是解析模版字符串生成AST。\nAST 是一个非常基础但是同时非常重要的，我们熟知的 TypeScript、babel、webpack、vue-cli 得都是依赖 AST 进行开发的。\n\n以 [acorn](https://github.com/acornjs/acorn) 为例\n```javascript\nconst a = 1\n```\n词法分析阶段：将字符组成的字符串分解成一个个代码块（词法单元），例子中代码会被解析成 const、a、=、1 四个词法单元。\n语法分析阶段：将词法单元流转换成一个由元素逐级嵌套组成的语法结构树，即所谓的抽象语法树。\n代码生成阶段：将 AST 转换成一系列可执行的机器指令代码，例子就是机器通过执行指令会在内存中创建一个变量 a，并将值 1 赋值给它。\n\n使用 acorn 转换转换的 AST\n```javascript\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 11,\n  \"body\": [\n    {\n      \"type\": \"VariableDeclaration\",\n      \"start\": 0,\n      \"end\": 11,\n      \"declarations\": [\n        {\n          \"type\": \"VariableDeclarator\",\n          \"start\": 6,\n          \"end\": 11,\n          \"id\": {\n            \"type\": \"Identifier\",\n            \"start\": 6,\n            \"end\": 7,\n            \"name\": \"a\"\n          },\n          \"init\": {\n            \"type\": \"Literal\",\n            \"start\": 10,\n            \"end\": 11,\n            \"value\": 1,\n            \"raw\": \"1\"\n          }\n        }\n      ],\n      \"kind\": \"const\"\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n然后分析语法树，并逆向进行翻译成相应的语法代码即可实现代码的编译（转换）\n\n\n### 附录 - VUE完整版和运行时\n使用vue.js时，可以看到官方提供了两个版本可以使用，包括vue.js（完整版）和vue.runtime.js（运行时版\nvue.runtime.js和vue.js的区别在于，vue.runtime.js不包含模版编译器来获得整个包体积的减少。\n\n如果你需要在客户端编译模板 (比如传入一个字符串给 template 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就将需要加上编译器，即完整版：\n```javascript\n// 需要编译器\nnew Vue({\n  template: '<div>{{ hi }}</div>'\n})\n\n// 不需要编译器\nnew Vue({\n  el: \"#app\",\n  data: { value: 0 },\n  render (h) {\n    return h('div', this.hi)\n  }\n})\n```\nh就是vue.runtime.js提供的函数，它接收模版字符串中的参数，返回渲染好的原始的html。\n在实际开发中，由于h函数的参数比较复杂，实际开发中通过使用webpack的vue-loader插件能将vue单文件组件（以.vue结尾的文件）转换为h函数所需要的参数\n\n","source":"_posts/compile.md","raw":"---\ntitle: 前端编译\ndate: 2021/02/26\ntag: [前端编译,compile]\ncategory: 笔记\n---\n\n计算机只能执行二进制文件，但是如果人工使用二进制编写代码，无疑是非常困难的，需要付出巨大的成本。\n学过 C++ 或者 Java 的都知道，使用这两种预约编写的源码文件要运行，必须先进行编译，编译就是将源码转成二进制的机器码的过程。\n执行编译的工具是一个特殊的软件，我们叫它为编译器（Compiler）。\n编译器识别代码中的词汇、句子以及各种特定的格式，并将他们转换成计算机能够识别的二进制形式，这个过程就是编译（Compile）。\n\n#### 编译型语言 VS 解释型语言\n当然并不是所有的编程语言都需要编译才能执行\n需要编译才能执行的语言（如：C、C++、Java）被称为编译型语言。\n不需要编译即可执行的语言（如:Python、JavaScript、Perl、Shell）被称为解释型语言。\n\n当然，解释型语言执行的时候也是需要转换成机器码才能执行的，只不过它们是在运行时才翻译成机器语言的，每执行一次都要翻译一次。因此效率比较低。\n而编译型语言编写的应用在编译后能直接运行，效率相对更高。\n\n#### 前端编译的转变\n前端开的主要编程语言是Javascript，Javascript是解释型语言，是不需要提前编译的，所谓开箱即用，因此前端行业（在很早之前）没有编译这回事。\n而随着前端越来越复杂，开发前端时一些新手段新特性越来越多，Vue、React、NodeJS、ES6新语法等变成了基本手段。\n甚至 CSS 也可以使用 Sass/Less语法来进行编写。而这些新特性大多数都是不能“开箱即用”的，都需要进行预先转换转换才能使用。\n因此，现在 Javascript 开发或者说前端开发逐渐变成了“非开箱即用”了。\n\n编译是一个语言到另一个语言表达的转变，这里面不仅仅是功能上的应用，还可以给程序带来性能上的优化。\n而前端的 ES6 转化到 ES5，Less/Sass 转换为 css，require依赖打包，代码压缩混淆都可以看做是语言的转换，更是提升了应用程序的性能。\n因此，这些操作是 ***“编译”***。\n\n#### 前端编译\n前端编译主要功能\n```html\n将框架(如 vue/react) 根据其特性语法进行模板解析、语法转换为常规 js。\n将 es6、es7 等高版本 js 转换为所需要版本(如es5)的js语法\n将 less、sass、css3 转换为 css\n将图片压缩转换(如雪碧图、base64等)\n将字体文件合并\n将 js/css 依赖合并，抽离公共部分\n```\n进行上述操作当前前端最常用的编译工具就是 Webpack，通过引用不同的 loader 和插件即可实现。\n比如使用 babel-loader 转换高级语法、使用 sass-loader 转换 sass 等等。\n\n#### 前端编译原理\n目前大多数编译过程都是先将源代码 Parser 成AST（抽象语法树），然后对 AST 进行分析，在这个分析过程中进行各种优化。\nAST 是源代码语法结构的一种抽象表示。\nBabel,Webpack，vue-cli和esLint等很多的工具和库的核心都是通过 AST 抽象语法树这个概念来实现对代码的检查、分析等操作的。\n在前端当中AST的使用场景非常广，比如在 vue.js 当中，我们在代码中编写的 template 转化成 render function 的过程当中第一步就是解析模版字符串生成AST。\nAST 是一个非常基础但是同时非常重要的，我们熟知的 TypeScript、babel、webpack、vue-cli 得都是依赖 AST 进行开发的。\n\n以 [acorn](https://github.com/acornjs/acorn) 为例\n```javascript\nconst a = 1\n```\n词法分析阶段：将字符组成的字符串分解成一个个代码块（词法单元），例子中代码会被解析成 const、a、=、1 四个词法单元。\n语法分析阶段：将词法单元流转换成一个由元素逐级嵌套组成的语法结构树，即所谓的抽象语法树。\n代码生成阶段：将 AST 转换成一系列可执行的机器指令代码，例子就是机器通过执行指令会在内存中创建一个变量 a，并将值 1 赋值给它。\n\n使用 acorn 转换转换的 AST\n```javascript\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 11,\n  \"body\": [\n    {\n      \"type\": \"VariableDeclaration\",\n      \"start\": 0,\n      \"end\": 11,\n      \"declarations\": [\n        {\n          \"type\": \"VariableDeclarator\",\n          \"start\": 6,\n          \"end\": 11,\n          \"id\": {\n            \"type\": \"Identifier\",\n            \"start\": 6,\n            \"end\": 7,\n            \"name\": \"a\"\n          },\n          \"init\": {\n            \"type\": \"Literal\",\n            \"start\": 10,\n            \"end\": 11,\n            \"value\": 1,\n            \"raw\": \"1\"\n          }\n        }\n      ],\n      \"kind\": \"const\"\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n然后分析语法树，并逆向进行翻译成相应的语法代码即可实现代码的编译（转换）\n\n\n### 附录 - VUE完整版和运行时\n使用vue.js时，可以看到官方提供了两个版本可以使用，包括vue.js（完整版）和vue.runtime.js（运行时版\nvue.runtime.js和vue.js的区别在于，vue.runtime.js不包含模版编译器来获得整个包体积的减少。\n\n如果你需要在客户端编译模板 (比如传入一个字符串给 template 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就将需要加上编译器，即完整版：\n```javascript\n// 需要编译器\nnew Vue({\n  template: '<div>{{ hi }}</div>'\n})\n\n// 不需要编译器\nnew Vue({\n  el: \"#app\",\n  data: { value: 0 },\n  render (h) {\n    return h('div', this.hi)\n  }\n})\n```\nh就是vue.runtime.js提供的函数，它接收模版字符串中的参数，返回渲染好的原始的html。\n在实际开发中，由于h函数的参数比较复杂，实际开发中通过使用webpack的vue-loader插件能将vue单文件组件（以.vue结尾的文件）转换为h函数所需要的参数\n\n","slug":"compile","published":1,"updated":"2021-03-30T01:32:00.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7uf80005a0vzdp9h1m0w","content":"<p>计算机只能执行二进制文件，但是如果人工使用二进制编写代码，无疑是非常困难的，需要付出巨大的成本。<br>学过 C++ 或者 Java 的都知道，使用这两种预约编写的源码文件要运行，必须先进行编译，编译就是将源码转成二进制的机器码的过程。<br>执行编译的工具是一个特殊的软件，我们叫它为编译器（Compiler）。<br>编译器识别代码中的词汇、句子以及各种特定的格式，并将他们转换成计算机能够识别的二进制形式，这个过程就是编译（Compile）。</p>\n<h4 id=\"编译型语言-VS-解释型语言\"><a href=\"#编译型语言-VS-解释型语言\" class=\"headerlink\" title=\"编译型语言 VS 解释型语言\"></a>编译型语言 VS 解释型语言</h4><p>当然并不是所有的编程语言都需要编译才能执行<br>需要编译才能执行的语言（如：C、C++、Java）被称为编译型语言。<br>不需要编译即可执行的语言（如:Python、JavaScript、Perl、Shell）被称为解释型语言。</p>\n<p>当然，解释型语言执行的时候也是需要转换成机器码才能执行的，只不过它们是在运行时才翻译成机器语言的，每执行一次都要翻译一次。因此效率比较低。<br>而编译型语言编写的应用在编译后能直接运行，效率相对更高。</p>\n<h4 id=\"前端编译的转变\"><a href=\"#前端编译的转变\" class=\"headerlink\" title=\"前端编译的转变\"></a>前端编译的转变</h4><p>前端开的主要编程语言是Javascript，Javascript是解释型语言，是不需要提前编译的，所谓开箱即用，因此前端行业（在很早之前）没有编译这回事。<br>而随着前端越来越复杂，开发前端时一些新手段新特性越来越多，Vue、React、NodeJS、ES6新语法等变成了基本手段。<br>甚至 CSS 也可以使用 Sass/Less语法来进行编写。而这些新特性大多数都是不能“开箱即用”的，都需要进行预先转换转换才能使用。<br>因此，现在 Javascript 开发或者说前端开发逐渐变成了“非开箱即用”了。</p>\n<p>编译是一个语言到另一个语言表达的转变，这里面不仅仅是功能上的应用，还可以给程序带来性能上的优化。<br>而前端的 ES6 转化到 ES5，Less/Sass 转换为 css，require依赖打包，代码压缩混淆都可以看做是语言的转换，更是提升了应用程序的性能。<br>因此，这些操作是 <strong><em>“编译”</em></strong>。</p>\n<h4 id=\"前端编译\"><a href=\"#前端编译\" class=\"headerlink\" title=\"前端编译\"></a>前端编译</h4><p>前端编译主要功能<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将框架(如 vue/react) 根据其特性语法进行模板解析、语法转换为常规 js。</span><br><span class=\"line\">将 es6、es7 等高版本 js 转换为所需要版本(如es5)的js语法</span><br><span class=\"line\">将 less、sass、css3 转换为 css</span><br><span class=\"line\">将图片压缩转换(如雪碧图、base64等)</span><br><span class=\"line\">将字体文件合并</span><br><span class=\"line\">将 js/css 依赖合并，抽离公共部分</span><br></pre></td></tr></table></figure><br>进行上述操作当前前端最常用的编译工具就是 Webpack，通过引用不同的 loader 和插件即可实现。<br>比如使用 babel-loader 转换高级语法、使用 sass-loader 转换 sass 等等。</p>\n<h4 id=\"前端编译原理\"><a href=\"#前端编译原理\" class=\"headerlink\" title=\"前端编译原理\"></a>前端编译原理</h4><p>目前大多数编译过程都是先将源代码 Parser 成AST（抽象语法树），然后对 AST 进行分析，在这个分析过程中进行各种优化。<br>AST 是源代码语法结构的一种抽象表示。<br>Babel,Webpack，vue-cli和esLint等很多的工具和库的核心都是通过 AST 抽象语法树这个概念来实现对代码的检查、分析等操作的。<br>在前端当中AST的使用场景非常广，比如在 vue.js 当中，我们在代码中编写的 template 转化成 render function 的过程当中第一步就是解析模版字符串生成AST。<br>AST 是一个非常基础但是同时非常重要的，我们熟知的 TypeScript、babel、webpack、vue-cli 得都是依赖 AST 进行开发的。</p>\n<p>以 <a href=\"https://github.com/acornjs/acorn\">acorn</a> 为例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure><br>词法分析阶段：将字符组成的字符串分解成一个个代码块（词法单元），例子中代码会被解析成 const、a、=、1 四个词法单元。<br>语法分析阶段：将词法单元流转换成一个由元素逐级嵌套组成的语法结构树，即所谓的抽象语法树。<br>代码生成阶段：将 AST 转换成一系列可执行的机器指令代码，例子就是机器通过执行指令会在内存中创建一个变量 a，并将值 1 赋值给它。</p>\n<p>使用 acorn 转换转换的 AST<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;Program&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;start&quot;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;end&quot;</span>: <span class=\"number\">11</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;body&quot;</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;VariableDeclaration&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;start&quot;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;end&quot;</span>: <span class=\"number\">11</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;declarations&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;VariableDeclarator&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;start&quot;</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;end&quot;</span>: <span class=\"number\">11</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;id&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;Identifier&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;start&quot;</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;end&quot;</span>: <span class=\"number\">7</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"string\">&quot;init&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;Literal&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;start&quot;</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;end&quot;</span>: <span class=\"number\">11</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;raw&quot;</span>: <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"string\">&quot;kind&quot;</span>: <span class=\"string\">&quot;const&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">&quot;sourceType&quot;</span>: <span class=\"string\">&quot;module&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后分析语法树，并逆向进行翻译成相应的语法代码即可实现代码的编译（转换）</p>\n<h3 id=\"附录-VUE完整版和运行时\"><a href=\"#附录-VUE完整版和运行时\" class=\"headerlink\" title=\"附录 - VUE完整版和运行时\"></a>附录 - VUE完整版和运行时</h3><p>使用vue.js时，可以看到官方提供了两个版本可以使用，包括vue.js（完整版）和vue.runtime.js（运行时版<br>vue.runtime.js和vue.js的区别在于，vue.runtime.js不包含模版编译器来获得整个包体积的减少。</p>\n<p>如果你需要在客户端编译模板 (比如传入一个字符串给 template 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就将需要加上编译器，即完整版：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需要编译器</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  template: <span class=\"string\">&#x27;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不需要编译器</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&quot;#app&quot;</span>,</span><br><span class=\"line\">  data: &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">  render (h) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h(<span class=\"string\">&#x27;div&#x27;</span>, <span class=\"built_in\">this</span>.hi)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>h就是vue.runtime.js提供的函数，它接收模版字符串中的参数，返回渲染好的原始的html。<br>在实际开发中，由于h函数的参数比较复杂，实际开发中通过使用webpack的vue-loader插件能将vue单文件组件（以.vue结尾的文件）转换为h函数所需要的参数</p>\n","site":{"data":{}},"excerpt":"","more":"<p>计算机只能执行二进制文件，但是如果人工使用二进制编写代码，无疑是非常困难的，需要付出巨大的成本。<br>学过 C++ 或者 Java 的都知道，使用这两种预约编写的源码文件要运行，必须先进行编译，编译就是将源码转成二进制的机器码的过程。<br>执行编译的工具是一个特殊的软件，我们叫它为编译器（Compiler）。<br>编译器识别代码中的词汇、句子以及各种特定的格式，并将他们转换成计算机能够识别的二进制形式，这个过程就是编译（Compile）。</p>\n<h4 id=\"编译型语言-VS-解释型语言\"><a href=\"#编译型语言-VS-解释型语言\" class=\"headerlink\" title=\"编译型语言 VS 解释型语言\"></a>编译型语言 VS 解释型语言</h4><p>当然并不是所有的编程语言都需要编译才能执行<br>需要编译才能执行的语言（如：C、C++、Java）被称为编译型语言。<br>不需要编译即可执行的语言（如:Python、JavaScript、Perl、Shell）被称为解释型语言。</p>\n<p>当然，解释型语言执行的时候也是需要转换成机器码才能执行的，只不过它们是在运行时才翻译成机器语言的，每执行一次都要翻译一次。因此效率比较低。<br>而编译型语言编写的应用在编译后能直接运行，效率相对更高。</p>\n<h4 id=\"前端编译的转变\"><a href=\"#前端编译的转变\" class=\"headerlink\" title=\"前端编译的转变\"></a>前端编译的转变</h4><p>前端开的主要编程语言是Javascript，Javascript是解释型语言，是不需要提前编译的，所谓开箱即用，因此前端行业（在很早之前）没有编译这回事。<br>而随着前端越来越复杂，开发前端时一些新手段新特性越来越多，Vue、React、NodeJS、ES6新语法等变成了基本手段。<br>甚至 CSS 也可以使用 Sass/Less语法来进行编写。而这些新特性大多数都是不能“开箱即用”的，都需要进行预先转换转换才能使用。<br>因此，现在 Javascript 开发或者说前端开发逐渐变成了“非开箱即用”了。</p>\n<p>编译是一个语言到另一个语言表达的转变，这里面不仅仅是功能上的应用，还可以给程序带来性能上的优化。<br>而前端的 ES6 转化到 ES5，Less/Sass 转换为 css，require依赖打包，代码压缩混淆都可以看做是语言的转换，更是提升了应用程序的性能。<br>因此，这些操作是 <strong><em>“编译”</em></strong>。</p>\n<h4 id=\"前端编译\"><a href=\"#前端编译\" class=\"headerlink\" title=\"前端编译\"></a>前端编译</h4><p>前端编译主要功能<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将框架(如 vue/react) 根据其特性语法进行模板解析、语法转换为常规 js。</span><br><span class=\"line\">将 es6、es7 等高版本 js 转换为所需要版本(如es5)的js语法</span><br><span class=\"line\">将 less、sass、css3 转换为 css</span><br><span class=\"line\">将图片压缩转换(如雪碧图、base64等)</span><br><span class=\"line\">将字体文件合并</span><br><span class=\"line\">将 js/css 依赖合并，抽离公共部分</span><br></pre></td></tr></table></figure><br>进行上述操作当前前端最常用的编译工具就是 Webpack，通过引用不同的 loader 和插件即可实现。<br>比如使用 babel-loader 转换高级语法、使用 sass-loader 转换 sass 等等。</p>\n<h4 id=\"前端编译原理\"><a href=\"#前端编译原理\" class=\"headerlink\" title=\"前端编译原理\"></a>前端编译原理</h4><p>目前大多数编译过程都是先将源代码 Parser 成AST（抽象语法树），然后对 AST 进行分析，在这个分析过程中进行各种优化。<br>AST 是源代码语法结构的一种抽象表示。<br>Babel,Webpack，vue-cli和esLint等很多的工具和库的核心都是通过 AST 抽象语法树这个概念来实现对代码的检查、分析等操作的。<br>在前端当中AST的使用场景非常广，比如在 vue.js 当中，我们在代码中编写的 template 转化成 render function 的过程当中第一步就是解析模版字符串生成AST。<br>AST 是一个非常基础但是同时非常重要的，我们熟知的 TypeScript、babel、webpack、vue-cli 得都是依赖 AST 进行开发的。</p>\n<p>以 <a href=\"https://github.com/acornjs/acorn\">acorn</a> 为例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure><br>词法分析阶段：将字符组成的字符串分解成一个个代码块（词法单元），例子中代码会被解析成 const、a、=、1 四个词法单元。<br>语法分析阶段：将词法单元流转换成一个由元素逐级嵌套组成的语法结构树，即所谓的抽象语法树。<br>代码生成阶段：将 AST 转换成一系列可执行的机器指令代码，例子就是机器通过执行指令会在内存中创建一个变量 a，并将值 1 赋值给它。</p>\n<p>使用 acorn 转换转换的 AST<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;Program&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;start&quot;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;end&quot;</span>: <span class=\"number\">11</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;body&quot;</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;VariableDeclaration&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;start&quot;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;end&quot;</span>: <span class=\"number\">11</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;declarations&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;VariableDeclarator&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;start&quot;</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;end&quot;</span>: <span class=\"number\">11</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;id&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;Identifier&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;start&quot;</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;end&quot;</span>: <span class=\"number\">7</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"string\">&quot;init&quot;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;Literal&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;start&quot;</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;end&quot;</span>: <span class=\"number\">11</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;raw&quot;</span>: <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"string\">&quot;kind&quot;</span>: <span class=\"string\">&quot;const&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">&quot;sourceType&quot;</span>: <span class=\"string\">&quot;module&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后分析语法树，并逆向进行翻译成相应的语法代码即可实现代码的编译（转换）</p>\n<h3 id=\"附录-VUE完整版和运行时\"><a href=\"#附录-VUE完整版和运行时\" class=\"headerlink\" title=\"附录 - VUE完整版和运行时\"></a>附录 - VUE完整版和运行时</h3><p>使用vue.js时，可以看到官方提供了两个版本可以使用，包括vue.js（完整版）和vue.runtime.js（运行时版<br>vue.runtime.js和vue.js的区别在于，vue.runtime.js不包含模版编译器来获得整个包体积的减少。</p>\n<p>如果你需要在客户端编译模板 (比如传入一个字符串给 template 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就将需要加上编译器，即完整版：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需要编译器</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  template: <span class=\"string\">&#x27;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不需要编译器</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&quot;#app&quot;</span>,</span><br><span class=\"line\">  data: &#123; <span class=\"attr\">value</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">  render (h) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h(<span class=\"string\">&#x27;div&#x27;</span>, <span class=\"built_in\">this</span>.hi)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>h就是vue.runtime.js提供的函数，它接收模版字符串中的参数，返回渲染好的原始的html。<br>在实际开发中，由于h函数的参数比较复杂，实际开发中通过使用webpack的vue-loader插件能将vue单文件组件（以.vue结尾的文件）转换为h函数所需要的参数</p>\n"},{"title":"Web安全","date":"2018-11-23T16:00:00.000Z","_content":"\n### 1.CSRF（Cross-site Request Forgery）简介\n跨站请求伪造，简称 CSRF。\n是一种诱骗用户在当前已登录的应用程序上执行非本意的操作的攻击方法，诱导用户发起非本意的请求，执行恶意操作。\n例如：以用户的名义发送邮件、发送消息、购买商品、转账汇款等。\n\n### CSRF 防护\n1.同源检测，禁止外域或者不信任域名发起的请求\n2.CSRF token，对于重要请求，按照约定规则生成token，发起请求的时候服务端对token进行校验。\n3.双重 Cookie 校验机制，在请求url中再附加一个Cookie信息\n4.Samesite Cookie属性，Chrome最新防护机制；Samesite=Strict 模式下，从第三方网站发起的请求都无法带上Cookie\n\n### 传送门\nCookie 的 SameSite 属性\nhttps://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html\n","source":"_posts/csrf.md","raw":"---\ntitle: Web安全\ntag: [js, csrf, web安全]\ndate: 2018/11/24\ncategory: 技术\n---\n\n### 1.CSRF（Cross-site Request Forgery）简介\n跨站请求伪造，简称 CSRF。\n是一种诱骗用户在当前已登录的应用程序上执行非本意的操作的攻击方法，诱导用户发起非本意的请求，执行恶意操作。\n例如：以用户的名义发送邮件、发送消息、购买商品、转账汇款等。\n\n### CSRF 防护\n1.同源检测，禁止外域或者不信任域名发起的请求\n2.CSRF token，对于重要请求，按照约定规则生成token，发起请求的时候服务端对token进行校验。\n3.双重 Cookie 校验机制，在请求url中再附加一个Cookie信息\n4.Samesite Cookie属性，Chrome最新防护机制；Samesite=Strict 模式下，从第三方网站发起的请求都无法带上Cookie\n\n### 传送门\nCookie 的 SameSite 属性\nhttps://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html\n","slug":"csrf","published":1,"updated":"2021-03-30T01:32:00.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7uf90006a0vz6iohdcoq","content":"<h3 id=\"1-CSRF（Cross-site-Request-Forgery）简介\"><a href=\"#1-CSRF（Cross-site-Request-Forgery）简介\" class=\"headerlink\" title=\"1.CSRF（Cross-site Request Forgery）简介\"></a>1.CSRF（Cross-site Request Forgery）简介</h3><p>跨站请求伪造，简称 CSRF。<br>是一种诱骗用户在当前已登录的应用程序上执行非本意的操作的攻击方法，诱导用户发起非本意的请求，执行恶意操作。<br>例如：以用户的名义发送邮件、发送消息、购买商品、转账汇款等。</p>\n<h3 id=\"CSRF-防护\"><a href=\"#CSRF-防护\" class=\"headerlink\" title=\"CSRF 防护\"></a>CSRF 防护</h3><p>1.同源检测，禁止外域或者不信任域名发起的请求<br>2.CSRF token，对于重要请求，按照约定规则生成token，发起请求的时候服务端对token进行校验。<br>3.双重 Cookie 校验机制，在请求url中再附加一个Cookie信息<br>4.Samesite Cookie属性，Chrome最新防护机制；Samesite=Strict 模式下，从第三方网站发起的请求都无法带上Cookie</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>Cookie 的 SameSite 属性<br><a href=\"https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html\">https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-CSRF（Cross-site-Request-Forgery）简介\"><a href=\"#1-CSRF（Cross-site-Request-Forgery）简介\" class=\"headerlink\" title=\"1.CSRF（Cross-site Request Forgery）简介\"></a>1.CSRF（Cross-site Request Forgery）简介</h3><p>跨站请求伪造，简称 CSRF。<br>是一种诱骗用户在当前已登录的应用程序上执行非本意的操作的攻击方法，诱导用户发起非本意的请求，执行恶意操作。<br>例如：以用户的名义发送邮件、发送消息、购买商品、转账汇款等。</p>\n<h3 id=\"CSRF-防护\"><a href=\"#CSRF-防护\" class=\"headerlink\" title=\"CSRF 防护\"></a>CSRF 防护</h3><p>1.同源检测，禁止外域或者不信任域名发起的请求<br>2.CSRF token，对于重要请求，按照约定规则生成token，发起请求的时候服务端对token进行校验。<br>3.双重 Cookie 校验机制，在请求url中再附加一个Cookie信息<br>4.Samesite Cookie属性，Chrome最新防护机制；Samesite=Strict 模式下，从第三方网站发起的请求都无法带上Cookie</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>Cookie 的 SameSite 属性<br><a href=\"https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html\">https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html</a></p>\n"},{"title":"响应式","date":"2021-01-10T16:00:00.000Z","_content":"\n当前实现\n#### proxy 对比 Object.defineProperty\nObject.defineProperty 数据劫持只是对对象的属性进行劫持，无法监听新增属性和删除属性\n```html\n深层对象的劫持需要一次性递归，性能不好\n劫持数组时需要重写覆盖部分 Array.prototype 原生方法\n```\n补充：\n其实在Object.defineProperty 本身是可用劫持数组的，本质上和劫持对象属性一样，只不过数组的属性是数组下标。\n对象属性的新增需要重新劫持，所以，对于已经被劫持的数组，push的时候也需要进行重新添加劫持。\nVue 的实现中，从性能/体验的性价比考虑，放弃了这个特性。\n\nproxy 数据劫持真正的对对象本身进行劫持，不好做polyfill\n```html\n可以监听到对象新增、删除属性\n只在 getter 时才对对象的下一层进行劫持(优化了性能)\n能正确监听原生数组方法\n```\n\n#### proxy 优势\n1.支持13种拦截操作，这是defineProperty不具备的\n```html\nget(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和 proxy['foo']。\nset(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v 或 proxy['foo'] = v ，返回一个布尔值。\nhas(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。\ndeleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值。\nownKeys(target)：拦截 Object.getOwnPropertyNames(proxy) 、 Object.getOwnPropertySymbols(proxy) 、Object.keys(proxy) 、for...in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。\ngetOwnPropertyDescriptor(target, propKey)：拦截 Object.getOwnPropertyDescriptor(proxy, propKey) ，返回属性的描述对象。\ndefineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc） 、Object.defineProperties(proxy, propDescs) ，返回一个布尔值。\npreventExtensions(target)：拦截 Object.preventExtensions(proxy) ，返回一个布尔值。\ngetPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy) ，返回一个对象。\nisExtensible(target)：拦截 Object.isExtensible(proxy) ，返回一个布尔值。\nsetPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto) ，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。\napply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(...args)、proxy.call(object, ...args) 、proxy.apply(...) 。\nconstruct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(...args) 。\n```\n2.作为新标准，长远来看，JS引擎会继续优化 Proxy ，但 getter 和 setter 基本不会再有针对性优化。\n\n\n### 传送门\n[Vue2.0响应式原理](https://github.com/answershuto/learnVue/blob/master/docs/响应式原理.MarkDownMarkDown)\n\n[Vue2.0 defineProperty正名](https://www.huaweicloud.com/articles/2474b1a4d8d3904e213cac1085726dda.html)","source":"_posts/data-bind.md","raw":"---\ntitle: 响应式\ndate: 2021/01/11\ntag: [proxy,响应式]\ncategory: 技术\n---\n\n当前实现\n#### proxy 对比 Object.defineProperty\nObject.defineProperty 数据劫持只是对对象的属性进行劫持，无法监听新增属性和删除属性\n```html\n深层对象的劫持需要一次性递归，性能不好\n劫持数组时需要重写覆盖部分 Array.prototype 原生方法\n```\n补充：\n其实在Object.defineProperty 本身是可用劫持数组的，本质上和劫持对象属性一样，只不过数组的属性是数组下标。\n对象属性的新增需要重新劫持，所以，对于已经被劫持的数组，push的时候也需要进行重新添加劫持。\nVue 的实现中，从性能/体验的性价比考虑，放弃了这个特性。\n\nproxy 数据劫持真正的对对象本身进行劫持，不好做polyfill\n```html\n可以监听到对象新增、删除属性\n只在 getter 时才对对象的下一层进行劫持(优化了性能)\n能正确监听原生数组方法\n```\n\n#### proxy 优势\n1.支持13种拦截操作，这是defineProperty不具备的\n```html\nget(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和 proxy['foo']。\nset(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v 或 proxy['foo'] = v ，返回一个布尔值。\nhas(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。\ndeleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值。\nownKeys(target)：拦截 Object.getOwnPropertyNames(proxy) 、 Object.getOwnPropertySymbols(proxy) 、Object.keys(proxy) 、for...in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。\ngetOwnPropertyDescriptor(target, propKey)：拦截 Object.getOwnPropertyDescriptor(proxy, propKey) ，返回属性的描述对象。\ndefineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc） 、Object.defineProperties(proxy, propDescs) ，返回一个布尔值。\npreventExtensions(target)：拦截 Object.preventExtensions(proxy) ，返回一个布尔值。\ngetPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy) ，返回一个对象。\nisExtensible(target)：拦截 Object.isExtensible(proxy) ，返回一个布尔值。\nsetPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto) ，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。\napply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(...args)、proxy.call(object, ...args) 、proxy.apply(...) 。\nconstruct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(...args) 。\n```\n2.作为新标准，长远来看，JS引擎会继续优化 Proxy ，但 getter 和 setter 基本不会再有针对性优化。\n\n\n### 传送门\n[Vue2.0响应式原理](https://github.com/answershuto/learnVue/blob/master/docs/响应式原理.MarkDownMarkDown)\n\n[Vue2.0 defineProperty正名](https://www.huaweicloud.com/articles/2474b1a4d8d3904e213cac1085726dda.html)","slug":"data-bind","published":1,"updated":"2021-03-30T01:32:00.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufa0007a0vzed0g2r5x","content":"<p>当前实现</p>\n<h4 id=\"proxy-对比-Object-defineProperty\"><a href=\"#proxy-对比-Object-defineProperty\" class=\"headerlink\" title=\"proxy 对比 Object.defineProperty\"></a>proxy 对比 Object.defineProperty</h4><p>Object.defineProperty 数据劫持只是对对象的属性进行劫持，无法监听新增属性和删除属性<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">深层对象的劫持需要一次性递归，性能不好</span><br><span class=\"line\">劫持数组时需要重写覆盖部分 Array.prototype 原生方法</span><br></pre></td></tr></table></figure><br>补充：<br>其实在Object.defineProperty 本身是可用劫持数组的，本质上和劫持对象属性一样，只不过数组的属性是数组下标。<br>对象属性的新增需要重新劫持，所以，对于已经被劫持的数组，push的时候也需要进行重新添加劫持。<br>Vue 的实现中，从性能/体验的性价比考虑，放弃了这个特性。</p>\n<p>proxy 数据劫持真正的对对象本身进行劫持，不好做polyfill<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可以监听到对象新增、删除属性</span><br><span class=\"line\">只在 getter 时才对对象的下一层进行劫持(优化了性能)</span><br><span class=\"line\">能正确监听原生数组方法</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"proxy-优势\"><a href=\"#proxy-优势\" class=\"headerlink\" title=\"proxy 优势\"></a>proxy 优势</h4><p>1.支持13种拦截操作，这是defineProperty不具备的<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和 proxy[&#x27;foo&#x27;]。</span><br><span class=\"line\">set(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v 或 proxy[&#x27;foo&#x27;] = v ，返回一个布尔值。</span><br><span class=\"line\">has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。</span><br><span class=\"line\">deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值。</span><br><span class=\"line\">ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy) 、 Object.getOwnPropertySymbols(proxy) 、Object.keys(proxy) 、for...in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。</span><br><span class=\"line\">getOwnPropertyDescriptor(target, propKey)：拦截 Object.getOwnPropertyDescriptor(proxy, propKey) ，返回属性的描述对象。</span><br><span class=\"line\">defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc） 、Object.defineProperties(proxy, propDescs) ，返回一个布尔值。</span><br><span class=\"line\">preventExtensions(target)：拦截 Object.preventExtensions(proxy) ，返回一个布尔值。</span><br><span class=\"line\">getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy) ，返回一个对象。</span><br><span class=\"line\">isExtensible(target)：拦截 Object.isExtensible(proxy) ，返回一个布尔值。</span><br><span class=\"line\">setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto) ，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</span><br><span class=\"line\">apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(...args)、proxy.call(object, ...args) 、proxy.apply(...) 。</span><br><span class=\"line\">construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(...args) 。</span><br></pre></td></tr></table></figure><br>2.作为新标准，长远来看，JS引擎会继续优化 Proxy ，但 getter 和 setter 基本不会再有针对性优化。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://github.com/answershuto/learnVue/blob/master/docs/响应式原理.MarkDownMarkDown\">Vue2.0响应式原理</a></p>\n<p><a href=\"https://www.huaweicloud.com/articles/2474b1a4d8d3904e213cac1085726dda.html\">Vue2.0 defineProperty正名</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>当前实现</p>\n<h4 id=\"proxy-对比-Object-defineProperty\"><a href=\"#proxy-对比-Object-defineProperty\" class=\"headerlink\" title=\"proxy 对比 Object.defineProperty\"></a>proxy 对比 Object.defineProperty</h4><p>Object.defineProperty 数据劫持只是对对象的属性进行劫持，无法监听新增属性和删除属性<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">深层对象的劫持需要一次性递归，性能不好</span><br><span class=\"line\">劫持数组时需要重写覆盖部分 Array.prototype 原生方法</span><br></pre></td></tr></table></figure><br>补充：<br>其实在Object.defineProperty 本身是可用劫持数组的，本质上和劫持对象属性一样，只不过数组的属性是数组下标。<br>对象属性的新增需要重新劫持，所以，对于已经被劫持的数组，push的时候也需要进行重新添加劫持。<br>Vue 的实现中，从性能/体验的性价比考虑，放弃了这个特性。</p>\n<p>proxy 数据劫持真正的对对象本身进行劫持，不好做polyfill<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可以监听到对象新增、删除属性</span><br><span class=\"line\">只在 getter 时才对对象的下一层进行劫持(优化了性能)</span><br><span class=\"line\">能正确监听原生数组方法</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"proxy-优势\"><a href=\"#proxy-优势\" class=\"headerlink\" title=\"proxy 优势\"></a>proxy 优势</h4><p>1.支持13种拦截操作，这是defineProperty不具备的<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和 proxy[&#x27;foo&#x27;]。</span><br><span class=\"line\">set(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v 或 proxy[&#x27;foo&#x27;] = v ，返回一个布尔值。</span><br><span class=\"line\">has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。</span><br><span class=\"line\">deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值。</span><br><span class=\"line\">ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy) 、 Object.getOwnPropertySymbols(proxy) 、Object.keys(proxy) 、for...in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。</span><br><span class=\"line\">getOwnPropertyDescriptor(target, propKey)：拦截 Object.getOwnPropertyDescriptor(proxy, propKey) ，返回属性的描述对象。</span><br><span class=\"line\">defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc） 、Object.defineProperties(proxy, propDescs) ，返回一个布尔值。</span><br><span class=\"line\">preventExtensions(target)：拦截 Object.preventExtensions(proxy) ，返回一个布尔值。</span><br><span class=\"line\">getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy) ，返回一个对象。</span><br><span class=\"line\">isExtensible(target)：拦截 Object.isExtensible(proxy) ，返回一个布尔值。</span><br><span class=\"line\">setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto) ，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</span><br><span class=\"line\">apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(...args)、proxy.call(object, ...args) 、proxy.apply(...) 。</span><br><span class=\"line\">construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(...args) 。</span><br></pre></td></tr></table></figure><br>2.作为新标准，长远来看，JS引擎会继续优化 Proxy ，但 getter 和 setter 基本不会再有针对性优化。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://github.com/answershuto/learnVue/blob/master/docs/响应式原理.MarkDownMarkDown\">Vue2.0响应式原理</a></p>\n<p><a href=\"https://www.huaweicloud.com/articles/2474b1a4d8d3904e213cac1085726dda.html\">Vue2.0 defineProperty正名</a></p>\n"},{"title":"Js脚本的异步加载","date":"2021-01-17T16:00:00.000Z","_content":"\n在浏览器中网页加载中 javascript 的 ***加载*** 和 ***执行***会默认阻塞 DOM 的加载和页面的渲染。\n因此，在编写代码的时候我们往往将 script 标签放到 body 的最后面。\n当然，也可以通过异步创建 script 标签的方式来实现 js的异步加载。\n\n只是，这些都是通过绕路的方式实现的。\n如何让脚本本身不阻塞页面（异步）来加载，是一个常态化的需求。\n为此，在 HTML4.1 规范中增加了一个 defer 属性来解决这个问题。\n\n#### script 标签的 defer 属性\nHTML4.1规范规定，只需要给 script 加上 defer 属性，脚本就可以延迟到文档完全被解析和显示之后执行。\n```html\n<html>\n  <head>\n    <script defer src=\"example1.js\"></script>\n    <script defer src=\"example2.js\"></script>\n  </head>\n  <body>DOM Content!</body>\n</html>\n```\n继HTML4.1规范之后，HTML5 也在之前的规范基础上补充和完善了几条规则\n```html\ndefer 属性只对外部脚本文件有效。 （在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。）\n\n加了 defer 属性的脚本应该按照它们出现的顺序执行\n\n所有的加了 defer 属性的脚本都会在 DOMContentLoaded 事件之前执行\n```\n\n因此，正常情况下，按照规范\n```html\n如上 DOM 结构中，example1.js 和 example2.js 脚本会在 DOM 渲染的时候同步下载，并不会阻塞 DOM 的加载。\n\n脚本下载完成之后，执行的时机应该是在 DOMContentLoaded 事件之前\n\nexample1.js 里面的代码会先于 example2.js执行。\n```\n\n然而，规范是规范，有了规范也得有浏览器产商遵循才行，对于 defer 属性也有部分浏览器并没有按照上述规范执行。\n比如：\n```html\n在多个 script 加了 defer 属性的情况下，执行顺序不一定是 script 标签出现的顺序；\n\n在某些浏览器环境下，defer 的脚本不一定在 DOMContentLoaded 事件之前执行等。\n```\n因此，稳妥起见，即便加了refer，最好还是将脚本放到 body 的最后。\n\n\nHTML5 规范除了补充了 defer 的规则，本身也新增了一个新的属性 async。\n#### script 标签的 async 属性\n```html\n<html>\n  <head>\n    <script async src=\"example1.js\"></script>\n    <script async src=\"example2.js\"></script>\n  </head>\n  <body>DOM Content!</body>\n</html>\n```\n从改变脚本的处理来看，async 和 补充版本的 defer 类似，都是为了异步加载 javascript 而存在的。\n但是也有一些区别\n```html\n最明显的区别是 defer 执行按照 script 标签的出现顺序，而 async 执行顺序是不确定的。\n\ndefer的下载独立，但是执行会在 DOMContentLoaded 事件之后；async 的下载和执行都是独立的，和其它脚本以及 DOM 的加载和解析都无关。\n```\n\n#### 总结\n1.异步脚本不会阻塞DOM，而且保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 之前或之后。\n2.正因为加了 defer 或者 async 的脚本不会阻塞 DOM 的加载，所以，内部不应该有操作 DOM 的行为。\n2.defer 脚本下载和执行都不会阻塞DOM。\n3.多个 async 的脚本并不会保证按照它们在文档中的先后顺序执行，因此，多个 async 的脚本之间不应该有依赖关系。\n4.async 的脚本下载和解析不会阻塞 DOM，解析完成之后执行的时候会阻塞 DOM\n\n#### 最后引用网上的一张图\n![https://i.stack.imgur.com/wfL82.png](http://zhoushirong.github.io/img/deferasync.png)\n\n\n#### 附录（同步脚本插入）\n```javascript\nvar script = document.createElement('script');\nscript.text = \"console.log('from script');\"\n// 等价于：\n// script.innerText = \"console.log('from script')\";\n// script.innerHTML = \"console.log('from script')\";\n\nconsole.log('before script');\ndocument.body.appendChild(script);\nconsole.log('after script');\n```\n执行结果：before script、from script、after script\n\n原因：\n```html\njavascript 脚本通过上面的方式插入到 DOM 的时候会立即执行\nappendChild 方法执行的是阻塞的，脚本执行完毕才会继续执行后面的代码。\n```\n\n#### 传送门\n[浅谈script标签中的async和defer](https://cloud.tencent.com/developer/article/1093912)","source":"_posts/defer.md","raw":"---\ntitle: Js脚本的异步加载\ndate: 2021/01/18\ntag: [defer,async]\ncategory: 笔记\n---\n\n在浏览器中网页加载中 javascript 的 ***加载*** 和 ***执行***会默认阻塞 DOM 的加载和页面的渲染。\n因此，在编写代码的时候我们往往将 script 标签放到 body 的最后面。\n当然，也可以通过异步创建 script 标签的方式来实现 js的异步加载。\n\n只是，这些都是通过绕路的方式实现的。\n如何让脚本本身不阻塞页面（异步）来加载，是一个常态化的需求。\n为此，在 HTML4.1 规范中增加了一个 defer 属性来解决这个问题。\n\n#### script 标签的 defer 属性\nHTML4.1规范规定，只需要给 script 加上 defer 属性，脚本就可以延迟到文档完全被解析和显示之后执行。\n```html\n<html>\n  <head>\n    <script defer src=\"example1.js\"></script>\n    <script defer src=\"example2.js\"></script>\n  </head>\n  <body>DOM Content!</body>\n</html>\n```\n继HTML4.1规范之后，HTML5 也在之前的规范基础上补充和完善了几条规则\n```html\ndefer 属性只对外部脚本文件有效。 （在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。）\n\n加了 defer 属性的脚本应该按照它们出现的顺序执行\n\n所有的加了 defer 属性的脚本都会在 DOMContentLoaded 事件之前执行\n```\n\n因此，正常情况下，按照规范\n```html\n如上 DOM 结构中，example1.js 和 example2.js 脚本会在 DOM 渲染的时候同步下载，并不会阻塞 DOM 的加载。\n\n脚本下载完成之后，执行的时机应该是在 DOMContentLoaded 事件之前\n\nexample1.js 里面的代码会先于 example2.js执行。\n```\n\n然而，规范是规范，有了规范也得有浏览器产商遵循才行，对于 defer 属性也有部分浏览器并没有按照上述规范执行。\n比如：\n```html\n在多个 script 加了 defer 属性的情况下，执行顺序不一定是 script 标签出现的顺序；\n\n在某些浏览器环境下，defer 的脚本不一定在 DOMContentLoaded 事件之前执行等。\n```\n因此，稳妥起见，即便加了refer，最好还是将脚本放到 body 的最后。\n\n\nHTML5 规范除了补充了 defer 的规则，本身也新增了一个新的属性 async。\n#### script 标签的 async 属性\n```html\n<html>\n  <head>\n    <script async src=\"example1.js\"></script>\n    <script async src=\"example2.js\"></script>\n  </head>\n  <body>DOM Content!</body>\n</html>\n```\n从改变脚本的处理来看，async 和 补充版本的 defer 类似，都是为了异步加载 javascript 而存在的。\n但是也有一些区别\n```html\n最明显的区别是 defer 执行按照 script 标签的出现顺序，而 async 执行顺序是不确定的。\n\ndefer的下载独立，但是执行会在 DOMContentLoaded 事件之后；async 的下载和执行都是独立的，和其它脚本以及 DOM 的加载和解析都无关。\n```\n\n#### 总结\n1.异步脚本不会阻塞DOM，而且保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 之前或之后。\n2.正因为加了 defer 或者 async 的脚本不会阻塞 DOM 的加载，所以，内部不应该有操作 DOM 的行为。\n2.defer 脚本下载和执行都不会阻塞DOM。\n3.多个 async 的脚本并不会保证按照它们在文档中的先后顺序执行，因此，多个 async 的脚本之间不应该有依赖关系。\n4.async 的脚本下载和解析不会阻塞 DOM，解析完成之后执行的时候会阻塞 DOM\n\n#### 最后引用网上的一张图\n![https://i.stack.imgur.com/wfL82.png](http://zhoushirong.github.io/img/deferasync.png)\n\n\n#### 附录（同步脚本插入）\n```javascript\nvar script = document.createElement('script');\nscript.text = \"console.log('from script');\"\n// 等价于：\n// script.innerText = \"console.log('from script')\";\n// script.innerHTML = \"console.log('from script')\";\n\nconsole.log('before script');\ndocument.body.appendChild(script);\nconsole.log('after script');\n```\n执行结果：before script、from script、after script\n\n原因：\n```html\njavascript 脚本通过上面的方式插入到 DOM 的时候会立即执行\nappendChild 方法执行的是阻塞的，脚本执行完毕才会继续执行后面的代码。\n```\n\n#### 传送门\n[浅谈script标签中的async和defer](https://cloud.tencent.com/developer/article/1093912)","slug":"defer","published":1,"updated":"2021-03-30T01:32:00.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufa0008a0vz5it9ahbz","content":"<p>在浏览器中网页加载中 javascript 的 <strong><em>加载</em></strong> 和 <strong><em>执行</em></strong>会默认阻塞 DOM 的加载和页面的渲染。<br>因此，在编写代码的时候我们往往将 script 标签放到 body 的最后面。<br>当然，也可以通过异步创建 script 标签的方式来实现 js的异步加载。</p>\n<p>只是，这些都是通过绕路的方式实现的。<br>如何让脚本本身不阻塞页面（异步）来加载，是一个常态化的需求。<br>为此，在 HTML4.1 规范中增加了一个 defer 属性来解决这个问题。</p>\n<h4 id=\"script-标签的-defer-属性\"><a href=\"#script-标签的-defer-属性\" class=\"headerlink\" title=\"script 标签的 defer 属性\"></a>script 标签的 defer 属性</h4><p>HTML4.1规范规定，只需要给 script 加上 defer 属性，脚本就可以延迟到文档完全被解析和显示之后执行。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;example1.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;example2.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>DOM Content!<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>继HTML4.1规范之后，HTML5 也在之前的规范基础上补充和完善了几条规则<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defer 属性只对外部脚本文件有效。 （在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。）</span><br><span class=\"line\"></span><br><span class=\"line\">加了 defer 属性的脚本应该按照它们出现的顺序执行</span><br><span class=\"line\"></span><br><span class=\"line\">所有的加了 defer 属性的脚本都会在 DOMContentLoaded 事件之前执行</span><br></pre></td></tr></table></figure></p>\n<p>因此，正常情况下，按照规范<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如上 DOM 结构中，example1.js 和 example2.js 脚本会在 DOM 渲染的时候同步下载，并不会阻塞 DOM 的加载。</span><br><span class=\"line\"></span><br><span class=\"line\">脚本下载完成之后，执行的时机应该是在 DOMContentLoaded 事件之前</span><br><span class=\"line\"></span><br><span class=\"line\">example1.js 里面的代码会先于 example2.js执行。</span><br></pre></td></tr></table></figure></p>\n<p>然而，规范是规范，有了规范也得有浏览器产商遵循才行，对于 defer 属性也有部分浏览器并没有按照上述规范执行。<br>比如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在多个 script 加了 defer 属性的情况下，执行顺序不一定是 script 标签出现的顺序；</span><br><span class=\"line\"></span><br><span class=\"line\">在某些浏览器环境下，defer 的脚本不一定在 DOMContentLoaded 事件之前执行等。</span><br></pre></td></tr></table></figure><br>因此，稳妥起见，即便加了refer，最好还是将脚本放到 body 的最后。</p>\n<p>HTML5 规范除了补充了 defer 的规则，本身也新增了一个新的属性 async。</p>\n<h4 id=\"script-标签的-async-属性\"><a href=\"#script-标签的-async-属性\" class=\"headerlink\" title=\"script 标签的 async 属性\"></a>script 标签的 async 属性</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;example1.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;example2.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>DOM Content!<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>从改变脚本的处理来看，async 和 补充版本的 defer 类似，都是为了异步加载 javascript 而存在的。<br>但是也有一些区别<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最明显的区别是 defer 执行按照 script 标签的出现顺序，而 async 执行顺序是不确定的。</span><br><span class=\"line\"></span><br><span class=\"line\">defer的下载独立，但是执行会在 DOMContentLoaded 事件之后；async 的下载和执行都是独立的，和其它脚本以及 DOM 的加载和解析都无关。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>1.异步脚本不会阻塞DOM，而且保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 之前或之后。<br>2.正因为加了 defer 或者 async 的脚本不会阻塞 DOM 的加载，所以，内部不应该有操作 DOM 的行为。<br>2.defer 脚本下载和执行都不会阻塞DOM。<br>3.多个 async 的脚本并不会保证按照它们在文档中的先后顺序执行，因此，多个 async 的脚本之间不应该有依赖关系。<br>4.async 的脚本下载和解析不会阻塞 DOM，解析完成之后执行的时候会阻塞 DOM</p>\n<h4 id=\"最后引用网上的一张图\"><a href=\"#最后引用网上的一张图\" class=\"headerlink\" title=\"最后引用网上的一张图\"></a>最后引用网上的一张图</h4><p><img src=\"http://zhoushirong.github.io/img/deferasync.png\" alt=\"https://i.stack.imgur.com/wfL82.png\"></p>\n<h4 id=\"附录（同步脚本插入）\"><a href=\"#附录（同步脚本插入）\" class=\"headerlink\" title=\"附录（同步脚本插入）\"></a>附录（同步脚本插入）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;script&#x27;</span>);</span><br><span class=\"line\">script.text = <span class=\"string\">&quot;console.log(&#x27;from script&#x27;);&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 等价于：</span></span><br><span class=\"line\"><span class=\"comment\">// script.innerText = &quot;console.log(&#x27;from script&#x27;)&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">// script.innerHTML = &quot;console.log(&#x27;from script&#x27;)&quot;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before script&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(script);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after script&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>执行结果：before script、from script、after script</p>\n<p>原因：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javascript 脚本通过上面的方式插入到 DOM 的时候会立即执行</span><br><span class=\"line\">appendChild 方法执行的是阻塞的，脚本执行完毕才会继续执行后面的代码。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h4><p><a href=\"https://cloud.tencent.com/developer/article/1093912\">浅谈script标签中的async和defer</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在浏览器中网页加载中 javascript 的 <strong><em>加载</em></strong> 和 <strong><em>执行</em></strong>会默认阻塞 DOM 的加载和页面的渲染。<br>因此，在编写代码的时候我们往往将 script 标签放到 body 的最后面。<br>当然，也可以通过异步创建 script 标签的方式来实现 js的异步加载。</p>\n<p>只是，这些都是通过绕路的方式实现的。<br>如何让脚本本身不阻塞页面（异步）来加载，是一个常态化的需求。<br>为此，在 HTML4.1 规范中增加了一个 defer 属性来解决这个问题。</p>\n<h4 id=\"script-标签的-defer-属性\"><a href=\"#script-标签的-defer-属性\" class=\"headerlink\" title=\"script 标签的 defer 属性\"></a>script 标签的 defer 属性</h4><p>HTML4.1规范规定，只需要给 script 加上 defer 属性，脚本就可以延迟到文档完全被解析和显示之后执行。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;example1.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;example2.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>DOM Content!<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>继HTML4.1规范之后，HTML5 也在之前的规范基础上补充和完善了几条规则<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defer 属性只对外部脚本文件有效。 （在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。）</span><br><span class=\"line\"></span><br><span class=\"line\">加了 defer 属性的脚本应该按照它们出现的顺序执行</span><br><span class=\"line\"></span><br><span class=\"line\">所有的加了 defer 属性的脚本都会在 DOMContentLoaded 事件之前执行</span><br></pre></td></tr></table></figure></p>\n<p>因此，正常情况下，按照规范<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如上 DOM 结构中，example1.js 和 example2.js 脚本会在 DOM 渲染的时候同步下载，并不会阻塞 DOM 的加载。</span><br><span class=\"line\"></span><br><span class=\"line\">脚本下载完成之后，执行的时机应该是在 DOMContentLoaded 事件之前</span><br><span class=\"line\"></span><br><span class=\"line\">example1.js 里面的代码会先于 example2.js执行。</span><br></pre></td></tr></table></figure></p>\n<p>然而，规范是规范，有了规范也得有浏览器产商遵循才行，对于 defer 属性也有部分浏览器并没有按照上述规范执行。<br>比如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在多个 script 加了 defer 属性的情况下，执行顺序不一定是 script 标签出现的顺序；</span><br><span class=\"line\"></span><br><span class=\"line\">在某些浏览器环境下，defer 的脚本不一定在 DOMContentLoaded 事件之前执行等。</span><br></pre></td></tr></table></figure><br>因此，稳妥起见，即便加了refer，最好还是将脚本放到 body 的最后。</p>\n<p>HTML5 规范除了补充了 defer 的规则，本身也新增了一个新的属性 async。</p>\n<h4 id=\"script-标签的-async-属性\"><a href=\"#script-标签的-async-属性\" class=\"headerlink\" title=\"script 标签的 async 属性\"></a>script 标签的 async 属性</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;example1.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;example2.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>DOM Content!<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>从改变脚本的处理来看，async 和 补充版本的 defer 类似，都是为了异步加载 javascript 而存在的。<br>但是也有一些区别<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最明显的区别是 defer 执行按照 script 标签的出现顺序，而 async 执行顺序是不确定的。</span><br><span class=\"line\"></span><br><span class=\"line\">defer的下载独立，但是执行会在 DOMContentLoaded 事件之后；async 的下载和执行都是独立的，和其它脚本以及 DOM 的加载和解析都无关。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>1.异步脚本不会阻塞DOM，而且保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 之前或之后。<br>2.正因为加了 defer 或者 async 的脚本不会阻塞 DOM 的加载，所以，内部不应该有操作 DOM 的行为。<br>2.defer 脚本下载和执行都不会阻塞DOM。<br>3.多个 async 的脚本并不会保证按照它们在文档中的先后顺序执行，因此，多个 async 的脚本之间不应该有依赖关系。<br>4.async 的脚本下载和解析不会阻塞 DOM，解析完成之后执行的时候会阻塞 DOM</p>\n<h4 id=\"最后引用网上的一张图\"><a href=\"#最后引用网上的一张图\" class=\"headerlink\" title=\"最后引用网上的一张图\"></a>最后引用网上的一张图</h4><p><img src=\"http://zhoushirong.github.io/img/deferasync.png\" alt=\"https://i.stack.imgur.com/wfL82.png\"></p>\n<h4 id=\"附录（同步脚本插入）\"><a href=\"#附录（同步脚本插入）\" class=\"headerlink\" title=\"附录（同步脚本插入）\"></a>附录（同步脚本插入）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;script&#x27;</span>);</span><br><span class=\"line\">script.text = <span class=\"string\">&quot;console.log(&#x27;from script&#x27;);&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 等价于：</span></span><br><span class=\"line\"><span class=\"comment\">// script.innerText = &quot;console.log(&#x27;from script&#x27;)&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">// script.innerHTML = &quot;console.log(&#x27;from script&#x27;)&quot;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before script&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(script);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after script&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>执行结果：before script、from script、after script</p>\n<p>原因：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javascript 脚本通过上面的方式插入到 DOM 的时候会立即执行</span><br><span class=\"line\">appendChild 方法执行的是阻塞的，脚本执行完毕才会继续执行后面的代码。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h4><p><a href=\"https://cloud.tencent.com/developer/article/1093912\">浅谈script标签中的async和defer</a></p>\n"},{"layout":"default","title":"DNS查询","date":"2016-12-26T00:08:48.000Z","_content":"\n从在浏览器输入网址到打开页面看到网页信息是一个非常复杂的过程。DNS解析是非常关键的一步。\n完整的执行一次页面的请求是一个非常复杂的过程，同时也是一个非常耗时的过程。\n好在经过这么多年的发展，技术的不断积累，已经做了非常多的优化，比如各种缓存、各种算法的优化等。\nDNS的主要作用就是将主机域名转换为ip地址。\n这里记录一下本人对于dns查询的一些笔记。\n\n\n发起一次http（非http2）请求需要经历下面的步骤\n\n``` html\n用户发起一次http请求（在浏览器输入url地址）\n\nDNS 域名解析\n\n发起 TCP 的 3 次握手\n\n建立 TCP 连接后发起 http 请求\n\n服务器响应 http 请求\n\n客户端接受信息展示给用户\n```\n\n这里主要介绍一下DNS的解析步骤，简化版的DNS查询过程如下\n\n``` html\n1.浏览器缓存：首先会查询浏览器是否存在dns缓存，如果用户访问过某个网站，浏览器会缓存这个DNS记录。\n在chrome浏览器可以输入这个查看（chrome://net-internals/#dns）\n\n2.操作系统缓存，如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用，这样便可获得系统缓存中的记录。\nOS缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值。\n\n3.路由器缓存，如果前面没有查询到，则会将请求发向路由器，它一般会有自己的DNS缓存。\n\n4.ISP DNS 缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。\n\n5.各个DNS服务器查询，通过一系列复杂的算法进行DNS查询（有人说是递归搜索）\n```\n\n\n\n### 名词解释\n\n\n**DNS:**网域名称系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。\n它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。\nDNS使用TCP和UDP端口53。\n当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。\n\n**ISP:** 互联网服务供应商(Internet Service Provider)又称因特网服务提供者、互联网服务提供商、网络服务供应商，即指提供互联网存取服务的公司。通常大型的电讯公司都会兼任互联网服务供应商。\n\n**主机记录(A记录):** A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。\n\n**别名记录(CNAME记录):** CNAME记录用于将某个别名指向到某个A记录上，这样就不需要再为某个新名字另外创建一条新的A记录。\n\n**TTL:** 表示 DNS 记录在 DNS 服务器上缓存时间\n\n**域名解析**: DNS就像是一个自动的电话号码簿。\n我们上网的时候通过在浏览器输入网址 (http://www.epoos.com) 的时候，就相当于输入用户名，解析（查找ip）就相当于通过用户名自动找到电话号码\n\n","source":"_posts/dns.md","raw":"---\nlayout: default\ntitle: DNS查询\ndate: 2016-12-26 08:08:48\ntag: dns\ncategory: 技术\n---\n\n从在浏览器输入网址到打开页面看到网页信息是一个非常复杂的过程。DNS解析是非常关键的一步。\n完整的执行一次页面的请求是一个非常复杂的过程，同时也是一个非常耗时的过程。\n好在经过这么多年的发展，技术的不断积累，已经做了非常多的优化，比如各种缓存、各种算法的优化等。\nDNS的主要作用就是将主机域名转换为ip地址。\n这里记录一下本人对于dns查询的一些笔记。\n\n\n发起一次http（非http2）请求需要经历下面的步骤\n\n``` html\n用户发起一次http请求（在浏览器输入url地址）\n\nDNS 域名解析\n\n发起 TCP 的 3 次握手\n\n建立 TCP 连接后发起 http 请求\n\n服务器响应 http 请求\n\n客户端接受信息展示给用户\n```\n\n这里主要介绍一下DNS的解析步骤，简化版的DNS查询过程如下\n\n``` html\n1.浏览器缓存：首先会查询浏览器是否存在dns缓存，如果用户访问过某个网站，浏览器会缓存这个DNS记录。\n在chrome浏览器可以输入这个查看（chrome://net-internals/#dns）\n\n2.操作系统缓存，如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用，这样便可获得系统缓存中的记录。\nOS缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值。\n\n3.路由器缓存，如果前面没有查询到，则会将请求发向路由器，它一般会有自己的DNS缓存。\n\n4.ISP DNS 缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。\n\n5.各个DNS服务器查询，通过一系列复杂的算法进行DNS查询（有人说是递归搜索）\n```\n\n\n\n### 名词解释\n\n\n**DNS:**网域名称系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。\n它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。\nDNS使用TCP和UDP端口53。\n当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。\n\n**ISP:** 互联网服务供应商(Internet Service Provider)又称因特网服务提供者、互联网服务提供商、网络服务供应商，即指提供互联网存取服务的公司。通常大型的电讯公司都会兼任互联网服务供应商。\n\n**主机记录(A记录):** A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。\n\n**别名记录(CNAME记录):** CNAME记录用于将某个别名指向到某个A记录上，这样就不需要再为某个新名字另外创建一条新的A记录。\n\n**TTL:** 表示 DNS 记录在 DNS 服务器上缓存时间\n\n**域名解析**: DNS就像是一个自动的电话号码簿。\n我们上网的时候通过在浏览器输入网址 (http://www.epoos.com) 的时候，就相当于输入用户名，解析（查找ip）就相当于通过用户名自动找到电话号码\n\n","slug":"dns","published":1,"updated":"2021-03-30T01:32:00.316Z","comments":1,"photos":[],"link":"","_id":"ckn2g7ufb0009a0vzglcfd1x0","content":"<p>从在浏览器输入网址到打开页面看到网页信息是一个非常复杂的过程。DNS解析是非常关键的一步。<br>完整的执行一次页面的请求是一个非常复杂的过程，同时也是一个非常耗时的过程。<br>好在经过这么多年的发展，技术的不断积累，已经做了非常多的优化，比如各种缓存、各种算法的优化等。<br>DNS的主要作用就是将主机域名转换为ip地址。<br>这里记录一下本人对于dns查询的一些笔记。</p>\n<p>发起一次http（非http2）请求需要经历下面的步骤</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户发起一次http请求（在浏览器输入url地址）</span><br><span class=\"line\"></span><br><span class=\"line\">DNS 域名解析</span><br><span class=\"line\"></span><br><span class=\"line\">发起 TCP 的 3 次握手</span><br><span class=\"line\"></span><br><span class=\"line\">建立 TCP 连接后发起 http 请求</span><br><span class=\"line\"></span><br><span class=\"line\">服务器响应 http 请求</span><br><span class=\"line\"></span><br><span class=\"line\">客户端接受信息展示给用户</span><br></pre></td></tr></table></figure>\n<p>这里主要介绍一下DNS的解析步骤，简化版的DNS查询过程如下</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.浏览器缓存：首先会查询浏览器是否存在dns缓存，如果用户访问过某个网站，浏览器会缓存这个DNS记录。</span><br><span class=\"line\">在chrome浏览器可以输入这个查看（chrome://net-internals/#dns）</span><br><span class=\"line\"></span><br><span class=\"line\">2.操作系统缓存，如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用，这样便可获得系统缓存中的记录。</span><br><span class=\"line\">OS缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值。</span><br><span class=\"line\"></span><br><span class=\"line\">3.路由器缓存，如果前面没有查询到，则会将请求发向路由器，它一般会有自己的DNS缓存。</span><br><span class=\"line\"></span><br><span class=\"line\">4.ISP DNS 缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。</span><br><span class=\"line\"></span><br><span class=\"line\">5.各个DNS服务器查询，通过一系列复杂的算法进行DNS查询（有人说是递归搜索）</span><br></pre></td></tr></table></figure>\n<h3 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h3><p><strong>DNS:</strong>网域名称系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。<br>它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。<br>DNS使用TCP和UDP端口53。<br>当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p>\n<p><strong>ISP:</strong> 互联网服务供应商(Internet Service Provider)又称因特网服务提供者、互联网服务提供商、网络服务供应商，即指提供互联网存取服务的公司。通常大型的电讯公司都会兼任互联网服务供应商。</p>\n<p><strong>主机记录(A记录):</strong> A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。</p>\n<p><strong>别名记录(CNAME记录):</strong> CNAME记录用于将某个别名指向到某个A记录上，这样就不需要再为某个新名字另外创建一条新的A记录。</p>\n<p><strong>TTL:</strong> 表示 DNS 记录在 DNS 服务器上缓存时间</p>\n<p><strong>域名解析</strong>: DNS就像是一个自动的电话号码簿。<br>我们上网的时候通过在浏览器输入网址 (<a href=\"http://www.epoos.com\">http://www.epoos.com</a>) 的时候，就相当于输入用户名，解析（查找ip）就相当于通过用户名自动找到电话号码</p>\n","site":{"data":{}},"excerpt":"","more":"<p>从在浏览器输入网址到打开页面看到网页信息是一个非常复杂的过程。DNS解析是非常关键的一步。<br>完整的执行一次页面的请求是一个非常复杂的过程，同时也是一个非常耗时的过程。<br>好在经过这么多年的发展，技术的不断积累，已经做了非常多的优化，比如各种缓存、各种算法的优化等。<br>DNS的主要作用就是将主机域名转换为ip地址。<br>这里记录一下本人对于dns查询的一些笔记。</p>\n<p>发起一次http（非http2）请求需要经历下面的步骤</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户发起一次http请求（在浏览器输入url地址）</span><br><span class=\"line\"></span><br><span class=\"line\">DNS 域名解析</span><br><span class=\"line\"></span><br><span class=\"line\">发起 TCP 的 3 次握手</span><br><span class=\"line\"></span><br><span class=\"line\">建立 TCP 连接后发起 http 请求</span><br><span class=\"line\"></span><br><span class=\"line\">服务器响应 http 请求</span><br><span class=\"line\"></span><br><span class=\"line\">客户端接受信息展示给用户</span><br></pre></td></tr></table></figure>\n<p>这里主要介绍一下DNS的解析步骤，简化版的DNS查询过程如下</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.浏览器缓存：首先会查询浏览器是否存在dns缓存，如果用户访问过某个网站，浏览器会缓存这个DNS记录。</span><br><span class=\"line\">在chrome浏览器可以输入这个查看（chrome://net-internals/#dns）</span><br><span class=\"line\"></span><br><span class=\"line\">2.操作系统缓存，如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用，这样便可获得系统缓存中的记录。</span><br><span class=\"line\">OS缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值。</span><br><span class=\"line\"></span><br><span class=\"line\">3.路由器缓存，如果前面没有查询到，则会将请求发向路由器，它一般会有自己的DNS缓存。</span><br><span class=\"line\"></span><br><span class=\"line\">4.ISP DNS 缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。</span><br><span class=\"line\"></span><br><span class=\"line\">5.各个DNS服务器查询，通过一系列复杂的算法进行DNS查询（有人说是递归搜索）</span><br></pre></td></tr></table></figure>\n<h3 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h3><p><strong>DNS:</strong>网域名称系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。<br>它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。<br>DNS使用TCP和UDP端口53。<br>当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p>\n<p><strong>ISP:</strong> 互联网服务供应商(Internet Service Provider)又称因特网服务提供者、互联网服务提供商、网络服务供应商，即指提供互联网存取服务的公司。通常大型的电讯公司都会兼任互联网服务供应商。</p>\n<p><strong>主机记录(A记录):</strong> A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。</p>\n<p><strong>别名记录(CNAME记录):</strong> CNAME记录用于将某个别名指向到某个A记录上，这样就不需要再为某个新名字另外创建一条新的A记录。</p>\n<p><strong>TTL:</strong> 表示 DNS 记录在 DNS 服务器上缓存时间</p>\n<p><strong>域名解析</strong>: DNS就像是一个自动的电话号码簿。<br>我们上网的时候通过在浏览器输入网址 (<a href=\"http://www.epoos.com\">http://www.epoos.com</a>) 的时候，就相当于输入用户名，解析（查找ip）就相当于通过用户名自动找到电话号码</p>\n"},{"title":"动态规划算法","date":"2021-01-29T16:00:00.000Z","_content":"\n#### 动态规划算法\n动态规划有时被认为是一种与递归相反的技术。\n递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整个问题。\n动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个整体解决方案，从而解决掉整个大问题。\n\n使用递归去解决问题虽然简洁，但效率不高。\n许多使用递归去解决的编程问题，可以重写为使用动态规划的技巧去解决。\n动态规划方案通常会使用一个数组来建立一张表，用于存放被分解成众多子问题的解。\n当算法执行完毕，最终的解将会在这个表中很明显的地方被找到\n\n计算斐波拉契数列的值，使用递归算法 和 动态规范算法举例\n```javascript\n/**\n * 递归算法计算\n */\nfunction recurFib(n) {\n  if (n < 2) return n\n  return recurFib(n - 1) + recurFib(n - 2)\n}\n/**\n * 动态规划算法计算\n * 将每一步的值先计算好，并存起来\n * 最后直接取最后一步的值即可\n */\nfunction dynFib(n) {\n  if (n < 2) return n\n\n  var val = new Array(n)\n  val[1] = 1\n  val[2] = 2\n  for (var i = 3; i <= n; i++) {\n    val[i] = val[i - 1] + val[i - 2]\n  }\n  return val[n - 1]\n}\n```\n就上述例子而言，如果仅仅是计算出斐波拉契数列的值，其实可以不用数组\n之所以使用数组就是为了保存每一步的值，然而我们其实不需要中间值，只需要最后的结果就行了。\n因此，可使用迭代的方式进行优化\n```javascript\nfunction iterFib(n) {\n  if (n < 2) return n\n  var last = 1 // 最后一个\n  var preLast = 1 // 下一个最后一个\n  var result = 1 // 当前结果\n  for (var i = 2; i < n; i++) {\n    result = preLast + last\n    preLast = last\n    last = result\n  }\n  return result\n}\n```\n\n#### 利用动态规划找出两个字符串的最长公共子序列长度\n```javascript\nfunction lcs(strX, strY) {\n  const m = strX.length\n  const n = strY.length\n  const nArr = new Array(n + 1).fill(0)\n  const l = []\n  for (let i = 0; i < m+1; i++) {\n    l[i] = [...nArr]\n  }\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (strX[i - 1] === strY[j - 1]) { // 两两遍历，如果有相等的，该坐标 +1\n        l[i][j] = l[i - 1][j - 1] + 1\n      } else {\n        l[i][j] = Math.max(l[i - 1][j], l[i][j - 1]) // max\n      }\n    }\n  }\n  // console.log(l)\n  return l[m][n] // {5}\n}\n// lcs('abbcc', 'dbbcc') // bbcc 4\nlcs('abbc', 'abbbc') // abbb 4\n// lcs('ababbccbac', 'abbcac') // abbcac 6\n```\n\n#### 背包问题\n背包问题是算法研究中的一个经典问题。\n一大堆物品物品规格和价值不同，你希望用自己的小背包装这些物品，直至装满，最后结果要使背包内的物品总价值最大。\n\n1.使用递归的方式解决背包问题\n```javascript\n/**\n*  @capacity 背包剩余容量\n*  @size 即将装入物品的体积\n*  @value 即将装入物品的价值\n*  @n 所有物品的数量\n*/\nfunction knapsack(capacity, size, value, n) {\n  // 物品装完或者背包装满的时候停止\n  if (n === 0 || capacity === 0) return 0\n\n  // 即将装入的物品体积 大于 背包剩余容积的时候，继续装\n  if (size[n - 1] > capacity) {\n    return knapsack(capacity, size, value, n - 1)\n  }\n  // 装入当前物品 和 装入其它物品哪个价值更大\n  return Math.max(\n    value[n - 1] + knapsack(capacity - size[n - 1], size, value, n - 1),\n                   knapsack(capacity,               size, value, n - 1)\n  )\n}\n// 一堆共5件物品，\nvar value = [4, 5, 10, 11, 13] // 物品价值分别是 4、5、10、11、13\nvar size  = [3, 4, 7, 8, 9] // 物品尺寸分别是 3、4、7、8、9\nvar capacity = 16 // 背包的容积为 16\nvar n = value.length // 所有物品数量\nvar result = knapsack(capacity, size, value, n) // 总价值计算\n// console.log(result)\n```\n\n2.动态规划算法\n上面的递归算法能解决问题，但是性能并不好，有大量的重复计算。\n使用动态规划来解决背包是一个更好的选择。\n动态规划解决此问题的关键思路是计算装入背包的每一个物品的最大价值，直到背包装满。\n```javascript\nfunction dKnapsack(capacity, size, value, n) {\n  var arr = []\n  for (var i = 0; i <= capacity + 1; i++) {\n    arr[i] = []\n  }\n  \n  for (var i = 0; i <= n; i++) {\n    for (var j = 0; j <= capacity; j++) {\n      if (i == 0 || j == 0) {\n        arr[i][j] = 0\n      } else if (size[i - 1] <= j) { // 即将装入的物品小于等于背包容积的时候\n        arr[i][j] = Math.max(\n          value[i - 1] + arr[i - 1][j - size[i - 1]], // 即将装入物品的价值 + 装入此物品之前的总价值\n          arr[i - 1][j]\n        )\n      } else { // 装不下的时候取上一次装入之后的总价值\n        arr[i][j] = arr[i - 1][j]\n      }\n    }\n  }\n  return arr[n][capacity]\n}\n\n// 一堆共5件物品，\nvar value = [4, 5, 10, 11, 13] // 物品价值分别是 4、5、10、11、13\nvar size  = [3, 4, 7, 8, 9] // 物品尺寸分别是 3、4、7、8、9\nvar capacity = 16 // 背包的容积为 16\nvar n = value.length // 所有物品数量\nvar result = dKnapsack(capacity, size, value, n) // 总价值计算\nconsole.log(result)\n```\n\n### 附录 - 动态规划状态转移方程\n状态转移方程，是动态规划中本阶段的状态往往是上一阶段状态和上一阶段决策的结果。\n如果给定了第K阶段的状态Sk以及决策uk(Sk)，则第K+1阶段的状态Sk+1也就完全确定。\n\n也就是说得到k阶段的状态和决策后就可以得到k+1阶段的状态\n状态转移就是从小规模问题的答案推导更大规模问题的答案，就是如何从已知求得未知的表达式。\n","source":"_posts/dynamic.md","raw":"\n---\ntitle: 动态规划算法\ndate: 2021/01/30\ntag: [动态规划,算法]\ncategory: 笔记\n---\n\n#### 动态规划算法\n动态规划有时被认为是一种与递归相反的技术。\n递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整个问题。\n动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个整体解决方案，从而解决掉整个大问题。\n\n使用递归去解决问题虽然简洁，但效率不高。\n许多使用递归去解决的编程问题，可以重写为使用动态规划的技巧去解决。\n动态规划方案通常会使用一个数组来建立一张表，用于存放被分解成众多子问题的解。\n当算法执行完毕，最终的解将会在这个表中很明显的地方被找到\n\n计算斐波拉契数列的值，使用递归算法 和 动态规范算法举例\n```javascript\n/**\n * 递归算法计算\n */\nfunction recurFib(n) {\n  if (n < 2) return n\n  return recurFib(n - 1) + recurFib(n - 2)\n}\n/**\n * 动态规划算法计算\n * 将每一步的值先计算好，并存起来\n * 最后直接取最后一步的值即可\n */\nfunction dynFib(n) {\n  if (n < 2) return n\n\n  var val = new Array(n)\n  val[1] = 1\n  val[2] = 2\n  for (var i = 3; i <= n; i++) {\n    val[i] = val[i - 1] + val[i - 2]\n  }\n  return val[n - 1]\n}\n```\n就上述例子而言，如果仅仅是计算出斐波拉契数列的值，其实可以不用数组\n之所以使用数组就是为了保存每一步的值，然而我们其实不需要中间值，只需要最后的结果就行了。\n因此，可使用迭代的方式进行优化\n```javascript\nfunction iterFib(n) {\n  if (n < 2) return n\n  var last = 1 // 最后一个\n  var preLast = 1 // 下一个最后一个\n  var result = 1 // 当前结果\n  for (var i = 2; i < n; i++) {\n    result = preLast + last\n    preLast = last\n    last = result\n  }\n  return result\n}\n```\n\n#### 利用动态规划找出两个字符串的最长公共子序列长度\n```javascript\nfunction lcs(strX, strY) {\n  const m = strX.length\n  const n = strY.length\n  const nArr = new Array(n + 1).fill(0)\n  const l = []\n  for (let i = 0; i < m+1; i++) {\n    l[i] = [...nArr]\n  }\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (strX[i - 1] === strY[j - 1]) { // 两两遍历，如果有相等的，该坐标 +1\n        l[i][j] = l[i - 1][j - 1] + 1\n      } else {\n        l[i][j] = Math.max(l[i - 1][j], l[i][j - 1]) // max\n      }\n    }\n  }\n  // console.log(l)\n  return l[m][n] // {5}\n}\n// lcs('abbcc', 'dbbcc') // bbcc 4\nlcs('abbc', 'abbbc') // abbb 4\n// lcs('ababbccbac', 'abbcac') // abbcac 6\n```\n\n#### 背包问题\n背包问题是算法研究中的一个经典问题。\n一大堆物品物品规格和价值不同，你希望用自己的小背包装这些物品，直至装满，最后结果要使背包内的物品总价值最大。\n\n1.使用递归的方式解决背包问题\n```javascript\n/**\n*  @capacity 背包剩余容量\n*  @size 即将装入物品的体积\n*  @value 即将装入物品的价值\n*  @n 所有物品的数量\n*/\nfunction knapsack(capacity, size, value, n) {\n  // 物品装完或者背包装满的时候停止\n  if (n === 0 || capacity === 0) return 0\n\n  // 即将装入的物品体积 大于 背包剩余容积的时候，继续装\n  if (size[n - 1] > capacity) {\n    return knapsack(capacity, size, value, n - 1)\n  }\n  // 装入当前物品 和 装入其它物品哪个价值更大\n  return Math.max(\n    value[n - 1] + knapsack(capacity - size[n - 1], size, value, n - 1),\n                   knapsack(capacity,               size, value, n - 1)\n  )\n}\n// 一堆共5件物品，\nvar value = [4, 5, 10, 11, 13] // 物品价值分别是 4、5、10、11、13\nvar size  = [3, 4, 7, 8, 9] // 物品尺寸分别是 3、4、7、8、9\nvar capacity = 16 // 背包的容积为 16\nvar n = value.length // 所有物品数量\nvar result = knapsack(capacity, size, value, n) // 总价值计算\n// console.log(result)\n```\n\n2.动态规划算法\n上面的递归算法能解决问题，但是性能并不好，有大量的重复计算。\n使用动态规划来解决背包是一个更好的选择。\n动态规划解决此问题的关键思路是计算装入背包的每一个物品的最大价值，直到背包装满。\n```javascript\nfunction dKnapsack(capacity, size, value, n) {\n  var arr = []\n  for (var i = 0; i <= capacity + 1; i++) {\n    arr[i] = []\n  }\n  \n  for (var i = 0; i <= n; i++) {\n    for (var j = 0; j <= capacity; j++) {\n      if (i == 0 || j == 0) {\n        arr[i][j] = 0\n      } else if (size[i - 1] <= j) { // 即将装入的物品小于等于背包容积的时候\n        arr[i][j] = Math.max(\n          value[i - 1] + arr[i - 1][j - size[i - 1]], // 即将装入物品的价值 + 装入此物品之前的总价值\n          arr[i - 1][j]\n        )\n      } else { // 装不下的时候取上一次装入之后的总价值\n        arr[i][j] = arr[i - 1][j]\n      }\n    }\n  }\n  return arr[n][capacity]\n}\n\n// 一堆共5件物品，\nvar value = [4, 5, 10, 11, 13] // 物品价值分别是 4、5、10、11、13\nvar size  = [3, 4, 7, 8, 9] // 物品尺寸分别是 3、4、7、8、9\nvar capacity = 16 // 背包的容积为 16\nvar n = value.length // 所有物品数量\nvar result = dKnapsack(capacity, size, value, n) // 总价值计算\nconsole.log(result)\n```\n\n### 附录 - 动态规划状态转移方程\n状态转移方程，是动态规划中本阶段的状态往往是上一阶段状态和上一阶段决策的结果。\n如果给定了第K阶段的状态Sk以及决策uk(Sk)，则第K+1阶段的状态Sk+1也就完全确定。\n\n也就是说得到k阶段的状态和决策后就可以得到k+1阶段的状态\n状态转移就是从小规模问题的答案推导更大规模问题的答案，就是如何从已知求得未知的表达式。\n","slug":"dynamic","published":1,"updated":"2021-03-30T01:32:00.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufc000aa0vzhoyv19ho","content":"<h4 id=\"动态规划算法\"><a href=\"#动态规划算法\" class=\"headerlink\" title=\"动态规划算法\"></a>动态规划算法</h4><p>动态规划有时被认为是一种与递归相反的技术。<br>递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整个问题。<br>动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个整体解决方案，从而解决掉整个大问题。</p>\n<p>使用递归去解决问题虽然简洁，但效率不高。<br>许多使用递归去解决的编程问题，可以重写为使用动态规划的技巧去解决。<br>动态规划方案通常会使用一个数组来建立一张表，用于存放被分解成众多子问题的解。<br>当算法执行完毕，最终的解将会在这个表中很明显的地方被找到</p>\n<p>计算斐波拉契数列的值，使用递归算法 和 动态规范算法举例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 递归算法计算</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recurFib</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> n</span><br><span class=\"line\">  <span class=\"keyword\">return</span> recurFib(n - <span class=\"number\">1</span>) + recurFib(n - <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 动态规划算法计算</span></span><br><span class=\"line\"><span class=\"comment\"> * 将每一步的值先计算好，并存起来</span></span><br><span class=\"line\"><span class=\"comment\"> * 最后直接取最后一步的值即可</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dynFib</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> n</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> val = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n)</span><br><span class=\"line\">  val[<span class=\"number\">1</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">  val[<span class=\"number\">2</span>] = <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    val[i] = val[i - <span class=\"number\">1</span>] + val[i - <span class=\"number\">2</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val[n - <span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>就上述例子而言，如果仅仅是计算出斐波拉契数列的值，其实可以不用数组<br>之所以使用数组就是为了保存每一步的值，然而我们其实不需要中间值，只需要最后的结果就行了。<br>因此，可使用迭代的方式进行优化<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">iterFib</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> n</span><br><span class=\"line\">  <span class=\"keyword\">var</span> last = <span class=\"number\">1</span> <span class=\"comment\">// 最后一个</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> preLast = <span class=\"number\">1</span> <span class=\"comment\">// 下一个最后一个</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"number\">1</span> <span class=\"comment\">// 当前结果</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">2</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    result = preLast + last</span><br><span class=\"line\">    preLast = last</span><br><span class=\"line\">    last = result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"利用动态规划找出两个字符串的最长公共子序列长度\"><a href=\"#利用动态规划找出两个字符串的最长公共子序列长度\" class=\"headerlink\" title=\"利用动态规划找出两个字符串的最长公共子序列长度\"></a>利用动态规划找出两个字符串的最长公共子序列长度</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lcs</span>(<span class=\"params\">strX, strY</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = strX.length</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = strY.length</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nArr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n + <span class=\"number\">1</span>).fill(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; m+<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    l[i] = [...nArr]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (strX[i - <span class=\"number\">1</span>] === strY[j - <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 两两遍历，如果有相等的，该坐标 +1</span></span><br><span class=\"line\">        l[i][j] = l[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        l[i][j] = <span class=\"built_in\">Math</span>.max(l[i - <span class=\"number\">1</span>][j], l[i][j - <span class=\"number\">1</span>]) <span class=\"comment\">// max</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(l)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> l[m][n] <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// lcs(&#x27;abbcc&#x27;, &#x27;dbbcc&#x27;) // bbcc 4</span></span><br><span class=\"line\">lcs(<span class=\"string\">&#x27;abbc&#x27;</span>, <span class=\"string\">&#x27;abbbc&#x27;</span>) <span class=\"comment\">// abbb 4</span></span><br><span class=\"line\"><span class=\"comment\">// lcs(&#x27;ababbccbac&#x27;, &#x27;abbcac&#x27;) // abbcac 6</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h4><p>背包问题是算法研究中的一个经典问题。<br>一大堆物品物品规格和价值不同，你希望用自己的小背包装这些物品，直至装满，最后结果要使背包内的物品总价值最大。</p>\n<p>1.使用递归的方式解决背包问题<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  <span class=\"doctag\">@capacity </span>背包剩余容量</span></span><br><span class=\"line\"><span class=\"comment\">*  <span class=\"doctag\">@size </span>即将装入物品的体积</span></span><br><span class=\"line\"><span class=\"comment\">*  <span class=\"doctag\">@value </span>即将装入物品的价值</span></span><br><span class=\"line\"><span class=\"comment\">*  <span class=\"doctag\">@n </span>所有物品的数量</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">knapsack</span>(<span class=\"params\">capacity, size, value, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 物品装完或者背包装满的时候停止</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span> || capacity === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 即将装入的物品体积 大于 背包剩余容积的时候，继续装</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (size[n - <span class=\"number\">1</span>] &gt; capacity) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> knapsack(capacity, size, value, n - <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 装入当前物品 和 装入其它物品哪个价值更大</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max(</span><br><span class=\"line\">    value[n - <span class=\"number\">1</span>] + knapsack(capacity - size[n - <span class=\"number\">1</span>], size, value, n - <span class=\"number\">1</span>),</span><br><span class=\"line\">                   knapsack(capacity,               size, value, n - <span class=\"number\">1</span>)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 一堆共5件物品，</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>] <span class=\"comment\">// 物品价值分别是 4、5、10、11、13</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> size  = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>] <span class=\"comment\">// 物品尺寸分别是 3、4、7、8、9</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> capacity = <span class=\"number\">16</span> <span class=\"comment\">// 背包的容积为 16</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> n = value.length <span class=\"comment\">// 所有物品数量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = knapsack(capacity, size, value, n) <span class=\"comment\">// 总价值计算</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(result)</span></span><br></pre></td></tr></table></figure></p>\n<p>2.动态规划算法<br>上面的递归算法能解决问题，但是性能并不好，有大量的重复计算。<br>使用动态规划来解决背包是一个更好的选择。<br>动态规划解决此问题的关键思路是计算装入背包的每一个物品的最大价值，直到背包装满。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dKnapsack</span>(<span class=\"params\">capacity, size, value, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;= capacity + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    arr[i] = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt;= capacity; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        arr[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (size[i - <span class=\"number\">1</span>] &lt;= j) &#123; <span class=\"comment\">// 即将装入的物品小于等于背包容积的时候</span></span><br><span class=\"line\">        arr[i][j] = <span class=\"built_in\">Math</span>.max(</span><br><span class=\"line\">          value[i - <span class=\"number\">1</span>] + arr[i - <span class=\"number\">1</span>][j - size[i - <span class=\"number\">1</span>]], <span class=\"comment\">// 即将装入物品的价值 + 装入此物品之前的总价值</span></span><br><span class=\"line\">          arr[i - <span class=\"number\">1</span>][j]</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 装不下的时候取上一次装入之后的总价值</span></span><br><span class=\"line\">        arr[i][j] = arr[i - <span class=\"number\">1</span>][j]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[n][capacity]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一堆共5件物品，</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>] <span class=\"comment\">// 物品价值分别是 4、5、10、11、13</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> size  = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>] <span class=\"comment\">// 物品尺寸分别是 3、4、7、8、9</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> capacity = <span class=\"number\">16</span> <span class=\"comment\">// 背包的容积为 16</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> n = value.length <span class=\"comment\">// 所有物品数量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = dKnapsack(capacity, size, value, n) <span class=\"comment\">// 总价值计算</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"附录-动态规划状态转移方程\"><a href=\"#附录-动态规划状态转移方程\" class=\"headerlink\" title=\"附录 - 动态规划状态转移方程\"></a>附录 - 动态规划状态转移方程</h3><p>状态转移方程，是动态规划中本阶段的状态往往是上一阶段状态和上一阶段决策的结果。<br>如果给定了第K阶段的状态Sk以及决策uk(Sk)，则第K+1阶段的状态Sk+1也就完全确定。</p>\n<p>也就是说得到k阶段的状态和决策后就可以得到k+1阶段的状态<br>状态转移就是从小规模问题的答案推导更大规模问题的答案，就是如何从已知求得未知的表达式。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"动态规划算法\"><a href=\"#动态规划算法\" class=\"headerlink\" title=\"动态规划算法\"></a>动态规划算法</h4><p>动态规划有时被认为是一种与递归相反的技术。<br>递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整个问题。<br>动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个整体解决方案，从而解决掉整个大问题。</p>\n<p>使用递归去解决问题虽然简洁，但效率不高。<br>许多使用递归去解决的编程问题，可以重写为使用动态规划的技巧去解决。<br>动态规划方案通常会使用一个数组来建立一张表，用于存放被分解成众多子问题的解。<br>当算法执行完毕，最终的解将会在这个表中很明显的地方被找到</p>\n<p>计算斐波拉契数列的值，使用递归算法 和 动态规范算法举例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 递归算法计算</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recurFib</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> n</span><br><span class=\"line\">  <span class=\"keyword\">return</span> recurFib(n - <span class=\"number\">1</span>) + recurFib(n - <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 动态规划算法计算</span></span><br><span class=\"line\"><span class=\"comment\"> * 将每一步的值先计算好，并存起来</span></span><br><span class=\"line\"><span class=\"comment\"> * 最后直接取最后一步的值即可</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dynFib</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> n</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> val = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n)</span><br><span class=\"line\">  val[<span class=\"number\">1</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">  val[<span class=\"number\">2</span>] = <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    val[i] = val[i - <span class=\"number\">1</span>] + val[i - <span class=\"number\">2</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val[n - <span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>就上述例子而言，如果仅仅是计算出斐波拉契数列的值，其实可以不用数组<br>之所以使用数组就是为了保存每一步的值，然而我们其实不需要中间值，只需要最后的结果就行了。<br>因此，可使用迭代的方式进行优化<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">iterFib</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> n</span><br><span class=\"line\">  <span class=\"keyword\">var</span> last = <span class=\"number\">1</span> <span class=\"comment\">// 最后一个</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> preLast = <span class=\"number\">1</span> <span class=\"comment\">// 下一个最后一个</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"number\">1</span> <span class=\"comment\">// 当前结果</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">2</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    result = preLast + last</span><br><span class=\"line\">    preLast = last</span><br><span class=\"line\">    last = result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"利用动态规划找出两个字符串的最长公共子序列长度\"><a href=\"#利用动态规划找出两个字符串的最长公共子序列长度\" class=\"headerlink\" title=\"利用动态规划找出两个字符串的最长公共子序列长度\"></a>利用动态规划找出两个字符串的最长公共子序列长度</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lcs</span>(<span class=\"params\">strX, strY</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> m = strX.length</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = strY.length</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nArr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n + <span class=\"number\">1</span>).fill(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> l = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; m+<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    l[i] = [...nArr]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (strX[i - <span class=\"number\">1</span>] === strY[j - <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 两两遍历，如果有相等的，该坐标 +1</span></span><br><span class=\"line\">        l[i][j] = l[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        l[i][j] = <span class=\"built_in\">Math</span>.max(l[i - <span class=\"number\">1</span>][j], l[i][j - <span class=\"number\">1</span>]) <span class=\"comment\">// max</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(l)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> l[m][n] <span class=\"comment\">// &#123;5&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// lcs(&#x27;abbcc&#x27;, &#x27;dbbcc&#x27;) // bbcc 4</span></span><br><span class=\"line\">lcs(<span class=\"string\">&#x27;abbc&#x27;</span>, <span class=\"string\">&#x27;abbbc&#x27;</span>) <span class=\"comment\">// abbb 4</span></span><br><span class=\"line\"><span class=\"comment\">// lcs(&#x27;ababbccbac&#x27;, &#x27;abbcac&#x27;) // abbcac 6</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h4><p>背包问题是算法研究中的一个经典问题。<br>一大堆物品物品规格和价值不同，你希望用自己的小背包装这些物品，直至装满，最后结果要使背包内的物品总价值最大。</p>\n<p>1.使用递归的方式解决背包问题<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  <span class=\"doctag\">@capacity </span>背包剩余容量</span></span><br><span class=\"line\"><span class=\"comment\">*  <span class=\"doctag\">@size </span>即将装入物品的体积</span></span><br><span class=\"line\"><span class=\"comment\">*  <span class=\"doctag\">@value </span>即将装入物品的价值</span></span><br><span class=\"line\"><span class=\"comment\">*  <span class=\"doctag\">@n </span>所有物品的数量</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">knapsack</span>(<span class=\"params\">capacity, size, value, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 物品装完或者背包装满的时候停止</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span> || capacity === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 即将装入的物品体积 大于 背包剩余容积的时候，继续装</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (size[n - <span class=\"number\">1</span>] &gt; capacity) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> knapsack(capacity, size, value, n - <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 装入当前物品 和 装入其它物品哪个价值更大</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max(</span><br><span class=\"line\">    value[n - <span class=\"number\">1</span>] + knapsack(capacity - size[n - <span class=\"number\">1</span>], size, value, n - <span class=\"number\">1</span>),</span><br><span class=\"line\">                   knapsack(capacity,               size, value, n - <span class=\"number\">1</span>)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 一堆共5件物品，</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>] <span class=\"comment\">// 物品价值分别是 4、5、10、11、13</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> size  = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>] <span class=\"comment\">// 物品尺寸分别是 3、4、7、8、9</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> capacity = <span class=\"number\">16</span> <span class=\"comment\">// 背包的容积为 16</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> n = value.length <span class=\"comment\">// 所有物品数量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = knapsack(capacity, size, value, n) <span class=\"comment\">// 总价值计算</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(result)</span></span><br></pre></td></tr></table></figure></p>\n<p>2.动态规划算法<br>上面的递归算法能解决问题，但是性能并不好，有大量的重复计算。<br>使用动态规划来解决背包是一个更好的选择。<br>动态规划解决此问题的关键思路是计算装入背包的每一个物品的最大价值，直到背包装满。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dKnapsack</span>(<span class=\"params\">capacity, size, value, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;= capacity + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    arr[i] = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt;= capacity; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        arr[i][j] = <span class=\"number\">0</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (size[i - <span class=\"number\">1</span>] &lt;= j) &#123; <span class=\"comment\">// 即将装入的物品小于等于背包容积的时候</span></span><br><span class=\"line\">        arr[i][j] = <span class=\"built_in\">Math</span>.max(</span><br><span class=\"line\">          value[i - <span class=\"number\">1</span>] + arr[i - <span class=\"number\">1</span>][j - size[i - <span class=\"number\">1</span>]], <span class=\"comment\">// 即将装入物品的价值 + 装入此物品之前的总价值</span></span><br><span class=\"line\">          arr[i - <span class=\"number\">1</span>][j]</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 装不下的时候取上一次装入之后的总价值</span></span><br><span class=\"line\">        arr[i][j] = arr[i - <span class=\"number\">1</span>][j]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[n][capacity]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一堆共5件物品，</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>] <span class=\"comment\">// 物品价值分别是 4、5、10、11、13</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> size  = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>] <span class=\"comment\">// 物品尺寸分别是 3、4、7、8、9</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> capacity = <span class=\"number\">16</span> <span class=\"comment\">// 背包的容积为 16</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> n = value.length <span class=\"comment\">// 所有物品数量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = dKnapsack(capacity, size, value, n) <span class=\"comment\">// 总价值计算</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"附录-动态规划状态转移方程\"><a href=\"#附录-动态规划状态转移方程\" class=\"headerlink\" title=\"附录 - 动态规划状态转移方程\"></a>附录 - 动态规划状态转移方程</h3><p>状态转移方程，是动态规划中本阶段的状态往往是上一阶段状态和上一阶段决策的结果。<br>如果给定了第K阶段的状态Sk以及决策uk(Sk)，则第K+1阶段的状态Sk+1也就完全确定。</p>\n<p>也就是说得到k阶段的状态和决策后就可以得到k+1阶段的状态<br>状态转移就是从小规模问题的答案推导更大规模问题的答案，就是如何从已知求得未知的表达式。</p>\n"},{"title":"事件冒泡与事件捕获","date":"2019-01-08T16:00:00.000Z","_content":"\n### 关于事件捕获和事件冒泡的理解\njavascript 的事件捕获和事件冒泡之前一直没能弄明白，知道看到一个例子。\n利用丢一颗石头入水的例子，就能够非常形象了，如图所示：\n\n<img src=\"http://zhoushirong.github.io/img/event.png\" alt=\"池塘入水\" width=\"300\" height=\"200\">\n\n事件捕获和事件冒泡就像是一颗石头(点击事件)投入水中：\n首先是最外层水面(html)接触(捕获)石头，然后石头下沉，内层的水(body/dom 父节点)捕获石头，直到池塘底部(目标节点)。\n当石头到达池塘底部(事件被捕获)之后，产生了一个气泡，然后就开始了冒泡阶段\n由底部（目标元素）产生的气泡，由内而外，不断向上冒泡，直到最外面（html标签）结束。\n\n\n好吧，我知道画的有点丑，但是不可否认，确实挺形象的。\n如果还是有些迷糊，那么可以再看一下下面这张图。(<a href=\"https://www.epoos.com/demo/event/index.html\" target=\"_blank\">点击可查看示例)</a>\n<a href=\"https://www.epoos.com/demo/event/index.html\" target=\"_blank\">\n  <img src=\"http://zhoushirong.github.io/img/event2.png\" alt=\"DOM 冒泡\" width=\"500\" height=\"300\">\n</a>\n\n去示例中试一试便清楚了~\n\n### 处理事件\n理解了事件的捕获和冒泡机制，对于事件处理就好办了。\n\n**监听事件**\n```javascript\n/**\n * @param { event } 事件\n * @param { functionEvent } 事件处理函数\n * @param { capture } 是否在捕获阶段触发事件\n **/\nelement.addEventListener(event, functionEvent, useCapture)\n```\n事件和事件处理函数很好理解。\ncapture 表示是否在捕获阶段处理函数\nps：默认为 false，表示在冒泡阶段处理函数，ie 低版本浏览器不支持在捕获阶段处理函数。\n\n**阻止默认事件**\n```javascript\nevent.preventDefault()  // 阻止事件默认动作，比如阻止 submit 按钮默认提交\nevent.stopPropagation() // 阻止捕获 和 冒泡阶段中事件的进一步传播，比如是在‘石头’下沉或者‘气泡’冒泡的过程中使之突然消失\n```\n\n**事件代理：**\n从上面事件机制可以看出，如果没有外部干扰，在子节点上触发的事件，在捕获和冒泡最终都会经过父节点\n因此，我们可以将事件处理函数绑定在父节点上面\n\n这样做的好处一个是可以不关心子元素是同步还是异步的\n另一个是如果有多个子元素，可以不用绑定多个事件（在异步列表 click 事件中很常见）。\n```html\n<ul id=\"ulId\">\n  <li>list1</li>\n  <li>list2</li>\n  <li>list3</li>\n</ul>\n```\n```javascript\ndocument.getElementById('ulId').addEventListener('click', function(e) {\n  var innerHTML = e.target.innerHTML // e.target 表示触发事件的元素（石头）\n  if(innerHTML === 'list1') {\n    console.log(1)\n  } else {\n    console.log(0)\n  }\n}, false)\n```\n\n","source":"_posts/event.md","raw":"---\ntitle: 事件冒泡与事件捕获\ndate: 2019/01/09\ntag: [js, event, 事件冒泡, 事件捕获]\n---\n\n### 关于事件捕获和事件冒泡的理解\njavascript 的事件捕获和事件冒泡之前一直没能弄明白，知道看到一个例子。\n利用丢一颗石头入水的例子，就能够非常形象了，如图所示：\n\n<img src=\"http://zhoushirong.github.io/img/event.png\" alt=\"池塘入水\" width=\"300\" height=\"200\">\n\n事件捕获和事件冒泡就像是一颗石头(点击事件)投入水中：\n首先是最外层水面(html)接触(捕获)石头，然后石头下沉，内层的水(body/dom 父节点)捕获石头，直到池塘底部(目标节点)。\n当石头到达池塘底部(事件被捕获)之后，产生了一个气泡，然后就开始了冒泡阶段\n由底部（目标元素）产生的气泡，由内而外，不断向上冒泡，直到最外面（html标签）结束。\n\n\n好吧，我知道画的有点丑，但是不可否认，确实挺形象的。\n如果还是有些迷糊，那么可以再看一下下面这张图。(<a href=\"https://www.epoos.com/demo/event/index.html\" target=\"_blank\">点击可查看示例)</a>\n<a href=\"https://www.epoos.com/demo/event/index.html\" target=\"_blank\">\n  <img src=\"http://zhoushirong.github.io/img/event2.png\" alt=\"DOM 冒泡\" width=\"500\" height=\"300\">\n</a>\n\n去示例中试一试便清楚了~\n\n### 处理事件\n理解了事件的捕获和冒泡机制，对于事件处理就好办了。\n\n**监听事件**\n```javascript\n/**\n * @param { event } 事件\n * @param { functionEvent } 事件处理函数\n * @param { capture } 是否在捕获阶段触发事件\n **/\nelement.addEventListener(event, functionEvent, useCapture)\n```\n事件和事件处理函数很好理解。\ncapture 表示是否在捕获阶段处理函数\nps：默认为 false，表示在冒泡阶段处理函数，ie 低版本浏览器不支持在捕获阶段处理函数。\n\n**阻止默认事件**\n```javascript\nevent.preventDefault()  // 阻止事件默认动作，比如阻止 submit 按钮默认提交\nevent.stopPropagation() // 阻止捕获 和 冒泡阶段中事件的进一步传播，比如是在‘石头’下沉或者‘气泡’冒泡的过程中使之突然消失\n```\n\n**事件代理：**\n从上面事件机制可以看出，如果没有外部干扰，在子节点上触发的事件，在捕获和冒泡最终都会经过父节点\n因此，我们可以将事件处理函数绑定在父节点上面\n\n这样做的好处一个是可以不关心子元素是同步还是异步的\n另一个是如果有多个子元素，可以不用绑定多个事件（在异步列表 click 事件中很常见）。\n```html\n<ul id=\"ulId\">\n  <li>list1</li>\n  <li>list2</li>\n  <li>list3</li>\n</ul>\n```\n```javascript\ndocument.getElementById('ulId').addEventListener('click', function(e) {\n  var innerHTML = e.target.innerHTML // e.target 表示触发事件的元素（石头）\n  if(innerHTML === 'list1') {\n    console.log(1)\n  } else {\n    console.log(0)\n  }\n}, false)\n```\n\n","slug":"event","published":1,"updated":"2021-03-30T01:32:00.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufd000ba0vz99gqgd74","content":"<h3 id=\"关于事件捕获和事件冒泡的理解\"><a href=\"#关于事件捕获和事件冒泡的理解\" class=\"headerlink\" title=\"关于事件捕获和事件冒泡的理解\"></a>关于事件捕获和事件冒泡的理解</h3><p>javascript 的事件捕获和事件冒泡之前一直没能弄明白，知道看到一个例子。<br>利用丢一颗石头入水的例子，就能够非常形象了，如图所示：</p>\n<p><img src=\"http://zhoushirong.github.io/img/event.png\" alt=\"池塘入水\" width=\"300\" height=\"200\"></p>\n<p>事件捕获和事件冒泡就像是一颗石头(点击事件)投入水中：<br>首先是最外层水面(html)接触(捕获)石头，然后石头下沉，内层的水(body/dom 父节点)捕获石头，直到池塘底部(目标节点)。<br>当石头到达池塘底部(事件被捕获)之后，产生了一个气泡，然后就开始了冒泡阶段<br>由底部（目标元素）产生的气泡，由内而外，不断向上冒泡，直到最外面（html标签）结束。</p>\n<p>好吧，我知道画的有点丑，但是不可否认，确实挺形象的。<br>如果还是有些迷糊，那么可以再看一下下面这张图。(<a href=\"https://www.epoos.com/demo/event/index.html\" target=\"_blank\">点击可查看示例)</a><br><a href=\"https://www.epoos.com/demo/event/index.html\" target=\"_blank\"><br>  <img src=\"http://zhoushirong.github.io/img/event2.png\" alt=\"DOM 冒泡\" width=\"500\" height=\"300\"><br></a></p>\n<p>去示例中试一试便清楚了~</p>\n<h3 id=\"处理事件\"><a href=\"#处理事件\" class=\"headerlink\" title=\"处理事件\"></a>处理事件</h3><p>理解了事件的捕获和冒泡机制，对于事件处理就好办了。</p>\n<p><strong>监听事件</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123; event &#125;</span> </span>事件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123; functionEvent &#125;</span> </span>事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123; capture &#125;</span> </span>是否在捕获阶段触发事件</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\">element.addEventListener(event, functionEvent, useCapture)</span><br></pre></td></tr></table></figure><br>事件和事件处理函数很好理解。<br>capture 表示是否在捕获阶段处理函数<br>ps：默认为 false，表示在冒泡阶段处理函数，ie 低版本浏览器不支持在捕获阶段处理函数。</p>\n<p><strong>阻止默认事件</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event.preventDefault()  <span class=\"comment\">// 阻止事件默认动作，比如阻止 submit 按钮默认提交</span></span><br><span class=\"line\">event.stopPropagation() <span class=\"comment\">// 阻止捕获 和 冒泡阶段中事件的进一步传播，比如是在‘石头’下沉或者‘气泡’冒泡的过程中使之突然消失</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>事件代理：</strong><br>从上面事件机制可以看出，如果没有外部干扰，在子节点上触发的事件，在捕获和冒泡最终都会经过父节点<br>因此，我们可以将事件处理函数绑定在父节点上面</p>\n<p>这样做的好处一个是可以不关心子元素是同步还是异步的<br>另一个是如果有多个子元素，可以不用绑定多个事件（在异步列表 click 事件中很常见）。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;ulId&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>list1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>list2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>list3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;ulId&#x27;</span>).addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> innerHTML = e.target.innerHTML <span class=\"comment\">// e.target 表示触发事件的元素（石头）</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">if</span>(<span class=\"params\">innerHTML === <span class=\"string\">&#x27;list1&#x27;</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"关于事件捕获和事件冒泡的理解\"><a href=\"#关于事件捕获和事件冒泡的理解\" class=\"headerlink\" title=\"关于事件捕获和事件冒泡的理解\"></a>关于事件捕获和事件冒泡的理解</h3><p>javascript 的事件捕获和事件冒泡之前一直没能弄明白，知道看到一个例子。<br>利用丢一颗石头入水的例子，就能够非常形象了，如图所示：</p>\n<p><img src=\"http://zhoushirong.github.io/img/event.png\" alt=\"池塘入水\" width=\"300\" height=\"200\"></p>\n<p>事件捕获和事件冒泡就像是一颗石头(点击事件)投入水中：<br>首先是最外层水面(html)接触(捕获)石头，然后石头下沉，内层的水(body/dom 父节点)捕获石头，直到池塘底部(目标节点)。<br>当石头到达池塘底部(事件被捕获)之后，产生了一个气泡，然后就开始了冒泡阶段<br>由底部（目标元素）产生的气泡，由内而外，不断向上冒泡，直到最外面（html标签）结束。</p>\n<p>好吧，我知道画的有点丑，但是不可否认，确实挺形象的。<br>如果还是有些迷糊，那么可以再看一下下面这张图。(<a href=\"https://www.epoos.com/demo/event/index.html\" target=\"_blank\">点击可查看示例)</a><br><a href=\"https://www.epoos.com/demo/event/index.html\" target=\"_blank\"><br>  <img src=\"http://zhoushirong.github.io/img/event2.png\" alt=\"DOM 冒泡\" width=\"500\" height=\"300\"><br></a></p>\n<p>去示例中试一试便清楚了~</p>\n<h3 id=\"处理事件\"><a href=\"#处理事件\" class=\"headerlink\" title=\"处理事件\"></a>处理事件</h3><p>理解了事件的捕获和冒泡机制，对于事件处理就好办了。</p>\n<p><strong>监听事件</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123; event &#125;</span> </span>事件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123; functionEvent &#125;</span> </span>事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123; capture &#125;</span> </span>是否在捕获阶段触发事件</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\">element.addEventListener(event, functionEvent, useCapture)</span><br></pre></td></tr></table></figure><br>事件和事件处理函数很好理解。<br>capture 表示是否在捕获阶段处理函数<br>ps：默认为 false，表示在冒泡阶段处理函数，ie 低版本浏览器不支持在捕获阶段处理函数。</p>\n<p><strong>阻止默认事件</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event.preventDefault()  <span class=\"comment\">// 阻止事件默认动作，比如阻止 submit 按钮默认提交</span></span><br><span class=\"line\">event.stopPropagation() <span class=\"comment\">// 阻止捕获 和 冒泡阶段中事件的进一步传播，比如是在‘石头’下沉或者‘气泡’冒泡的过程中使之突然消失</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>事件代理：</strong><br>从上面事件机制可以看出，如果没有外部干扰，在子节点上触发的事件，在捕获和冒泡最终都会经过父节点<br>因此，我们可以将事件处理函数绑定在父节点上面</p>\n<p>这样做的好处一个是可以不关心子元素是同步还是异步的<br>另一个是如果有多个子元素，可以不用绑定多个事件（在异步列表 click 事件中很常见）。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;ulId&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>list1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>list2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>list3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;ulId&#x27;</span>).addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> innerHTML = e.target.innerHTML <span class=\"comment\">// e.target 表示触发事件的元素（石头）</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">if</span>(<span class=\"params\">innerHTML === <span class=\"string\">&#x27;list1&#x27;</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"getBoundingClientReact方法","date":"2018-03-19T16:00:00.000Z","_content":"\n\n##### getBoundingClientRect方法兼容IE7写法\n\n```javascript\nrectObject = object.getBoundingClientRect(); // 返回元素的大小及其相对于视口的位置\n```\n\nie7中的getBoundingClientRect方法只有bottom、left、right、top属性，没有width合height\n\n![图片](http://zhoushirong.github.io/img/rect.png)\n\n通过上图可以看出：\n除了width和height，其它几个属性都是相对于视口的左上角而言的。\n\n根据left、right的值可以推算出width\n\n根据top、bottom的值可以推算出height\n\n完整的代码如下：\n```javascript\n/**\n * getBoundingClientRect 兼容IE7\n * @param {DOM Object} obj \n */\nfunction getBoundingClientRect(obj) {\n    var boundingClientRect = obj.getBoundingClientRect();\n    var newObj = {\n        bottom: boundingClientRect.bottom,\n        left: boundingClientRect.left,\n        right: boundingClientRect.right,\n        top: boundingClientRect.top\n    }\n\n\tif (boundingClientRect.width) {\n\t\tnewObj.width = boundingClientRect.width;\n\t\tnewObj.height = boundingClientRect.height;\n\t} else {\n\t\tnewObj.width = boundingClientRect.right - boundingClientRect.left;\n\t\tnewObj.height = boundingClientRect.bottom - boundingClientRect.top;\n    }\n\treturn newObj;\n}\n```\n\n\n\n### 参考链接\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect","source":"_posts/getrect.md","raw":"---\ntitle: getBoundingClientReact方法\ndate: 2018/03/20\ntag: js\ncategory: 技术\n---\n\n\n##### getBoundingClientRect方法兼容IE7写法\n\n```javascript\nrectObject = object.getBoundingClientRect(); // 返回元素的大小及其相对于视口的位置\n```\n\nie7中的getBoundingClientRect方法只有bottom、left、right、top属性，没有width合height\n\n![图片](http://zhoushirong.github.io/img/rect.png)\n\n通过上图可以看出：\n除了width和height，其它几个属性都是相对于视口的左上角而言的。\n\n根据left、right的值可以推算出width\n\n根据top、bottom的值可以推算出height\n\n完整的代码如下：\n```javascript\n/**\n * getBoundingClientRect 兼容IE7\n * @param {DOM Object} obj \n */\nfunction getBoundingClientRect(obj) {\n    var boundingClientRect = obj.getBoundingClientRect();\n    var newObj = {\n        bottom: boundingClientRect.bottom,\n        left: boundingClientRect.left,\n        right: boundingClientRect.right,\n        top: boundingClientRect.top\n    }\n\n\tif (boundingClientRect.width) {\n\t\tnewObj.width = boundingClientRect.width;\n\t\tnewObj.height = boundingClientRect.height;\n\t} else {\n\t\tnewObj.width = boundingClientRect.right - boundingClientRect.left;\n\t\tnewObj.height = boundingClientRect.bottom - boundingClientRect.top;\n    }\n\treturn newObj;\n}\n```\n\n\n\n### 参考链接\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect","slug":"getrect","published":1,"updated":"2021-03-30T01:32:00.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufd000ca0vzebct18fi","content":"<h5 id=\"getBoundingClientRect方法兼容IE7写法\"><a href=\"#getBoundingClientRect方法兼容IE7写法\" class=\"headerlink\" title=\"getBoundingClientRect方法兼容IE7写法\"></a>getBoundingClientRect方法兼容IE7写法</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rectObject = object.getBoundingClientRect(); <span class=\"comment\">// 返回元素的大小及其相对于视口的位置</span></span><br></pre></td></tr></table></figure>\n<p>ie7中的getBoundingClientRect方法只有bottom、left、right、top属性，没有width合height</p>\n<p><img src=\"http://zhoushirong.github.io/img/rect.png\" alt=\"图片\"></p>\n<p>通过上图可以看出：<br>除了width和height，其它几个属性都是相对于视口的左上角而言的。</p>\n<p>根据left、right的值可以推算出width</p>\n<p>根据top、bottom的值可以推算出height</p>\n<p>完整的代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * getBoundingClientRect 兼容IE7</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;DOM Object&#125;</span> </span>obj </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoundingClientRect</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> boundingClientRect = obj.getBoundingClientRect();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newObj = &#123;</span><br><span class=\"line\">        bottom: boundingClientRect.bottom,</span><br><span class=\"line\">        left: boundingClientRect.left,</span><br><span class=\"line\">        right: boundingClientRect.right,</span><br><span class=\"line\">        top: boundingClientRect.top</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (boundingClientRect.width) &#123;</span><br><span class=\"line\">\t\tnewObj.width = boundingClientRect.width;</span><br><span class=\"line\">\t\tnewObj.height = boundingClientRect.height;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tnewObj.width = boundingClientRect.right - boundingClientRect.left;</span><br><span class=\"line\">\t\tnewObj.height = boundingClientRect.bottom - boundingClientRect.top;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect\">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"getBoundingClientRect方法兼容IE7写法\"><a href=\"#getBoundingClientRect方法兼容IE7写法\" class=\"headerlink\" title=\"getBoundingClientRect方法兼容IE7写法\"></a>getBoundingClientRect方法兼容IE7写法</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rectObject = object.getBoundingClientRect(); <span class=\"comment\">// 返回元素的大小及其相对于视口的位置</span></span><br></pre></td></tr></table></figure>\n<p>ie7中的getBoundingClientRect方法只有bottom、left、right、top属性，没有width合height</p>\n<p><img src=\"http://zhoushirong.github.io/img/rect.png\" alt=\"图片\"></p>\n<p>通过上图可以看出：<br>除了width和height，其它几个属性都是相对于视口的左上角而言的。</p>\n<p>根据left、right的值可以推算出width</p>\n<p>根据top、bottom的值可以推算出height</p>\n<p>完整的代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * getBoundingClientRect 兼容IE7</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;DOM Object&#125;</span> </span>obj </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoundingClientRect</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> boundingClientRect = obj.getBoundingClientRect();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newObj = &#123;</span><br><span class=\"line\">        bottom: boundingClientRect.bottom,</span><br><span class=\"line\">        left: boundingClientRect.left,</span><br><span class=\"line\">        right: boundingClientRect.right,</span><br><span class=\"line\">        top: boundingClientRect.top</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (boundingClientRect.width) &#123;</span><br><span class=\"line\">\t\tnewObj.width = boundingClientRect.width;</span><br><span class=\"line\">\t\tnewObj.height = boundingClientRect.height;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tnewObj.width = boundingClientRect.right - boundingClientRect.left;</span><br><span class=\"line\">\t\tnewObj.height = boundingClientRect.bottom - boundingClientRect.top;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect\">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect</a></p>\n"},{"title":"常用的git命令","date":"2018-01-09T16:00:00.000Z","_content":"\ngit是一种分布式版本管理工具，他有着强大的开源社区github，结合smartgit能够快速、高效、准确的对分支进行切换。\n但是如果仅仅只是使用smartgit图形界面有时候也很不方便，至少在服务器上就没招了，因此了解一些git bash的基本命令是十分必要的。\n接下来会介绍一些常用的基本的git bash命令。\n\n### 配置git用户名和邮箱\n\n``` shell\ngit config user.username \"用户名\" \ngit config user.email \"邮箱\"\n```\n\n### 生成ssh-key\n```shell\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n```\n参数详解：\n```html\n-e：读取openssh的私钥或者公钥文件；\n-C：添加注释；\n-f：指定用来保存密钥的文件名；\n-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；\n-l：显示公钥文件的指纹数据；\n-N：提供一个新密语；\n-P：提供（旧）密语；\n-q：静默模式；\n-t：指定要创建的密钥类型。\n```\n\n可以使用其默认的\n``` shell\nzsr :: ~ ‹master*› % ssh-keygen                                                                 \nGenerating public/private rsa key pair.\nEnter file in which to save the key (~/.ssh/id_rsa): ~/.ssh/githubsshkey # 填写路径，可以指定文件名，可以缺省（缺省默认为 id_rsa）\nEnter passphrase (empty for no passphrase): # 密码可为空\nEnter same passphrase again: # 密码可为空\nYour identification has been saved in ~/.ssh/githubsshkey.\nYour public key has been saved in ~/.ssh/githubsshkey.pub.\nThe key fingerprint is:\nSHA256:Va57YAfyxN86cD5a1ejR6imhQiJuM/2IeTyK5FI+W+4 zsr@zsr.local\nThe key's randomart image is:\n+---[RSA 2048]----+\n|            .    |\n|         . o     |\n|        . = .    |\n|         = + . + |\n|        S * + = o|\n|  . . . .. B.+ o |\n| o...+ o  ..B.o  |\n|.oo+=o=.. .+.+ . |\n| .+=E=.o...  .o  |\n+----[SHA256]-----+\n```\n\n然后根据提示连续回车即可在~/.ssh 目录下得到githubsshkey 和githubsshkey.pub \n其中githubsshkey.pub文件里面存放的就是我们要使用的public key。\n\n\n### 生成多个ssh-key\n要生成多个key重复上面操作即可，生成之后再.ssh目录下创建一个config文件，并配置私钥(没有.pub的那个文件)的相对路径\n``` shell\nHost github.com\nUser zhoushirong\nIdentityFile ~/.ssh/githubsshkey\n```\n\n### git 常用命令\n``` shell\ngit clone git仓库地址 # 从git仓库拉取git代码到本地\n\ngit branch # 列出本地分支\n\ngit branch -r # 列出远程分支\n\ngit branch -a # 列出本地和远程分支\n\ngit branch 分支名 # 创建一个分支（*只是创建，不切换）\n\ngit branch -d | -D 分支名 # 删除本地分支\n\ngit branch -d | -D  -r 分支名 # 删除远程分支\n\ngit checkout 分支名 # 拉取远程分支\n\n```\n\n\n### git commit && push\n``` shell\ngit commit # 提交缓存区里面的文件\n\ngit commit -m \"提交描述信息\"\n\ngit push # 将本地仓库修改推送到服务器上的仓库\n\ngit push origin develop#— 将新分支push到远程分支\n\ngit push --set-upstream origin develop#— 将新分支push到远程分支并与之关联起来\n```\n\n### git 合并a 分支到 b分支\n\nstep1:\n\n``` shell\ngit checkout b\n```\n\nstep2:\n\n``` shell\ngit merge a\n```\n\n### git查看log\n\nstep1:\n``` shell\ngit log —— 按提交时间列出所有的更新\n\ngit log --pretty # pretty确定输出格式\n\ngit log --pretty=oneline # 日志简化版，只有commit message 和 hash\n\ngit log --pretty=oneline 文件名 # 显示某一个文件的git日志\n\ngit log -p -2 # -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新：\n```\n\n\n### gitignore\n\n有时候会遇到加入.gitignore文件的时候无效的问题，这个是因为某些文件已经被纳入了版本库\n\n解决办法：\n\n``` shell\ngit rm -r --cached .\n\ngit add .\n\ngit commit -m 'clean commit messages'\n\ngit push\n```\n\n### git撤销修改\n\ngit有四个区：工作区（Working Area）、暂存区（Stage）、本地仓库（Local Repository）、远程仓库（Remote Repository）\ngit有五种状态：未修改（Orgin）、已修改（Modified）、已暂存(Staged)、已提交（Committed）、已推送（Pushed）\n\n1.已修改，未暂存\n``` shell\ngit diff # 查看修改\ngit checkout . # 撤销修改(方法一)\ngit reset --hard # 撤销修改(方法二)\n```\n\n2.已暂存\n``` shell\ngit add . # 加入暂存\ngit diff --cached #  查看修改\n\ngit reset # 把修改退回到git add .之前\ngit checkcout . # 撤回已修改，未缓存状态\n\ngit reset --hard # 等同于上面两个命令的组合\n```\n\n3.已提交，未推送\n``` shell\ngit commit -m 'commit message' # 提交修改\ngit diff master orgin/master # 查看修改\ngit reset --hard orgin/master # 撤回修改（orgin/master代表远程仓库，相当于从远程仓库把代码取回来）\n```\n\n4.已推送的代码撤销\n``` shell\ngit reset --hard HEAD^ # 恢复本地仓库\ngit push -f # 强制push到远程仓库\n```\n\n\n### git push提示没有权限\n\n```shell\nzsr@zsr:~/wywork/epay% git push\ngit@g.hz.netease.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n解决办法\n```shell\nssh-add -l\n# Then, if you don't see your key listed, add it with:\nssh-add ~/.ssh/identity # 生成的私钥\n```\n\n### 提示DNS欺骗检测\n\n```shel \n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nThe ECDSA host key for [g.hz.netease.com]:22222 has changed,\nand the key for the corresponding IP address [59.111.178.110]:22222\nis unknown. This could either mean that\nDNS SPOOFING is happening or the IP address for the host\nand its host key have changed at the same time.\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the ECDSA key sent by the remote host is\nSHA256:iktCbxKzaP13xO9iY/5B9tkuIYE9BZfC31uW1Z6F4YQ.\nPlease contact your system administrator.\nAdd correct host key in ~/.ssh/known_hosts to get rid of this message.\nOffending ECDSA key in ~/.ssh/known_hosts:20\nECDSA host key for [g.hz.netease.com]:22222 has changed and you have requested strict checking.\nHost key verification failed.\nfatal: Could not read from remote repository.\n```\n\n出错原因：\n```shell\nknow_hosts \n# ssh登录的时候，当远程主机的公钥被接受以后，就会保存远程主机的公钥到此文件\n# 出错的原因可能是公钥和对应的主机对应不上了。\n```\n\n解决办法\n```shell\n# 删除~/.ssh/known_hosts里面对应的公钥条目、或者直接删除此文件\nrm -rf ~/.ssh/known_hosts\n```\n\n\n### 传送门\n\n[https://git-scm.com/book/zh/v1/起步-关于版本控制](https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5)\n\n","source":"_posts/git.md","raw":"---\ntitle: 常用的git命令\ndate: 2018/01/10\ntag: git\ncategory: 技术\n---\n\ngit是一种分布式版本管理工具，他有着强大的开源社区github，结合smartgit能够快速、高效、准确的对分支进行切换。\n但是如果仅仅只是使用smartgit图形界面有时候也很不方便，至少在服务器上就没招了，因此了解一些git bash的基本命令是十分必要的。\n接下来会介绍一些常用的基本的git bash命令。\n\n### 配置git用户名和邮箱\n\n``` shell\ngit config user.username \"用户名\" \ngit config user.email \"邮箱\"\n```\n\n### 生成ssh-key\n```shell\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n```\n参数详解：\n```html\n-e：读取openssh的私钥或者公钥文件；\n-C：添加注释；\n-f：指定用来保存密钥的文件名；\n-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；\n-l：显示公钥文件的指纹数据；\n-N：提供一个新密语；\n-P：提供（旧）密语；\n-q：静默模式；\n-t：指定要创建的密钥类型。\n```\n\n可以使用其默认的\n``` shell\nzsr :: ~ ‹master*› % ssh-keygen                                                                 \nGenerating public/private rsa key pair.\nEnter file in which to save the key (~/.ssh/id_rsa): ~/.ssh/githubsshkey # 填写路径，可以指定文件名，可以缺省（缺省默认为 id_rsa）\nEnter passphrase (empty for no passphrase): # 密码可为空\nEnter same passphrase again: # 密码可为空\nYour identification has been saved in ~/.ssh/githubsshkey.\nYour public key has been saved in ~/.ssh/githubsshkey.pub.\nThe key fingerprint is:\nSHA256:Va57YAfyxN86cD5a1ejR6imhQiJuM/2IeTyK5FI+W+4 zsr@zsr.local\nThe key's randomart image is:\n+---[RSA 2048]----+\n|            .    |\n|         . o     |\n|        . = .    |\n|         = + . + |\n|        S * + = o|\n|  . . . .. B.+ o |\n| o...+ o  ..B.o  |\n|.oo+=o=.. .+.+ . |\n| .+=E=.o...  .o  |\n+----[SHA256]-----+\n```\n\n然后根据提示连续回车即可在~/.ssh 目录下得到githubsshkey 和githubsshkey.pub \n其中githubsshkey.pub文件里面存放的就是我们要使用的public key。\n\n\n### 生成多个ssh-key\n要生成多个key重复上面操作即可，生成之后再.ssh目录下创建一个config文件，并配置私钥(没有.pub的那个文件)的相对路径\n``` shell\nHost github.com\nUser zhoushirong\nIdentityFile ~/.ssh/githubsshkey\n```\n\n### git 常用命令\n``` shell\ngit clone git仓库地址 # 从git仓库拉取git代码到本地\n\ngit branch # 列出本地分支\n\ngit branch -r # 列出远程分支\n\ngit branch -a # 列出本地和远程分支\n\ngit branch 分支名 # 创建一个分支（*只是创建，不切换）\n\ngit branch -d | -D 分支名 # 删除本地分支\n\ngit branch -d | -D  -r 分支名 # 删除远程分支\n\ngit checkout 分支名 # 拉取远程分支\n\n```\n\n\n### git commit && push\n``` shell\ngit commit # 提交缓存区里面的文件\n\ngit commit -m \"提交描述信息\"\n\ngit push # 将本地仓库修改推送到服务器上的仓库\n\ngit push origin develop#— 将新分支push到远程分支\n\ngit push --set-upstream origin develop#— 将新分支push到远程分支并与之关联起来\n```\n\n### git 合并a 分支到 b分支\n\nstep1:\n\n``` shell\ngit checkout b\n```\n\nstep2:\n\n``` shell\ngit merge a\n```\n\n### git查看log\n\nstep1:\n``` shell\ngit log —— 按提交时间列出所有的更新\n\ngit log --pretty # pretty确定输出格式\n\ngit log --pretty=oneline # 日志简化版，只有commit message 和 hash\n\ngit log --pretty=oneline 文件名 # 显示某一个文件的git日志\n\ngit log -p -2 # -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新：\n```\n\n\n### gitignore\n\n有时候会遇到加入.gitignore文件的时候无效的问题，这个是因为某些文件已经被纳入了版本库\n\n解决办法：\n\n``` shell\ngit rm -r --cached .\n\ngit add .\n\ngit commit -m 'clean commit messages'\n\ngit push\n```\n\n### git撤销修改\n\ngit有四个区：工作区（Working Area）、暂存区（Stage）、本地仓库（Local Repository）、远程仓库（Remote Repository）\ngit有五种状态：未修改（Orgin）、已修改（Modified）、已暂存(Staged)、已提交（Committed）、已推送（Pushed）\n\n1.已修改，未暂存\n``` shell\ngit diff # 查看修改\ngit checkout . # 撤销修改(方法一)\ngit reset --hard # 撤销修改(方法二)\n```\n\n2.已暂存\n``` shell\ngit add . # 加入暂存\ngit diff --cached #  查看修改\n\ngit reset # 把修改退回到git add .之前\ngit checkcout . # 撤回已修改，未缓存状态\n\ngit reset --hard # 等同于上面两个命令的组合\n```\n\n3.已提交，未推送\n``` shell\ngit commit -m 'commit message' # 提交修改\ngit diff master orgin/master # 查看修改\ngit reset --hard orgin/master # 撤回修改（orgin/master代表远程仓库，相当于从远程仓库把代码取回来）\n```\n\n4.已推送的代码撤销\n``` shell\ngit reset --hard HEAD^ # 恢复本地仓库\ngit push -f # 强制push到远程仓库\n```\n\n\n### git push提示没有权限\n\n```shell\nzsr@zsr:~/wywork/epay% git push\ngit@g.hz.netease.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n解决办法\n```shell\nssh-add -l\n# Then, if you don't see your key listed, add it with:\nssh-add ~/.ssh/identity # 生成的私钥\n```\n\n### 提示DNS欺骗检测\n\n```shel \n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nThe ECDSA host key for [g.hz.netease.com]:22222 has changed,\nand the key for the corresponding IP address [59.111.178.110]:22222\nis unknown. This could either mean that\nDNS SPOOFING is happening or the IP address for the host\nand its host key have changed at the same time.\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the ECDSA key sent by the remote host is\nSHA256:iktCbxKzaP13xO9iY/5B9tkuIYE9BZfC31uW1Z6F4YQ.\nPlease contact your system administrator.\nAdd correct host key in ~/.ssh/known_hosts to get rid of this message.\nOffending ECDSA key in ~/.ssh/known_hosts:20\nECDSA host key for [g.hz.netease.com]:22222 has changed and you have requested strict checking.\nHost key verification failed.\nfatal: Could not read from remote repository.\n```\n\n出错原因：\n```shell\nknow_hosts \n# ssh登录的时候，当远程主机的公钥被接受以后，就会保存远程主机的公钥到此文件\n# 出错的原因可能是公钥和对应的主机对应不上了。\n```\n\n解决办法\n```shell\n# 删除~/.ssh/known_hosts里面对应的公钥条目、或者直接删除此文件\nrm -rf ~/.ssh/known_hosts\n```\n\n\n### 传送门\n\n[https://git-scm.com/book/zh/v1/起步-关于版本控制](https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5)\n\n","slug":"git","published":1,"updated":"2021-03-30T01:32:00.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufe000da0vz62k7ex60","content":"<p>git是一种分布式版本管理工具，他有着强大的开源社区github，结合smartgit能够快速、高效、准确的对分支进行切换。<br>但是如果仅仅只是使用smartgit图形界面有时候也很不方便，至少在服务器上就没招了，因此了解一些git bash的基本命令是十分必要的。<br>接下来会介绍一些常用的基本的git bash命令。</p>\n<h3 id=\"配置git用户名和邮箱\"><a href=\"#配置git用户名和邮箱\" class=\"headerlink\" title=\"配置git用户名和邮箱\"></a>配置git用户名和邮箱</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config user.username &quot;用户名&quot; </span><br><span class=\"line\">git config user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成ssh-key\"><a href=\"#生成ssh-key\" class=\"headerlink\" title=\"生成ssh-key\"></a>生成ssh-key</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<p>参数详解：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-e：读取openssh的私钥或者公钥文件；</span><br><span class=\"line\">-C：添加注释；</span><br><span class=\"line\">-f：指定用来保存密钥的文件名；</span><br><span class=\"line\">-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；</span><br><span class=\"line\">-l：显示公钥文件的指纹数据；</span><br><span class=\"line\">-N：提供一个新密语；</span><br><span class=\"line\">-P：提供（旧）密语；</span><br><span class=\"line\">-q：静默模式；</span><br><span class=\"line\">-t：指定要创建的密钥类型。</span><br></pre></td></tr></table></figure></p>\n<p>可以使用其默认的<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zsr :: ~ ‹master*› % ssh-keygen                                                                 </span><br><span class=\"line\">Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (~/.ssh/id_rsa): ~/.ssh/githubsshkey # 填写路径，可以指定文件名，可以缺省（缺省默认为 id_rsa）</span><br><span class=\"line\">Enter passphrase (empty for no passphrase): # 密码可为空</span><br><span class=\"line\">Enter same passphrase again: # 密码可为空</span><br><span class=\"line\">Your identification has been saved in ~/.ssh/githubsshkey.</span><br><span class=\"line\">Your public key has been saved in ~/.ssh/githubsshkey.pub.</span><br><span class=\"line\">The key fingerprint is:</span><br><span class=\"line\">SHA256:Va57YAfyxN86cD5a1ejR6imhQiJuM/2IeTyK5FI+W+4 zsr@zsr.local</span><br><span class=\"line\">The key&#x27;s randomart image is:</span><br><span class=\"line\">+---[RSA 2048]----+</span><br><span class=\"line\">|            .    |</span><br><span class=\"line\">|         . o     |</span><br><span class=\"line\">|        . = .    |</span><br><span class=\"line\">|         = + . + |</span><br><span class=\"line\">|        S * + = o|</span><br><span class=\"line\">|  . . . .. B.+ o |</span><br><span class=\"line\">| o...+ o  ..B.o  |</span><br><span class=\"line\">|.oo+=o=.. .+.+ . |</span><br><span class=\"line\">| .+=E=.o...  .o  |</span><br><span class=\"line\">+----[SHA256]-----+</span><br></pre></td></tr></table></figure></p>\n<p>然后根据提示连续回车即可在~/.ssh 目录下得到githubsshkey 和githubsshkey.pub<br>其中githubsshkey.pub文件里面存放的就是我们要使用的public key。</p>\n<h3 id=\"生成多个ssh-key\"><a href=\"#生成多个ssh-key\" class=\"headerlink\" title=\"生成多个ssh-key\"></a>生成多个ssh-key</h3><p>要生成多个key重复上面操作即可，生成之后再.ssh目录下创建一个config文件，并配置私钥(没有.pub的那个文件)的相对路径<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host github.com</span><br><span class=\"line\">User zhoushirong</span><br><span class=\"line\">IdentityFile ~/.ssh/githubsshkey</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"git-常用命令\"><a href=\"#git-常用命令\" class=\"headerlink\" title=\"git 常用命令\"></a>git 常用命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git仓库地址 # 从git仓库拉取git代码到本地</span><br><span class=\"line\"></span><br><span class=\"line\">git branch # 列出本地分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -r # 列出远程分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -a # 列出本地和远程分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch 分支名 # 创建一个分支（*只是创建，不切换）</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -d | -D 分支名 # 删除本地分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -d | -D  -r 分支名 # 删除远程分支</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout 分支名 # 拉取远程分支</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"git-commit-amp-amp-push\"><a href=\"#git-commit-amp-amp-push\" class=\"headerlink\" title=\"git commit &amp;&amp; push\"></a>git commit &amp;&amp; push</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit # 提交缓存区里面的文件</span><br><span class=\"line\"></span><br><span class=\"line\">git commit -m &quot;提交描述信息&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">git push # 将本地仓库修改推送到服务器上的仓库</span><br><span class=\"line\"></span><br><span class=\"line\">git push origin develop#— 将新分支push到远程分支</span><br><span class=\"line\"></span><br><span class=\"line\">git push --set-upstream origin develop#— 将新分支push到远程分支并与之关联起来</span><br></pre></td></tr></table></figure>\n<h3 id=\"git-合并a-分支到-b分支\"><a href=\"#git-合并a-分支到-b分支\" class=\"headerlink\" title=\"git 合并a 分支到 b分支\"></a>git 合并a 分支到 b分支</h3><p>step1:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout b</span><br></pre></td></tr></table></figure>\n<p>step2:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge a</span><br></pre></td></tr></table></figure>\n<h3 id=\"git查看log\"><a href=\"#git查看log\" class=\"headerlink\" title=\"git查看log\"></a>git查看log</h3><p>step1:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log —— 按提交时间列出所有的更新</span><br><span class=\"line\"></span><br><span class=\"line\">git log --pretty # pretty确定输出格式</span><br><span class=\"line\"></span><br><span class=\"line\">git log --pretty=oneline # 日志简化版，只有commit message 和 hash</span><br><span class=\"line\"></span><br><span class=\"line\">git log --pretty=oneline 文件名 # 显示某一个文件的git日志</span><br><span class=\"line\"></span><br><span class=\"line\">git log -p -2 # -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新：</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"gitignore\"><a href=\"#gitignore\" class=\"headerlink\" title=\"gitignore\"></a>gitignore</h3><p>有时候会遇到加入.gitignore文件的时候无效的问题，这个是因为某些文件已经被纳入了版本库</p>\n<p>解决办法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r --cached .</span><br><span class=\"line\"></span><br><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\">git commit -m &#x27;clean commit messages&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n<h3 id=\"git撤销修改\"><a href=\"#git撤销修改\" class=\"headerlink\" title=\"git撤销修改\"></a>git撤销修改</h3><p>git有四个区：工作区（Working Area）、暂存区（Stage）、本地仓库（Local Repository）、远程仓库（Remote Repository）<br>git有五种状态：未修改（Orgin）、已修改（Modified）、已暂存(Staged)、已提交（Committed）、已推送（Pushed）</p>\n<p>1.已修改，未暂存<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff # 查看修改</span><br><span class=\"line\">git checkout . # 撤销修改(方法一)</span><br><span class=\"line\">git reset --hard # 撤销修改(方法二)</span><br></pre></td></tr></table></figure></p>\n<p>2.已暂存<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add . # 加入暂存</span><br><span class=\"line\">git diff --cached #  查看修改</span><br><span class=\"line\"></span><br><span class=\"line\">git reset # 把修改退回到git add .之前</span><br><span class=\"line\">git checkcout . # 撤回已修改，未缓存状态</span><br><span class=\"line\"></span><br><span class=\"line\">git reset --hard # 等同于上面两个命令的组合</span><br></pre></td></tr></table></figure></p>\n<p>3.已提交，未推送<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &#x27;commit message&#x27; # 提交修改</span><br><span class=\"line\">git diff master orgin/master # 查看修改</span><br><span class=\"line\">git reset --hard orgin/master # 撤回修改（orgin/master代表远程仓库，相当于从远程仓库把代码取回来）</span><br></pre></td></tr></table></figure></p>\n<p>4.已推送的代码撤销<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^ # 恢复本地仓库</span><br><span class=\"line\">git push -f # 强制push到远程仓库</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"git-push提示没有权限\"><a href=\"#git-push提示没有权限\" class=\"headerlink\" title=\"git push提示没有权限\"></a>git push提示没有权限</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zsr@zsr:~/wywork/epay% git push</span><br><span class=\"line\">git@g.hz.netease.com: Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br></pre></td></tr></table></figure>\n<p>解决办法<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-add -l</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Then, <span class=\"keyword\">if</span> you don<span class=\"string\">&#x27;t see your key listed, add it with:</span></span></span><br><span class=\"line\">ssh-add ~/.ssh/identity # 生成的私钥</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"提示DNS欺骗检测\"><a href=\"#提示DNS欺骗检测\" class=\"headerlink\" title=\"提示DNS欺骗检测\"></a>提示DNS欺骗检测</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class=\"line\">@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @</span><br><span class=\"line\">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class=\"line\">The ECDSA host key for [g.hz.netease.com]:22222 has changed,</span><br><span class=\"line\">and the key for the corresponding IP address [59.111.178.110]:22222</span><br><span class=\"line\">is unknown. This could either mean that</span><br><span class=\"line\">DNS SPOOFING is happening or the IP address for the host</span><br><span class=\"line\">and its host key have changed at the same time.</span><br><span class=\"line\">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class=\"line\">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class=\"line\">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class=\"line\">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class=\"line\">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class=\"line\">It is also possible that a host key has just been changed.</span><br><span class=\"line\">The fingerprint for the ECDSA key sent by the remote host is</span><br><span class=\"line\">SHA256:iktCbxKzaP13xO9iY&#x2F;5B9tkuIYE9BZfC31uW1Z6F4YQ.</span><br><span class=\"line\">Please contact your system administrator.</span><br><span class=\"line\">Add correct host key in ~&#x2F;.ssh&#x2F;known_hosts to get rid of this message.</span><br><span class=\"line\">Offending ECDSA key in ~&#x2F;.ssh&#x2F;known_hosts:20</span><br><span class=\"line\">ECDSA host key for [g.hz.netease.com]:22222 has changed and you have requested strict checking.</span><br><span class=\"line\">Host key verification failed.</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure>\n<p>出错原因：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">know_hosts </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ssh登录的时候，当远程主机的公钥被接受以后，就会保存远程主机的公钥到此文件</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 出错的原因可能是公钥和对应的主机对应不上了。</span></span><br></pre></td></tr></table></figure></p>\n<p>解决办法<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 删除~/.ssh/known_hosts里面对应的公钥条目、或者直接删除此文件</span></span><br><span class=\"line\">rm -rf ~/.ssh/known_hosts</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5\">https://git-scm.com/book/zh/v1/起步-关于版本控制</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>git是一种分布式版本管理工具，他有着强大的开源社区github，结合smartgit能够快速、高效、准确的对分支进行切换。<br>但是如果仅仅只是使用smartgit图形界面有时候也很不方便，至少在服务器上就没招了，因此了解一些git bash的基本命令是十分必要的。<br>接下来会介绍一些常用的基本的git bash命令。</p>\n<h3 id=\"配置git用户名和邮箱\"><a href=\"#配置git用户名和邮箱\" class=\"headerlink\" title=\"配置git用户名和邮箱\"></a>配置git用户名和邮箱</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config user.username &quot;用户名&quot; </span><br><span class=\"line\">git config user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成ssh-key\"><a href=\"#生成ssh-key\" class=\"headerlink\" title=\"生成ssh-key\"></a>生成ssh-key</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<p>参数详解：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-e：读取openssh的私钥或者公钥文件；</span><br><span class=\"line\">-C：添加注释；</span><br><span class=\"line\">-f：指定用来保存密钥的文件名；</span><br><span class=\"line\">-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；</span><br><span class=\"line\">-l：显示公钥文件的指纹数据；</span><br><span class=\"line\">-N：提供一个新密语；</span><br><span class=\"line\">-P：提供（旧）密语；</span><br><span class=\"line\">-q：静默模式；</span><br><span class=\"line\">-t：指定要创建的密钥类型。</span><br></pre></td></tr></table></figure></p>\n<p>可以使用其默认的<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zsr :: ~ ‹master*› % ssh-keygen                                                                 </span><br><span class=\"line\">Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (~/.ssh/id_rsa): ~/.ssh/githubsshkey # 填写路径，可以指定文件名，可以缺省（缺省默认为 id_rsa）</span><br><span class=\"line\">Enter passphrase (empty for no passphrase): # 密码可为空</span><br><span class=\"line\">Enter same passphrase again: # 密码可为空</span><br><span class=\"line\">Your identification has been saved in ~/.ssh/githubsshkey.</span><br><span class=\"line\">Your public key has been saved in ~/.ssh/githubsshkey.pub.</span><br><span class=\"line\">The key fingerprint is:</span><br><span class=\"line\">SHA256:Va57YAfyxN86cD5a1ejR6imhQiJuM/2IeTyK5FI+W+4 zsr@zsr.local</span><br><span class=\"line\">The key&#x27;s randomart image is:</span><br><span class=\"line\">+---[RSA 2048]----+</span><br><span class=\"line\">|            .    |</span><br><span class=\"line\">|         . o     |</span><br><span class=\"line\">|        . = .    |</span><br><span class=\"line\">|         = + . + |</span><br><span class=\"line\">|        S * + = o|</span><br><span class=\"line\">|  . . . .. B.+ o |</span><br><span class=\"line\">| o...+ o  ..B.o  |</span><br><span class=\"line\">|.oo+=o=.. .+.+ . |</span><br><span class=\"line\">| .+=E=.o...  .o  |</span><br><span class=\"line\">+----[SHA256]-----+</span><br></pre></td></tr></table></figure></p>\n<p>然后根据提示连续回车即可在~/.ssh 目录下得到githubsshkey 和githubsshkey.pub<br>其中githubsshkey.pub文件里面存放的就是我们要使用的public key。</p>\n<h3 id=\"生成多个ssh-key\"><a href=\"#生成多个ssh-key\" class=\"headerlink\" title=\"生成多个ssh-key\"></a>生成多个ssh-key</h3><p>要生成多个key重复上面操作即可，生成之后再.ssh目录下创建一个config文件，并配置私钥(没有.pub的那个文件)的相对路径<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host github.com</span><br><span class=\"line\">User zhoushirong</span><br><span class=\"line\">IdentityFile ~/.ssh/githubsshkey</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"git-常用命令\"><a href=\"#git-常用命令\" class=\"headerlink\" title=\"git 常用命令\"></a>git 常用命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git仓库地址 # 从git仓库拉取git代码到本地</span><br><span class=\"line\"></span><br><span class=\"line\">git branch # 列出本地分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -r # 列出远程分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -a # 列出本地和远程分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch 分支名 # 创建一个分支（*只是创建，不切换）</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -d | -D 分支名 # 删除本地分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -d | -D  -r 分支名 # 删除远程分支</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout 分支名 # 拉取远程分支</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"git-commit-amp-amp-push\"><a href=\"#git-commit-amp-amp-push\" class=\"headerlink\" title=\"git commit &amp;&amp; push\"></a>git commit &amp;&amp; push</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit # 提交缓存区里面的文件</span><br><span class=\"line\"></span><br><span class=\"line\">git commit -m &quot;提交描述信息&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">git push # 将本地仓库修改推送到服务器上的仓库</span><br><span class=\"line\"></span><br><span class=\"line\">git push origin develop#— 将新分支push到远程分支</span><br><span class=\"line\"></span><br><span class=\"line\">git push --set-upstream origin develop#— 将新分支push到远程分支并与之关联起来</span><br></pre></td></tr></table></figure>\n<h3 id=\"git-合并a-分支到-b分支\"><a href=\"#git-合并a-分支到-b分支\" class=\"headerlink\" title=\"git 合并a 分支到 b分支\"></a>git 合并a 分支到 b分支</h3><p>step1:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout b</span><br></pre></td></tr></table></figure>\n<p>step2:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge a</span><br></pre></td></tr></table></figure>\n<h3 id=\"git查看log\"><a href=\"#git查看log\" class=\"headerlink\" title=\"git查看log\"></a>git查看log</h3><p>step1:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log —— 按提交时间列出所有的更新</span><br><span class=\"line\"></span><br><span class=\"line\">git log --pretty # pretty确定输出格式</span><br><span class=\"line\"></span><br><span class=\"line\">git log --pretty=oneline # 日志简化版，只有commit message 和 hash</span><br><span class=\"line\"></span><br><span class=\"line\">git log --pretty=oneline 文件名 # 显示某一个文件的git日志</span><br><span class=\"line\"></span><br><span class=\"line\">git log -p -2 # -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新：</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"gitignore\"><a href=\"#gitignore\" class=\"headerlink\" title=\"gitignore\"></a>gitignore</h3><p>有时候会遇到加入.gitignore文件的时候无效的问题，这个是因为某些文件已经被纳入了版本库</p>\n<p>解决办法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r --cached .</span><br><span class=\"line\"></span><br><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\">git commit -m &#x27;clean commit messages&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n<h3 id=\"git撤销修改\"><a href=\"#git撤销修改\" class=\"headerlink\" title=\"git撤销修改\"></a>git撤销修改</h3><p>git有四个区：工作区（Working Area）、暂存区（Stage）、本地仓库（Local Repository）、远程仓库（Remote Repository）<br>git有五种状态：未修改（Orgin）、已修改（Modified）、已暂存(Staged)、已提交（Committed）、已推送（Pushed）</p>\n<p>1.已修改，未暂存<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff # 查看修改</span><br><span class=\"line\">git checkout . # 撤销修改(方法一)</span><br><span class=\"line\">git reset --hard # 撤销修改(方法二)</span><br></pre></td></tr></table></figure></p>\n<p>2.已暂存<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add . # 加入暂存</span><br><span class=\"line\">git diff --cached #  查看修改</span><br><span class=\"line\"></span><br><span class=\"line\">git reset # 把修改退回到git add .之前</span><br><span class=\"line\">git checkcout . # 撤回已修改，未缓存状态</span><br><span class=\"line\"></span><br><span class=\"line\">git reset --hard # 等同于上面两个命令的组合</span><br></pre></td></tr></table></figure></p>\n<p>3.已提交，未推送<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &#x27;commit message&#x27; # 提交修改</span><br><span class=\"line\">git diff master orgin/master # 查看修改</span><br><span class=\"line\">git reset --hard orgin/master # 撤回修改（orgin/master代表远程仓库，相当于从远程仓库把代码取回来）</span><br></pre></td></tr></table></figure></p>\n<p>4.已推送的代码撤销<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^ # 恢复本地仓库</span><br><span class=\"line\">git push -f # 强制push到远程仓库</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"git-push提示没有权限\"><a href=\"#git-push提示没有权限\" class=\"headerlink\" title=\"git push提示没有权限\"></a>git push提示没有权限</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zsr@zsr:~/wywork/epay% git push</span><br><span class=\"line\">git@g.hz.netease.com: Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br></pre></td></tr></table></figure>\n<p>解决办法<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-add -l</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Then, <span class=\"keyword\">if</span> you don<span class=\"string\">&#x27;t see your key listed, add it with:</span></span></span><br><span class=\"line\">ssh-add ~/.ssh/identity # 生成的私钥</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"提示DNS欺骗检测\"><a href=\"#提示DNS欺骗检测\" class=\"headerlink\" title=\"提示DNS欺骗检测\"></a>提示DNS欺骗检测</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class=\"line\">@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @</span><br><span class=\"line\">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class=\"line\">The ECDSA host key for [g.hz.netease.com]:22222 has changed,</span><br><span class=\"line\">and the key for the corresponding IP address [59.111.178.110]:22222</span><br><span class=\"line\">is unknown. This could either mean that</span><br><span class=\"line\">DNS SPOOFING is happening or the IP address for the host</span><br><span class=\"line\">and its host key have changed at the same time.</span><br><span class=\"line\">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class=\"line\">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class=\"line\">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class=\"line\">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class=\"line\">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class=\"line\">It is also possible that a host key has just been changed.</span><br><span class=\"line\">The fingerprint for the ECDSA key sent by the remote host is</span><br><span class=\"line\">SHA256:iktCbxKzaP13xO9iY&#x2F;5B9tkuIYE9BZfC31uW1Z6F4YQ.</span><br><span class=\"line\">Please contact your system administrator.</span><br><span class=\"line\">Add correct host key in ~&#x2F;.ssh&#x2F;known_hosts to get rid of this message.</span><br><span class=\"line\">Offending ECDSA key in ~&#x2F;.ssh&#x2F;known_hosts:20</span><br><span class=\"line\">ECDSA host key for [g.hz.netease.com]:22222 has changed and you have requested strict checking.</span><br><span class=\"line\">Host key verification failed.</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure>\n<p>出错原因：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">know_hosts </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ssh登录的时候，当远程主机的公钥被接受以后，就会保存远程主机的公钥到此文件</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 出错的原因可能是公钥和对应的主机对应不上了。</span></span><br></pre></td></tr></table></figure></p>\n<p>解决办法<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 删除~/.ssh/known_hosts里面对应的公钥条目、或者直接删除此文件</span></span><br><span class=\"line\">rm -rf ~/.ssh/known_hosts</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5\">https://git-scm.com/book/zh/v1/起步-关于版本控制</a></p>\n"},{"title":"Gulp基本用法","date":"2016-12-19T16:00:00.000Z","_content":"\nGulp是一个模块化打包工具。\nGulp本身只有几个入口，支持他拥有强大功能的是各种各样的插件。\nGulp的使用看起来非常简单，只需要一个一个任务链式执行就可以了，它还可以与Webpack结合起来使用\n比如将Webpack作为一个插件来处理ES6转换为ES5的操作。\n下面记录一下Gulp的API以及一些用到的插件。\n\n\n``` javascript\ngulp.src(globs[, options])\n```\n输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。\n\nglobs：一种匹配文件的规则。\n\n---\n\n``` javascript\ngulp.dest(path[, options])\n```\n能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。\n\n文件被写入的路径是以所给的相对路径根据所给的目标目录计算而来。类似的，相对路径也可以根据所给的 base 来计算。 请查看上述的 gulp.src 来了解更多信息。\n\n---\n\n``` javascript\ngulp.task(name[, deps], fn)\n```\n定义一个使用 Orchestrator 实现的任务（task）\n\nOrchestrator: 一个执行并发任务的库。\n\n---\n\n``` javascript\ngulp.watch(glob[, opts], tasks)\n```\n监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。\n\nglob：\n\n类型： String or Array\n\n一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。\n\neg:\n\n``` javascript\nvar watcher = gulp.watch('js/**/*.js', ['uglify','reload']);\nwatcher.on('change', function(event) {\n  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');\n});\n\ngulp.watch('js/**/*.js', function(event) {\n  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');\n});\n```\n\n---\n\n\n\n### 相关链接：\n\n中文网官网：\n\nhttp://www.gulpjs.com.cn/docs/api/\n\n#### gulp-babel插件：\n\ngulp使用babel编译文件\n\nhttps://github.com/babel/gulp-babel\n\n\n#### gulp-util插件\n\ngulp插件的一些实用方法（Utility functions for gulp plugins）\n\nhttps://github.com/gulpjs/gulp-util\n\n\n#### gulp-imagemin插件\n\n压缩png、jpeg、gif、svg图片用的压缩工具（Minify PNG, JPEG, GIF and SVG images with imagemin）\n\nhttps://github.com/sindresorhus/gulp-imagemin\n\n\n#### gulp-clean插件\n\n用来移除文件或者文件夹的插件（A gulp plugin for removing files and folders from given paths.）\n\nhttps://github.com/peter-vilja/gulp-clean\n\n\n#### gulp-sequence插件\n\n执行一个连续的gulp任务（Run a series of gulp tasks in order.）\n\nhttps://github.com/teambition/gulp-sequence\n\n\n#### gulp.spritesmith插件\n\n合并图片（不会翻译）（Convert a set of images into a spritesheet and CSS variables via gulp）\n\nhttps://github.com/twolfson/gulp.spritesmith\n\n\n#### gulp-sourcemaps插件\n\ngulp sourcemap支持（Source map support for Gulp.js）\n\nhttps://github.com/floridoo/gulp-sourcemaps\n\n\n#### gulp-concat插件\n\n合并文件流（Streaming concat middleware for gulp）\n\nhttps://github.com/contra/gulp-concat\n\n\n#### gulp-autoprefixer 插件\n\n给css加前缀（Prefix CSS）\n\nhttps://github.com/sindresorhus/gulp-autoprefixer\n\n\n#### gulp-file-include插件\n\n文件include合并支持（a gulp plugin for file include）\n\nhttps://github.com/coderhaoxin/gulp-file-include\n\n\n#### gulp-rev插件\n\n静态资源加hash重命名\n(Static asset revisioning by appending content hash to filenames: unicorn.css → unicorn-d41d8cd98f.css)\n\nhttps://github.com/sindresorhus/gulp-rev\n\n\n#### gulp-rev-collector插件\n\n文件变化之后修改时间戳（不会翻译）\n\n（Static asset revision data collector from manifests, generated from different streams, and replace their links in html template.）\n\nhttps://github.com/shonny-ua/gulp-rev-collector\n\n\n#### browser-sync插件\n\n浏览器实时更新(Keep multiple browsers & devices in sync when building websites.)\n\nhttps://github.com/browsersync/browser-sync\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/gulp.md","raw":"---\ntitle: Gulp基本用法\ndate: 2016/12/20\ntag: gulp\ncategory: 技术\n---\n\nGulp是一个模块化打包工具。\nGulp本身只有几个入口，支持他拥有强大功能的是各种各样的插件。\nGulp的使用看起来非常简单，只需要一个一个任务链式执行就可以了，它还可以与Webpack结合起来使用\n比如将Webpack作为一个插件来处理ES6转换为ES5的操作。\n下面记录一下Gulp的API以及一些用到的插件。\n\n\n``` javascript\ngulp.src(globs[, options])\n```\n输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。\n\nglobs：一种匹配文件的规则。\n\n---\n\n``` javascript\ngulp.dest(path[, options])\n```\n能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。\n\n文件被写入的路径是以所给的相对路径根据所给的目标目录计算而来。类似的，相对路径也可以根据所给的 base 来计算。 请查看上述的 gulp.src 来了解更多信息。\n\n---\n\n``` javascript\ngulp.task(name[, deps], fn)\n```\n定义一个使用 Orchestrator 实现的任务（task）\n\nOrchestrator: 一个执行并发任务的库。\n\n---\n\n``` javascript\ngulp.watch(glob[, opts], tasks)\n```\n监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。\n\nglob：\n\n类型： String or Array\n\n一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。\n\neg:\n\n``` javascript\nvar watcher = gulp.watch('js/**/*.js', ['uglify','reload']);\nwatcher.on('change', function(event) {\n  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');\n});\n\ngulp.watch('js/**/*.js', function(event) {\n  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');\n});\n```\n\n---\n\n\n\n### 相关链接：\n\n中文网官网：\n\nhttp://www.gulpjs.com.cn/docs/api/\n\n#### gulp-babel插件：\n\ngulp使用babel编译文件\n\nhttps://github.com/babel/gulp-babel\n\n\n#### gulp-util插件\n\ngulp插件的一些实用方法（Utility functions for gulp plugins）\n\nhttps://github.com/gulpjs/gulp-util\n\n\n#### gulp-imagemin插件\n\n压缩png、jpeg、gif、svg图片用的压缩工具（Minify PNG, JPEG, GIF and SVG images with imagemin）\n\nhttps://github.com/sindresorhus/gulp-imagemin\n\n\n#### gulp-clean插件\n\n用来移除文件或者文件夹的插件（A gulp plugin for removing files and folders from given paths.）\n\nhttps://github.com/peter-vilja/gulp-clean\n\n\n#### gulp-sequence插件\n\n执行一个连续的gulp任务（Run a series of gulp tasks in order.）\n\nhttps://github.com/teambition/gulp-sequence\n\n\n#### gulp.spritesmith插件\n\n合并图片（不会翻译）（Convert a set of images into a spritesheet and CSS variables via gulp）\n\nhttps://github.com/twolfson/gulp.spritesmith\n\n\n#### gulp-sourcemaps插件\n\ngulp sourcemap支持（Source map support for Gulp.js）\n\nhttps://github.com/floridoo/gulp-sourcemaps\n\n\n#### gulp-concat插件\n\n合并文件流（Streaming concat middleware for gulp）\n\nhttps://github.com/contra/gulp-concat\n\n\n#### gulp-autoprefixer 插件\n\n给css加前缀（Prefix CSS）\n\nhttps://github.com/sindresorhus/gulp-autoprefixer\n\n\n#### gulp-file-include插件\n\n文件include合并支持（a gulp plugin for file include）\n\nhttps://github.com/coderhaoxin/gulp-file-include\n\n\n#### gulp-rev插件\n\n静态资源加hash重命名\n(Static asset revisioning by appending content hash to filenames: unicorn.css → unicorn-d41d8cd98f.css)\n\nhttps://github.com/sindresorhus/gulp-rev\n\n\n#### gulp-rev-collector插件\n\n文件变化之后修改时间戳（不会翻译）\n\n（Static asset revision data collector from manifests, generated from different streams, and replace their links in html template.）\n\nhttps://github.com/shonny-ua/gulp-rev-collector\n\n\n#### browser-sync插件\n\n浏览器实时更新(Keep multiple browsers & devices in sync when building websites.)\n\nhttps://github.com/browsersync/browser-sync\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"gulp","published":1,"updated":"2021-03-30T01:32:00.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7uff000ea0vz827gcd0h","content":"<p>Gulp是一个模块化打包工具。<br>Gulp本身只有几个入口，支持他拥有强大功能的是各种各样的插件。<br>Gulp的使用看起来非常简单，只需要一个一个任务链式执行就可以了，它还可以与Webpack结合起来使用<br>比如将Webpack作为一个插件来处理ES6转换为ES5的操作。<br>下面记录一下Gulp的API以及一些用到的插件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.src(globs[, options])</span><br></pre></td></tr></table></figure>\n<p>输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。</p>\n<p>globs：一种匹配文件的规则。</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.dest(path[, options])</span><br></pre></td></tr></table></figure>\n<p>能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。</p>\n<p>文件被写入的路径是以所给的相对路径根据所给的目标目录计算而来。类似的，相对路径也可以根据所给的 base 来计算。 请查看上述的 gulp.src 来了解更多信息。</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(name[, deps], fn)</span><br></pre></td></tr></table></figure>\n<p>定义一个使用 Orchestrator 实现的任务（task）</p>\n<p>Orchestrator: 一个执行并发任务的库。</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.watch(glob[, opts], tasks)</span><br></pre></td></tr></table></figure>\n<p>监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。</p>\n<p>glob：</p>\n<p>类型： String or Array</p>\n<p>一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。</p>\n<p>eg:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> watcher = gulp.watch(<span class=\"string\">&#x27;js/**/*.js&#x27;</span>, [<span class=\"string\">&#x27;uglify&#x27;</span>,<span class=\"string\">&#x27;reload&#x27;</span>]);</span><br><span class=\"line\">watcher.on(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;File &#x27;</span> + event.path + <span class=\"string\">&#x27; was &#x27;</span> + event.type + <span class=\"string\">&#x27;, running tasks...&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.watch(<span class=\"string\">&#x27;js/**/*.js&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;File &#x27;</span> + event.path + <span class=\"string\">&#x27; was &#x27;</span> + event.type + <span class=\"string\">&#x27;, running tasks...&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"相关链接：\"><a href=\"#相关链接：\" class=\"headerlink\" title=\"相关链接：\"></a>相关链接：</h3><p>中文网官网：</p>\n<p><a href=\"http://www.gulpjs.com.cn/docs/api/\">http://www.gulpjs.com.cn/docs/api/</a></p>\n<h4 id=\"gulp-babel插件：\"><a href=\"#gulp-babel插件：\" class=\"headerlink\" title=\"gulp-babel插件：\"></a>gulp-babel插件：</h4><p>gulp使用babel编译文件</p>\n<p><a href=\"https://github.com/babel/gulp-babel\">https://github.com/babel/gulp-babel</a></p>\n<h4 id=\"gulp-util插件\"><a href=\"#gulp-util插件\" class=\"headerlink\" title=\"gulp-util插件\"></a>gulp-util插件</h4><p>gulp插件的一些实用方法（Utility functions for gulp plugins）</p>\n<p><a href=\"https://github.com/gulpjs/gulp-util\">https://github.com/gulpjs/gulp-util</a></p>\n<h4 id=\"gulp-imagemin插件\"><a href=\"#gulp-imagemin插件\" class=\"headerlink\" title=\"gulp-imagemin插件\"></a>gulp-imagemin插件</h4><p>压缩png、jpeg、gif、svg图片用的压缩工具（Minify PNG, JPEG, GIF and SVG images with imagemin）</p>\n<p><a href=\"https://github.com/sindresorhus/gulp-imagemin\">https://github.com/sindresorhus/gulp-imagemin</a></p>\n<h4 id=\"gulp-clean插件\"><a href=\"#gulp-clean插件\" class=\"headerlink\" title=\"gulp-clean插件\"></a>gulp-clean插件</h4><p>用来移除文件或者文件夹的插件（A gulp plugin for removing files and folders from given paths.）</p>\n<p><a href=\"https://github.com/peter-vilja/gulp-clean\">https://github.com/peter-vilja/gulp-clean</a></p>\n<h4 id=\"gulp-sequence插件\"><a href=\"#gulp-sequence插件\" class=\"headerlink\" title=\"gulp-sequence插件\"></a>gulp-sequence插件</h4><p>执行一个连续的gulp任务（Run a series of gulp tasks in order.）</p>\n<p><a href=\"https://github.com/teambition/gulp-sequence\">https://github.com/teambition/gulp-sequence</a></p>\n<h4 id=\"gulp-spritesmith插件\"><a href=\"#gulp-spritesmith插件\" class=\"headerlink\" title=\"gulp.spritesmith插件\"></a>gulp.spritesmith插件</h4><p>合并图片（不会翻译）（Convert a set of images into a spritesheet and CSS variables via gulp）</p>\n<p><a href=\"https://github.com/twolfson/gulp.spritesmith\">https://github.com/twolfson/gulp.spritesmith</a></p>\n<h4 id=\"gulp-sourcemaps插件\"><a href=\"#gulp-sourcemaps插件\" class=\"headerlink\" title=\"gulp-sourcemaps插件\"></a>gulp-sourcemaps插件</h4><p>gulp sourcemap支持（Source map support for Gulp.js）</p>\n<p><a href=\"https://github.com/floridoo/gulp-sourcemaps\">https://github.com/floridoo/gulp-sourcemaps</a></p>\n<h4 id=\"gulp-concat插件\"><a href=\"#gulp-concat插件\" class=\"headerlink\" title=\"gulp-concat插件\"></a>gulp-concat插件</h4><p>合并文件流（Streaming concat middleware for gulp）</p>\n<p><a href=\"https://github.com/contra/gulp-concat\">https://github.com/contra/gulp-concat</a></p>\n<h4 id=\"gulp-autoprefixer-插件\"><a href=\"#gulp-autoprefixer-插件\" class=\"headerlink\" title=\"gulp-autoprefixer 插件\"></a>gulp-autoprefixer 插件</h4><p>给css加前缀（Prefix CSS）</p>\n<p><a href=\"https://github.com/sindresorhus/gulp-autoprefixer\">https://github.com/sindresorhus/gulp-autoprefixer</a></p>\n<h4 id=\"gulp-file-include插件\"><a href=\"#gulp-file-include插件\" class=\"headerlink\" title=\"gulp-file-include插件\"></a>gulp-file-include插件</h4><p>文件include合并支持（a gulp plugin for file include）</p>\n<p><a href=\"https://github.com/coderhaoxin/gulp-file-include\">https://github.com/coderhaoxin/gulp-file-include</a></p>\n<h4 id=\"gulp-rev插件\"><a href=\"#gulp-rev插件\" class=\"headerlink\" title=\"gulp-rev插件\"></a>gulp-rev插件</h4><p>静态资源加hash重命名<br>(Static asset revisioning by appending content hash to filenames: unicorn.css → unicorn-d41d8cd98f.css)</p>\n<p><a href=\"https://github.com/sindresorhus/gulp-rev\">https://github.com/sindresorhus/gulp-rev</a></p>\n<h4 id=\"gulp-rev-collector插件\"><a href=\"#gulp-rev-collector插件\" class=\"headerlink\" title=\"gulp-rev-collector插件\"></a>gulp-rev-collector插件</h4><p>文件变化之后修改时间戳（不会翻译）</p>\n<p>（Static asset revision data collector from manifests, generated from different streams, and replace their links in html template.）</p>\n<p><a href=\"https://github.com/shonny-ua/gulp-rev-collector\">https://github.com/shonny-ua/gulp-rev-collector</a></p>\n<h4 id=\"browser-sync插件\"><a href=\"#browser-sync插件\" class=\"headerlink\" title=\"browser-sync插件\"></a>browser-sync插件</h4><p>浏览器实时更新(Keep multiple browsers &amp; devices in sync when building websites.)</p>\n<p><a href=\"https://github.com/browsersync/browser-sync\">https://github.com/browsersync/browser-sync</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Gulp是一个模块化打包工具。<br>Gulp本身只有几个入口，支持他拥有强大功能的是各种各样的插件。<br>Gulp的使用看起来非常简单，只需要一个一个任务链式执行就可以了，它还可以与Webpack结合起来使用<br>比如将Webpack作为一个插件来处理ES6转换为ES5的操作。<br>下面记录一下Gulp的API以及一些用到的插件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.src(globs[, options])</span><br></pre></td></tr></table></figure>\n<p>输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。</p>\n<p>globs：一种匹配文件的规则。</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.dest(path[, options])</span><br></pre></td></tr></table></figure>\n<p>能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。</p>\n<p>文件被写入的路径是以所给的相对路径根据所给的目标目录计算而来。类似的，相对路径也可以根据所给的 base 来计算。 请查看上述的 gulp.src 来了解更多信息。</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(name[, deps], fn)</span><br></pre></td></tr></table></figure>\n<p>定义一个使用 Orchestrator 实现的任务（task）</p>\n<p>Orchestrator: 一个执行并发任务的库。</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.watch(glob[, opts], tasks)</span><br></pre></td></tr></table></figure>\n<p>监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。</p>\n<p>glob：</p>\n<p>类型： String or Array</p>\n<p>一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。</p>\n<p>eg:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> watcher = gulp.watch(<span class=\"string\">&#x27;js/**/*.js&#x27;</span>, [<span class=\"string\">&#x27;uglify&#x27;</span>,<span class=\"string\">&#x27;reload&#x27;</span>]);</span><br><span class=\"line\">watcher.on(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;File &#x27;</span> + event.path + <span class=\"string\">&#x27; was &#x27;</span> + event.type + <span class=\"string\">&#x27;, running tasks...&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.watch(<span class=\"string\">&#x27;js/**/*.js&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;File &#x27;</span> + event.path + <span class=\"string\">&#x27; was &#x27;</span> + event.type + <span class=\"string\">&#x27;, running tasks...&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"相关链接：\"><a href=\"#相关链接：\" class=\"headerlink\" title=\"相关链接：\"></a>相关链接：</h3><p>中文网官网：</p>\n<p><a href=\"http://www.gulpjs.com.cn/docs/api/\">http://www.gulpjs.com.cn/docs/api/</a></p>\n<h4 id=\"gulp-babel插件：\"><a href=\"#gulp-babel插件：\" class=\"headerlink\" title=\"gulp-babel插件：\"></a>gulp-babel插件：</h4><p>gulp使用babel编译文件</p>\n<p><a href=\"https://github.com/babel/gulp-babel\">https://github.com/babel/gulp-babel</a></p>\n<h4 id=\"gulp-util插件\"><a href=\"#gulp-util插件\" class=\"headerlink\" title=\"gulp-util插件\"></a>gulp-util插件</h4><p>gulp插件的一些实用方法（Utility functions for gulp plugins）</p>\n<p><a href=\"https://github.com/gulpjs/gulp-util\">https://github.com/gulpjs/gulp-util</a></p>\n<h4 id=\"gulp-imagemin插件\"><a href=\"#gulp-imagemin插件\" class=\"headerlink\" title=\"gulp-imagemin插件\"></a>gulp-imagemin插件</h4><p>压缩png、jpeg、gif、svg图片用的压缩工具（Minify PNG, JPEG, GIF and SVG images with imagemin）</p>\n<p><a href=\"https://github.com/sindresorhus/gulp-imagemin\">https://github.com/sindresorhus/gulp-imagemin</a></p>\n<h4 id=\"gulp-clean插件\"><a href=\"#gulp-clean插件\" class=\"headerlink\" title=\"gulp-clean插件\"></a>gulp-clean插件</h4><p>用来移除文件或者文件夹的插件（A gulp plugin for removing files and folders from given paths.）</p>\n<p><a href=\"https://github.com/peter-vilja/gulp-clean\">https://github.com/peter-vilja/gulp-clean</a></p>\n<h4 id=\"gulp-sequence插件\"><a href=\"#gulp-sequence插件\" class=\"headerlink\" title=\"gulp-sequence插件\"></a>gulp-sequence插件</h4><p>执行一个连续的gulp任务（Run a series of gulp tasks in order.）</p>\n<p><a href=\"https://github.com/teambition/gulp-sequence\">https://github.com/teambition/gulp-sequence</a></p>\n<h4 id=\"gulp-spritesmith插件\"><a href=\"#gulp-spritesmith插件\" class=\"headerlink\" title=\"gulp.spritesmith插件\"></a>gulp.spritesmith插件</h4><p>合并图片（不会翻译）（Convert a set of images into a spritesheet and CSS variables via gulp）</p>\n<p><a href=\"https://github.com/twolfson/gulp.spritesmith\">https://github.com/twolfson/gulp.spritesmith</a></p>\n<h4 id=\"gulp-sourcemaps插件\"><a href=\"#gulp-sourcemaps插件\" class=\"headerlink\" title=\"gulp-sourcemaps插件\"></a>gulp-sourcemaps插件</h4><p>gulp sourcemap支持（Source map support for Gulp.js）</p>\n<p><a href=\"https://github.com/floridoo/gulp-sourcemaps\">https://github.com/floridoo/gulp-sourcemaps</a></p>\n<h4 id=\"gulp-concat插件\"><a href=\"#gulp-concat插件\" class=\"headerlink\" title=\"gulp-concat插件\"></a>gulp-concat插件</h4><p>合并文件流（Streaming concat middleware for gulp）</p>\n<p><a href=\"https://github.com/contra/gulp-concat\">https://github.com/contra/gulp-concat</a></p>\n<h4 id=\"gulp-autoprefixer-插件\"><a href=\"#gulp-autoprefixer-插件\" class=\"headerlink\" title=\"gulp-autoprefixer 插件\"></a>gulp-autoprefixer 插件</h4><p>给css加前缀（Prefix CSS）</p>\n<p><a href=\"https://github.com/sindresorhus/gulp-autoprefixer\">https://github.com/sindresorhus/gulp-autoprefixer</a></p>\n<h4 id=\"gulp-file-include插件\"><a href=\"#gulp-file-include插件\" class=\"headerlink\" title=\"gulp-file-include插件\"></a>gulp-file-include插件</h4><p>文件include合并支持（a gulp plugin for file include）</p>\n<p><a href=\"https://github.com/coderhaoxin/gulp-file-include\">https://github.com/coderhaoxin/gulp-file-include</a></p>\n<h4 id=\"gulp-rev插件\"><a href=\"#gulp-rev插件\" class=\"headerlink\" title=\"gulp-rev插件\"></a>gulp-rev插件</h4><p>静态资源加hash重命名<br>(Static asset revisioning by appending content hash to filenames: unicorn.css → unicorn-d41d8cd98f.css)</p>\n<p><a href=\"https://github.com/sindresorhus/gulp-rev\">https://github.com/sindresorhus/gulp-rev</a></p>\n<h4 id=\"gulp-rev-collector插件\"><a href=\"#gulp-rev-collector插件\" class=\"headerlink\" title=\"gulp-rev-collector插件\"></a>gulp-rev-collector插件</h4><p>文件变化之后修改时间戳（不会翻译）</p>\n<p>（Static asset revision data collector from manifests, generated from different streams, and replace their links in html template.）</p>\n<p><a href=\"https://github.com/shonny-ua/gulp-rev-collector\">https://github.com/shonny-ua/gulp-rev-collector</a></p>\n<h4 id=\"browser-sync插件\"><a href=\"#browser-sync插件\" class=\"headerlink\" title=\"browser-sync插件\"></a>browser-sync插件</h4><p>浏览器实时更新(Keep multiple browsers &amp; devices in sync when building websites.)</p>\n<p><a href=\"https://github.com/browsersync/browser-sync\">https://github.com/browsersync/browser-sync</a></p>\n"},{"title":"Nginx防止别人的域名解析到自己的服务器上","date":"2017-02-22T16:00:00.000Z","_content":"\n今天早上打开百度统计，发现突然多了一些奇怪的入口页面，点进去全部是我的网站内容，当时我就懵逼了。\n看了下请求的页面地址的ip，发现是指向我的服务器的，还以为是中毒了，检查了下nginx配置和服务器登录信息，发现没有异常。后面经过google发现，原来是别人把自己的域名解析到了我的服务器上。他们这样做的目的是为了可以增加搜索引擎对他的域名的收录。\n虽然对自己的站点看似没什么影响，但是总感觉心里不爽，于是网上查了下资料，解决了此问题。\n\n### Top10入口页面\n入口页面\t| 浏览量(PV)\t| 占比\n-|-\nhttp://xxxxx1.com\t| 1 | 5.56%\nhttp://www.xxxxx2.com | 1 | 5.56%\nhttp://www.xxxxx3.com | 1 | 5.56%\nhttp://www.xxxxx4.com | 1 | 5.56%\nhttp://xxxxx5.com | 1 | 5.56%\nhttp://xxxxx6.com | 1 | 5.56%\nhttp://xxxxx7.com | 1\t| 5.56%\nhttp://www.xxxxx8.com\t| 1\t|5.56%\nhttp://www.xxxxx9.com | 1 | 5.56%\nhttp://www.xxxxx10.com\t| 1\t| 5.56%\n||\n\n### 解决办法\n将nginx的默认配置修改一下，将其指向500或者直接rewrite到自己的网站。\n\n``` shell\nserver {  \n  listen 80 default;  \n  return 500;  \n}\n```\n当然也可以写成这样，跳转到自己的网站\n\n``` shell\nserver {\n  listen 80 default;  \n  rewrite ^(.*) https://www.epoos.com;\n}  \n```\n\n还可以粗暴一点，直接返回404，并关闭到accesslog日志\n\n``` shel\nserver {\n  listen 80 default;\n  location / {\n    return 404;\n    access_log off;\n  }\n}\n```","source":"_posts/host-ip.md","raw":"---\ntitle: Nginx防止别人的域名解析到自己的服务器上\ndate: 2017/02/23\ntag: nginx\ncategory: 技术\n---\n\n今天早上打开百度统计，发现突然多了一些奇怪的入口页面，点进去全部是我的网站内容，当时我就懵逼了。\n看了下请求的页面地址的ip，发现是指向我的服务器的，还以为是中毒了，检查了下nginx配置和服务器登录信息，发现没有异常。后面经过google发现，原来是别人把自己的域名解析到了我的服务器上。他们这样做的目的是为了可以增加搜索引擎对他的域名的收录。\n虽然对自己的站点看似没什么影响，但是总感觉心里不爽，于是网上查了下资料，解决了此问题。\n\n### Top10入口页面\n入口页面\t| 浏览量(PV)\t| 占比\n-|-\nhttp://xxxxx1.com\t| 1 | 5.56%\nhttp://www.xxxxx2.com | 1 | 5.56%\nhttp://www.xxxxx3.com | 1 | 5.56%\nhttp://www.xxxxx4.com | 1 | 5.56%\nhttp://xxxxx5.com | 1 | 5.56%\nhttp://xxxxx6.com | 1 | 5.56%\nhttp://xxxxx7.com | 1\t| 5.56%\nhttp://www.xxxxx8.com\t| 1\t|5.56%\nhttp://www.xxxxx9.com | 1 | 5.56%\nhttp://www.xxxxx10.com\t| 1\t| 5.56%\n||\n\n### 解决办法\n将nginx的默认配置修改一下，将其指向500或者直接rewrite到自己的网站。\n\n``` shell\nserver {  \n  listen 80 default;  \n  return 500;  \n}\n```\n当然也可以写成这样，跳转到自己的网站\n\n``` shell\nserver {\n  listen 80 default;  \n  rewrite ^(.*) https://www.epoos.com;\n}  \n```\n\n还可以粗暴一点，直接返回404，并关闭到accesslog日志\n\n``` shel\nserver {\n  listen 80 default;\n  location / {\n    return 404;\n    access_log off;\n  }\n}\n```","slug":"host-ip","published":1,"updated":"2021-03-30T01:32:00.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufg000fa0vzgkufbx20","content":"<p>今天早上打开百度统计，发现突然多了一些奇怪的入口页面，点进去全部是我的网站内容，当时我就懵逼了。<br>看了下请求的页面地址的ip，发现是指向我的服务器的，还以为是中毒了，检查了下nginx配置和服务器登录信息，发现没有异常。后面经过google发现，原来是别人把自己的域名解析到了我的服务器上。他们这样做的目的是为了可以增加搜索引擎对他的域名的收录。<br>虽然对自己的站点看似没什么影响，但是总感觉心里不爽，于是网上查了下资料，解决了此问题。</p>\n<h3 id=\"Top10入口页面\"><a href=\"#Top10入口页面\" class=\"headerlink\" title=\"Top10入口页面\"></a>Top10入口页面</h3><table>\n<thead>\n<tr>\n<th>入口页面</th>\n<th>浏览量(PV)</th>\n<th>占比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://xxxxx1.com\">http://xxxxx1.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://www.xxxxx2.com\">http://www.xxxxx2.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://www.xxxxx3.com\">http://www.xxxxx3.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://www.xxxxx4.com\">http://www.xxxxx4.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://xxxxx5.com\">http://xxxxx5.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://xxxxx6.com\">http://xxxxx6.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://xxxxx7.com\">http://xxxxx7.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://www.xxxxx8.com\">http://www.xxxxx8.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://www.xxxxx9.com\">http://www.xxxxx9.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://www.xxxxx10.com\">http://www.xxxxx10.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>将nginx的默认配置修改一下，将其指向500或者直接rewrite到自己的网站。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;  </span><br><span class=\"line\">  listen 80 default;  </span><br><span class=\"line\">  return 500;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然也可以写成这样，跳转到自己的网站</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">  listen 80 default;  </span><br><span class=\"line\">  rewrite ^(.*) https://www.epoos.com;</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>还可以粗暴一点，直接返回404，并关闭到accesslog日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">  listen 80 default;</span><br><span class=\"line\">  location &#x2F; &#123;</span><br><span class=\"line\">    return 404;</span><br><span class=\"line\">    access_log off;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>今天早上打开百度统计，发现突然多了一些奇怪的入口页面，点进去全部是我的网站内容，当时我就懵逼了。<br>看了下请求的页面地址的ip，发现是指向我的服务器的，还以为是中毒了，检查了下nginx配置和服务器登录信息，发现没有异常。后面经过google发现，原来是别人把自己的域名解析到了我的服务器上。他们这样做的目的是为了可以增加搜索引擎对他的域名的收录。<br>虽然对自己的站点看似没什么影响，但是总感觉心里不爽，于是网上查了下资料，解决了此问题。</p>\n<h3 id=\"Top10入口页面\"><a href=\"#Top10入口页面\" class=\"headerlink\" title=\"Top10入口页面\"></a>Top10入口页面</h3><table>\n<thead>\n<tr>\n<th>入口页面</th>\n<th>浏览量(PV)</th>\n<th>占比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://xxxxx1.com\">http://xxxxx1.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://www.xxxxx2.com\">http://www.xxxxx2.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://www.xxxxx3.com\">http://www.xxxxx3.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://www.xxxxx4.com\">http://www.xxxxx4.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://xxxxx5.com\">http://xxxxx5.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://xxxxx6.com\">http://xxxxx6.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://xxxxx7.com\">http://xxxxx7.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://www.xxxxx8.com\">http://www.xxxxx8.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://www.xxxxx9.com\">http://www.xxxxx9.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td><a href=\"http://www.xxxxx10.com\">http://www.xxxxx10.com</a></td>\n<td>1</td>\n<td>5.56%</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>将nginx的默认配置修改一下，将其指向500或者直接rewrite到自己的网站。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;  </span><br><span class=\"line\">  listen 80 default;  </span><br><span class=\"line\">  return 500;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然也可以写成这样，跳转到自己的网站</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">  listen 80 default;  </span><br><span class=\"line\">  rewrite ^(.*) https://www.epoos.com;</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>还可以粗暴一点，直接返回404，并关闭到accesslog日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">  listen 80 default;</span><br><span class=\"line\">  location &#x2F; &#123;</span><br><span class=\"line\">    return 404;</span><br><span class=\"line\">    access_log off;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"http的请求头基础","date":"2021-01-11T16:00:00.000Z","_content":"\n### 互联网媒体类型\n互联网媒体类型（Internet media type，也称为MIME类型（MIME type）或内容类型（content type））\n是给互联网上传输的内容赋予的分类类型。互联网媒体类型与文件拓展名相对应。\n\n一个MIME类型一定包括 ***类型（type）***和 ***子类型（subtype）***\n还可能包括一个或多个 ***可选参数（optional parameter）***。\n\n比如，HTML文件的互联网媒体类型可能是\n```html\ntext/html; charset=UTF-8\n```\n上面例子，文件类型为text，子类型为html，charset是一个可选参数，其值为UTF-8\n\n#### Content-Type（内容类型）\n实体头部用于指示资源的MIME类型，一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件\n这就是为什么发起请求的时候，有的是请求图片，有的是请求网页，有的是下载文件的原因了。\n\n#### request 里面的 Content-Type \n用于表明发送数据流的类型，服务端根据此类型来采用该类型文件的解析方式来解析数据\n\n\n#### 使用 post 方式提交数据的时候指定的几种 body 类型。\n这是将发送信息至服务器时内容的编码类型。服务端根据这些类型来判断使用哪种方式解析数据。\n\n值 | 描述\n--|--\napplication/x-www-form-urlencoded | 原生的 form 表单的提交的默认数据格式，Body 中的数据以'key1=value1&key2=value2'的文本格式传输；如果是使用 ajax提交，则需要手动格式化body的内容。\nmultipart/form-data | Http协议最开始是不支持文件上传的，直到1995年发布的规范新增这个contentType类型，multipart单词是多部分的意思，这意味着body中的数据允许由多部分组成，可以同时传入二进制和文本；将表单的数据组织成Key-Value形式，用分隔符 boundary（boundary可任意设置）处理成一条消息。可同时上传文件和参数。 \napplication/json | body内容是 json 格式的文本\ntext/plain | body 的内容就只是文本，空格转换为 \"+\" 加号，但不对特殊字符编码。\n\n#### form-data 举例\n```html\n<form action='xxx' method='post' enctype='multipart/form-data'>\n  <input type='text' name='user_name' value='user_name_str'/>\n  <input type='file' name='file_name' />\n  <button type='submit'>提交</button>\n</form>\n```\n下面的使用jquery post 提交方式和上面是等效的\n```javascript\n$.ajax({\n  url: 'xxx',\n  type: 'POST',\n  contentType: 'multipart/form-data', // jquery ajax 默认为 x-www-form-urllencoded\n  success: function() {}\n})\n```\n#### response 里面的 Content-Type\nHttp响应也会带Content-Type，原理和请求的一致，目的是告诉客户端实际返回的内容的内容类型，让接收方知道怎么解析数据。\n\n\n#### 常见媒体格式（维基百科）\n\n##### Type application\n值 | 描述\n--|--\napplication/atom+xml | Atom feeds\napplication/ecmascript | ECMAScript/JavaScript;[4]（相当于application/javascript但是严格的处理规则）\napplication/EDI-X12 | EDI ANSI ASC X12资料[5]\napplication/EDIFACT | EDI EDIFACT资料[5]\napplication/json | JSON（JavaScript Object Notation）[6]\napplication/javascript | JavaScript。\napplication/octet-stream | 任意的二进制文件（通常做为通知浏览器下载文件\napplication/ogg | Ogg, 视频文件格式[9]\napplication/pdf | PDF（Portable Document Format）[10]\napplication/postscript | PostScript[7]\napplication/rdf+xml | Resource Description Framework[11]\napplication/rss+xml | RSS feeds\napplication/soap+xml | SOAP[12]\napplication/font-woff | Web Open Font Format;（推荐使用；使用application/x-font-woff直到它变为官方标准）\napplication/xhtml+xml | XHTML[13]\napplication/xml | XML文件[14]\napplication/xml-dtd | DTD文件[14]\napplication/xop+xml | XML-binary Optimized Packaging[15]\napplication/zip | ZIP压缩包[16]\napplication/gzip | Gzip[17]\n\n##### Type Audio\n值 | 描述\n--|--\naudio/mp4 | MP4音频档案[18]\naudio/mpeg | MP3或其他MPEG音频档案[19]\naudio/ogg | Ogg音频档案[9]\naudio/vorbis | Vorbis音频档案[20]\naudio/vnd.rn-realaudio | RealAudio音频档案[21]\naudio/vnd.wave | WAV音频档案[22]\naudio/webm | WebM音频档案\naudio/flac | FLAC音频档案\n\n##### Type Image\n值 | 描述\n--|--\nimage/gif | GIF图像文件[23]\nimage/jpeg | JPEG图像文件[23]\nimage/png | PNG图像文件[24]\nimage/webp | WebP图像文件\nimage/svg+xml | SVG向量图像文件[25]\nimage/tiff | TIFF图像文件[26]\nimage/icon | ICO图片文件。\n\n##### Type Text\n值 | 描述\n--|--\ntext/css | CSS文件[29]\ntext/csv | CSV文件[30]\ntext/html | HTML文件[31]\ntext/javascript | (过时)，推荐使用 application/javascript。\ntext/plain | 纯文字内容[32]\ntext/vcard | vCard（电子名片）[33]\ntext/xml | XML[14]\n\n##### Type Video\n值 | 描述\n--|--\nvideo/mpeg | MPEG-1视频文件[34]\nvideo/mp4 | MP4视频文件[35]\nvideo/ogg | Ogg视频文件[9]\nvideo/quicktime | QuickTime视频文件[36]\nvideo/webm | WebM视频文件（基于Matroska基础）\nvideo/x-matroska | Matroska（多媒体封装格式）\nvideo/x-ms-wmv | Windows Media Video视频文件[37]\nvideo/x-flv | Flash Video（FLV档）\n\n##### Type Model(三维计算机图形文件)\n值 | 描述\n--|--\nmodel/example[27] | Example Media Types for Use in Documentation\nmodel/iges | IGS files, IGES files[28]\nmodel/mesh | MSH files, MESH files[28]\nmodel/vrml | WRL files, VRML files[28]\nmodel/x3d+binary | X3D ISO standard for representing 3D computer graphics, X3DB binary files\nmodel/x3d+vrml | X3D ISO standard for representing 3D computer graphics, X3DV VRML files\nmodel/x3d+xml | X3D ISO standard for representing 3D computer graphics, X3D XML files\n\n#### Request Headers的候选属性\n属性值 | 描述 | 示例\n--|--|--\nAccept | 指定客户端能够接收的内容类型 | Accept: text/plain, text/html\nAccept-Charset | 请求头用来告知（服务器）客户端可以处理的字符集类型。 | Accept-Charset: utf-8, iso-8859-1;q=0.5, *;q=0.1\nAccept-Encoding | 指定浏览器可以支持的web服务器返回内容压缩编码类型 | Accept-Encoding: compress, gzip, deflate\nAccept-Language | 浏览器可接受的语言 | Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7\nAccept-Ranges | 请求资源的某一段数据 | Accept-Ranges: bytes=0-1023\nAuthorization | 请求消息首部包含有用来向（代理）服务器证明用户代理身份的凭证。 | Authorization: Basic QWxhZLRpbjpvcGVuIHNoc2FtZQ==\nCache-Control | 指定请求和响应遵循的缓存机制 | Cache-Control: no-cache(或者 max-age=100)\nConnection | 决定当前的事务完成后，是否会关闭网络连接 | Connection: keep-alive\nCookie | HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器 | Cookie: $Version=1; Skin=new;\nContent-Length | 请求的内容长度 | Content-Length: 348\nContent-Type | 请求的与实体对应的MIME信息 | Content-Type: application/x-www-form-urlencoded\nDate | 请求发送的日期和时间 | Date: Tue, 15 Nov 2018 08:22:31 GMT\nExpect | 包含一个期望条件，表示服务器只有在满足此期望条件的情况下才能妥善地处理请求 | Expect: 100-continue\nFrom | 发出请求的用户的Email | From: user@email.com\nHost | 指定请求的服务器的域名和端口号 | Host: www.yanggb.com\nIf-Match | 只有请求内容与实体相匹配才有效 | If-Match: \"737060ff8c284d8af7ad2082f209582d\"\nIf-Modified-Since | 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 | If-Modified-Since: Sat, 29 Oct 2018 19:43:31 GMT\nIf-None-Match | 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 | If-None-Match: \"737060cd8c284d8af7ad3082f209582d\"\nIf-Range | 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag | If-Range: \"737060cd8c284d8af7ad3082f209582d\"\nIf-Unmodified-Since | 只在实体在指定时间之后未被修改才请求成功 | If-Unmodified-Since: Sat, 29 Oct 2018 19:23:11 GMT\nMax-Forwards | 限制信息通过代理和网关传送的时间 | Max-Forwards: 10\nPragma | 用来包含实现特定的指令 | Pragma: no-cache\nProxy-Authorization | 连接到代理的授权证书 | Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\nRange | 只请求实体的一部分，指定范围 | Range: bytes=500-999\nReferer | 先前网页的地址，当前请求网页紧随其后，即来路 | Referer: http://www.yanggb.com/yanggb1.html\nTE | 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 | TE: trailers,deflate;q=0.5\nUpgrade | 向服务器指定某种传输协议以便服务器进行转换（如果支持） | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\nUser-Agent | User-Agent的内容包含发出请求的用户信息 | User-Agent: Mozilla/5.0 (Linux; X11)\nVia | 通知中间网关或代理服务器地址，通信协议 | Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\nWarning | 关于消息实体的警告信息 | Warn: 199 Miscellaneous warning\n\n\n#### Response Headers的候选属性\n候选属性 | 说明 | 示例\n--|--|--\nAccept-Ranges | 表明服务器是否支持指定范围请求及哪种类型的分段请求 | Accept-Ranges: bytes\nAge | 从原始服务器到代理缓存形成的估算时间（以秒计，非负） | Age: 12\nAllow | 对某网络资源的有效的请求行为，不允许则返回405 | Allow: GET, HEAD\nAccess-Control-Allow-Credentials | 表示是否可以将对请求的响应暴露给页面，常用作跨域 | Access-Control-Allow-Credentials: true\nAccess-Control-Allow-Origin | 表示请求的许可域名 | Access-Control-Allow-Origin: https://www.163.com\nAccess-Control-Allow-Methods | 预检请求应答中明确客户端所要访问的资源允许使用的方法(列表)。 | Access-Control-Allow-Methods: POST, OPTIONS\nCache-Control | 告诉所有的缓存机制是否可以缓存及哪种类型 | Cache-Control: no-cache\nContent-Encoding | web服务器支持的返回内容压缩编码类型 | Content-Encoding: gzip\nContent-Language | 响应体的语言 | Content-Language: en,zh\nContent-Length | 响应体的长度 | Content-Length: 348\nContent-Location | 请求资源可替代的备用的另一地址 | Content-Location: /index.htm\nContent-MD5 | 返回资源的MD5校验值 | Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==\nContent-Range | 在整个返回体中本部分的字节位置 | Content-Range: bytes 21010-47021/47022\nContent-Type | 返回内容的MIME类型 | Content-Type: text/html; charset=utf-8\nDate | 原始服务器消息发出的时间 | Date: Tue, 15 Nov 2018 08:22:22 GMT\nETag | 请求变量的实体标签的当前值 | ETag: \"737060cd8c284d8af7ad3082f209582d\"\nExpires | 响应过期的日期和时间 | Expires: Thu, 01 Dec 2018 16:00:00 GMT\nLast-Modified | 请求资源的最后修改时间 | Last-Modified: Tue, 15 Nov 2018 12:25:26 GMT\nLocation | 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 | Location: http://www.yanggb.com/yanggb2.html\nPragma | 包括实现特定的指令，它可应用到响应链上的任何接收方 | Pragma: no-cache\nProxy-Authenticate | 它指出认证方案和可应用到代理的该URL上的参数 | Proxy-Authenticate: Basic\nrefresh | 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） | Refresh: 5; url=http://www.yanggb.com/yanggb9.html\nRetry-After | 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 | Retry-After: 120\nServer | web服务器软件名称 | Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)\nSet-Cookie | 设置Http Cookie | Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1\nTrailer | 指出头域在分块传输编码的尾部存在 | Trailer: Max-Forwards\nTransfer-Encoding | 文件传输编码 | Transfer-Encoding:chunked\nVary | 告诉下游代理是使用缓存响应还是从原始服务器请求 | Vary: *\nVia | 告知代理客户端响应是通过哪里发送的 | Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\nWarning | 警告实体可能存在的问题 | Warning: 199 Miscellaneous warning\nWWW-Authenticate | 表明客户端请求实体应该使用的授权方案 | WWW-Authenticate: Basic\n\n### 传送门\n[互联网媒体类型](https://zh.wikipedia.org/wiki/互联网媒体类型)\n\n\n\n\n\n\n\n","source":"_posts/http-headers.md","raw":"---\ntitle: http的请求头基础\ndate: 2021/01/12\ntag: [MIMETYPE,CONTENTTYPE,请求头]\ncategory: 笔记\n---\n\n### 互联网媒体类型\n互联网媒体类型（Internet media type，也称为MIME类型（MIME type）或内容类型（content type））\n是给互联网上传输的内容赋予的分类类型。互联网媒体类型与文件拓展名相对应。\n\n一个MIME类型一定包括 ***类型（type）***和 ***子类型（subtype）***\n还可能包括一个或多个 ***可选参数（optional parameter）***。\n\n比如，HTML文件的互联网媒体类型可能是\n```html\ntext/html; charset=UTF-8\n```\n上面例子，文件类型为text，子类型为html，charset是一个可选参数，其值为UTF-8\n\n#### Content-Type（内容类型）\n实体头部用于指示资源的MIME类型，一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件\n这就是为什么发起请求的时候，有的是请求图片，有的是请求网页，有的是下载文件的原因了。\n\n#### request 里面的 Content-Type \n用于表明发送数据流的类型，服务端根据此类型来采用该类型文件的解析方式来解析数据\n\n\n#### 使用 post 方式提交数据的时候指定的几种 body 类型。\n这是将发送信息至服务器时内容的编码类型。服务端根据这些类型来判断使用哪种方式解析数据。\n\n值 | 描述\n--|--\napplication/x-www-form-urlencoded | 原生的 form 表单的提交的默认数据格式，Body 中的数据以'key1=value1&key2=value2'的文本格式传输；如果是使用 ajax提交，则需要手动格式化body的内容。\nmultipart/form-data | Http协议最开始是不支持文件上传的，直到1995年发布的规范新增这个contentType类型，multipart单词是多部分的意思，这意味着body中的数据允许由多部分组成，可以同时传入二进制和文本；将表单的数据组织成Key-Value形式，用分隔符 boundary（boundary可任意设置）处理成一条消息。可同时上传文件和参数。 \napplication/json | body内容是 json 格式的文本\ntext/plain | body 的内容就只是文本，空格转换为 \"+\" 加号，但不对特殊字符编码。\n\n#### form-data 举例\n```html\n<form action='xxx' method='post' enctype='multipart/form-data'>\n  <input type='text' name='user_name' value='user_name_str'/>\n  <input type='file' name='file_name' />\n  <button type='submit'>提交</button>\n</form>\n```\n下面的使用jquery post 提交方式和上面是等效的\n```javascript\n$.ajax({\n  url: 'xxx',\n  type: 'POST',\n  contentType: 'multipart/form-data', // jquery ajax 默认为 x-www-form-urllencoded\n  success: function() {}\n})\n```\n#### response 里面的 Content-Type\nHttp响应也会带Content-Type，原理和请求的一致，目的是告诉客户端实际返回的内容的内容类型，让接收方知道怎么解析数据。\n\n\n#### 常见媒体格式（维基百科）\n\n##### Type application\n值 | 描述\n--|--\napplication/atom+xml | Atom feeds\napplication/ecmascript | ECMAScript/JavaScript;[4]（相当于application/javascript但是严格的处理规则）\napplication/EDI-X12 | EDI ANSI ASC X12资料[5]\napplication/EDIFACT | EDI EDIFACT资料[5]\napplication/json | JSON（JavaScript Object Notation）[6]\napplication/javascript | JavaScript。\napplication/octet-stream | 任意的二进制文件（通常做为通知浏览器下载文件\napplication/ogg | Ogg, 视频文件格式[9]\napplication/pdf | PDF（Portable Document Format）[10]\napplication/postscript | PostScript[7]\napplication/rdf+xml | Resource Description Framework[11]\napplication/rss+xml | RSS feeds\napplication/soap+xml | SOAP[12]\napplication/font-woff | Web Open Font Format;（推荐使用；使用application/x-font-woff直到它变为官方标准）\napplication/xhtml+xml | XHTML[13]\napplication/xml | XML文件[14]\napplication/xml-dtd | DTD文件[14]\napplication/xop+xml | XML-binary Optimized Packaging[15]\napplication/zip | ZIP压缩包[16]\napplication/gzip | Gzip[17]\n\n##### Type Audio\n值 | 描述\n--|--\naudio/mp4 | MP4音频档案[18]\naudio/mpeg | MP3或其他MPEG音频档案[19]\naudio/ogg | Ogg音频档案[9]\naudio/vorbis | Vorbis音频档案[20]\naudio/vnd.rn-realaudio | RealAudio音频档案[21]\naudio/vnd.wave | WAV音频档案[22]\naudio/webm | WebM音频档案\naudio/flac | FLAC音频档案\n\n##### Type Image\n值 | 描述\n--|--\nimage/gif | GIF图像文件[23]\nimage/jpeg | JPEG图像文件[23]\nimage/png | PNG图像文件[24]\nimage/webp | WebP图像文件\nimage/svg+xml | SVG向量图像文件[25]\nimage/tiff | TIFF图像文件[26]\nimage/icon | ICO图片文件。\n\n##### Type Text\n值 | 描述\n--|--\ntext/css | CSS文件[29]\ntext/csv | CSV文件[30]\ntext/html | HTML文件[31]\ntext/javascript | (过时)，推荐使用 application/javascript。\ntext/plain | 纯文字内容[32]\ntext/vcard | vCard（电子名片）[33]\ntext/xml | XML[14]\n\n##### Type Video\n值 | 描述\n--|--\nvideo/mpeg | MPEG-1视频文件[34]\nvideo/mp4 | MP4视频文件[35]\nvideo/ogg | Ogg视频文件[9]\nvideo/quicktime | QuickTime视频文件[36]\nvideo/webm | WebM视频文件（基于Matroska基础）\nvideo/x-matroska | Matroska（多媒体封装格式）\nvideo/x-ms-wmv | Windows Media Video视频文件[37]\nvideo/x-flv | Flash Video（FLV档）\n\n##### Type Model(三维计算机图形文件)\n值 | 描述\n--|--\nmodel/example[27] | Example Media Types for Use in Documentation\nmodel/iges | IGS files, IGES files[28]\nmodel/mesh | MSH files, MESH files[28]\nmodel/vrml | WRL files, VRML files[28]\nmodel/x3d+binary | X3D ISO standard for representing 3D computer graphics, X3DB binary files\nmodel/x3d+vrml | X3D ISO standard for representing 3D computer graphics, X3DV VRML files\nmodel/x3d+xml | X3D ISO standard for representing 3D computer graphics, X3D XML files\n\n#### Request Headers的候选属性\n属性值 | 描述 | 示例\n--|--|--\nAccept | 指定客户端能够接收的内容类型 | Accept: text/plain, text/html\nAccept-Charset | 请求头用来告知（服务器）客户端可以处理的字符集类型。 | Accept-Charset: utf-8, iso-8859-1;q=0.5, *;q=0.1\nAccept-Encoding | 指定浏览器可以支持的web服务器返回内容压缩编码类型 | Accept-Encoding: compress, gzip, deflate\nAccept-Language | 浏览器可接受的语言 | Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7\nAccept-Ranges | 请求资源的某一段数据 | Accept-Ranges: bytes=0-1023\nAuthorization | 请求消息首部包含有用来向（代理）服务器证明用户代理身份的凭证。 | Authorization: Basic QWxhZLRpbjpvcGVuIHNoc2FtZQ==\nCache-Control | 指定请求和响应遵循的缓存机制 | Cache-Control: no-cache(或者 max-age=100)\nConnection | 决定当前的事务完成后，是否会关闭网络连接 | Connection: keep-alive\nCookie | HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器 | Cookie: $Version=1; Skin=new;\nContent-Length | 请求的内容长度 | Content-Length: 348\nContent-Type | 请求的与实体对应的MIME信息 | Content-Type: application/x-www-form-urlencoded\nDate | 请求发送的日期和时间 | Date: Tue, 15 Nov 2018 08:22:31 GMT\nExpect | 包含一个期望条件，表示服务器只有在满足此期望条件的情况下才能妥善地处理请求 | Expect: 100-continue\nFrom | 发出请求的用户的Email | From: user@email.com\nHost | 指定请求的服务器的域名和端口号 | Host: www.yanggb.com\nIf-Match | 只有请求内容与实体相匹配才有效 | If-Match: \"737060ff8c284d8af7ad2082f209582d\"\nIf-Modified-Since | 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 | If-Modified-Since: Sat, 29 Oct 2018 19:43:31 GMT\nIf-None-Match | 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 | If-None-Match: \"737060cd8c284d8af7ad3082f209582d\"\nIf-Range | 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag | If-Range: \"737060cd8c284d8af7ad3082f209582d\"\nIf-Unmodified-Since | 只在实体在指定时间之后未被修改才请求成功 | If-Unmodified-Since: Sat, 29 Oct 2018 19:23:11 GMT\nMax-Forwards | 限制信息通过代理和网关传送的时间 | Max-Forwards: 10\nPragma | 用来包含实现特定的指令 | Pragma: no-cache\nProxy-Authorization | 连接到代理的授权证书 | Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\nRange | 只请求实体的一部分，指定范围 | Range: bytes=500-999\nReferer | 先前网页的地址，当前请求网页紧随其后，即来路 | Referer: http://www.yanggb.com/yanggb1.html\nTE | 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 | TE: trailers,deflate;q=0.5\nUpgrade | 向服务器指定某种传输协议以便服务器进行转换（如果支持） | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\nUser-Agent | User-Agent的内容包含发出请求的用户信息 | User-Agent: Mozilla/5.0 (Linux; X11)\nVia | 通知中间网关或代理服务器地址，通信协议 | Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\nWarning | 关于消息实体的警告信息 | Warn: 199 Miscellaneous warning\n\n\n#### Response Headers的候选属性\n候选属性 | 说明 | 示例\n--|--|--\nAccept-Ranges | 表明服务器是否支持指定范围请求及哪种类型的分段请求 | Accept-Ranges: bytes\nAge | 从原始服务器到代理缓存形成的估算时间（以秒计，非负） | Age: 12\nAllow | 对某网络资源的有效的请求行为，不允许则返回405 | Allow: GET, HEAD\nAccess-Control-Allow-Credentials | 表示是否可以将对请求的响应暴露给页面，常用作跨域 | Access-Control-Allow-Credentials: true\nAccess-Control-Allow-Origin | 表示请求的许可域名 | Access-Control-Allow-Origin: https://www.163.com\nAccess-Control-Allow-Methods | 预检请求应答中明确客户端所要访问的资源允许使用的方法(列表)。 | Access-Control-Allow-Methods: POST, OPTIONS\nCache-Control | 告诉所有的缓存机制是否可以缓存及哪种类型 | Cache-Control: no-cache\nContent-Encoding | web服务器支持的返回内容压缩编码类型 | Content-Encoding: gzip\nContent-Language | 响应体的语言 | Content-Language: en,zh\nContent-Length | 响应体的长度 | Content-Length: 348\nContent-Location | 请求资源可替代的备用的另一地址 | Content-Location: /index.htm\nContent-MD5 | 返回资源的MD5校验值 | Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==\nContent-Range | 在整个返回体中本部分的字节位置 | Content-Range: bytes 21010-47021/47022\nContent-Type | 返回内容的MIME类型 | Content-Type: text/html; charset=utf-8\nDate | 原始服务器消息发出的时间 | Date: Tue, 15 Nov 2018 08:22:22 GMT\nETag | 请求变量的实体标签的当前值 | ETag: \"737060cd8c284d8af7ad3082f209582d\"\nExpires | 响应过期的日期和时间 | Expires: Thu, 01 Dec 2018 16:00:00 GMT\nLast-Modified | 请求资源的最后修改时间 | Last-Modified: Tue, 15 Nov 2018 12:25:26 GMT\nLocation | 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 | Location: http://www.yanggb.com/yanggb2.html\nPragma | 包括实现特定的指令，它可应用到响应链上的任何接收方 | Pragma: no-cache\nProxy-Authenticate | 它指出认证方案和可应用到代理的该URL上的参数 | Proxy-Authenticate: Basic\nrefresh | 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） | Refresh: 5; url=http://www.yanggb.com/yanggb9.html\nRetry-After | 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 | Retry-After: 120\nServer | web服务器软件名称 | Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)\nSet-Cookie | 设置Http Cookie | Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1\nTrailer | 指出头域在分块传输编码的尾部存在 | Trailer: Max-Forwards\nTransfer-Encoding | 文件传输编码 | Transfer-Encoding:chunked\nVary | 告诉下游代理是使用缓存响应还是从原始服务器请求 | Vary: *\nVia | 告知代理客户端响应是通过哪里发送的 | Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\nWarning | 警告实体可能存在的问题 | Warning: 199 Miscellaneous warning\nWWW-Authenticate | 表明客户端请求实体应该使用的授权方案 | WWW-Authenticate: Basic\n\n### 传送门\n[互联网媒体类型](https://zh.wikipedia.org/wiki/互联网媒体类型)\n\n\n\n\n\n\n\n","slug":"http-headers","published":1,"updated":"2021-03-30T01:32:00.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufh000ga0vz9x8v4pno","content":"<h3 id=\"互联网媒体类型\"><a href=\"#互联网媒体类型\" class=\"headerlink\" title=\"互联网媒体类型\"></a>互联网媒体类型</h3><p>互联网媒体类型（Internet media type，也称为MIME类型（MIME type）或内容类型（content type））<br>是给互联网上传输的内容赋予的分类类型。互联网媒体类型与文件拓展名相对应。</p>\n<p>一个MIME类型一定包括 <strong><em>类型（type）</em></strong>和 <strong><em>子类型（subtype）</em></strong><br>还可能包括一个或多个 <strong><em>可选参数（optional parameter）</em></strong>。</p>\n<p>比如，HTML文件的互联网媒体类型可能是<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><br>上面例子，文件类型为text，子类型为html，charset是一个可选参数，其值为UTF-8</p>\n<h4 id=\"Content-Type（内容类型）\"><a href=\"#Content-Type（内容类型）\" class=\"headerlink\" title=\"Content-Type（内容类型）\"></a>Content-Type（内容类型）</h4><p>实体头部用于指示资源的MIME类型，一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件<br>这就是为什么发起请求的时候，有的是请求图片，有的是请求网页，有的是下载文件的原因了。</p>\n<h4 id=\"request-里面的-Content-Type\"><a href=\"#request-里面的-Content-Type\" class=\"headerlink\" title=\"request 里面的 Content-Type\"></a>request 里面的 Content-Type</h4><p>用于表明发送数据流的类型，服务端根据此类型来采用该类型文件的解析方式来解析数据</p>\n<h4 id=\"使用-post-方式提交数据的时候指定的几种-body-类型。\"><a href=\"#使用-post-方式提交数据的时候指定的几种-body-类型。\" class=\"headerlink\" title=\"使用 post 方式提交数据的时候指定的几种 body 类型。\"></a>使用 post 方式提交数据的时候指定的几种 body 类型。</h4><p>这是将发送信息至服务器时内容的编码类型。服务端根据这些类型来判断使用哪种方式解析数据。</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>application/x-www-form-urlencoded</td>\n<td>原生的 form 表单的提交的默认数据格式，Body 中的数据以’key1=value1&amp;key2=value2’的文本格式传输；如果是使用 ajax提交，则需要手动格式化body的内容。</td>\n</tr>\n<tr>\n<td>multipart/form-data</td>\n<td>Http协议最开始是不支持文件上传的，直到1995年发布的规范新增这个contentType类型，multipart单词是多部分的意思，这意味着body中的数据允许由多部分组成，可以同时传入二进制和文本；将表单的数据组织成Key-Value形式，用分隔符 boundary（boundary可任意设置）处理成一条消息。可同时上传文件和参数。 </td>\n</tr>\n<tr>\n<td>application/json</td>\n<td>body内容是 json 格式的文本</td>\n</tr>\n<tr>\n<td>text/plain</td>\n<td>body 的内容就只是文本，空格转换为 “+” 加号，但不对特殊字符编码。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"form-data-举例\"><a href=\"#form-data-举例\" class=\"headerlink\" title=\"form-data 举例\"></a>form-data 举例</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&#x27;xxx&#x27;</span> <span class=\"attr\">method</span>=<span class=\"string\">&#x27;post&#x27;</span> <span class=\"attr\">enctype</span>=<span class=\"string\">&#x27;multipart/form-data&#x27;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;text&#x27;</span> <span class=\"attr\">name</span>=<span class=\"string\">&#x27;user_name&#x27;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#x27;user_name_str&#x27;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;file&#x27;</span> <span class=\"attr\">name</span>=<span class=\"string\">&#x27;file_name&#x27;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;submit&#x27;</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>下面的使用jquery post 提交方式和上面是等效的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">&#x27;xxx&#x27;</span>,</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;POST&#x27;</span>,</span><br><span class=\"line\">  contentType: <span class=\"string\">&#x27;multipart/form-data&#x27;</span>, <span class=\"comment\">// jquery ajax 默认为 x-www-form-urllencoded</span></span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"response-里面的-Content-Type\"><a href=\"#response-里面的-Content-Type\" class=\"headerlink\" title=\"response 里面的 Content-Type\"></a>response 里面的 Content-Type</h4><p>Http响应也会带Content-Type，原理和请求的一致，目的是告诉客户端实际返回的内容的内容类型，让接收方知道怎么解析数据。</p>\n<h4 id=\"常见媒体格式（维基百科）\"><a href=\"#常见媒体格式（维基百科）\" class=\"headerlink\" title=\"常见媒体格式（维基百科）\"></a>常见媒体格式（维基百科）</h4><h5 id=\"Type-application\"><a href=\"#Type-application\" class=\"headerlink\" title=\"Type application\"></a>Type application</h5><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>application/atom+xml</td>\n<td>Atom feeds</td>\n</tr>\n<tr>\n<td>application/ecmascript</td>\n<td>ECMAScript/JavaScript;[4]（相当于application/javascript但是严格的处理规则）</td>\n</tr>\n<tr>\n<td>application/EDI-X12</td>\n<td>EDI ANSI ASC X12资料[5]</td>\n</tr>\n<tr>\n<td>application/EDIFACT</td>\n<td>EDI EDIFACT资料[5]</td>\n</tr>\n<tr>\n<td>application/json</td>\n<td>JSON（JavaScript Object Notation）[6]</td>\n</tr>\n<tr>\n<td>application/javascript</td>\n<td>JavaScript。</td>\n</tr>\n<tr>\n<td>application/octet-stream</td>\n<td>任意的二进制文件（通常做为通知浏览器下载文件</td>\n</tr>\n<tr>\n<td>application/ogg</td>\n<td>Ogg, 视频文件格式[9]</td>\n</tr>\n<tr>\n<td>application/pdf</td>\n<td>PDF（Portable Document Format）[10]</td>\n</tr>\n<tr>\n<td>application/postscript</td>\n<td>PostScript[7]</td>\n</tr>\n<tr>\n<td>application/rdf+xml</td>\n<td>Resource Description Framework[11]</td>\n</tr>\n<tr>\n<td>application/rss+xml</td>\n<td>RSS feeds</td>\n</tr>\n<tr>\n<td>application/soap+xml</td>\n<td>SOAP[12]</td>\n</tr>\n<tr>\n<td>application/font-woff</td>\n<td>Web Open Font Format;（推荐使用；使用application/x-font-woff直到它变为官方标准）</td>\n</tr>\n<tr>\n<td>application/xhtml+xml</td>\n<td>XHTML[13]</td>\n</tr>\n<tr>\n<td>application/xml</td>\n<td>XML文件[14]</td>\n</tr>\n<tr>\n<td>application/xml-dtd</td>\n<td>DTD文件[14]</td>\n</tr>\n<tr>\n<td>application/xop+xml</td>\n<td>XML-binary Optimized Packaging[15]</td>\n</tr>\n<tr>\n<td>application/zip</td>\n<td>ZIP压缩包[16]</td>\n</tr>\n<tr>\n<td>application/gzip</td>\n<td>Gzip[17]</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Type-Audio\"><a href=\"#Type-Audio\" class=\"headerlink\" title=\"Type Audio\"></a>Type Audio</h5><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>audio/mp4</td>\n<td>MP4音频档案[18]</td>\n</tr>\n<tr>\n<td>audio/mpeg</td>\n<td>MP3或其他MPEG音频档案[19]</td>\n</tr>\n<tr>\n<td>audio/ogg</td>\n<td>Ogg音频档案[9]</td>\n</tr>\n<tr>\n<td>audio/vorbis</td>\n<td>Vorbis音频档案[20]</td>\n</tr>\n<tr>\n<td>audio/vnd.rn-realaudio</td>\n<td>RealAudio音频档案[21]</td>\n</tr>\n<tr>\n<td>audio/vnd.wave</td>\n<td>WAV音频档案[22]</td>\n</tr>\n<tr>\n<td>audio/webm</td>\n<td>WebM音频档案</td>\n</tr>\n<tr>\n<td>audio/flac</td>\n<td>FLAC音频档案</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Type-Image\"><a href=\"#Type-Image\" class=\"headerlink\" title=\"Type Image\"></a>Type Image</h5><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>image/gif</td>\n<td>GIF图像文件[23]</td>\n</tr>\n<tr>\n<td>image/jpeg</td>\n<td>JPEG图像文件[23]</td>\n</tr>\n<tr>\n<td>image/png</td>\n<td>PNG图像文件[24]</td>\n</tr>\n<tr>\n<td>image/webp</td>\n<td>WebP图像文件</td>\n</tr>\n<tr>\n<td>image/svg+xml</td>\n<td>SVG向量图像文件[25]</td>\n</tr>\n<tr>\n<td>image/tiff</td>\n<td>TIFF图像文件[26]</td>\n</tr>\n<tr>\n<td>image/icon</td>\n<td>ICO图片文件。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Type-Text\"><a href=\"#Type-Text\" class=\"headerlink\" title=\"Type Text\"></a>Type Text</h5><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>text/css</td>\n<td>CSS文件[29]</td>\n</tr>\n<tr>\n<td>text/csv</td>\n<td>CSV文件[30]</td>\n</tr>\n<tr>\n<td>text/html</td>\n<td>HTML文件[31]</td>\n</tr>\n<tr>\n<td>text/javascript</td>\n<td>(过时)，推荐使用 application/javascript。</td>\n</tr>\n<tr>\n<td>text/plain</td>\n<td>纯文字内容[32]</td>\n</tr>\n<tr>\n<td>text/vcard</td>\n<td>vCard（电子名片）[33]</td>\n</tr>\n<tr>\n<td>text/xml</td>\n<td>XML[14]</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Type-Video\"><a href=\"#Type-Video\" class=\"headerlink\" title=\"Type Video\"></a>Type Video</h5><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>video/mpeg</td>\n<td>MPEG-1视频文件[34]</td>\n</tr>\n<tr>\n<td>video/mp4</td>\n<td>MP4视频文件[35]</td>\n</tr>\n<tr>\n<td>video/ogg</td>\n<td>Ogg视频文件[9]</td>\n</tr>\n<tr>\n<td>video/quicktime</td>\n<td>QuickTime视频文件[36]</td>\n</tr>\n<tr>\n<td>video/webm</td>\n<td>WebM视频文件（基于Matroska基础）</td>\n</tr>\n<tr>\n<td>video/x-matroska</td>\n<td>Matroska（多媒体封装格式）</td>\n</tr>\n<tr>\n<td>video/x-ms-wmv</td>\n<td>Windows Media Video视频文件[37]</td>\n</tr>\n<tr>\n<td>video/x-flv</td>\n<td>Flash Video（FLV档）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Type-Model-三维计算机图形文件\"><a href=\"#Type-Model-三维计算机图形文件\" class=\"headerlink\" title=\"Type Model(三维计算机图形文件)\"></a>Type Model(三维计算机图形文件)</h5><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>model/example[27]</td>\n<td>Example Media Types for Use in Documentation</td>\n</tr>\n<tr>\n<td>model/iges</td>\n<td>IGS files, IGES files[28]</td>\n</tr>\n<tr>\n<td>model/mesh</td>\n<td>MSH files, MESH files[28]</td>\n</tr>\n<tr>\n<td>model/vrml</td>\n<td>WRL files, VRML files[28]</td>\n</tr>\n<tr>\n<td>model/x3d+binary</td>\n<td>X3D ISO standard for representing 3D computer graphics, X3DB binary files</td>\n</tr>\n<tr>\n<td>model/x3d+vrml</td>\n<td>X3D ISO standard for representing 3D computer graphics, X3DV VRML files</td>\n</tr>\n<tr>\n<td>model/x3d+xml</td>\n<td>X3D ISO standard for representing 3D computer graphics, X3D XML files</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Request-Headers的候选属性\"><a href=\"#Request-Headers的候选属性\" class=\"headerlink\" title=\"Request Headers的候选属性\"></a>Request Headers的候选属性</h4><table>\n<thead>\n<tr>\n<th>属性值</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept</td>\n<td>指定客户端能够接收的内容类型</td>\n<td>Accept: text/plain, text/html</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>请求头用来告知（服务器）客户端可以处理的字符集类型。</td>\n<td>Accept-Charset: utf-8, iso-8859-1;q=0.5, *;q=0.1</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>指定浏览器可以支持的web服务器返回内容压缩编码类型</td>\n<td>Accept-Encoding: compress, gzip, deflate</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>浏览器可接受的语言</td>\n<td>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7</td>\n</tr>\n<tr>\n<td>Accept-Ranges</td>\n<td>请求资源的某一段数据</td>\n<td>Accept-Ranges: bytes=0-1023</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>请求消息首部包含有用来向（代理）服务器证明用户代理身份的凭证。</td>\n<td>Authorization: Basic QWxhZLRpbjpvcGVuIHNoc2FtZQ==</td>\n</tr>\n<tr>\n<td>Cache-Control</td>\n<td>指定请求和响应遵循的缓存机制</td>\n<td>Cache-Control: no-cache(或者 max-age=100)</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>决定当前的事务完成后，是否会关闭网络连接</td>\n<td>Connection: keep-alive</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器</td>\n<td>Cookie: $Version=1; Skin=new;</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>请求的内容长度</td>\n<td>Content-Length: 348</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>请求的与实体对应的MIME信息</td>\n<td>Content-Type: application/x-www-form-urlencoded</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>请求发送的日期和时间</td>\n<td>Date: Tue, 15 Nov 2018 08:22:31 GMT</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>包含一个期望条件，表示服务器只有在满足此期望条件的情况下才能妥善地处理请求</td>\n<td>Expect: 100-continue</td>\n</tr>\n<tr>\n<td>From</td>\n<td>发出请求的用户的Email</td>\n<td>From: <a href=\"mailto:user@email.com\">user@email.com</a></td>\n</tr>\n<tr>\n<td>Host</td>\n<td>指定请求的服务器的域名和端口号</td>\n<td>Host: <a href=\"http://www.yanggb.com\">www.yanggb.com</a></td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>只有请求内容与实体相匹配才有效</td>\n<td>If-Match: “737060ff8c284d8af7ad2082f209582d”</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>\n<td>If-Modified-Since: Sat, 29 Oct 2018 19:43:31 GMT</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>\n<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>\n<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>只在实体在指定时间之后未被修改才请求成功</td>\n<td>If-Unmodified-Since: Sat, 29 Oct 2018 19:23:11 GMT</td>\n</tr>\n<tr>\n<td>Max-Forwards</td>\n<td>限制信息通过代理和网关传送的时间</td>\n<td>Max-Forwards: 10</td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>用来包含实现特定的指令</td>\n<td>Pragma: no-cache</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>连接到代理的授权证书</td>\n<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>只请求实体的一部分，指定范围</td>\n<td>Range: bytes=500-999</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>先前网页的地址，当前请求网页紧随其后，即来路</td>\n<td>Referer: <a href=\"http://www.yanggb.com/yanggb1.html\">http://www.yanggb.com/yanggb1.html</a></td>\n</tr>\n<tr>\n<td>TE</td>\n<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>\n<td>TE: trailers,deflate;q=0.5</td>\n</tr>\n<tr>\n<td>Upgrade</td>\n<td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>\n<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>User-Agent的内容包含发出请求的用户信息</td>\n<td>User-Agent: Mozilla/5.0 (Linux; X11)</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>通知中间网关或代理服务器地址，通信协议</td>\n<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>关于消息实体的警告信息</td>\n<td>Warn: 199 Miscellaneous warning</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Response-Headers的候选属性\"><a href=\"#Response-Headers的候选属性\" class=\"headerlink\" title=\"Response Headers的候选属性\"></a>Response Headers的候选属性</h4><table>\n<thead>\n<tr>\n<th>候选属性</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept-Ranges</td>\n<td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td>\n<td>Accept-Ranges: bytes</td>\n</tr>\n<tr>\n<td>Age</td>\n<td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>\n<td>Age: 12</td>\n</tr>\n<tr>\n<td>Allow</td>\n<td>对某网络资源的有效的请求行为，不允许则返回405</td>\n<td>Allow: GET, HEAD</td>\n</tr>\n<tr>\n<td>Access-Control-Allow-Credentials</td>\n<td>表示是否可以将对请求的响应暴露给页面，常用作跨域</td>\n<td>Access-Control-Allow-Credentials: true</td>\n</tr>\n<tr>\n<td>Access-Control-Allow-Origin</td>\n<td>表示请求的许可域名</td>\n<td>Access-Control-Allow-Origin: <a href=\"https://www.163.com\">https://www.163.com</a></td>\n</tr>\n<tr>\n<td>Access-Control-Allow-Methods</td>\n<td>预检请求应答中明确客户端所要访问的资源允许使用的方法(列表)。</td>\n<td>Access-Control-Allow-Methods: POST, OPTIONS</td>\n</tr>\n<tr>\n<td>Cache-Control</td>\n<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>\n<td>Cache-Control: no-cache</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>web服务器支持的返回内容压缩编码类型</td>\n<td>Content-Encoding: gzip</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>响应体的语言</td>\n<td>Content-Language: en,zh</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>响应体的长度</td>\n<td>Content-Length: 348</td>\n</tr>\n<tr>\n<td>Content-Location</td>\n<td>请求资源可替代的备用的另一地址</td>\n<td>Content-Location: /index.htm</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>返回资源的MD5校验值</td>\n<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>在整个返回体中本部分的字节位置</td>\n<td>Content-Range: bytes 21010-47021/47022</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>返回内容的MIME类型</td>\n<td>Content-Type: text/html; charset=utf-8</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>原始服务器消息发出的时间</td>\n<td>Date: Tue, 15 Nov 2018 08:22:22 GMT</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>请求变量的实体标签的当前值</td>\n<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>响应过期的日期和时间</td>\n<td>Expires: Thu, 01 Dec 2018 16:00:00 GMT</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>请求资源的最后修改时间</td>\n<td>Last-Modified: Tue, 15 Nov 2018 12:25:26 GMT</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>\n<td>Location: <a href=\"http://www.yanggb.com/yanggb2.html\">http://www.yanggb.com/yanggb2.html</a></td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>包括实现特定的指令，它可应用到响应链上的任何接收方</td>\n<td>Pragma: no-cache</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>它指出认证方案和可应用到代理的该URL上的参数</td>\n<td>Proxy-Authenticate: Basic</td>\n</tr>\n<tr>\n<td>refresh</td>\n<td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>\n<td>Refresh: 5; url=<a href=\"http://www.yanggb.com/yanggb9.html\">http://www.yanggb.com/yanggb9.html</a></td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>\n<td>Retry-After: 120</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>web服务器软件名称</td>\n<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置Http Cookie</td>\n<td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>指出头域在分块传输编码的尾部存在</td>\n<td>Trailer: Max-Forwards</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>文件传输编码</td>\n<td>Transfer-Encoding:chunked</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>告诉下游代理是使用缓存响应还是从原始服务器请求</td>\n<td>Vary: *</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>告知代理客户端响应是通过哪里发送的</td>\n<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>警告实体可能存在的问题</td>\n<td>Warning: 199 Miscellaneous warning</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>表明客户端请求实体应该使用的授权方案</td>\n<td>WWW-Authenticate: Basic</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://zh.wikipedia.org/wiki/互联网媒体类型\">互联网媒体类型</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"互联网媒体类型\"><a href=\"#互联网媒体类型\" class=\"headerlink\" title=\"互联网媒体类型\"></a>互联网媒体类型</h3><p>互联网媒体类型（Internet media type，也称为MIME类型（MIME type）或内容类型（content type））<br>是给互联网上传输的内容赋予的分类类型。互联网媒体类型与文件拓展名相对应。</p>\n<p>一个MIME类型一定包括 <strong><em>类型（type）</em></strong>和 <strong><em>子类型（subtype）</em></strong><br>还可能包括一个或多个 <strong><em>可选参数（optional parameter）</em></strong>。</p>\n<p>比如，HTML文件的互联网媒体类型可能是<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><br>上面例子，文件类型为text，子类型为html，charset是一个可选参数，其值为UTF-8</p>\n<h4 id=\"Content-Type（内容类型）\"><a href=\"#Content-Type（内容类型）\" class=\"headerlink\" title=\"Content-Type（内容类型）\"></a>Content-Type（内容类型）</h4><p>实体头部用于指示资源的MIME类型，一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件<br>这就是为什么发起请求的时候，有的是请求图片，有的是请求网页，有的是下载文件的原因了。</p>\n<h4 id=\"request-里面的-Content-Type\"><a href=\"#request-里面的-Content-Type\" class=\"headerlink\" title=\"request 里面的 Content-Type\"></a>request 里面的 Content-Type</h4><p>用于表明发送数据流的类型，服务端根据此类型来采用该类型文件的解析方式来解析数据</p>\n<h4 id=\"使用-post-方式提交数据的时候指定的几种-body-类型。\"><a href=\"#使用-post-方式提交数据的时候指定的几种-body-类型。\" class=\"headerlink\" title=\"使用 post 方式提交数据的时候指定的几种 body 类型。\"></a>使用 post 方式提交数据的时候指定的几种 body 类型。</h4><p>这是将发送信息至服务器时内容的编码类型。服务端根据这些类型来判断使用哪种方式解析数据。</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>application/x-www-form-urlencoded</td>\n<td>原生的 form 表单的提交的默认数据格式，Body 中的数据以’key1=value1&amp;key2=value2’的文本格式传输；如果是使用 ajax提交，则需要手动格式化body的内容。</td>\n</tr>\n<tr>\n<td>multipart/form-data</td>\n<td>Http协议最开始是不支持文件上传的，直到1995年发布的规范新增这个contentType类型，multipart单词是多部分的意思，这意味着body中的数据允许由多部分组成，可以同时传入二进制和文本；将表单的数据组织成Key-Value形式，用分隔符 boundary（boundary可任意设置）处理成一条消息。可同时上传文件和参数。 </td>\n</tr>\n<tr>\n<td>application/json</td>\n<td>body内容是 json 格式的文本</td>\n</tr>\n<tr>\n<td>text/plain</td>\n<td>body 的内容就只是文本，空格转换为 “+” 加号，但不对特殊字符编码。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"form-data-举例\"><a href=\"#form-data-举例\" class=\"headerlink\" title=\"form-data 举例\"></a>form-data 举例</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&#x27;xxx&#x27;</span> <span class=\"attr\">method</span>=<span class=\"string\">&#x27;post&#x27;</span> <span class=\"attr\">enctype</span>=<span class=\"string\">&#x27;multipart/form-data&#x27;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;text&#x27;</span> <span class=\"attr\">name</span>=<span class=\"string\">&#x27;user_name&#x27;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#x27;user_name_str&#x27;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;file&#x27;</span> <span class=\"attr\">name</span>=<span class=\"string\">&#x27;file_name&#x27;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;submit&#x27;</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>下面的使用jquery post 提交方式和上面是等效的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">&#x27;xxx&#x27;</span>,</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;POST&#x27;</span>,</span><br><span class=\"line\">  contentType: <span class=\"string\">&#x27;multipart/form-data&#x27;</span>, <span class=\"comment\">// jquery ajax 默认为 x-www-form-urllencoded</span></span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"response-里面的-Content-Type\"><a href=\"#response-里面的-Content-Type\" class=\"headerlink\" title=\"response 里面的 Content-Type\"></a>response 里面的 Content-Type</h4><p>Http响应也会带Content-Type，原理和请求的一致，目的是告诉客户端实际返回的内容的内容类型，让接收方知道怎么解析数据。</p>\n<h4 id=\"常见媒体格式（维基百科）\"><a href=\"#常见媒体格式（维基百科）\" class=\"headerlink\" title=\"常见媒体格式（维基百科）\"></a>常见媒体格式（维基百科）</h4><h5 id=\"Type-application\"><a href=\"#Type-application\" class=\"headerlink\" title=\"Type application\"></a>Type application</h5><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>application/atom+xml</td>\n<td>Atom feeds</td>\n</tr>\n<tr>\n<td>application/ecmascript</td>\n<td>ECMAScript/JavaScript;[4]（相当于application/javascript但是严格的处理规则）</td>\n</tr>\n<tr>\n<td>application/EDI-X12</td>\n<td>EDI ANSI ASC X12资料[5]</td>\n</tr>\n<tr>\n<td>application/EDIFACT</td>\n<td>EDI EDIFACT资料[5]</td>\n</tr>\n<tr>\n<td>application/json</td>\n<td>JSON（JavaScript Object Notation）[6]</td>\n</tr>\n<tr>\n<td>application/javascript</td>\n<td>JavaScript。</td>\n</tr>\n<tr>\n<td>application/octet-stream</td>\n<td>任意的二进制文件（通常做为通知浏览器下载文件</td>\n</tr>\n<tr>\n<td>application/ogg</td>\n<td>Ogg, 视频文件格式[9]</td>\n</tr>\n<tr>\n<td>application/pdf</td>\n<td>PDF（Portable Document Format）[10]</td>\n</tr>\n<tr>\n<td>application/postscript</td>\n<td>PostScript[7]</td>\n</tr>\n<tr>\n<td>application/rdf+xml</td>\n<td>Resource Description Framework[11]</td>\n</tr>\n<tr>\n<td>application/rss+xml</td>\n<td>RSS feeds</td>\n</tr>\n<tr>\n<td>application/soap+xml</td>\n<td>SOAP[12]</td>\n</tr>\n<tr>\n<td>application/font-woff</td>\n<td>Web Open Font Format;（推荐使用；使用application/x-font-woff直到它变为官方标准）</td>\n</tr>\n<tr>\n<td>application/xhtml+xml</td>\n<td>XHTML[13]</td>\n</tr>\n<tr>\n<td>application/xml</td>\n<td>XML文件[14]</td>\n</tr>\n<tr>\n<td>application/xml-dtd</td>\n<td>DTD文件[14]</td>\n</tr>\n<tr>\n<td>application/xop+xml</td>\n<td>XML-binary Optimized Packaging[15]</td>\n</tr>\n<tr>\n<td>application/zip</td>\n<td>ZIP压缩包[16]</td>\n</tr>\n<tr>\n<td>application/gzip</td>\n<td>Gzip[17]</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Type-Audio\"><a href=\"#Type-Audio\" class=\"headerlink\" title=\"Type Audio\"></a>Type Audio</h5><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>audio/mp4</td>\n<td>MP4音频档案[18]</td>\n</tr>\n<tr>\n<td>audio/mpeg</td>\n<td>MP3或其他MPEG音频档案[19]</td>\n</tr>\n<tr>\n<td>audio/ogg</td>\n<td>Ogg音频档案[9]</td>\n</tr>\n<tr>\n<td>audio/vorbis</td>\n<td>Vorbis音频档案[20]</td>\n</tr>\n<tr>\n<td>audio/vnd.rn-realaudio</td>\n<td>RealAudio音频档案[21]</td>\n</tr>\n<tr>\n<td>audio/vnd.wave</td>\n<td>WAV音频档案[22]</td>\n</tr>\n<tr>\n<td>audio/webm</td>\n<td>WebM音频档案</td>\n</tr>\n<tr>\n<td>audio/flac</td>\n<td>FLAC音频档案</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Type-Image\"><a href=\"#Type-Image\" class=\"headerlink\" title=\"Type Image\"></a>Type Image</h5><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>image/gif</td>\n<td>GIF图像文件[23]</td>\n</tr>\n<tr>\n<td>image/jpeg</td>\n<td>JPEG图像文件[23]</td>\n</tr>\n<tr>\n<td>image/png</td>\n<td>PNG图像文件[24]</td>\n</tr>\n<tr>\n<td>image/webp</td>\n<td>WebP图像文件</td>\n</tr>\n<tr>\n<td>image/svg+xml</td>\n<td>SVG向量图像文件[25]</td>\n</tr>\n<tr>\n<td>image/tiff</td>\n<td>TIFF图像文件[26]</td>\n</tr>\n<tr>\n<td>image/icon</td>\n<td>ICO图片文件。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Type-Text\"><a href=\"#Type-Text\" class=\"headerlink\" title=\"Type Text\"></a>Type Text</h5><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>text/css</td>\n<td>CSS文件[29]</td>\n</tr>\n<tr>\n<td>text/csv</td>\n<td>CSV文件[30]</td>\n</tr>\n<tr>\n<td>text/html</td>\n<td>HTML文件[31]</td>\n</tr>\n<tr>\n<td>text/javascript</td>\n<td>(过时)，推荐使用 application/javascript。</td>\n</tr>\n<tr>\n<td>text/plain</td>\n<td>纯文字内容[32]</td>\n</tr>\n<tr>\n<td>text/vcard</td>\n<td>vCard（电子名片）[33]</td>\n</tr>\n<tr>\n<td>text/xml</td>\n<td>XML[14]</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Type-Video\"><a href=\"#Type-Video\" class=\"headerlink\" title=\"Type Video\"></a>Type Video</h5><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>video/mpeg</td>\n<td>MPEG-1视频文件[34]</td>\n</tr>\n<tr>\n<td>video/mp4</td>\n<td>MP4视频文件[35]</td>\n</tr>\n<tr>\n<td>video/ogg</td>\n<td>Ogg视频文件[9]</td>\n</tr>\n<tr>\n<td>video/quicktime</td>\n<td>QuickTime视频文件[36]</td>\n</tr>\n<tr>\n<td>video/webm</td>\n<td>WebM视频文件（基于Matroska基础）</td>\n</tr>\n<tr>\n<td>video/x-matroska</td>\n<td>Matroska（多媒体封装格式）</td>\n</tr>\n<tr>\n<td>video/x-ms-wmv</td>\n<td>Windows Media Video视频文件[37]</td>\n</tr>\n<tr>\n<td>video/x-flv</td>\n<td>Flash Video（FLV档）</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Type-Model-三维计算机图形文件\"><a href=\"#Type-Model-三维计算机图形文件\" class=\"headerlink\" title=\"Type Model(三维计算机图形文件)\"></a>Type Model(三维计算机图形文件)</h5><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>model/example[27]</td>\n<td>Example Media Types for Use in Documentation</td>\n</tr>\n<tr>\n<td>model/iges</td>\n<td>IGS files, IGES files[28]</td>\n</tr>\n<tr>\n<td>model/mesh</td>\n<td>MSH files, MESH files[28]</td>\n</tr>\n<tr>\n<td>model/vrml</td>\n<td>WRL files, VRML files[28]</td>\n</tr>\n<tr>\n<td>model/x3d+binary</td>\n<td>X3D ISO standard for representing 3D computer graphics, X3DB binary files</td>\n</tr>\n<tr>\n<td>model/x3d+vrml</td>\n<td>X3D ISO standard for representing 3D computer graphics, X3DV VRML files</td>\n</tr>\n<tr>\n<td>model/x3d+xml</td>\n<td>X3D ISO standard for representing 3D computer graphics, X3D XML files</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Request-Headers的候选属性\"><a href=\"#Request-Headers的候选属性\" class=\"headerlink\" title=\"Request Headers的候选属性\"></a>Request Headers的候选属性</h4><table>\n<thead>\n<tr>\n<th>属性值</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept</td>\n<td>指定客户端能够接收的内容类型</td>\n<td>Accept: text/plain, text/html</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>请求头用来告知（服务器）客户端可以处理的字符集类型。</td>\n<td>Accept-Charset: utf-8, iso-8859-1;q=0.5, *;q=0.1</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>指定浏览器可以支持的web服务器返回内容压缩编码类型</td>\n<td>Accept-Encoding: compress, gzip, deflate</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>浏览器可接受的语言</td>\n<td>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7</td>\n</tr>\n<tr>\n<td>Accept-Ranges</td>\n<td>请求资源的某一段数据</td>\n<td>Accept-Ranges: bytes=0-1023</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>请求消息首部包含有用来向（代理）服务器证明用户代理身份的凭证。</td>\n<td>Authorization: Basic QWxhZLRpbjpvcGVuIHNoc2FtZQ==</td>\n</tr>\n<tr>\n<td>Cache-Control</td>\n<td>指定请求和响应遵循的缓存机制</td>\n<td>Cache-Control: no-cache(或者 max-age=100)</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>决定当前的事务完成后，是否会关闭网络连接</td>\n<td>Connection: keep-alive</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器</td>\n<td>Cookie: $Version=1; Skin=new;</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>请求的内容长度</td>\n<td>Content-Length: 348</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>请求的与实体对应的MIME信息</td>\n<td>Content-Type: application/x-www-form-urlencoded</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>请求发送的日期和时间</td>\n<td>Date: Tue, 15 Nov 2018 08:22:31 GMT</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>包含一个期望条件，表示服务器只有在满足此期望条件的情况下才能妥善地处理请求</td>\n<td>Expect: 100-continue</td>\n</tr>\n<tr>\n<td>From</td>\n<td>发出请求的用户的Email</td>\n<td>From: <a href=\"mailto:user@email.com\">user@email.com</a></td>\n</tr>\n<tr>\n<td>Host</td>\n<td>指定请求的服务器的域名和端口号</td>\n<td>Host: <a href=\"http://www.yanggb.com\">www.yanggb.com</a></td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>只有请求内容与实体相匹配才有效</td>\n<td>If-Match: “737060ff8c284d8af7ad2082f209582d”</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>\n<td>If-Modified-Since: Sat, 29 Oct 2018 19:43:31 GMT</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>\n<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>\n<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>只在实体在指定时间之后未被修改才请求成功</td>\n<td>If-Unmodified-Since: Sat, 29 Oct 2018 19:23:11 GMT</td>\n</tr>\n<tr>\n<td>Max-Forwards</td>\n<td>限制信息通过代理和网关传送的时间</td>\n<td>Max-Forwards: 10</td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>用来包含实现特定的指令</td>\n<td>Pragma: no-cache</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>连接到代理的授权证书</td>\n<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>只请求实体的一部分，指定范围</td>\n<td>Range: bytes=500-999</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>先前网页的地址，当前请求网页紧随其后，即来路</td>\n<td>Referer: <a href=\"http://www.yanggb.com/yanggb1.html\">http://www.yanggb.com/yanggb1.html</a></td>\n</tr>\n<tr>\n<td>TE</td>\n<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>\n<td>TE: trailers,deflate;q=0.5</td>\n</tr>\n<tr>\n<td>Upgrade</td>\n<td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>\n<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>User-Agent的内容包含发出请求的用户信息</td>\n<td>User-Agent: Mozilla/5.0 (Linux; X11)</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>通知中间网关或代理服务器地址，通信协议</td>\n<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>关于消息实体的警告信息</td>\n<td>Warn: 199 Miscellaneous warning</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Response-Headers的候选属性\"><a href=\"#Response-Headers的候选属性\" class=\"headerlink\" title=\"Response Headers的候选属性\"></a>Response Headers的候选属性</h4><table>\n<thead>\n<tr>\n<th>候选属性</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept-Ranges</td>\n<td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td>\n<td>Accept-Ranges: bytes</td>\n</tr>\n<tr>\n<td>Age</td>\n<td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>\n<td>Age: 12</td>\n</tr>\n<tr>\n<td>Allow</td>\n<td>对某网络资源的有效的请求行为，不允许则返回405</td>\n<td>Allow: GET, HEAD</td>\n</tr>\n<tr>\n<td>Access-Control-Allow-Credentials</td>\n<td>表示是否可以将对请求的响应暴露给页面，常用作跨域</td>\n<td>Access-Control-Allow-Credentials: true</td>\n</tr>\n<tr>\n<td>Access-Control-Allow-Origin</td>\n<td>表示请求的许可域名</td>\n<td>Access-Control-Allow-Origin: <a href=\"https://www.163.com\">https://www.163.com</a></td>\n</tr>\n<tr>\n<td>Access-Control-Allow-Methods</td>\n<td>预检请求应答中明确客户端所要访问的资源允许使用的方法(列表)。</td>\n<td>Access-Control-Allow-Methods: POST, OPTIONS</td>\n</tr>\n<tr>\n<td>Cache-Control</td>\n<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>\n<td>Cache-Control: no-cache</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>web服务器支持的返回内容压缩编码类型</td>\n<td>Content-Encoding: gzip</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>响应体的语言</td>\n<td>Content-Language: en,zh</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>响应体的长度</td>\n<td>Content-Length: 348</td>\n</tr>\n<tr>\n<td>Content-Location</td>\n<td>请求资源可替代的备用的另一地址</td>\n<td>Content-Location: /index.htm</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>返回资源的MD5校验值</td>\n<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>在整个返回体中本部分的字节位置</td>\n<td>Content-Range: bytes 21010-47021/47022</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>返回内容的MIME类型</td>\n<td>Content-Type: text/html; charset=utf-8</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>原始服务器消息发出的时间</td>\n<td>Date: Tue, 15 Nov 2018 08:22:22 GMT</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>请求变量的实体标签的当前值</td>\n<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>响应过期的日期和时间</td>\n<td>Expires: Thu, 01 Dec 2018 16:00:00 GMT</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>请求资源的最后修改时间</td>\n<td>Last-Modified: Tue, 15 Nov 2018 12:25:26 GMT</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>\n<td>Location: <a href=\"http://www.yanggb.com/yanggb2.html\">http://www.yanggb.com/yanggb2.html</a></td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>包括实现特定的指令，它可应用到响应链上的任何接收方</td>\n<td>Pragma: no-cache</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>它指出认证方案和可应用到代理的该URL上的参数</td>\n<td>Proxy-Authenticate: Basic</td>\n</tr>\n<tr>\n<td>refresh</td>\n<td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>\n<td>Refresh: 5; url=<a href=\"http://www.yanggb.com/yanggb9.html\">http://www.yanggb.com/yanggb9.html</a></td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>\n<td>Retry-After: 120</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>web服务器软件名称</td>\n<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置Http Cookie</td>\n<td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>指出头域在分块传输编码的尾部存在</td>\n<td>Trailer: Max-Forwards</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>文件传输编码</td>\n<td>Transfer-Encoding:chunked</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>告诉下游代理是使用缓存响应还是从原始服务器请求</td>\n<td>Vary: *</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>告知代理客户端响应是通过哪里发送的</td>\n<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>警告实体可能存在的问题</td>\n<td>Warning: 199 Miscellaneous warning</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>表明客户端请求实体应该使用的授权方案</td>\n<td>WWW-Authenticate: Basic</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://zh.wikipedia.org/wiki/互联网媒体类型\">互联网媒体类型</a></p>\n"},{"title":"超文本传输协议 HTTP","date":"2017-02-26T16:00:00.000Z","_content":"\n超文本传输协议（HyperText Transfer Protocol，缩写：HTTP）是互联网上应用最为广泛的一种网络协议。\n设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\n通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。\nHTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）\n\n通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。\nHTTP服务器则在那个端口监听客户端的请求。\n一旦收到请求，服务器会向客户端返回一个状态，比如\"HTTP/1.1 200 OK\"，以及返回的内容，如请求的文件、错误消息、或者其它信息\n\n### 版本\n```html\nHTTP/0.9\nHTTP/1.0\nHTTP/1.1\nHTTP/2\n```\n\n\n### 请求方法\nHTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源\n\n- *OPTIONS：*这个方法可以使服务器传回该资源所支持的所有HTTP请求方法。用'\\*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。\n\n- *GET：*向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。\n\n- *HEAD：*与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。\n\n- *POST：*向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。\n\n- *PUT：*向指定资源位置上传其最新内容。\n\n- *DELETE：*请求服务器删除Request-URI所标识的资源。\n\n- *TRACE：*回显服务器收到的请求，主要用于测试或诊断。\n\n- *CONNECT：*HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。\n\n- *方法名称是区分大小写的。\n当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。*\n\n---\n\n### TCP三次握手\n- 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；\n- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n- 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n\n### TCP四次挥手\n\n---\n\n### 状态码\n\n1xx：消息——请求已被服务器接收，继续处理\n2xx：成功——请求已成功被服务器接收、理解、并接受\n3xx：重定向——需要后续操作才能完成这一请求\n4xx：请求错误——请求含有词法错误或者无法被执行\n5xx：服务器错误——服务器在处理某个正确请求时发生错误\n\n---\n\n### http1.0和http1.1的区别\n\n- 缓存处理：增加缓存头来控制缓存策略。\n- 带宽优化及网络连接的使用：支持断点续传以及部分请求\n- 错误通知的管理：新增多个错误状态码\n- 互联网地址的维护：HTTP1.1的请求消息和响应消息都应支持Host头域\n- 长连接：一个tcp可用于多个http\n\n---\n\n\n### http缓存\n\n通过http获取网络数据的成本是非常高的，尤其是当需要大范围获取数据的时候，好在浏览器都有缓存策略\n\n1.使用 ETag 验证缓存的响应：\n服务器下发给客户端的时候在ETag头返回一个验证令牌Response Headers（ETag:\"58b4e12b-2492d\"）\n当客户端再次请求的时候讲令牌带上,Request Headers（If-None-Match:W/\"58b4e12b-2492d\"）\n服务端验证令牌如果没有发生改变则返回304\n\n\n2.Cache-Control：\n每个资源都可以通过 Cache-Control HTTP 头来定义自己的缓存策略\nCache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久\n\n``` html\nCache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了\n```\n- no-cache 和 no-store\nno-cache：表示必须先与服务器确认返回的响应是否被更改，然后通过ETag来判断是否需要下载资源。\nno-store：禁止浏览器和所有中继缓存存储返回的任何版本的响应。\n例如：一个包含个人隐私数据或银行数据的响应。每次用户请求该资源时，都会向服务器发送一个请求，每次都会下载完整的响应\n\n- public和private\n如果响应被标记为public，即使有关联的 HTTP 认证，甚至响应状态码无法正常缓存，响应也可以被缓存。大多数情况下，public不是必须的，因为明确的缓存信息（例如max-age）已表示 响应可以被缓存。\n相比之下，浏览器可以缓存private响应，但是通常只为单个用户缓存，因此，不允许任何中继缓存对其进行缓存 - 例如，用户浏览器可以缓存包含用户私人信息的 HTML 网页，但是 CDN 不能缓存。\n\n- max-age\n该指令指定从当前请求开始，允许获取的响应被重用的最长时间（单位为秒）\n\n- s-maxage\n同max-age，只用于共享缓存（比如CDN缓存）。\n\n- Last-modified（类似于ETag）\n服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式\n当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。\n\n\n3.expires：\nExpires 头指定了一个日期/时间， 在这个日期/时间之后，HTTP响应被认为是过时的\n如果还有一个 设置了 \"max-age\" 或者 \"s-max-age\" 指令的Cache-Control响应头，那么  Expires 头就会被忽略。\n\n\n### HTTP跨域\n\n当一个资源从该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个*跨域http请求*\n处于安全原因，浏览器会限制从脚本内发起的跨域http请求。\n例如，XMLHttpRequest和Fetch API遵循同源策略。 \n这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。\n\n（跨域并非不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如  Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。）———— MDN HTTP访问控制（CORS）\n\n*CORS*(跨域资源共享) 机制允许web应用服务进行跨域访问控制。现代浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险\n\n*跨域资源共享标准（ cross-origin sharing standard ）*允许在下列场景中使用跨域 HTTP 请求：\n\n```html\n1.由XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。\n2.Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。\n3.WebGL 贴图\n4.使用 drawImage 将 Images/video 画面绘制到 canvas\n5.样式表（使用 CSSOM）\n6.Scripts (未处理的异常)\n```\n\n\n跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的HTTP请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。\n（预检请求一般是浏览器检测到请求跨域之后自动发起的，预检请求报文中的 Access-Control-Request-Method 首部字段告知服务器实际请求所使用的 HTTP 方法；Access-Control-Request-Headers首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。）\n\n跨域请求分两种：简单请求和预检请求。\n\n##### 什么是简单请求?\n需要满足下列所有的条件，为简单请求。\n```html\n1.使用下列方法之一： GET/POST/HEAD\n\n2.Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：\nAccept\nAccept-Language\nContent-Language\nContent-Type （需要注意额外的限制）\nDPR\nDownlink\nSave-Data\nViewport-Width\nWidth\n\n3.content-type值仅限于下列三者之一\ntext/plain\nmultipart/form-data\napplication/x-www-form-urlencoded\n\n4.请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。\n\n5.请求中没有使用 ReadableStream 对象。\n```\n\n##### 附带身份凭证的跨域请求\n默认跨域请求是不会发送基于  HTTP cookies 和 HTTP 认证信息的身份凭证的。如果要发送身份凭证，需要设置XMLHttprequest的某个特殊标志位。\n如：\n```html\nxhr.withCredentials = true\n```\n之后，服务端需要在响应中携带下面的属性，浏览器才会将收到的响应内容返回给请求的发送者\n```html\nAccess-Control-Allow-Credentials: true // 响应头表示是否可以将对请求的相应暴露给页面。返回true则可以，其它则不可以\n```\n\n对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为（ * ）\n\n\n##### Access-Control-Allow-Origin，服务器响应首部字段。\n```html\nAccess-Control-Allow-Origin: <origin> | *\n```\n\n##### Access-Control-Expose-Headers \n在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。\n如：\n```html\nAccess-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header\n```\n\n##### Access-Control-Allow-Credentials\n```html\nAccess-Control-Allow-Credentials 头指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。\n```\n\n##### XDomainRequest (IE89专用)\nXDomainRequest是在IE8和IE9上的HTTP access control (CORS) 的实现，在IE10中被 包含CORS的XMLHttpRequest 取代了，如果你的开发目标是IE10或IE的后续版本，或想要支待其他的浏览器，你需要使用标准的HTTP access control。\n该接口可以发送GET和POST请求\nXDomainRequest为了确保安全构建，采用了多种方法。\n被请求的URL的服务器必须带有 设置为（“ * ”）或包含了请求方的Access-Control-Allow-Origin的头部。\n\n限制\n```html\n1.必须使用 HTTP 或 HTTPS 协议访问目标 URL(不能http、https跨协议访问)\n2.只能使用 HTTP 的 GET 方法和 POST 方法访问目标 URL\n3.请求中不能加入自定义的报头\n4.只支持 text/plain 作为请求报头Content-Type的取值\n5.身份验证和cookie不能和请求一起发送 （解决办法，将cookie等信息放在请求body里面）\n...\n```\n\n\n---\n\n## 相关链接\n\n### 维基百科（需代理方能打开）\nhttps://zh.wikipedia.org/wiki/超文本传输协议\n\n### http1.0和http1.1的区别\nhttp://blog.csdn.net/forgotaboutgirl/article/details/6936982\n\n### http、socket、tcp/ip的区别\nhttp://jingyan.baidu.com/article/08b6a591e07ecc14a80922f1.html\n\n### http缓存\nhttps://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\n\nhttp://www.alloyteam.com/2016/03/discussion-on-web-caching/\n\n### http状态码\n\nhttps://zh.wikipedia.org/wiki/HTTP状态码\n\n### XDomainRequest\nhttps://www.cnblogs.com/onepixel/articles/7567948.html\n\n### 三次握手与四次挥手\nhttps://zhuanlan.zhihu.com/p/53374516\nhttps://hit-alibaba.github.io/interview/basic/network/TCP.html","source":"_posts/http.md","raw":"---\ntitle: 超文本传输协议 HTTP\ntag: [http,cache,缓存]\ndate: 2017/02/27\ncategory: 技术\n---\n\n超文本传输协议（HyperText Transfer Protocol，缩写：HTTP）是互联网上应用最为广泛的一种网络协议。\n设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\n通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。\nHTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）\n\n通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。\nHTTP服务器则在那个端口监听客户端的请求。\n一旦收到请求，服务器会向客户端返回一个状态，比如\"HTTP/1.1 200 OK\"，以及返回的内容，如请求的文件、错误消息、或者其它信息\n\n### 版本\n```html\nHTTP/0.9\nHTTP/1.0\nHTTP/1.1\nHTTP/2\n```\n\n\n### 请求方法\nHTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源\n\n- *OPTIONS：*这个方法可以使服务器传回该资源所支持的所有HTTP请求方法。用'\\*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。\n\n- *GET：*向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。\n\n- *HEAD：*与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。\n\n- *POST：*向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。\n\n- *PUT：*向指定资源位置上传其最新内容。\n\n- *DELETE：*请求服务器删除Request-URI所标识的资源。\n\n- *TRACE：*回显服务器收到的请求，主要用于测试或诊断。\n\n- *CONNECT：*HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。\n\n- *方法名称是区分大小写的。\n当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。*\n\n---\n\n### TCP三次握手\n- 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；\n- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n- 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n\n### TCP四次挥手\n\n---\n\n### 状态码\n\n1xx：消息——请求已被服务器接收，继续处理\n2xx：成功——请求已成功被服务器接收、理解、并接受\n3xx：重定向——需要后续操作才能完成这一请求\n4xx：请求错误——请求含有词法错误或者无法被执行\n5xx：服务器错误——服务器在处理某个正确请求时发生错误\n\n---\n\n### http1.0和http1.1的区别\n\n- 缓存处理：增加缓存头来控制缓存策略。\n- 带宽优化及网络连接的使用：支持断点续传以及部分请求\n- 错误通知的管理：新增多个错误状态码\n- 互联网地址的维护：HTTP1.1的请求消息和响应消息都应支持Host头域\n- 长连接：一个tcp可用于多个http\n\n---\n\n\n### http缓存\n\n通过http获取网络数据的成本是非常高的，尤其是当需要大范围获取数据的时候，好在浏览器都有缓存策略\n\n1.使用 ETag 验证缓存的响应：\n服务器下发给客户端的时候在ETag头返回一个验证令牌Response Headers（ETag:\"58b4e12b-2492d\"）\n当客户端再次请求的时候讲令牌带上,Request Headers（If-None-Match:W/\"58b4e12b-2492d\"）\n服务端验证令牌如果没有发生改变则返回304\n\n\n2.Cache-Control：\n每个资源都可以通过 Cache-Control HTTP 头来定义自己的缓存策略\nCache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久\n\n``` html\nCache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了\n```\n- no-cache 和 no-store\nno-cache：表示必须先与服务器确认返回的响应是否被更改，然后通过ETag来判断是否需要下载资源。\nno-store：禁止浏览器和所有中继缓存存储返回的任何版本的响应。\n例如：一个包含个人隐私数据或银行数据的响应。每次用户请求该资源时，都会向服务器发送一个请求，每次都会下载完整的响应\n\n- public和private\n如果响应被标记为public，即使有关联的 HTTP 认证，甚至响应状态码无法正常缓存，响应也可以被缓存。大多数情况下，public不是必须的，因为明确的缓存信息（例如max-age）已表示 响应可以被缓存。\n相比之下，浏览器可以缓存private响应，但是通常只为单个用户缓存，因此，不允许任何中继缓存对其进行缓存 - 例如，用户浏览器可以缓存包含用户私人信息的 HTML 网页，但是 CDN 不能缓存。\n\n- max-age\n该指令指定从当前请求开始，允许获取的响应被重用的最长时间（单位为秒）\n\n- s-maxage\n同max-age，只用于共享缓存（比如CDN缓存）。\n\n- Last-modified（类似于ETag）\n服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式\n当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。\n\n\n3.expires：\nExpires 头指定了一个日期/时间， 在这个日期/时间之后，HTTP响应被认为是过时的\n如果还有一个 设置了 \"max-age\" 或者 \"s-max-age\" 指令的Cache-Control响应头，那么  Expires 头就会被忽略。\n\n\n### HTTP跨域\n\n当一个资源从该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个*跨域http请求*\n处于安全原因，浏览器会限制从脚本内发起的跨域http请求。\n例如，XMLHttpRequest和Fetch API遵循同源策略。 \n这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。\n\n（跨域并非不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如  Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。）———— MDN HTTP访问控制（CORS）\n\n*CORS*(跨域资源共享) 机制允许web应用服务进行跨域访问控制。现代浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险\n\n*跨域资源共享标准（ cross-origin sharing standard ）*允许在下列场景中使用跨域 HTTP 请求：\n\n```html\n1.由XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。\n2.Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。\n3.WebGL 贴图\n4.使用 drawImage 将 Images/video 画面绘制到 canvas\n5.样式表（使用 CSSOM）\n6.Scripts (未处理的异常)\n```\n\n\n跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的HTTP请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。\n（预检请求一般是浏览器检测到请求跨域之后自动发起的，预检请求报文中的 Access-Control-Request-Method 首部字段告知服务器实际请求所使用的 HTTP 方法；Access-Control-Request-Headers首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。）\n\n跨域请求分两种：简单请求和预检请求。\n\n##### 什么是简单请求?\n需要满足下列所有的条件，为简单请求。\n```html\n1.使用下列方法之一： GET/POST/HEAD\n\n2.Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：\nAccept\nAccept-Language\nContent-Language\nContent-Type （需要注意额外的限制）\nDPR\nDownlink\nSave-Data\nViewport-Width\nWidth\n\n3.content-type值仅限于下列三者之一\ntext/plain\nmultipart/form-data\napplication/x-www-form-urlencoded\n\n4.请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。\n\n5.请求中没有使用 ReadableStream 对象。\n```\n\n##### 附带身份凭证的跨域请求\n默认跨域请求是不会发送基于  HTTP cookies 和 HTTP 认证信息的身份凭证的。如果要发送身份凭证，需要设置XMLHttprequest的某个特殊标志位。\n如：\n```html\nxhr.withCredentials = true\n```\n之后，服务端需要在响应中携带下面的属性，浏览器才会将收到的响应内容返回给请求的发送者\n```html\nAccess-Control-Allow-Credentials: true // 响应头表示是否可以将对请求的相应暴露给页面。返回true则可以，其它则不可以\n```\n\n对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为（ * ）\n\n\n##### Access-Control-Allow-Origin，服务器响应首部字段。\n```html\nAccess-Control-Allow-Origin: <origin> | *\n```\n\n##### Access-Control-Expose-Headers \n在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。\n如：\n```html\nAccess-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header\n```\n\n##### Access-Control-Allow-Credentials\n```html\nAccess-Control-Allow-Credentials 头指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。\n```\n\n##### XDomainRequest (IE89专用)\nXDomainRequest是在IE8和IE9上的HTTP access control (CORS) 的实现，在IE10中被 包含CORS的XMLHttpRequest 取代了，如果你的开发目标是IE10或IE的后续版本，或想要支待其他的浏览器，你需要使用标准的HTTP access control。\n该接口可以发送GET和POST请求\nXDomainRequest为了确保安全构建，采用了多种方法。\n被请求的URL的服务器必须带有 设置为（“ * ”）或包含了请求方的Access-Control-Allow-Origin的头部。\n\n限制\n```html\n1.必须使用 HTTP 或 HTTPS 协议访问目标 URL(不能http、https跨协议访问)\n2.只能使用 HTTP 的 GET 方法和 POST 方法访问目标 URL\n3.请求中不能加入自定义的报头\n4.只支持 text/plain 作为请求报头Content-Type的取值\n5.身份验证和cookie不能和请求一起发送 （解决办法，将cookie等信息放在请求body里面）\n...\n```\n\n\n---\n\n## 相关链接\n\n### 维基百科（需代理方能打开）\nhttps://zh.wikipedia.org/wiki/超文本传输协议\n\n### http1.0和http1.1的区别\nhttp://blog.csdn.net/forgotaboutgirl/article/details/6936982\n\n### http、socket、tcp/ip的区别\nhttp://jingyan.baidu.com/article/08b6a591e07ecc14a80922f1.html\n\n### http缓存\nhttps://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\n\nhttp://www.alloyteam.com/2016/03/discussion-on-web-caching/\n\n### http状态码\n\nhttps://zh.wikipedia.org/wiki/HTTP状态码\n\n### XDomainRequest\nhttps://www.cnblogs.com/onepixel/articles/7567948.html\n\n### 三次握手与四次挥手\nhttps://zhuanlan.zhihu.com/p/53374516\nhttps://hit-alibaba.github.io/interview/basic/network/TCP.html","slug":"http","published":1,"updated":"2021-03-30T01:32:00.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufh000ha0vz59nc548g","content":"<p>超文本传输协议（HyperText Transfer Protocol，缩写：HTTP）是互联网上应用最为广泛的一种网络协议。<br>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。<br>通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。<br>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）</p>\n<p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。<br>HTTP服务器则在那个端口监听客户端的请求。<br>一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息</p>\n<h3 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/0.9</span><br><span class=\"line\">HTTP/1.0</span><br><span class=\"line\">HTTP/1.1</span><br><span class=\"line\">HTTP/2</span><br></pre></td></tr></table></figure>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源</p>\n<ul>\n<li><p><em>OPTIONS：</em>这个方法可以使服务器传回该资源所支持的所有HTTP请求方法。用’*‘来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p>\n</li>\n<li><p><em>GET：</em>向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。</p>\n</li>\n<li><p><em>HEAD：</em>与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</p>\n</li>\n<li><p><em>POST：</em>向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</p>\n</li>\n<li><p><em>PUT：</em>向指定资源位置上传其最新内容。</p>\n</li>\n<li><p><em>DELETE：</em>请求服务器删除Request-URI所标识的资源。</p>\n</li>\n<li><p><em>TRACE：</em>回显服务器收到的请求，主要用于测试或诊断。</p>\n</li>\n<li><p><em>CONNECT：</em>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</p>\n</li>\n<li><p><em>方法名称是区分大小写的。<br>当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。</em></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"TCP三次握手\"><a href=\"#TCP三次握手\" class=\"headerlink\" title=\"TCP三次握手\"></a>TCP三次握手</h3><ul>\n<li>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</li>\n<li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>\n<li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>\n</ul>\n<h3 id=\"TCP四次挥手\"><a href=\"#TCP四次挥手\" class=\"headerlink\" title=\"TCP四次挥手\"></a>TCP四次挥手</h3><hr>\n<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><p>1xx：消息——请求已被服务器接收，继续处理<br>2xx：成功——请求已成功被服务器接收、理解、并接受<br>3xx：重定向——需要后续操作才能完成这一请求<br>4xx：请求错误——请求含有词法错误或者无法被执行<br>5xx：服务器错误——服务器在处理某个正确请求时发生错误</p>\n<hr>\n<h3 id=\"http1-0和http1-1的区别\"><a href=\"#http1-0和http1-1的区别\" class=\"headerlink\" title=\"http1.0和http1.1的区别\"></a>http1.0和http1.1的区别</h3><ul>\n<li>缓存处理：增加缓存头来控制缓存策略。</li>\n<li>带宽优化及网络连接的使用：支持断点续传以及部分请求</li>\n<li>错误通知的管理：新增多个错误状态码</li>\n<li>互联网地址的维护：HTTP1.1的请求消息和响应消息都应支持Host头域</li>\n<li>长连接：一个tcp可用于多个http</li>\n</ul>\n<hr>\n<h3 id=\"http缓存\"><a href=\"#http缓存\" class=\"headerlink\" title=\"http缓存\"></a>http缓存</h3><p>通过http获取网络数据的成本是非常高的，尤其是当需要大范围获取数据的时候，好在浏览器都有缓存策略</p>\n<p>1.使用 ETag 验证缓存的响应：<br>服务器下发给客户端的时候在ETag头返回一个验证令牌Response Headers（ETag:”58b4e12b-2492d”）<br>当客户端再次请求的时候讲令牌带上,Request Headers（If-None-Match:W/“58b4e12b-2492d”）<br>服务端验证令牌如果没有发生改变则返回304</p>\n<p>2.Cache-Control：<br>每个资源都可以通过 Cache-Control HTTP 头来定义自己的缓存策略<br>Cache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>no-cache 和 no-store<br>no-cache：表示必须先与服务器确认返回的响应是否被更改，然后通过ETag来判断是否需要下载资源。<br>no-store：禁止浏览器和所有中继缓存存储返回的任何版本的响应。<br>例如：一个包含个人隐私数据或银行数据的响应。每次用户请求该资源时，都会向服务器发送一个请求，每次都会下载完整的响应</p>\n</li>\n<li><p>public和private<br>如果响应被标记为public，即使有关联的 HTTP 认证，甚至响应状态码无法正常缓存，响应也可以被缓存。大多数情况下，public不是必须的，因为明确的缓存信息（例如max-age）已表示 响应可以被缓存。<br>相比之下，浏览器可以缓存private响应，但是通常只为单个用户缓存，因此，不允许任何中继缓存对其进行缓存 - 例如，用户浏览器可以缓存包含用户私人信息的 HTML 网页，但是 CDN 不能缓存。</p>\n</li>\n<li><p>max-age<br>该指令指定从当前请求开始，允许获取的响应被重用的最长时间（单位为秒）</p>\n</li>\n<li><p>s-maxage<br>同max-age，只用于共享缓存（比如CDN缓存）。</p>\n</li>\n<li><p>Last-modified（类似于ETag）<br>服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式<br>当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。</p>\n</li>\n</ul>\n<p>3.expires：<br>Expires 头指定了一个日期/时间， 在这个日期/时间之后，HTTP响应被认为是过时的<br>如果还有一个 设置了 “max-age” 或者 “s-max-age” 指令的Cache-Control响应头，那么  Expires 头就会被忽略。</p>\n<h3 id=\"HTTP跨域\"><a href=\"#HTTP跨域\" class=\"headerlink\" title=\"HTTP跨域\"></a>HTTP跨域</h3><p>当一个资源从该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个<em>跨域http请求</em><br>处于安全原因，浏览器会限制从脚本内发起的跨域http请求。<br>例如，XMLHttpRequest和Fetch API遵循同源策略。<br>这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。</p>\n<p>（跨域并非不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如  Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。）———— MDN HTTP访问控制（CORS）</p>\n<p><em>CORS</em>(跨域资源共享) 机制允许web应用服务进行跨域访问控制。现代浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险</p>\n<p><em>跨域资源共享标准（ cross-origin sharing standard ）</em>允许在下列场景中使用跨域 HTTP 请求：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.由XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。</span><br><span class=\"line\">2.Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。</span><br><span class=\"line\">3.WebGL 贴图</span><br><span class=\"line\">4.使用 drawImage 将 Images/video 画面绘制到 canvas</span><br><span class=\"line\">5.样式表（使用 CSSOM）</span><br><span class=\"line\">6.Scripts (未处理的异常)</span><br></pre></td></tr></table></figure>\n<p>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的HTTP请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。<br>（预检请求一般是浏览器检测到请求跨域之后自动发起的，预检请求报文中的 Access-Control-Request-Method 首部字段告知服务器实际请求所使用的 HTTP 方法；Access-Control-Request-Headers首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。）</p>\n<p>跨域请求分两种：简单请求和预检请求。</p>\n<h5 id=\"什么是简单请求\"><a href=\"#什么是简单请求\" class=\"headerlink\" title=\"什么是简单请求?\"></a>什么是简单请求?</h5><p>需要满足下列所有的条件，为简单请求。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.使用下列方法之一： GET/POST/HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">2.Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：</span><br><span class=\"line\">Accept</span><br><span class=\"line\">Accept-Language</span><br><span class=\"line\">Content-Language</span><br><span class=\"line\">Content-Type （需要注意额外的限制）</span><br><span class=\"line\">DPR</span><br><span class=\"line\">Downlink</span><br><span class=\"line\">Save-Data</span><br><span class=\"line\">Viewport-Width</span><br><span class=\"line\">Width</span><br><span class=\"line\"></span><br><span class=\"line\">3.content-type值仅限于下列三者之一</span><br><span class=\"line\">text/plain</span><br><span class=\"line\">multipart/form-data</span><br><span class=\"line\">application/x-www-form-urlencoded</span><br><span class=\"line\"></span><br><span class=\"line\">4.请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</span><br><span class=\"line\"></span><br><span class=\"line\">5.请求中没有使用 ReadableStream 对象。</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"附带身份凭证的跨域请求\"><a href=\"#附带身份凭证的跨域请求\" class=\"headerlink\" title=\"附带身份凭证的跨域请求\"></a>附带身份凭证的跨域请求</h5><p>默认跨域请求是不会发送基于  HTTP cookies 和 HTTP 认证信息的身份凭证的。如果要发送身份凭证，需要设置XMLHttprequest的某个特殊标志位。<br>如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.withCredentials = true</span><br></pre></td></tr></table></figure><br>之后，服务端需要在响应中携带下面的属性，浏览器才会将收到的响应内容返回给请求的发送者<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Credentials: true // 响应头表示是否可以将对请求的相应暴露给页面。返回true则可以，其它则不可以</span><br></pre></td></tr></table></figure></p>\n<p>对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为（ * ）</p>\n<h5 id=\"Access-Control-Allow-Origin，服务器响应首部字段。\"><a href=\"#Access-Control-Allow-Origin，服务器响应首部字段。\" class=\"headerlink\" title=\"Access-Control-Allow-Origin，服务器响应首部字段。\"></a>Access-Control-Allow-Origin，服务器响应首部字段。</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: <span class=\"tag\">&lt;<span class=\"name\">origin</span>&gt;</span> | *</span><br></pre></td></tr></table></figure>\n<h5 id=\"Access-Control-Expose-Headers\"><a href=\"#Access-Control-Expose-Headers\" class=\"headerlink\" title=\"Access-Control-Expose-Headers\"></a>Access-Control-Expose-Headers</h5><p>在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。<br>如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Access-Control-Allow-Credentials\"><a href=\"#Access-Control-Allow-Credentials\" class=\"headerlink\" title=\"Access-Control-Allow-Credentials\"></a>Access-Control-Allow-Credentials</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Credentials 头指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。</span><br></pre></td></tr></table></figure>\n<h5 id=\"XDomainRequest-IE89专用\"><a href=\"#XDomainRequest-IE89专用\" class=\"headerlink\" title=\"XDomainRequest (IE89专用)\"></a>XDomainRequest (IE89专用)</h5><p>XDomainRequest是在IE8和IE9上的HTTP access control (CORS) 的实现，在IE10中被 包含CORS的XMLHttpRequest 取代了，如果你的开发目标是IE10或IE的后续版本，或想要支待其他的浏览器，你需要使用标准的HTTP access control。<br>该接口可以发送GET和POST请求<br>XDomainRequest为了确保安全构建，采用了多种方法。<br>被请求的URL的服务器必须带有 设置为（“ * ”）或包含了请求方的Access-Control-Allow-Origin的头部。</p>\n<p>限制<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.必须使用 HTTP 或 HTTPS 协议访问目标 URL(不能http、https跨协议访问)</span><br><span class=\"line\">2.只能使用 HTTP 的 GET 方法和 POST 方法访问目标 URL</span><br><span class=\"line\">3.请求中不能加入自定义的报头</span><br><span class=\"line\">4.只支持 text/plain 作为请求报头Content-Type的取值</span><br><span class=\"line\">5.身份验证和cookie不能和请求一起发送 （解决办法，将cookie等信息放在请求body里面）</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><h3 id=\"维基百科（需代理方能打开）\"><a href=\"#维基百科（需代理方能打开）\" class=\"headerlink\" title=\"维基百科（需代理方能打开）\"></a>维基百科（需代理方能打开）</h3><p><a href=\"https://zh.wikipedia.org/wiki/超文本传输协议\">https://zh.wikipedia.org/wiki/超文本传输协议</a></p>\n<h3 id=\"http1-0和http1-1的区别-1\"><a href=\"#http1-0和http1-1的区别-1\" class=\"headerlink\" title=\"http1.0和http1.1的区别\"></a>http1.0和http1.1的区别</h3><p><a href=\"http://blog.csdn.net/forgotaboutgirl/article/details/6936982\">http://blog.csdn.net/forgotaboutgirl/article/details/6936982</a></p>\n<h3 id=\"http、socket、tcp-ip的区别\"><a href=\"#http、socket、tcp-ip的区别\" class=\"headerlink\" title=\"http、socket、tcp/ip的区别\"></a>http、socket、tcp/ip的区别</h3><p><a href=\"http://jingyan.baidu.com/article/08b6a591e07ecc14a80922f1.html\">http://jingyan.baidu.com/article/08b6a591e07ecc14a80922f1.html</a></p>\n<h3 id=\"http缓存-1\"><a href=\"#http缓存-1\" class=\"headerlink\" title=\"http缓存\"></a>http缓存</h3><p><a href=\"https://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\">https://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a></p>\n<p><a href=\"http://www.alloyteam.com/2016/03/discussion-on-web-caching/\">http://www.alloyteam.com/2016/03/discussion-on-web-caching/</a></p>\n<h3 id=\"http状态码\"><a href=\"#http状态码\" class=\"headerlink\" title=\"http状态码\"></a>http状态码</h3><p><a href=\"https://zh.wikipedia.org/wiki/HTTP状态码\">https://zh.wikipedia.org/wiki/HTTP状态码</a></p>\n<h3 id=\"XDomainRequest\"><a href=\"#XDomainRequest\" class=\"headerlink\" title=\"XDomainRequest\"></a>XDomainRequest</h3><p><a href=\"https://www.cnblogs.com/onepixel/articles/7567948.html\">https://www.cnblogs.com/onepixel/articles/7567948.html</a></p>\n<h3 id=\"三次握手与四次挥手\"><a href=\"#三次握手与四次挥手\" class=\"headerlink\" title=\"三次握手与四次挥手\"></a>三次握手与四次挥手</h3><p><a href=\"https://zhuanlan.zhihu.com/p/53374516\">https://zhuanlan.zhihu.com/p/53374516</a><br><a href=\"https://hit-alibaba.github.io/interview/basic/network/TCP.html\">https://hit-alibaba.github.io/interview/basic/network/TCP.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>超文本传输协议（HyperText Transfer Protocol，缩写：HTTP）是互联网上应用最为广泛的一种网络协议。<br>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。<br>通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。<br>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）</p>\n<p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。<br>HTTP服务器则在那个端口监听客户端的请求。<br>一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息</p>\n<h3 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/0.9</span><br><span class=\"line\">HTTP/1.0</span><br><span class=\"line\">HTTP/1.1</span><br><span class=\"line\">HTTP/2</span><br></pre></td></tr></table></figure>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源</p>\n<ul>\n<li><p><em>OPTIONS：</em>这个方法可以使服务器传回该资源所支持的所有HTTP请求方法。用’*‘来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p>\n</li>\n<li><p><em>GET：</em>向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。</p>\n</li>\n<li><p><em>HEAD：</em>与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</p>\n</li>\n<li><p><em>POST：</em>向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</p>\n</li>\n<li><p><em>PUT：</em>向指定资源位置上传其最新内容。</p>\n</li>\n<li><p><em>DELETE：</em>请求服务器删除Request-URI所标识的资源。</p>\n</li>\n<li><p><em>TRACE：</em>回显服务器收到的请求，主要用于测试或诊断。</p>\n</li>\n<li><p><em>CONNECT：</em>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</p>\n</li>\n<li><p><em>方法名称是区分大小写的。<br>当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。</em></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"TCP三次握手\"><a href=\"#TCP三次握手\" class=\"headerlink\" title=\"TCP三次握手\"></a>TCP三次握手</h3><ul>\n<li>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</li>\n<li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>\n<li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>\n</ul>\n<h3 id=\"TCP四次挥手\"><a href=\"#TCP四次挥手\" class=\"headerlink\" title=\"TCP四次挥手\"></a>TCP四次挥手</h3><hr>\n<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><p>1xx：消息——请求已被服务器接收，继续处理<br>2xx：成功——请求已成功被服务器接收、理解、并接受<br>3xx：重定向——需要后续操作才能完成这一请求<br>4xx：请求错误——请求含有词法错误或者无法被执行<br>5xx：服务器错误——服务器在处理某个正确请求时发生错误</p>\n<hr>\n<h3 id=\"http1-0和http1-1的区别\"><a href=\"#http1-0和http1-1的区别\" class=\"headerlink\" title=\"http1.0和http1.1的区别\"></a>http1.0和http1.1的区别</h3><ul>\n<li>缓存处理：增加缓存头来控制缓存策略。</li>\n<li>带宽优化及网络连接的使用：支持断点续传以及部分请求</li>\n<li>错误通知的管理：新增多个错误状态码</li>\n<li>互联网地址的维护：HTTP1.1的请求消息和响应消息都应支持Host头域</li>\n<li>长连接：一个tcp可用于多个http</li>\n</ul>\n<hr>\n<h3 id=\"http缓存\"><a href=\"#http缓存\" class=\"headerlink\" title=\"http缓存\"></a>http缓存</h3><p>通过http获取网络数据的成本是非常高的，尤其是当需要大范围获取数据的时候，好在浏览器都有缓存策略</p>\n<p>1.使用 ETag 验证缓存的响应：<br>服务器下发给客户端的时候在ETag头返回一个验证令牌Response Headers（ETag:”58b4e12b-2492d”）<br>当客户端再次请求的时候讲令牌带上,Request Headers（If-None-Match:W/“58b4e12b-2492d”）<br>服务端验证令牌如果没有发生改变则返回304</p>\n<p>2.Cache-Control：<br>每个资源都可以通过 Cache-Control HTTP 头来定义自己的缓存策略<br>Cache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>no-cache 和 no-store<br>no-cache：表示必须先与服务器确认返回的响应是否被更改，然后通过ETag来判断是否需要下载资源。<br>no-store：禁止浏览器和所有中继缓存存储返回的任何版本的响应。<br>例如：一个包含个人隐私数据或银行数据的响应。每次用户请求该资源时，都会向服务器发送一个请求，每次都会下载完整的响应</p>\n</li>\n<li><p>public和private<br>如果响应被标记为public，即使有关联的 HTTP 认证，甚至响应状态码无法正常缓存，响应也可以被缓存。大多数情况下，public不是必须的，因为明确的缓存信息（例如max-age）已表示 响应可以被缓存。<br>相比之下，浏览器可以缓存private响应，但是通常只为单个用户缓存，因此，不允许任何中继缓存对其进行缓存 - 例如，用户浏览器可以缓存包含用户私人信息的 HTML 网页，但是 CDN 不能缓存。</p>\n</li>\n<li><p>max-age<br>该指令指定从当前请求开始，允许获取的响应被重用的最长时间（单位为秒）</p>\n</li>\n<li><p>s-maxage<br>同max-age，只用于共享缓存（比如CDN缓存）。</p>\n</li>\n<li><p>Last-modified（类似于ETag）<br>服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式<br>当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。</p>\n</li>\n</ul>\n<p>3.expires：<br>Expires 头指定了一个日期/时间， 在这个日期/时间之后，HTTP响应被认为是过时的<br>如果还有一个 设置了 “max-age” 或者 “s-max-age” 指令的Cache-Control响应头，那么  Expires 头就会被忽略。</p>\n<h3 id=\"HTTP跨域\"><a href=\"#HTTP跨域\" class=\"headerlink\" title=\"HTTP跨域\"></a>HTTP跨域</h3><p>当一个资源从该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个<em>跨域http请求</em><br>处于安全原因，浏览器会限制从脚本内发起的跨域http请求。<br>例如，XMLHttpRequest和Fetch API遵循同源策略。<br>这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。</p>\n<p>（跨域并非不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如  Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。）———— MDN HTTP访问控制（CORS）</p>\n<p><em>CORS</em>(跨域资源共享) 机制允许web应用服务进行跨域访问控制。现代浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险</p>\n<p><em>跨域资源共享标准（ cross-origin sharing standard ）</em>允许在下列场景中使用跨域 HTTP 请求：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.由XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。</span><br><span class=\"line\">2.Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。</span><br><span class=\"line\">3.WebGL 贴图</span><br><span class=\"line\">4.使用 drawImage 将 Images/video 画面绘制到 canvas</span><br><span class=\"line\">5.样式表（使用 CSSOM）</span><br><span class=\"line\">6.Scripts (未处理的异常)</span><br></pre></td></tr></table></figure>\n<p>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的HTTP请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。<br>（预检请求一般是浏览器检测到请求跨域之后自动发起的，预检请求报文中的 Access-Control-Request-Method 首部字段告知服务器实际请求所使用的 HTTP 方法；Access-Control-Request-Headers首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。）</p>\n<p>跨域请求分两种：简单请求和预检请求。</p>\n<h5 id=\"什么是简单请求\"><a href=\"#什么是简单请求\" class=\"headerlink\" title=\"什么是简单请求?\"></a>什么是简单请求?</h5><p>需要满足下列所有的条件，为简单请求。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.使用下列方法之一： GET/POST/HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">2.Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：</span><br><span class=\"line\">Accept</span><br><span class=\"line\">Accept-Language</span><br><span class=\"line\">Content-Language</span><br><span class=\"line\">Content-Type （需要注意额外的限制）</span><br><span class=\"line\">DPR</span><br><span class=\"line\">Downlink</span><br><span class=\"line\">Save-Data</span><br><span class=\"line\">Viewport-Width</span><br><span class=\"line\">Width</span><br><span class=\"line\"></span><br><span class=\"line\">3.content-type值仅限于下列三者之一</span><br><span class=\"line\">text/plain</span><br><span class=\"line\">multipart/form-data</span><br><span class=\"line\">application/x-www-form-urlencoded</span><br><span class=\"line\"></span><br><span class=\"line\">4.请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</span><br><span class=\"line\"></span><br><span class=\"line\">5.请求中没有使用 ReadableStream 对象。</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"附带身份凭证的跨域请求\"><a href=\"#附带身份凭证的跨域请求\" class=\"headerlink\" title=\"附带身份凭证的跨域请求\"></a>附带身份凭证的跨域请求</h5><p>默认跨域请求是不会发送基于  HTTP cookies 和 HTTP 认证信息的身份凭证的。如果要发送身份凭证，需要设置XMLHttprequest的某个特殊标志位。<br>如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.withCredentials = true</span><br></pre></td></tr></table></figure><br>之后，服务端需要在响应中携带下面的属性，浏览器才会将收到的响应内容返回给请求的发送者<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Credentials: true // 响应头表示是否可以将对请求的相应暴露给页面。返回true则可以，其它则不可以</span><br></pre></td></tr></table></figure></p>\n<p>对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为（ * ）</p>\n<h5 id=\"Access-Control-Allow-Origin，服务器响应首部字段。\"><a href=\"#Access-Control-Allow-Origin，服务器响应首部字段。\" class=\"headerlink\" title=\"Access-Control-Allow-Origin，服务器响应首部字段。\"></a>Access-Control-Allow-Origin，服务器响应首部字段。</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Origin: <span class=\"tag\">&lt;<span class=\"name\">origin</span>&gt;</span> | *</span><br></pre></td></tr></table></figure>\n<h5 id=\"Access-Control-Expose-Headers\"><a href=\"#Access-Control-Expose-Headers\" class=\"headerlink\" title=\"Access-Control-Expose-Headers\"></a>Access-Control-Expose-Headers</h5><p>在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。<br>如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Access-Control-Allow-Credentials\"><a href=\"#Access-Control-Allow-Credentials\" class=\"headerlink\" title=\"Access-Control-Allow-Credentials\"></a>Access-Control-Allow-Credentials</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Credentials 头指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。</span><br></pre></td></tr></table></figure>\n<h5 id=\"XDomainRequest-IE89专用\"><a href=\"#XDomainRequest-IE89专用\" class=\"headerlink\" title=\"XDomainRequest (IE89专用)\"></a>XDomainRequest (IE89专用)</h5><p>XDomainRequest是在IE8和IE9上的HTTP access control (CORS) 的实现，在IE10中被 包含CORS的XMLHttpRequest 取代了，如果你的开发目标是IE10或IE的后续版本，或想要支待其他的浏览器，你需要使用标准的HTTP access control。<br>该接口可以发送GET和POST请求<br>XDomainRequest为了确保安全构建，采用了多种方法。<br>被请求的URL的服务器必须带有 设置为（“ * ”）或包含了请求方的Access-Control-Allow-Origin的头部。</p>\n<p>限制<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.必须使用 HTTP 或 HTTPS 协议访问目标 URL(不能http、https跨协议访问)</span><br><span class=\"line\">2.只能使用 HTTP 的 GET 方法和 POST 方法访问目标 URL</span><br><span class=\"line\">3.请求中不能加入自定义的报头</span><br><span class=\"line\">4.只支持 text/plain 作为请求报头Content-Type的取值</span><br><span class=\"line\">5.身份验证和cookie不能和请求一起发送 （解决办法，将cookie等信息放在请求body里面）</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><h3 id=\"维基百科（需代理方能打开）\"><a href=\"#维基百科（需代理方能打开）\" class=\"headerlink\" title=\"维基百科（需代理方能打开）\"></a>维基百科（需代理方能打开）</h3><p><a href=\"https://zh.wikipedia.org/wiki/超文本传输协议\">https://zh.wikipedia.org/wiki/超文本传输协议</a></p>\n<h3 id=\"http1-0和http1-1的区别-1\"><a href=\"#http1-0和http1-1的区别-1\" class=\"headerlink\" title=\"http1.0和http1.1的区别\"></a>http1.0和http1.1的区别</h3><p><a href=\"http://blog.csdn.net/forgotaboutgirl/article/details/6936982\">http://blog.csdn.net/forgotaboutgirl/article/details/6936982</a></p>\n<h3 id=\"http、socket、tcp-ip的区别\"><a href=\"#http、socket、tcp-ip的区别\" class=\"headerlink\" title=\"http、socket、tcp/ip的区别\"></a>http、socket、tcp/ip的区别</h3><p><a href=\"http://jingyan.baidu.com/article/08b6a591e07ecc14a80922f1.html\">http://jingyan.baidu.com/article/08b6a591e07ecc14a80922f1.html</a></p>\n<h3 id=\"http缓存-1\"><a href=\"#http缓存-1\" class=\"headerlink\" title=\"http缓存\"></a>http缓存</h3><p><a href=\"https://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\">https://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a></p>\n<p><a href=\"http://www.alloyteam.com/2016/03/discussion-on-web-caching/\">http://www.alloyteam.com/2016/03/discussion-on-web-caching/</a></p>\n<h3 id=\"http状态码\"><a href=\"#http状态码\" class=\"headerlink\" title=\"http状态码\"></a>http状态码</h3><p><a href=\"https://zh.wikipedia.org/wiki/HTTP状态码\">https://zh.wikipedia.org/wiki/HTTP状态码</a></p>\n<h3 id=\"XDomainRequest\"><a href=\"#XDomainRequest\" class=\"headerlink\" title=\"XDomainRequest\"></a>XDomainRequest</h3><p><a href=\"https://www.cnblogs.com/onepixel/articles/7567948.html\">https://www.cnblogs.com/onepixel/articles/7567948.html</a></p>\n<h3 id=\"三次握手与四次挥手\"><a href=\"#三次握手与四次挥手\" class=\"headerlink\" title=\"三次握手与四次挥手\"></a>三次握手与四次挥手</h3><p><a href=\"https://zhuanlan.zhihu.com/p/53374516\">https://zhuanlan.zhihu.com/p/53374516</a><br><a href=\"https://hit-alibaba.github.io/interview/basic/network/TCP.html\">https://hit-alibaba.github.io/interview/basic/network/TCP.html</a></p>\n"},{"title":"Http2基础及本地环境搭建","date":"2016-12-28T16:00:00.000Z","_content":"\nHttp/2,超文本传输协议第二版，最初命名为http2.0,是http协议的第二个版本，使用于万维网。\n它是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。\n随着http2的标准的确定，各大浏览器的大力支持，http2这个字眼开始出现在我们的视野里。\n为什么要使用http2呢，它和之前的http有什么区别？\n\n### 相对于http1.1的优点\n\n``` html\n1.多路复用、请求优化：一个连接内可以有无限个并行的请求即允许多个并行的http请求共用一个tpc连接。\n多路复用还可以设置优先级，让重要的资源先行。\n\n2.压缩了 HTTP 头：多个请求\n\n3.支持服务器推送：可以将一些资源直接通过服务器推送到用户端，减少请求次数。\n\n4.强制使用SSL传输协议\n```\n\n\n### Http2的安装注意事项\n\n``` html\n1.Http2是基于https的，因此，在使用Http2之前，首先需要弄好https，也就是需要申请网站证书。\n我这里用的是腾讯云的主机、腾讯云的域名、腾讯云的证书（买域名免费用，文章后面有传送门，https证书的申请、证书的安装）。\n\n2.需要Nginx版本1.9.5及以上。\n从最新发布的 Nginx 1.9.5 开始，httpv2module 已经替换了 ngxhttpspdy_module 并正式开始提供全面的 HTTP/2 支持。\n\n3.openssl版本1.0.2及以上。\nHttp2 需要扩展支持，可以用的有 ALPN 和 NPN 两种（Chrome 已经移除了对 NPN 的支持）\n为了使用 ALPN 需要将 OpenSSL 升级到 1.0.2 以上版本。\n```\nps:\n本人就是卡在这里卡了几天，折腾了好久最终重装了ubuntu系统 Ubuntu Server 16.04.1。\n因为，Ubuntu 16.04 LTS 1.0.2g,之前的版本自带的openssl都不支持http2\n当然爱折腾的也可以在不升级系统的情况下，自己安装新的openssl、然后进行一系列的重新编译nginx\n\n\n### 查看nginx和openssl版本\n``` shell\nopenssl version # LibreSSL 2.2.7\nnginx -v # nginx version: nginx/1.10.1\nnginx -V # 同上\n```\n\n\n#### http2配置\n\n在上面https的配置里面找到之前配置443的地方，加上一个http2就可以了\n\n``` html\nserver {\n    listen 443 http2;\n    server_name localhost;\n    ssl on;\n    ssl_certificate 1_www.domain.com_bundle.crt;\n    ssl_certificate_key 2_www.domain.com.key;\n    ssl_session_timeout 5m;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;\n    ssl_prefer_server_ciphers on;\n    location / {\n        root   html;\n        index  index.html index.htm;\n    }\n}\n```\n\n至此，正http2环境已经搭建完成，刷新页面，就可以看见网站的请求已经变成了http2了 \n\neg:https://www.epoos.com/\n\n\n\n\n\n### 传送门：\n\n#### http2的兼容性\n\nhttp://caniuse.com/#search=http2\n\n#### https证书申请\n\nhttps://www.qcloud.com/document/product/214/6989\n\n#### https证书安装\n\nhttps://www.qcloud.com/document/product/400/4143\n\n#### Supporting HTTP/2\n\nhttps://www.nginx.com/blog/supporting-http2-google-chrome-users/","source":"_posts/http2.md","raw":"---\ntitle: Http2基础及本地环境搭建\ndate: 2016/12/29\ntag: http2\ncategory: 技术\n---\n\nHttp/2,超文本传输协议第二版，最初命名为http2.0,是http协议的第二个版本，使用于万维网。\n它是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。\n随着http2的标准的确定，各大浏览器的大力支持，http2这个字眼开始出现在我们的视野里。\n为什么要使用http2呢，它和之前的http有什么区别？\n\n### 相对于http1.1的优点\n\n``` html\n1.多路复用、请求优化：一个连接内可以有无限个并行的请求即允许多个并行的http请求共用一个tpc连接。\n多路复用还可以设置优先级，让重要的资源先行。\n\n2.压缩了 HTTP 头：多个请求\n\n3.支持服务器推送：可以将一些资源直接通过服务器推送到用户端，减少请求次数。\n\n4.强制使用SSL传输协议\n```\n\n\n### Http2的安装注意事项\n\n``` html\n1.Http2是基于https的，因此，在使用Http2之前，首先需要弄好https，也就是需要申请网站证书。\n我这里用的是腾讯云的主机、腾讯云的域名、腾讯云的证书（买域名免费用，文章后面有传送门，https证书的申请、证书的安装）。\n\n2.需要Nginx版本1.9.5及以上。\n从最新发布的 Nginx 1.9.5 开始，httpv2module 已经替换了 ngxhttpspdy_module 并正式开始提供全面的 HTTP/2 支持。\n\n3.openssl版本1.0.2及以上。\nHttp2 需要扩展支持，可以用的有 ALPN 和 NPN 两种（Chrome 已经移除了对 NPN 的支持）\n为了使用 ALPN 需要将 OpenSSL 升级到 1.0.2 以上版本。\n```\nps:\n本人就是卡在这里卡了几天，折腾了好久最终重装了ubuntu系统 Ubuntu Server 16.04.1。\n因为，Ubuntu 16.04 LTS 1.0.2g,之前的版本自带的openssl都不支持http2\n当然爱折腾的也可以在不升级系统的情况下，自己安装新的openssl、然后进行一系列的重新编译nginx\n\n\n### 查看nginx和openssl版本\n``` shell\nopenssl version # LibreSSL 2.2.7\nnginx -v # nginx version: nginx/1.10.1\nnginx -V # 同上\n```\n\n\n#### http2配置\n\n在上面https的配置里面找到之前配置443的地方，加上一个http2就可以了\n\n``` html\nserver {\n    listen 443 http2;\n    server_name localhost;\n    ssl on;\n    ssl_certificate 1_www.domain.com_bundle.crt;\n    ssl_certificate_key 2_www.domain.com.key;\n    ssl_session_timeout 5m;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;\n    ssl_prefer_server_ciphers on;\n    location / {\n        root   html;\n        index  index.html index.htm;\n    }\n}\n```\n\n至此，正http2环境已经搭建完成，刷新页面，就可以看见网站的请求已经变成了http2了 \n\neg:https://www.epoos.com/\n\n\n\n\n\n### 传送门：\n\n#### http2的兼容性\n\nhttp://caniuse.com/#search=http2\n\n#### https证书申请\n\nhttps://www.qcloud.com/document/product/214/6989\n\n#### https证书安装\n\nhttps://www.qcloud.com/document/product/400/4143\n\n#### Supporting HTTP/2\n\nhttps://www.nginx.com/blog/supporting-http2-google-chrome-users/","slug":"http2","published":1,"updated":"2021-03-30T01:32:00.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufi000ia0vzcj2b13d4","content":"<p>Http/2,超文本传输协议第二版，最初命名为http2.0,是http协议的第二个版本，使用于万维网。<br>它是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。<br>随着http2的标准的确定，各大浏览器的大力支持，http2这个字眼开始出现在我们的视野里。<br>为什么要使用http2呢，它和之前的http有什么区别？</p>\n<h3 id=\"相对于http1-1的优点\"><a href=\"#相对于http1-1的优点\" class=\"headerlink\" title=\"相对于http1.1的优点\"></a>相对于http1.1的优点</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.多路复用、请求优化：一个连接内可以有无限个并行的请求即允许多个并行的http请求共用一个tpc连接。</span><br><span class=\"line\">多路复用还可以设置优先级，让重要的资源先行。</span><br><span class=\"line\"></span><br><span class=\"line\">2.压缩了 HTTP 头：多个请求</span><br><span class=\"line\"></span><br><span class=\"line\">3.支持服务器推送：可以将一些资源直接通过服务器推送到用户端，减少请求次数。</span><br><span class=\"line\"></span><br><span class=\"line\">4.强制使用SSL传输协议</span><br></pre></td></tr></table></figure>\n<h3 id=\"Http2的安装注意事项\"><a href=\"#Http2的安装注意事项\" class=\"headerlink\" title=\"Http2的安装注意事项\"></a>Http2的安装注意事项</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.Http2是基于https的，因此，在使用Http2之前，首先需要弄好https，也就是需要申请网站证书。</span><br><span class=\"line\">我这里用的是腾讯云的主机、腾讯云的域名、腾讯云的证书（买域名免费用，文章后面有传送门，https证书的申请、证书的安装）。</span><br><span class=\"line\"></span><br><span class=\"line\">2.需要Nginx版本1.9.5及以上。</span><br><span class=\"line\">从最新发布的 Nginx 1.9.5 开始，httpv2module 已经替换了 ngxhttpspdy_module 并正式开始提供全面的 HTTP/2 支持。</span><br><span class=\"line\"></span><br><span class=\"line\">3.openssl版本1.0.2及以上。</span><br><span class=\"line\">Http2 需要扩展支持，可以用的有 ALPN 和 NPN 两种（Chrome 已经移除了对 NPN 的支持）</span><br><span class=\"line\">为了使用 ALPN 需要将 OpenSSL 升级到 1.0.2 以上版本。</span><br></pre></td></tr></table></figure>\n<p>ps:<br>本人就是卡在这里卡了几天，折腾了好久最终重装了ubuntu系统 Ubuntu Server 16.04.1。<br>因为，Ubuntu 16.04 LTS 1.0.2g,之前的版本自带的openssl都不支持http2<br>当然爱折腾的也可以在不升级系统的情况下，自己安装新的openssl、然后进行一系列的重新编译nginx</p>\n<h3 id=\"查看nginx和openssl版本\"><a href=\"#查看nginx和openssl版本\" class=\"headerlink\" title=\"查看nginx和openssl版本\"></a>查看nginx和openssl版本</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl version # LibreSSL 2.2.7</span><br><span class=\"line\">nginx -v # nginx version: nginx/1.10.1</span><br><span class=\"line\">nginx -V # 同上</span><br></pre></td></tr></table></figure>\n<h4 id=\"http2配置\"><a href=\"#http2配置\" class=\"headerlink\" title=\"http2配置\"></a>http2配置</h4><p>在上面https的配置里面找到之前配置443的地方，加上一个http2就可以了</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443 http2;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\">    ssl on;</span><br><span class=\"line\">    ssl_certificate 1_www.domain.com_bundle.crt;</span><br><span class=\"line\">    ssl_certificate_key 2_www.domain.com.key;</span><br><span class=\"line\">    ssl_session_timeout 5m;</span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   html;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，正http2环境已经搭建完成，刷新页面，就可以看见网站的请求已经变成了http2了 </p>\n<p>eg:<a href=\"https://www.epoos.com/\">https://www.epoos.com/</a></p>\n<h3 id=\"传送门：\"><a href=\"#传送门：\" class=\"headerlink\" title=\"传送门：\"></a>传送门：</h3><h4 id=\"http2的兼容性\"><a href=\"#http2的兼容性\" class=\"headerlink\" title=\"http2的兼容性\"></a>http2的兼容性</h4><p><a href=\"http://caniuse.com/#search=http2\">http://caniuse.com/#search=http2</a></p>\n<h4 id=\"https证书申请\"><a href=\"#https证书申请\" class=\"headerlink\" title=\"https证书申请\"></a>https证书申请</h4><p><a href=\"https://www.qcloud.com/document/product/214/6989\">https://www.qcloud.com/document/product/214/6989</a></p>\n<h4 id=\"https证书安装\"><a href=\"#https证书安装\" class=\"headerlink\" title=\"https证书安装\"></a>https证书安装</h4><p><a href=\"https://www.qcloud.com/document/product/400/4143\">https://www.qcloud.com/document/product/400/4143</a></p>\n<h4 id=\"Supporting-HTTP-2\"><a href=\"#Supporting-HTTP-2\" class=\"headerlink\" title=\"Supporting HTTP/2\"></a>Supporting HTTP/2</h4><p><a href=\"https://www.nginx.com/blog/supporting-http2-google-chrome-users/\">https://www.nginx.com/blog/supporting-http2-google-chrome-users/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Http/2,超文本传输协议第二版，最初命名为http2.0,是http协议的第二个版本，使用于万维网。<br>它是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。<br>随着http2的标准的确定，各大浏览器的大力支持，http2这个字眼开始出现在我们的视野里。<br>为什么要使用http2呢，它和之前的http有什么区别？</p>\n<h3 id=\"相对于http1-1的优点\"><a href=\"#相对于http1-1的优点\" class=\"headerlink\" title=\"相对于http1.1的优点\"></a>相对于http1.1的优点</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.多路复用、请求优化：一个连接内可以有无限个并行的请求即允许多个并行的http请求共用一个tpc连接。</span><br><span class=\"line\">多路复用还可以设置优先级，让重要的资源先行。</span><br><span class=\"line\"></span><br><span class=\"line\">2.压缩了 HTTP 头：多个请求</span><br><span class=\"line\"></span><br><span class=\"line\">3.支持服务器推送：可以将一些资源直接通过服务器推送到用户端，减少请求次数。</span><br><span class=\"line\"></span><br><span class=\"line\">4.强制使用SSL传输协议</span><br></pre></td></tr></table></figure>\n<h3 id=\"Http2的安装注意事项\"><a href=\"#Http2的安装注意事项\" class=\"headerlink\" title=\"Http2的安装注意事项\"></a>Http2的安装注意事项</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.Http2是基于https的，因此，在使用Http2之前，首先需要弄好https，也就是需要申请网站证书。</span><br><span class=\"line\">我这里用的是腾讯云的主机、腾讯云的域名、腾讯云的证书（买域名免费用，文章后面有传送门，https证书的申请、证书的安装）。</span><br><span class=\"line\"></span><br><span class=\"line\">2.需要Nginx版本1.9.5及以上。</span><br><span class=\"line\">从最新发布的 Nginx 1.9.5 开始，httpv2module 已经替换了 ngxhttpspdy_module 并正式开始提供全面的 HTTP/2 支持。</span><br><span class=\"line\"></span><br><span class=\"line\">3.openssl版本1.0.2及以上。</span><br><span class=\"line\">Http2 需要扩展支持，可以用的有 ALPN 和 NPN 两种（Chrome 已经移除了对 NPN 的支持）</span><br><span class=\"line\">为了使用 ALPN 需要将 OpenSSL 升级到 1.0.2 以上版本。</span><br></pre></td></tr></table></figure>\n<p>ps:<br>本人就是卡在这里卡了几天，折腾了好久最终重装了ubuntu系统 Ubuntu Server 16.04.1。<br>因为，Ubuntu 16.04 LTS 1.0.2g,之前的版本自带的openssl都不支持http2<br>当然爱折腾的也可以在不升级系统的情况下，自己安装新的openssl、然后进行一系列的重新编译nginx</p>\n<h3 id=\"查看nginx和openssl版本\"><a href=\"#查看nginx和openssl版本\" class=\"headerlink\" title=\"查看nginx和openssl版本\"></a>查看nginx和openssl版本</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl version # LibreSSL 2.2.7</span><br><span class=\"line\">nginx -v # nginx version: nginx/1.10.1</span><br><span class=\"line\">nginx -V # 同上</span><br></pre></td></tr></table></figure>\n<h4 id=\"http2配置\"><a href=\"#http2配置\" class=\"headerlink\" title=\"http2配置\"></a>http2配置</h4><p>在上面https的配置里面找到之前配置443的地方，加上一个http2就可以了</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443 http2;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\">    ssl on;</span><br><span class=\"line\">    ssl_certificate 1_www.domain.com_bundle.crt;</span><br><span class=\"line\">    ssl_certificate_key 2_www.domain.com.key;</span><br><span class=\"line\">    ssl_session_timeout 5m;</span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   html;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，正http2环境已经搭建完成，刷新页面，就可以看见网站的请求已经变成了http2了 </p>\n<p>eg:<a href=\"https://www.epoos.com/\">https://www.epoos.com/</a></p>\n<h3 id=\"传送门：\"><a href=\"#传送门：\" class=\"headerlink\" title=\"传送门：\"></a>传送门：</h3><h4 id=\"http2的兼容性\"><a href=\"#http2的兼容性\" class=\"headerlink\" title=\"http2的兼容性\"></a>http2的兼容性</h4><p><a href=\"http://caniuse.com/#search=http2\">http://caniuse.com/#search=http2</a></p>\n<h4 id=\"https证书申请\"><a href=\"#https证书申请\" class=\"headerlink\" title=\"https证书申请\"></a>https证书申请</h4><p><a href=\"https://www.qcloud.com/document/product/214/6989\">https://www.qcloud.com/document/product/214/6989</a></p>\n<h4 id=\"https证书安装\"><a href=\"#https证书安装\" class=\"headerlink\" title=\"https证书安装\"></a>https证书安装</h4><p><a href=\"https://www.qcloud.com/document/product/400/4143\">https://www.qcloud.com/document/product/400/4143</a></p>\n<h4 id=\"Supporting-HTTP-2\"><a href=\"#Supporting-HTTP-2\" class=\"headerlink\" title=\"Supporting HTTP/2\"></a>Supporting HTTP/2</h4><p><a href=\"https://www.nginx.com/blog/supporting-http2-google-chrome-users/\">https://www.nginx.com/blog/supporting-http2-google-chrome-users/</a></p>\n"},{"title":"Http3基础","date":"2021-01-12T16:00:00.000Z","_content":"\n#### http2.0 相对于 http1.0 的优点\nhttp2.0的出现确实给互联网带来了很多的好处，相比于http1.0已经好很多很多了。\n```html\n二进制分帧，二进制协议替代原来的超文本文本协议，二进制格式在协议的解析和优化扩展上带来更多的优势和可能\n头部压缩，使用HPACK压缩头部信息，减少冗余信息的传输，节约带宽\n多路复用，多个请求可通过一个TCP连接进行并发完成。支持优先级和流量控制\n服务端推送，可以将js和css等资源预先推送到客服端(浏览器内存中)，当客户端使用的时候不需要重新拉取。\n保护网站安全，只有https的网站可以使用http2.0，确保信息不回被明文传输。\n```\n\n#### QUIC 协议简介\nQUIC（ Quick UDP Internet Connections）,快速 UDP 网络连接，是一种实验性的网络协议，基于UDP协议在两端之间进行通信，支持多路复用。\n2018年10月，互联网工程任务组 HTTP 及 QUIC 工作小组正式将基于 QUIC 协议的 HTTP（英语：HTTP over QUIC）重命名为HTTP/3以为确立下一代规范做准备。\nQUIC旨在提供几乎等同于TCP连接的可靠性，但延迟大大减少\nQUIC使用UDP协议作为其基础，每个QUIC流是单独控制，在QUIC级别而不是UDP级别重传丢失的数据。如果在一个流中发生错误，协议栈仍然可以独立地继续为其他流提供服务。\n\n大多数情况下 TCP 协议通知数据包丢失或损坏之前可能会收到大量的正常数据，但是在纠正错误之前其他的正常请求都会等待甚至重发\n而QUIC 在修复单个流时可以自由处理其他数据，也就是说即使一个请求发生了错误也不会影响到其他的请求。\n\n\n#### http3.0相对于 http2.0 的优点\n优点都是比出来的，没有完美的技术，看起来极好极好的很完美的http2.0，其实也有存在很多问题\n```html\n一是对线头阻塞(HOL)问题的解决更为彻底，TCP传输数据时时，若一个数据包出现问题，TCP需要等待该包重传后，才能继续传输其它数据包，而QUIC基于UDP协议，一条链接上可以有多个流，当UDP数据包在出问题需要重传时，并不会对其他流的传输产生影响。同时还可以对关键包发送多次，从而解决队头阻塞问题。\n\n快速重启会话，切换网络时也能连接保持，可以内建与TCP中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接\n\n快速建立网络连接，最快零RTT建立连接，目前TCP与SSL/TLS(1.0,1.1,1.2)每次建连需要TCP三次握手+安全握手，需要4~5个RRT（RTT耗时包括三部分：往返传播时延、网络设备内排队时延、应用程序数据处理时延。），QUIC的 0RTT 对于第一次交互的客户端和服务端也是做不到的。\n\n前向安全。即使被人抓包存储起来，在未来某个时间点秘钥被破解后仍然不能解密。\n```\n\n#### http3.0 为什么使用 udp 而不使用 tcp\n基于TCP开发的设备和协议非常多，兼容困难\n提供了0-RTT支持，客户端可以在完成TLS协商前请求数，建立连接速度快\nTCP协议栈是Linux内部的重要部分，修改和升级成本很大\nUDP本身是无连接的、没有建链和拆链成本\nUDP的数据包无队头阻塞问题\nUDP改造成本小，tcp的历史包袱太重，改造成本太大\n#### http3.0 初体验\n由于当下http3.0还是正式推出，Nginx当前最新版本也不支持配置，所以如果要自己在自己的网站上使用http3.0还是很麻烦的，还得自己编译一个nginx内核。\n\n当然，如果仅仅是感受一下http3.0还是很简单的\nGoogle 搜索，Gmail 或者 Youtube官网，当前都已经使用了 Http3 协议了，只不过该功能被隐藏了起来。\n要想感受一下http3.0请求，只需在最新版本的chrome浏览器，然后给它开启 QUIC 特性即可。\n\n本人当前chrome版本\n```html\n版本 87.0.4280.141（正式版本） (x86_64) \n```\n开启方式\n```html\n在 chrome://flags/ 中找到 Experimental 中 QUIC protocol, 设置为Enabled. 重启浏览器生效\n```\n![http://zhoushirong.github.io/img/http3-1.png](http://zhoushirong.github.io/img/http3-1.png)\n\n判断自己的浏览器是否成功开启了http3.0的方法\n```html\n开着控制台访问Google，看看http请求是否是http3.0的协议\n```\n![http://zhoushirong.github.io/img/http3.png](http://zhoushirong.github.io/img/http3.png)\n\n或者安装这个chrome插件\n```html\n在 chrome store 里面安装 HTTP/2 and SPDY indicator 插件\n```\n安装之后如果看到插件栏有一个闪电图标说明开启成功了，此后如果访问http3请求的网站，这个图标会变成绿色。\n\n\n\n#### 什么是队头阻塞简介\n队头阻塞 Head-of-line blocking(缩写为HOL blocking)是计算机网络中是一种性能受限的现象，通俗来说就是：一个数据包影响了一堆数据包\n队头阻塞问题可能存在于HTTP层和TCP层，在HTTP1.x时两个层次都存在该问题。\nHTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在TCP层仍然存在队头阻塞问题。\nTCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。\n\n### 传送门\n[为什么HTTP3.0使用UDP协议](https://network.51cto.com/art/202009/625999.htm)\n\n[一文读懂 HTTP/2 及 HTTP/3 特性](https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/)\n\n[http2/http3协议有什么优劣](https://github.com/LuckyWinty/fe-weekly-questions/issues/3)\n\n[QUIC协议浅析与HTTP/3.0](https://www.jianshu.com/p/bb3eeb36b479)","source":"_posts/http3.md","raw":"---\ntitle: Http3基础\ndate: 2021/01/13\ntag: [http3,http]\ncategory: 笔记\n---\n\n#### http2.0 相对于 http1.0 的优点\nhttp2.0的出现确实给互联网带来了很多的好处，相比于http1.0已经好很多很多了。\n```html\n二进制分帧，二进制协议替代原来的超文本文本协议，二进制格式在协议的解析和优化扩展上带来更多的优势和可能\n头部压缩，使用HPACK压缩头部信息，减少冗余信息的传输，节约带宽\n多路复用，多个请求可通过一个TCP连接进行并发完成。支持优先级和流量控制\n服务端推送，可以将js和css等资源预先推送到客服端(浏览器内存中)，当客户端使用的时候不需要重新拉取。\n保护网站安全，只有https的网站可以使用http2.0，确保信息不回被明文传输。\n```\n\n#### QUIC 协议简介\nQUIC（ Quick UDP Internet Connections）,快速 UDP 网络连接，是一种实验性的网络协议，基于UDP协议在两端之间进行通信，支持多路复用。\n2018年10月，互联网工程任务组 HTTP 及 QUIC 工作小组正式将基于 QUIC 协议的 HTTP（英语：HTTP over QUIC）重命名为HTTP/3以为确立下一代规范做准备。\nQUIC旨在提供几乎等同于TCP连接的可靠性，但延迟大大减少\nQUIC使用UDP协议作为其基础，每个QUIC流是单独控制，在QUIC级别而不是UDP级别重传丢失的数据。如果在一个流中发生错误，协议栈仍然可以独立地继续为其他流提供服务。\n\n大多数情况下 TCP 协议通知数据包丢失或损坏之前可能会收到大量的正常数据，但是在纠正错误之前其他的正常请求都会等待甚至重发\n而QUIC 在修复单个流时可以自由处理其他数据，也就是说即使一个请求发生了错误也不会影响到其他的请求。\n\n\n#### http3.0相对于 http2.0 的优点\n优点都是比出来的，没有完美的技术，看起来极好极好的很完美的http2.0，其实也有存在很多问题\n```html\n一是对线头阻塞(HOL)问题的解决更为彻底，TCP传输数据时时，若一个数据包出现问题，TCP需要等待该包重传后，才能继续传输其它数据包，而QUIC基于UDP协议，一条链接上可以有多个流，当UDP数据包在出问题需要重传时，并不会对其他流的传输产生影响。同时还可以对关键包发送多次，从而解决队头阻塞问题。\n\n快速重启会话，切换网络时也能连接保持，可以内建与TCP中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接\n\n快速建立网络连接，最快零RTT建立连接，目前TCP与SSL/TLS(1.0,1.1,1.2)每次建连需要TCP三次握手+安全握手，需要4~5个RRT（RTT耗时包括三部分：往返传播时延、网络设备内排队时延、应用程序数据处理时延。），QUIC的 0RTT 对于第一次交互的客户端和服务端也是做不到的。\n\n前向安全。即使被人抓包存储起来，在未来某个时间点秘钥被破解后仍然不能解密。\n```\n\n#### http3.0 为什么使用 udp 而不使用 tcp\n基于TCP开发的设备和协议非常多，兼容困难\n提供了0-RTT支持，客户端可以在完成TLS协商前请求数，建立连接速度快\nTCP协议栈是Linux内部的重要部分，修改和升级成本很大\nUDP本身是无连接的、没有建链和拆链成本\nUDP的数据包无队头阻塞问题\nUDP改造成本小，tcp的历史包袱太重，改造成本太大\n#### http3.0 初体验\n由于当下http3.0还是正式推出，Nginx当前最新版本也不支持配置，所以如果要自己在自己的网站上使用http3.0还是很麻烦的，还得自己编译一个nginx内核。\n\n当然，如果仅仅是感受一下http3.0还是很简单的\nGoogle 搜索，Gmail 或者 Youtube官网，当前都已经使用了 Http3 协议了，只不过该功能被隐藏了起来。\n要想感受一下http3.0请求，只需在最新版本的chrome浏览器，然后给它开启 QUIC 特性即可。\n\n本人当前chrome版本\n```html\n版本 87.0.4280.141（正式版本） (x86_64) \n```\n开启方式\n```html\n在 chrome://flags/ 中找到 Experimental 中 QUIC protocol, 设置为Enabled. 重启浏览器生效\n```\n![http://zhoushirong.github.io/img/http3-1.png](http://zhoushirong.github.io/img/http3-1.png)\n\n判断自己的浏览器是否成功开启了http3.0的方法\n```html\n开着控制台访问Google，看看http请求是否是http3.0的协议\n```\n![http://zhoushirong.github.io/img/http3.png](http://zhoushirong.github.io/img/http3.png)\n\n或者安装这个chrome插件\n```html\n在 chrome store 里面安装 HTTP/2 and SPDY indicator 插件\n```\n安装之后如果看到插件栏有一个闪电图标说明开启成功了，此后如果访问http3请求的网站，这个图标会变成绿色。\n\n\n\n#### 什么是队头阻塞简介\n队头阻塞 Head-of-line blocking(缩写为HOL blocking)是计算机网络中是一种性能受限的现象，通俗来说就是：一个数据包影响了一堆数据包\n队头阻塞问题可能存在于HTTP层和TCP层，在HTTP1.x时两个层次都存在该问题。\nHTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在TCP层仍然存在队头阻塞问题。\nTCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。\n\n### 传送门\n[为什么HTTP3.0使用UDP协议](https://network.51cto.com/art/202009/625999.htm)\n\n[一文读懂 HTTP/2 及 HTTP/3 特性](https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/)\n\n[http2/http3协议有什么优劣](https://github.com/LuckyWinty/fe-weekly-questions/issues/3)\n\n[QUIC协议浅析与HTTP/3.0](https://www.jianshu.com/p/bb3eeb36b479)","slug":"http3","published":1,"updated":"2021-03-30T01:32:00.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufj000ja0vz5p5u9u8e","content":"<h4 id=\"http2-0-相对于-http1-0-的优点\"><a href=\"#http2-0-相对于-http1-0-的优点\" class=\"headerlink\" title=\"http2.0 相对于 http1.0 的优点\"></a>http2.0 相对于 http1.0 的优点</h4><p>http2.0的出现确实给互联网带来了很多的好处，相比于http1.0已经好很多很多了。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二进制分帧，二进制协议替代原来的超文本文本协议，二进制格式在协议的解析和优化扩展上带来更多的优势和可能</span><br><span class=\"line\">头部压缩，使用HPACK压缩头部信息，减少冗余信息的传输，节约带宽</span><br><span class=\"line\">多路复用，多个请求可通过一个TCP连接进行并发完成。支持优先级和流量控制</span><br><span class=\"line\">服务端推送，可以将js和css等资源预先推送到客服端(浏览器内存中)，当客户端使用的时候不需要重新拉取。</span><br><span class=\"line\">保护网站安全，只有https的网站可以使用http2.0，确保信息不回被明文传输。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"QUIC-协议简介\"><a href=\"#QUIC-协议简介\" class=\"headerlink\" title=\"QUIC 协议简介\"></a>QUIC 协议简介</h4><p>QUIC（ Quick UDP Internet Connections）,快速 UDP 网络连接，是一种实验性的网络协议，基于UDP协议在两端之间进行通信，支持多路复用。<br>2018年10月，互联网工程任务组 HTTP 及 QUIC 工作小组正式将基于 QUIC 协议的 HTTP（英语：HTTP over QUIC）重命名为HTTP/3以为确立下一代规范做准备。<br>QUIC旨在提供几乎等同于TCP连接的可靠性，但延迟大大减少<br>QUIC使用UDP协议作为其基础，每个QUIC流是单独控制，在QUIC级别而不是UDP级别重传丢失的数据。如果在一个流中发生错误，协议栈仍然可以独立地继续为其他流提供服务。</p>\n<p>大多数情况下 TCP 协议通知数据包丢失或损坏之前可能会收到大量的正常数据，但是在纠正错误之前其他的正常请求都会等待甚至重发<br>而QUIC 在修复单个流时可以自由处理其他数据，也就是说即使一个请求发生了错误也不会影响到其他的请求。</p>\n<h4 id=\"http3-0相对于-http2-0-的优点\"><a href=\"#http3-0相对于-http2-0-的优点\" class=\"headerlink\" title=\"http3.0相对于 http2.0 的优点\"></a>http3.0相对于 http2.0 的优点</h4><p>优点都是比出来的，没有完美的技术，看起来极好极好的很完美的http2.0，其实也有存在很多问题<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一是对线头阻塞(HOL)问题的解决更为彻底，TCP传输数据时时，若一个数据包出现问题，TCP需要等待该包重传后，才能继续传输其它数据包，而QUIC基于UDP协议，一条链接上可以有多个流，当UDP数据包在出问题需要重传时，并不会对其他流的传输产生影响。同时还可以对关键包发送多次，从而解决队头阻塞问题。</span><br><span class=\"line\"></span><br><span class=\"line\">快速重启会话，切换网络时也能连接保持，可以内建与TCP中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接</span><br><span class=\"line\"></span><br><span class=\"line\">快速建立网络连接，最快零RTT建立连接，目前TCP与SSL/TLS(1.0,1.1,1.2)每次建连需要TCP三次握手+安全握手，需要4~5个RRT（RTT耗时包括三部分：往返传播时延、网络设备内排队时延、应用程序数据处理时延。），QUIC的 0RTT 对于第一次交互的客户端和服务端也是做不到的。</span><br><span class=\"line\"></span><br><span class=\"line\">前向安全。即使被人抓包存储起来，在未来某个时间点秘钥被破解后仍然不能解密。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"http3-0-为什么使用-udp-而不使用-tcp\"><a href=\"#http3-0-为什么使用-udp-而不使用-tcp\" class=\"headerlink\" title=\"http3.0 为什么使用 udp 而不使用 tcp\"></a>http3.0 为什么使用 udp 而不使用 tcp</h4><p>基于TCP开发的设备和协议非常多，兼容困难<br>提供了0-RTT支持，客户端可以在完成TLS协商前请求数，建立连接速度快<br>TCP协议栈是Linux内部的重要部分，修改和升级成本很大<br>UDP本身是无连接的、没有建链和拆链成本<br>UDP的数据包无队头阻塞问题<br>UDP改造成本小，tcp的历史包袱太重，改造成本太大</p>\n<h4 id=\"http3-0-初体验\"><a href=\"#http3-0-初体验\" class=\"headerlink\" title=\"http3.0 初体验\"></a>http3.0 初体验</h4><p>由于当下http3.0还是正式推出，Nginx当前最新版本也不支持配置，所以如果要自己在自己的网站上使用http3.0还是很麻烦的，还得自己编译一个nginx内核。</p>\n<p>当然，如果仅仅是感受一下http3.0还是很简单的<br>Google 搜索，Gmail 或者 Youtube官网，当前都已经使用了 Http3 协议了，只不过该功能被隐藏了起来。<br>要想感受一下http3.0请求，只需在最新版本的chrome浏览器，然后给它开启 QUIC 特性即可。</p>\n<p>本人当前chrome版本<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">版本 87.0.4280.141（正式版本） (x86_64) </span><br></pre></td></tr></table></figure><br>开启方式<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 chrome://flags/ 中找到 Experimental 中 QUIC protocol, 设置为Enabled. 重启浏览器生效</span><br></pre></td></tr></table></figure><br><img src=\"http://zhoushirong.github.io/img/http3-1.png\" alt=\"http://zhoushirong.github.io/img/http3-1.png\"></p>\n<p>判断自己的浏览器是否成功开启了http3.0的方法<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开着控制台访问Google，看看http请求是否是http3.0的协议</span><br></pre></td></tr></table></figure><br><img src=\"http://zhoushirong.github.io/img/http3.png\" alt=\"http://zhoushirong.github.io/img/http3.png\"></p>\n<p>或者安装这个chrome插件<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 chrome store 里面安装 HTTP/2 and SPDY indicator 插件</span><br></pre></td></tr></table></figure><br>安装之后如果看到插件栏有一个闪电图标说明开启成功了，此后如果访问http3请求的网站，这个图标会变成绿色。</p>\n<h4 id=\"什么是队头阻塞简介\"><a href=\"#什么是队头阻塞简介\" class=\"headerlink\" title=\"什么是队头阻塞简介\"></a>什么是队头阻塞简介</h4><p>队头阻塞 Head-of-line blocking(缩写为HOL blocking)是计算机网络中是一种性能受限的现象，通俗来说就是：一个数据包影响了一堆数据包<br>队头阻塞问题可能存在于HTTP层和TCP层，在HTTP1.x时两个层次都存在该问题。<br>HTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在TCP层仍然存在队头阻塞问题。<br>TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://network.51cto.com/art/202009/625999.htm\">为什么HTTP3.0使用UDP协议</a></p>\n<p><a href=\"https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/\">一文读懂 HTTP/2 及 HTTP/3 特性</a></p>\n<p><a href=\"https://github.com/LuckyWinty/fe-weekly-questions/issues/3\">http2/http3协议有什么优劣</a></p>\n<p><a href=\"https://www.jianshu.com/p/bb3eeb36b479\">QUIC协议浅析与HTTP/3.0</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"http2-0-相对于-http1-0-的优点\"><a href=\"#http2-0-相对于-http1-0-的优点\" class=\"headerlink\" title=\"http2.0 相对于 http1.0 的优点\"></a>http2.0 相对于 http1.0 的优点</h4><p>http2.0的出现确实给互联网带来了很多的好处，相比于http1.0已经好很多很多了。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二进制分帧，二进制协议替代原来的超文本文本协议，二进制格式在协议的解析和优化扩展上带来更多的优势和可能</span><br><span class=\"line\">头部压缩，使用HPACK压缩头部信息，减少冗余信息的传输，节约带宽</span><br><span class=\"line\">多路复用，多个请求可通过一个TCP连接进行并发完成。支持优先级和流量控制</span><br><span class=\"line\">服务端推送，可以将js和css等资源预先推送到客服端(浏览器内存中)，当客户端使用的时候不需要重新拉取。</span><br><span class=\"line\">保护网站安全，只有https的网站可以使用http2.0，确保信息不回被明文传输。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"QUIC-协议简介\"><a href=\"#QUIC-协议简介\" class=\"headerlink\" title=\"QUIC 协议简介\"></a>QUIC 协议简介</h4><p>QUIC（ Quick UDP Internet Connections）,快速 UDP 网络连接，是一种实验性的网络协议，基于UDP协议在两端之间进行通信，支持多路复用。<br>2018年10月，互联网工程任务组 HTTP 及 QUIC 工作小组正式将基于 QUIC 协议的 HTTP（英语：HTTP over QUIC）重命名为HTTP/3以为确立下一代规范做准备。<br>QUIC旨在提供几乎等同于TCP连接的可靠性，但延迟大大减少<br>QUIC使用UDP协议作为其基础，每个QUIC流是单独控制，在QUIC级别而不是UDP级别重传丢失的数据。如果在一个流中发生错误，协议栈仍然可以独立地继续为其他流提供服务。</p>\n<p>大多数情况下 TCP 协议通知数据包丢失或损坏之前可能会收到大量的正常数据，但是在纠正错误之前其他的正常请求都会等待甚至重发<br>而QUIC 在修复单个流时可以自由处理其他数据，也就是说即使一个请求发生了错误也不会影响到其他的请求。</p>\n<h4 id=\"http3-0相对于-http2-0-的优点\"><a href=\"#http3-0相对于-http2-0-的优点\" class=\"headerlink\" title=\"http3.0相对于 http2.0 的优点\"></a>http3.0相对于 http2.0 的优点</h4><p>优点都是比出来的，没有完美的技术，看起来极好极好的很完美的http2.0，其实也有存在很多问题<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一是对线头阻塞(HOL)问题的解决更为彻底，TCP传输数据时时，若一个数据包出现问题，TCP需要等待该包重传后，才能继续传输其它数据包，而QUIC基于UDP协议，一条链接上可以有多个流，当UDP数据包在出问题需要重传时，并不会对其他流的传输产生影响。同时还可以对关键包发送多次，从而解决队头阻塞问题。</span><br><span class=\"line\"></span><br><span class=\"line\">快速重启会话，切换网络时也能连接保持，可以内建与TCP中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接</span><br><span class=\"line\"></span><br><span class=\"line\">快速建立网络连接，最快零RTT建立连接，目前TCP与SSL/TLS(1.0,1.1,1.2)每次建连需要TCP三次握手+安全握手，需要4~5个RRT（RTT耗时包括三部分：往返传播时延、网络设备内排队时延、应用程序数据处理时延。），QUIC的 0RTT 对于第一次交互的客户端和服务端也是做不到的。</span><br><span class=\"line\"></span><br><span class=\"line\">前向安全。即使被人抓包存储起来，在未来某个时间点秘钥被破解后仍然不能解密。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"http3-0-为什么使用-udp-而不使用-tcp\"><a href=\"#http3-0-为什么使用-udp-而不使用-tcp\" class=\"headerlink\" title=\"http3.0 为什么使用 udp 而不使用 tcp\"></a>http3.0 为什么使用 udp 而不使用 tcp</h4><p>基于TCP开发的设备和协议非常多，兼容困难<br>提供了0-RTT支持，客户端可以在完成TLS协商前请求数，建立连接速度快<br>TCP协议栈是Linux内部的重要部分，修改和升级成本很大<br>UDP本身是无连接的、没有建链和拆链成本<br>UDP的数据包无队头阻塞问题<br>UDP改造成本小，tcp的历史包袱太重，改造成本太大</p>\n<h4 id=\"http3-0-初体验\"><a href=\"#http3-0-初体验\" class=\"headerlink\" title=\"http3.0 初体验\"></a>http3.0 初体验</h4><p>由于当下http3.0还是正式推出，Nginx当前最新版本也不支持配置，所以如果要自己在自己的网站上使用http3.0还是很麻烦的，还得自己编译一个nginx内核。</p>\n<p>当然，如果仅仅是感受一下http3.0还是很简单的<br>Google 搜索，Gmail 或者 Youtube官网，当前都已经使用了 Http3 协议了，只不过该功能被隐藏了起来。<br>要想感受一下http3.0请求，只需在最新版本的chrome浏览器，然后给它开启 QUIC 特性即可。</p>\n<p>本人当前chrome版本<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">版本 87.0.4280.141（正式版本） (x86_64) </span><br></pre></td></tr></table></figure><br>开启方式<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 chrome://flags/ 中找到 Experimental 中 QUIC protocol, 设置为Enabled. 重启浏览器生效</span><br></pre></td></tr></table></figure><br><img src=\"http://zhoushirong.github.io/img/http3-1.png\" alt=\"http://zhoushirong.github.io/img/http3-1.png\"></p>\n<p>判断自己的浏览器是否成功开启了http3.0的方法<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开着控制台访问Google，看看http请求是否是http3.0的协议</span><br></pre></td></tr></table></figure><br><img src=\"http://zhoushirong.github.io/img/http3.png\" alt=\"http://zhoushirong.github.io/img/http3.png\"></p>\n<p>或者安装这个chrome插件<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 chrome store 里面安装 HTTP/2 and SPDY indicator 插件</span><br></pre></td></tr></table></figure><br>安装之后如果看到插件栏有一个闪电图标说明开启成功了，此后如果访问http3请求的网站，这个图标会变成绿色。</p>\n<h4 id=\"什么是队头阻塞简介\"><a href=\"#什么是队头阻塞简介\" class=\"headerlink\" title=\"什么是队头阻塞简介\"></a>什么是队头阻塞简介</h4><p>队头阻塞 Head-of-line blocking(缩写为HOL blocking)是计算机网络中是一种性能受限的现象，通俗来说就是：一个数据包影响了一堆数据包<br>队头阻塞问题可能存在于HTTP层和TCP层，在HTTP1.x时两个层次都存在该问题。<br>HTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在TCP层仍然存在队头阻塞问题。<br>TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://network.51cto.com/art/202009/625999.htm\">为什么HTTP3.0使用UDP协议</a></p>\n<p><a href=\"https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/\">一文读懂 HTTP/2 及 HTTP/3 特性</a></p>\n<p><a href=\"https://github.com/LuckyWinty/fe-weekly-questions/issues/3\">http2/http3协议有什么优劣</a></p>\n<p><a href=\"https://www.jianshu.com/p/bb3eeb36b479\">QUIC协议浅析与HTTP/3.0</a></p>\n"},{"title":"Https基础以及本地Https搭建","date":"2017-12-11T16:00:00.000Z","_content":"\n### 一、https是什么（相关概念简述）？\n超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。 —— 维基百科\n\n#### 1.对称加密和非对称加密\n对称加密：需要对加解密的数据采用相同的密钥的加密算法。\n优点：加密算法公开，计算量小，加密速度快，通常用在消息发送方加密大量数据的时候使用\n缺点：需要消息传递的双方约定加密的密钥，一旦一方的密钥泄漏，信息就变得不安全了\n\n非对称加密：需要两个密钥（公钥和私钥）来进行加密和解密，公钥解密私钥的加密数据、私钥解密公钥的加密数据，私钥一般存储在服务器端不会外漏\n优点：相对于对称加密更安全，即使公钥泄漏也没办法解密\n缺点：加解密花费时间长，只适合小数据量的加解密。\n\n\n#### 2.https的加解密方式\nhttps采用的是非对称加密和对称加密混合的方式进行加密的。\n使用非对称加密的方式加密传递对称加密的密钥，随后使用对称加密进行通讯。\n\nHTTP 建立 TCP 链接需要进行三次握手\nHTTPS 在 TCP 之上又加上了 TLS 的握手过程，在握手过程中确定双方传输数据的密码信息。\nSSL/TLS 握手是为了安全的协商出一份对称加密的密钥\n\n#### 3.对称加密与非对称加密：\n\n对称加密算法在加密和解密时使用的是同一个秘钥；\n而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。\n\n与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。\n公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。\n因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。\n\n\n#### 4.https TLS握手过程：\n\n``` html\n1.浏览器发送一个消息：包含一个随机数Random1，支持的加密套件，TLS版本号（被叫做ClientHello请求）\n2.服务端接收消息并回应（被叫做ServerHello）\n\ta）验证tls版本是否支持\n\tb)服务端从客户端发送的加密规则中选择一组加密套件\n\tc)接收随机数Random1,生成一份随机数Random2\n\td)下发证书，包含公钥、随机数Random2（公钥放在服务器的数字证书中）\n\te)如果有必要服务端需要确认客户端身份，则会要求客户端发送自己的证书（如usb密钥）\n3.浏览器接收证书信息\n  a)验证证书的合法性\n  b)取出服务端发送过来的证书中的公钥,生成随机数Random3，并用证书中提供的公钥加密Random3\n  c)最后将加密后的随机数消息发送给服务器\n4.服务器接收浏览器发来的信息：使用自己的私钥将Random3解密出来，\n5.用三个随机数生成session Key作为对称密钥，为后续数据传输用\n```\n\n握手结束之后，之后所有的通信数据将由浏览器之前生成的随机密码并利用对称加密算法进行加密\n\nps：之前浏览器与服务端互相发送加密的握手消息验证，目的是为了保证双方都获得了一致的对称加解密的密码，并且验证双方可以正常的加解密数据，为后面的真正数据传输做一次测试。\n\n\n#### 5.https session Key\nhttps建立连接是一个比较复杂的过程，如果连接断开之后需要重新进行建立连接。\n重连有两种方式：sessionID和session ticket\n\n如果对话中断，客户端可以发送之前的session重连对话，如果服务端存在这个sessionId就可以重新建立连接。\n\nsession ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。\n所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。\n\n\n##### 6.openssl是什么？\n是一个开源程序的套件,这个套件有三个部分组成：一是libcryto，这是一个具有通用功能的加密库，里面实现了众多的加密库；二是libssl，这个是实现ssl机制的，它是用于实现TLS/SSL的功能；三是openssl，是个多功能命令行工具，它可以实现加密解密，甚至还可以当CA来用，可以让你创建证书、吊销证书。\n\n\n### 二、为什么要使用https\n1.数据加密，提高安全性。\n\n2.证书保证，防止冒充\n\n3.校验数据，防止被篡改\n\n\n\n### 三、如何使用https\n\n#### 1.使用openssl生成本地证书\n\n##### 1）准备工作\n创建一个存放证书的目录，如/sshkey：\n``` shell\ncd ~\nmkdir sshkey\n```\n\n在sskkey目录下创建demoCA子目录\n``` shell\ncd sshkey\nmkdir demoCA && cd demoCA && touch index.txt && touch serial && echo \"01\">./serial && mkdir newcerts\n```\n\n#### 2）正式生成：\n\n制作CA证书：\n\n第一步：生成ca.key CA私钥\n```shell\nopenssl genrsa -des3 -out ca.key 2048\n```\n\n第二步：生成ca.crt CA根证书（公钥）：\n```shell\nopenssl req -new -x509 -days 7305 -key ca.key -out ca.crt\n```\n\n生成网站的证书，并用CA签名认证（假设网站域名为www.example.com）\n\n第三步：生成www.example.com证书私钥：\n```shell\nopenssl genrsa -des3 -out www.example.com.pem 1024\n```\n\n第四步：制作解密后的www.example.com证书私钥：\n```shell\nopenssl rsa -in www.example.com.pem -out www.example.com.key\n```\nps:在common name中填入网站域名，如www.example.com即可生成改站点的证书(这里一定要填入common name，不然生成的东西为空)\n\n第五步：生成签名请求：\n```shell\nopenssl req -new -key www.example.com.pem -out www.example.com.csr\n```\n\n第六步：用CA进行签名：\n```shell\nopenssl ca -policy policy_anything -days 1460 -cert ca.crt -keyfile ca.key -in www.example.com.csr -out www.example.com.crt\n```\n\n如果一切顺利，生成完成之后在demoCA下应该会看到如下子目录\n\n```shell\n#ls\nca.crt # 根证书\nca.key # CA私钥\nwww.example.com.crt # \nwww.example.com.csr\nwww.example.com.key\nwww.example.com.pem\ndemoCA\t\t\t\n```\n\n\n##### 遇到的问题\n如果遇到如下报错\n``` html\nUsing configuration from /private/etc/ssl/openssl.cnf\nvariable lookup failed for ca::default_ca\n140735980385160:error:0E06D06C:configuration file routines:NCONF_get_string:no value:/BuildRoot/Library/Caches/com.apple.xbs/Sources/libressl/libressl-22/libressl/crypto/conf/conf_lib.c:323:group=ca name=default_ca\n```\n\n解决办法：将openssl安装目录下的openssl.cnf 拷贝到配置目录\n``` shell\ncp /usr/local/etc/openssl/openssl.cnf /private/etc/ssl/openssl.cnf\n```\n\n并修改其中的配置文件的dir的文件路径为之前创建的demoCA文件路径\n``` shell\ndir >> = /Users/zsr/learn/epoos/sshkey/demoCA/ > >\n```\n\n至此，使用openssl生成本地证书的过程就结束了，接下来就只需要在nginx中配置一番就可以看到一个https的网站了。\n\n#### 2.生成证书之后nginx配置如下：\n```shell\n  1 server # 使用nginx做普通http代理\n  2 {\n  3     listen 80;\n  4     server_name www.example.com;\n  5     index index.html;\n  6     location /\n  7     {\n  8         #proxy_pass http://10.242.22.138:8084/;\n  9         alias /Users/zsr/learn/example/;\n 10     }\n 11     error_log /usr/local/etc/nginx/logs/error.log;\n 12 }\n\n 13 server # 使用nginx做普通https代理\n 14 {\n 15   listen 443;\n 16   server_name www.example.com;\n 17   index index.html;\n 18   location /\n 19   {\n 20     alias /Users/zsr/learn/example/;\n 21   }\n 22   ssl on;\n 23   ssl_certificate /Users/zsr/learn/example/sshkey/www.example.com.crt\n 24   ssl_certificate_key /Users/zsr/learn/example/sshkey/www.example.com.key\n 25 }\n```\n\n\n\n\n### 相关传送门：\n\n生成证书\nhttp://blog.creke.net/762.html\n\nhttps介绍：\nhttp://wetest.qq.com/lab/view/110.html\n\n知乎上的https介绍：\nhttps://zhuanlan.zhihu.com/p/26682342\n\n简书上的介绍\nhttp://www.jianshu.com/p/7158568e4867\n\n阮一峰系列\n\nhttp://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\n\nhttp://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\n\nhttp://www.ruanyifeng.com/blog/2016/08/http.html\n","source":"_posts/https.md","raw":"---\ntitle: Https基础以及本地Https搭建\ntag: https\ndate: 2017/12/12\ncategory: 技术\n---\n\n### 一、https是什么（相关概念简述）？\n超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。 —— 维基百科\n\n#### 1.对称加密和非对称加密\n对称加密：需要对加解密的数据采用相同的密钥的加密算法。\n优点：加密算法公开，计算量小，加密速度快，通常用在消息发送方加密大量数据的时候使用\n缺点：需要消息传递的双方约定加密的密钥，一旦一方的密钥泄漏，信息就变得不安全了\n\n非对称加密：需要两个密钥（公钥和私钥）来进行加密和解密，公钥解密私钥的加密数据、私钥解密公钥的加密数据，私钥一般存储在服务器端不会外漏\n优点：相对于对称加密更安全，即使公钥泄漏也没办法解密\n缺点：加解密花费时间长，只适合小数据量的加解密。\n\n\n#### 2.https的加解密方式\nhttps采用的是非对称加密和对称加密混合的方式进行加密的。\n使用非对称加密的方式加密传递对称加密的密钥，随后使用对称加密进行通讯。\n\nHTTP 建立 TCP 链接需要进行三次握手\nHTTPS 在 TCP 之上又加上了 TLS 的握手过程，在握手过程中确定双方传输数据的密码信息。\nSSL/TLS 握手是为了安全的协商出一份对称加密的密钥\n\n#### 3.对称加密与非对称加密：\n\n对称加密算法在加密和解密时使用的是同一个秘钥；\n而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。\n\n与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。\n公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。\n因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。\n\n\n#### 4.https TLS握手过程：\n\n``` html\n1.浏览器发送一个消息：包含一个随机数Random1，支持的加密套件，TLS版本号（被叫做ClientHello请求）\n2.服务端接收消息并回应（被叫做ServerHello）\n\ta）验证tls版本是否支持\n\tb)服务端从客户端发送的加密规则中选择一组加密套件\n\tc)接收随机数Random1,生成一份随机数Random2\n\td)下发证书，包含公钥、随机数Random2（公钥放在服务器的数字证书中）\n\te)如果有必要服务端需要确认客户端身份，则会要求客户端发送自己的证书（如usb密钥）\n3.浏览器接收证书信息\n  a)验证证书的合法性\n  b)取出服务端发送过来的证书中的公钥,生成随机数Random3，并用证书中提供的公钥加密Random3\n  c)最后将加密后的随机数消息发送给服务器\n4.服务器接收浏览器发来的信息：使用自己的私钥将Random3解密出来，\n5.用三个随机数生成session Key作为对称密钥，为后续数据传输用\n```\n\n握手结束之后，之后所有的通信数据将由浏览器之前生成的随机密码并利用对称加密算法进行加密\n\nps：之前浏览器与服务端互相发送加密的握手消息验证，目的是为了保证双方都获得了一致的对称加解密的密码，并且验证双方可以正常的加解密数据，为后面的真正数据传输做一次测试。\n\n\n#### 5.https session Key\nhttps建立连接是一个比较复杂的过程，如果连接断开之后需要重新进行建立连接。\n重连有两种方式：sessionID和session ticket\n\n如果对话中断，客户端可以发送之前的session重连对话，如果服务端存在这个sessionId就可以重新建立连接。\n\nsession ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。\n所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。\n\n\n##### 6.openssl是什么？\n是一个开源程序的套件,这个套件有三个部分组成：一是libcryto，这是一个具有通用功能的加密库，里面实现了众多的加密库；二是libssl，这个是实现ssl机制的，它是用于实现TLS/SSL的功能；三是openssl，是个多功能命令行工具，它可以实现加密解密，甚至还可以当CA来用，可以让你创建证书、吊销证书。\n\n\n### 二、为什么要使用https\n1.数据加密，提高安全性。\n\n2.证书保证，防止冒充\n\n3.校验数据，防止被篡改\n\n\n\n### 三、如何使用https\n\n#### 1.使用openssl生成本地证书\n\n##### 1）准备工作\n创建一个存放证书的目录，如/sshkey：\n``` shell\ncd ~\nmkdir sshkey\n```\n\n在sskkey目录下创建demoCA子目录\n``` shell\ncd sshkey\nmkdir demoCA && cd demoCA && touch index.txt && touch serial && echo \"01\">./serial && mkdir newcerts\n```\n\n#### 2）正式生成：\n\n制作CA证书：\n\n第一步：生成ca.key CA私钥\n```shell\nopenssl genrsa -des3 -out ca.key 2048\n```\n\n第二步：生成ca.crt CA根证书（公钥）：\n```shell\nopenssl req -new -x509 -days 7305 -key ca.key -out ca.crt\n```\n\n生成网站的证书，并用CA签名认证（假设网站域名为www.example.com）\n\n第三步：生成www.example.com证书私钥：\n```shell\nopenssl genrsa -des3 -out www.example.com.pem 1024\n```\n\n第四步：制作解密后的www.example.com证书私钥：\n```shell\nopenssl rsa -in www.example.com.pem -out www.example.com.key\n```\nps:在common name中填入网站域名，如www.example.com即可生成改站点的证书(这里一定要填入common name，不然生成的东西为空)\n\n第五步：生成签名请求：\n```shell\nopenssl req -new -key www.example.com.pem -out www.example.com.csr\n```\n\n第六步：用CA进行签名：\n```shell\nopenssl ca -policy policy_anything -days 1460 -cert ca.crt -keyfile ca.key -in www.example.com.csr -out www.example.com.crt\n```\n\n如果一切顺利，生成完成之后在demoCA下应该会看到如下子目录\n\n```shell\n#ls\nca.crt # 根证书\nca.key # CA私钥\nwww.example.com.crt # \nwww.example.com.csr\nwww.example.com.key\nwww.example.com.pem\ndemoCA\t\t\t\n```\n\n\n##### 遇到的问题\n如果遇到如下报错\n``` html\nUsing configuration from /private/etc/ssl/openssl.cnf\nvariable lookup failed for ca::default_ca\n140735980385160:error:0E06D06C:configuration file routines:NCONF_get_string:no value:/BuildRoot/Library/Caches/com.apple.xbs/Sources/libressl/libressl-22/libressl/crypto/conf/conf_lib.c:323:group=ca name=default_ca\n```\n\n解决办法：将openssl安装目录下的openssl.cnf 拷贝到配置目录\n``` shell\ncp /usr/local/etc/openssl/openssl.cnf /private/etc/ssl/openssl.cnf\n```\n\n并修改其中的配置文件的dir的文件路径为之前创建的demoCA文件路径\n``` shell\ndir >> = /Users/zsr/learn/epoos/sshkey/demoCA/ > >\n```\n\n至此，使用openssl生成本地证书的过程就结束了，接下来就只需要在nginx中配置一番就可以看到一个https的网站了。\n\n#### 2.生成证书之后nginx配置如下：\n```shell\n  1 server # 使用nginx做普通http代理\n  2 {\n  3     listen 80;\n  4     server_name www.example.com;\n  5     index index.html;\n  6     location /\n  7     {\n  8         #proxy_pass http://10.242.22.138:8084/;\n  9         alias /Users/zsr/learn/example/;\n 10     }\n 11     error_log /usr/local/etc/nginx/logs/error.log;\n 12 }\n\n 13 server # 使用nginx做普通https代理\n 14 {\n 15   listen 443;\n 16   server_name www.example.com;\n 17   index index.html;\n 18   location /\n 19   {\n 20     alias /Users/zsr/learn/example/;\n 21   }\n 22   ssl on;\n 23   ssl_certificate /Users/zsr/learn/example/sshkey/www.example.com.crt\n 24   ssl_certificate_key /Users/zsr/learn/example/sshkey/www.example.com.key\n 25 }\n```\n\n\n\n\n### 相关传送门：\n\n生成证书\nhttp://blog.creke.net/762.html\n\nhttps介绍：\nhttp://wetest.qq.com/lab/view/110.html\n\n知乎上的https介绍：\nhttps://zhuanlan.zhihu.com/p/26682342\n\n简书上的介绍\nhttp://www.jianshu.com/p/7158568e4867\n\n阮一峰系列\n\nhttp://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\n\nhttp://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\n\nhttp://www.ruanyifeng.com/blog/2016/08/http.html\n","slug":"https","published":1,"updated":"2021-03-30T01:32:00.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufj000ka0vz118pg7mi","content":"<h3 id=\"一、https是什么（相关概念简述）？\"><a href=\"#一、https是什么（相关概念简述）？\" class=\"headerlink\" title=\"一、https是什么（相关概念简述）？\"></a>一、https是什么（相关概念简述）？</h3><p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。 —— 维基百科</p>\n<h4 id=\"1-对称加密和非对称加密\"><a href=\"#1-对称加密和非对称加密\" class=\"headerlink\" title=\"1.对称加密和非对称加密\"></a>1.对称加密和非对称加密</h4><p>对称加密：需要对加解密的数据采用相同的密钥的加密算法。<br>优点：加密算法公开，计算量小，加密速度快，通常用在消息发送方加密大量数据的时候使用<br>缺点：需要消息传递的双方约定加密的密钥，一旦一方的密钥泄漏，信息就变得不安全了</p>\n<p>非对称加密：需要两个密钥（公钥和私钥）来进行加密和解密，公钥解密私钥的加密数据、私钥解密公钥的加密数据，私钥一般存储在服务器端不会外漏<br>优点：相对于对称加密更安全，即使公钥泄漏也没办法解密<br>缺点：加解密花费时间长，只适合小数据量的加解密。</p>\n<h4 id=\"2-https的加解密方式\"><a href=\"#2-https的加解密方式\" class=\"headerlink\" title=\"2.https的加解密方式\"></a>2.https的加解密方式</h4><p>https采用的是非对称加密和对称加密混合的方式进行加密的。<br>使用非对称加密的方式加密传递对称加密的密钥，随后使用对称加密进行通讯。</p>\n<p>HTTP 建立 TCP 链接需要进行三次握手<br>HTTPS 在 TCP 之上又加上了 TLS 的握手过程，在握手过程中确定双方传输数据的密码信息。<br>SSL/TLS 握手是为了安全的协商出一份对称加密的密钥</p>\n<h4 id=\"3-对称加密与非对称加密：\"><a href=\"#3-对称加密与非对称加密：\" class=\"headerlink\" title=\"3.对称加密与非对称加密：\"></a>3.对称加密与非对称加密：</h4><p>对称加密算法在加密和解密时使用的是同一个秘钥；<br>而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。</p>\n<p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。<br>公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。<br>因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>\n<h4 id=\"4-https-TLS握手过程：\"><a href=\"#4-https-TLS握手过程：\" class=\"headerlink\" title=\"4.https TLS握手过程：\"></a>4.https TLS握手过程：</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.浏览器发送一个消息：包含一个随机数Random1，支持的加密套件，TLS版本号（被叫做ClientHello请求）</span><br><span class=\"line\">2.服务端接收消息并回应（被叫做ServerHello）</span><br><span class=\"line\">\ta）验证tls版本是否支持</span><br><span class=\"line\">\tb)服务端从客户端发送的加密规则中选择一组加密套件</span><br><span class=\"line\">\tc)接收随机数Random1,生成一份随机数Random2</span><br><span class=\"line\">\td)下发证书，包含公钥、随机数Random2（公钥放在服务器的数字证书中）</span><br><span class=\"line\">\te)如果有必要服务端需要确认客户端身份，则会要求客户端发送自己的证书（如usb密钥）</span><br><span class=\"line\">3.浏览器接收证书信息</span><br><span class=\"line\">  a)验证证书的合法性</span><br><span class=\"line\">  b)取出服务端发送过来的证书中的公钥,生成随机数Random3，并用证书中提供的公钥加密Random3</span><br><span class=\"line\">  c)最后将加密后的随机数消息发送给服务器</span><br><span class=\"line\">4.服务器接收浏览器发来的信息：使用自己的私钥将Random3解密出来，</span><br><span class=\"line\">5.用三个随机数生成session Key作为对称密钥，为后续数据传输用</span><br></pre></td></tr></table></figure>\n<p>握手结束之后，之后所有的通信数据将由浏览器之前生成的随机密码并利用对称加密算法进行加密</p>\n<p>ps：之前浏览器与服务端互相发送加密的握手消息验证，目的是为了保证双方都获得了一致的对称加解密的密码，并且验证双方可以正常的加解密数据，为后面的真正数据传输做一次测试。</p>\n<h4 id=\"5-https-session-Key\"><a href=\"#5-https-session-Key\" class=\"headerlink\" title=\"5.https session Key\"></a>5.https session Key</h4><p>https建立连接是一个比较复杂的过程，如果连接断开之后需要重新进行建立连接。<br>重连有两种方式：sessionID和session ticket</p>\n<p>如果对话中断，客户端可以发送之前的session重连对话，如果服务端存在这个sessionId就可以重新建立连接。</p>\n<p>session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。<br>所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。</p>\n<h5 id=\"6-openssl是什么？\"><a href=\"#6-openssl是什么？\" class=\"headerlink\" title=\"6.openssl是什么？\"></a>6.openssl是什么？</h5><p>是一个开源程序的套件,这个套件有三个部分组成：一是libcryto，这是一个具有通用功能的加密库，里面实现了众多的加密库；二是libssl，这个是实现ssl机制的，它是用于实现TLS/SSL的功能；三是openssl，是个多功能命令行工具，它可以实现加密解密，甚至还可以当CA来用，可以让你创建证书、吊销证书。</p>\n<h3 id=\"二、为什么要使用https\"><a href=\"#二、为什么要使用https\" class=\"headerlink\" title=\"二、为什么要使用https\"></a>二、为什么要使用https</h3><p>1.数据加密，提高安全性。</p>\n<p>2.证书保证，防止冒充</p>\n<p>3.校验数据，防止被篡改</p>\n<h3 id=\"三、如何使用https\"><a href=\"#三、如何使用https\" class=\"headerlink\" title=\"三、如何使用https\"></a>三、如何使用https</h3><h4 id=\"1-使用openssl生成本地证书\"><a href=\"#1-使用openssl生成本地证书\" class=\"headerlink\" title=\"1.使用openssl生成本地证书\"></a>1.使用openssl生成本地证书</h4><h5 id=\"1）准备工作\"><a href=\"#1）准备工作\" class=\"headerlink\" title=\"1）准备工作\"></a>1）准备工作</h5><p>创建一个存放证书的目录，如/sshkey：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">mkdir sshkey</span><br></pre></td></tr></table></figure></p>\n<p>在sskkey目录下创建demoCA子目录<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd sshkey</span><br><span class=\"line\">mkdir demoCA &amp;&amp; cd demoCA &amp;&amp; touch index.txt &amp;&amp; touch serial &amp;&amp; echo &quot;01&quot;&gt;./serial &amp;&amp; mkdir newcerts</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2）正式生成：\"><a href=\"#2）正式生成：\" class=\"headerlink\" title=\"2）正式生成：\"></a>2）正式生成：</h4><p>制作CA证书：</p>\n<p>第一步：生成ca.key CA私钥<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out ca.key 2048</span><br></pre></td></tr></table></figure></p>\n<p>第二步：生成ca.crt CA根证书（公钥）：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -x509 -days 7305 -key ca.key -out ca.crt</span><br></pre></td></tr></table></figure></p>\n<p>生成网站的证书，并用CA签名认证（假设网站域名为<a href=\"http://www.example.com）\">www.example.com）</a></p>\n<p>第三步：生成<a href=\"http://www.example.com证书私钥：\">www.example.com证书私钥：</a><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out www.example.com.pem 1024</span><br></pre></td></tr></table></figure></p>\n<p>第四步：制作解密后的<a href=\"http://www.example.com证书私钥：\">www.example.com证书私钥：</a><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -in www.example.com.pem -out www.example.com.key</span><br></pre></td></tr></table></figure><br>ps:在common name中填入网站域名，如<a href=\"http://www.example.com即可生成改站点的证书\">www.example.com即可生成改站点的证书</a>(这里一定要填入common name，不然生成的东西为空)</p>\n<p>第五步：生成签名请求：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -key www.example.com.pem -out www.example.com.csr</span><br></pre></td></tr></table></figure></p>\n<p>第六步：用CA进行签名：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl ca -policy policy_anything -days 1460 -cert ca.crt -keyfile ca.key -in www.example.com.csr -out www.example.com.crt</span><br></pre></td></tr></table></figure></p>\n<p>如果一切顺利，生成完成之后在demoCA下应该会看到如下子目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ls</span></span><br><span class=\"line\">ca.crt # 根证书</span><br><span class=\"line\">ca.key # CA私钥</span><br><span class=\"line\">www.example.com.crt # </span><br><span class=\"line\">www.example.com.csr</span><br><span class=\"line\">www.example.com.key</span><br><span class=\"line\">www.example.com.pem</span><br><span class=\"line\">demoCA\t\t\t</span><br></pre></td></tr></table></figure>\n<h5 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h5><p>如果遇到如下报错<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Using configuration from /private/etc/ssl/openssl.cnf</span><br><span class=\"line\">variable lookup failed for ca::default_ca</span><br><span class=\"line\">140735980385160:error:0E06D06C:configuration file routines:NCONF_get_string:no value:/BuildRoot/Library/Caches/com.apple.xbs/Sources/libressl/libressl-22/libressl/crypto/conf/conf_lib.c:323:group=ca name=default_ca</span><br></pre></td></tr></table></figure></p>\n<p>解决办法：将openssl安装目录下的openssl.cnf 拷贝到配置目录<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /usr/local/etc/openssl/openssl.cnf /private/etc/ssl/openssl.cnf</span><br></pre></td></tr></table></figure></p>\n<p>并修改其中的配置文件的dir的文件路径为之前创建的demoCA文件路径<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir &gt;&gt; = /Users/zsr/learn/epoos/sshkey/demoCA/ &gt; &gt;</span><br></pre></td></tr></table></figure></p>\n<p>至此，使用openssl生成本地证书的过程就结束了，接下来就只需要在nginx中配置一番就可以看到一个https的网站了。</p>\n<h4 id=\"2-生成证书之后nginx配置如下：\"><a href=\"#2-生成证书之后nginx配置如下：\" class=\"headerlink\" title=\"2.生成证书之后nginx配置如下：\"></a>2.生成证书之后nginx配置如下：</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 server # 使用nginx做普通http代理</span><br><span class=\"line\"> 2 &#123;</span><br><span class=\"line\"> 3     listen 80;</span><br><span class=\"line\"> 4     server_name www.example.com;</span><br><span class=\"line\"> 5     index index.html;</span><br><span class=\"line\"> 6     location /</span><br><span class=\"line\"> 7     &#123;</span><br><span class=\"line\"> 8         #proxy_pass http://10.242.22.138:8084/;</span><br><span class=\"line\"> 9         alias /Users/zsr/learn/example/;</span><br><span class=\"line\">10     &#125;</span><br><span class=\"line\">11     error_log /usr/local/etc/nginx/logs/error.log;</span><br><span class=\"line\">12 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">13 server # 使用nginx做普通https代理</span><br><span class=\"line\">14 &#123;</span><br><span class=\"line\">15   listen 443;</span><br><span class=\"line\">16   server_name www.example.com;</span><br><span class=\"line\">17   index index.html;</span><br><span class=\"line\">18   location /</span><br><span class=\"line\">19   &#123;</span><br><span class=\"line\">20     alias /Users/zsr/learn/example/;</span><br><span class=\"line\">21   &#125;</span><br><span class=\"line\">22   ssl on;</span><br><span class=\"line\">23   ssl_certificate /Users/zsr/learn/example/sshkey/www.example.com.crt</span><br><span class=\"line\">24   ssl_certificate_key /Users/zsr/learn/example/sshkey/www.example.com.key</span><br><span class=\"line\">25 &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"相关传送门：\"><a href=\"#相关传送门：\" class=\"headerlink\" title=\"相关传送门：\"></a>相关传送门：</h3><p>生成证书<br><a href=\"http://blog.creke.net/762.html\">http://blog.creke.net/762.html</a></p>\n<p>https介绍：<br><a href=\"http://wetest.qq.com/lab/view/110.html\">http://wetest.qq.com/lab/view/110.html</a></p>\n<p>知乎上的https介绍：<br><a href=\"https://zhuanlan.zhihu.com/p/26682342\">https://zhuanlan.zhihu.com/p/26682342</a></p>\n<p>简书上的介绍<br><a href=\"http://www.jianshu.com/p/7158568e4867\">http://www.jianshu.com/p/7158568e4867</a></p>\n<p>阮一峰系列</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2016/08/http.html\">http://www.ruanyifeng.com/blog/2016/08/http.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、https是什么（相关概念简述）？\"><a href=\"#一、https是什么（相关概念简述）？\" class=\"headerlink\" title=\"一、https是什么（相关概念简述）？\"></a>一、https是什么（相关概念简述）？</h3><p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。 —— 维基百科</p>\n<h4 id=\"1-对称加密和非对称加密\"><a href=\"#1-对称加密和非对称加密\" class=\"headerlink\" title=\"1.对称加密和非对称加密\"></a>1.对称加密和非对称加密</h4><p>对称加密：需要对加解密的数据采用相同的密钥的加密算法。<br>优点：加密算法公开，计算量小，加密速度快，通常用在消息发送方加密大量数据的时候使用<br>缺点：需要消息传递的双方约定加密的密钥，一旦一方的密钥泄漏，信息就变得不安全了</p>\n<p>非对称加密：需要两个密钥（公钥和私钥）来进行加密和解密，公钥解密私钥的加密数据、私钥解密公钥的加密数据，私钥一般存储在服务器端不会外漏<br>优点：相对于对称加密更安全，即使公钥泄漏也没办法解密<br>缺点：加解密花费时间长，只适合小数据量的加解密。</p>\n<h4 id=\"2-https的加解密方式\"><a href=\"#2-https的加解密方式\" class=\"headerlink\" title=\"2.https的加解密方式\"></a>2.https的加解密方式</h4><p>https采用的是非对称加密和对称加密混合的方式进行加密的。<br>使用非对称加密的方式加密传递对称加密的密钥，随后使用对称加密进行通讯。</p>\n<p>HTTP 建立 TCP 链接需要进行三次握手<br>HTTPS 在 TCP 之上又加上了 TLS 的握手过程，在握手过程中确定双方传输数据的密码信息。<br>SSL/TLS 握手是为了安全的协商出一份对称加密的密钥</p>\n<h4 id=\"3-对称加密与非对称加密：\"><a href=\"#3-对称加密与非对称加密：\" class=\"headerlink\" title=\"3.对称加密与非对称加密：\"></a>3.对称加密与非对称加密：</h4><p>对称加密算法在加密和解密时使用的是同一个秘钥；<br>而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。</p>\n<p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。<br>公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。<br>因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>\n<h4 id=\"4-https-TLS握手过程：\"><a href=\"#4-https-TLS握手过程：\" class=\"headerlink\" title=\"4.https TLS握手过程：\"></a>4.https TLS握手过程：</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.浏览器发送一个消息：包含一个随机数Random1，支持的加密套件，TLS版本号（被叫做ClientHello请求）</span><br><span class=\"line\">2.服务端接收消息并回应（被叫做ServerHello）</span><br><span class=\"line\">\ta）验证tls版本是否支持</span><br><span class=\"line\">\tb)服务端从客户端发送的加密规则中选择一组加密套件</span><br><span class=\"line\">\tc)接收随机数Random1,生成一份随机数Random2</span><br><span class=\"line\">\td)下发证书，包含公钥、随机数Random2（公钥放在服务器的数字证书中）</span><br><span class=\"line\">\te)如果有必要服务端需要确认客户端身份，则会要求客户端发送自己的证书（如usb密钥）</span><br><span class=\"line\">3.浏览器接收证书信息</span><br><span class=\"line\">  a)验证证书的合法性</span><br><span class=\"line\">  b)取出服务端发送过来的证书中的公钥,生成随机数Random3，并用证书中提供的公钥加密Random3</span><br><span class=\"line\">  c)最后将加密后的随机数消息发送给服务器</span><br><span class=\"line\">4.服务器接收浏览器发来的信息：使用自己的私钥将Random3解密出来，</span><br><span class=\"line\">5.用三个随机数生成session Key作为对称密钥，为后续数据传输用</span><br></pre></td></tr></table></figure>\n<p>握手结束之后，之后所有的通信数据将由浏览器之前生成的随机密码并利用对称加密算法进行加密</p>\n<p>ps：之前浏览器与服务端互相发送加密的握手消息验证，目的是为了保证双方都获得了一致的对称加解密的密码，并且验证双方可以正常的加解密数据，为后面的真正数据传输做一次测试。</p>\n<h4 id=\"5-https-session-Key\"><a href=\"#5-https-session-Key\" class=\"headerlink\" title=\"5.https session Key\"></a>5.https session Key</h4><p>https建立连接是一个比较复杂的过程，如果连接断开之后需要重新进行建立连接。<br>重连有两种方式：sessionID和session ticket</p>\n<p>如果对话中断，客户端可以发送之前的session重连对话，如果服务端存在这个sessionId就可以重新建立连接。</p>\n<p>session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。<br>所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。</p>\n<h5 id=\"6-openssl是什么？\"><a href=\"#6-openssl是什么？\" class=\"headerlink\" title=\"6.openssl是什么？\"></a>6.openssl是什么？</h5><p>是一个开源程序的套件,这个套件有三个部分组成：一是libcryto，这是一个具有通用功能的加密库，里面实现了众多的加密库；二是libssl，这个是实现ssl机制的，它是用于实现TLS/SSL的功能；三是openssl，是个多功能命令行工具，它可以实现加密解密，甚至还可以当CA来用，可以让你创建证书、吊销证书。</p>\n<h3 id=\"二、为什么要使用https\"><a href=\"#二、为什么要使用https\" class=\"headerlink\" title=\"二、为什么要使用https\"></a>二、为什么要使用https</h3><p>1.数据加密，提高安全性。</p>\n<p>2.证书保证，防止冒充</p>\n<p>3.校验数据，防止被篡改</p>\n<h3 id=\"三、如何使用https\"><a href=\"#三、如何使用https\" class=\"headerlink\" title=\"三、如何使用https\"></a>三、如何使用https</h3><h4 id=\"1-使用openssl生成本地证书\"><a href=\"#1-使用openssl生成本地证书\" class=\"headerlink\" title=\"1.使用openssl生成本地证书\"></a>1.使用openssl生成本地证书</h4><h5 id=\"1）准备工作\"><a href=\"#1）准备工作\" class=\"headerlink\" title=\"1）准备工作\"></a>1）准备工作</h5><p>创建一个存放证书的目录，如/sshkey：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">mkdir sshkey</span><br></pre></td></tr></table></figure></p>\n<p>在sskkey目录下创建demoCA子目录<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd sshkey</span><br><span class=\"line\">mkdir demoCA &amp;&amp; cd demoCA &amp;&amp; touch index.txt &amp;&amp; touch serial &amp;&amp; echo &quot;01&quot;&gt;./serial &amp;&amp; mkdir newcerts</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2）正式生成：\"><a href=\"#2）正式生成：\" class=\"headerlink\" title=\"2）正式生成：\"></a>2）正式生成：</h4><p>制作CA证书：</p>\n<p>第一步：生成ca.key CA私钥<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out ca.key 2048</span><br></pre></td></tr></table></figure></p>\n<p>第二步：生成ca.crt CA根证书（公钥）：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -x509 -days 7305 -key ca.key -out ca.crt</span><br></pre></td></tr></table></figure></p>\n<p>生成网站的证书，并用CA签名认证（假设网站域名为<a href=\"http://www.example.com）\">www.example.com）</a></p>\n<p>第三步：生成<a href=\"http://www.example.com证书私钥：\">www.example.com证书私钥：</a><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out www.example.com.pem 1024</span><br></pre></td></tr></table></figure></p>\n<p>第四步：制作解密后的<a href=\"http://www.example.com证书私钥：\">www.example.com证书私钥：</a><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -in www.example.com.pem -out www.example.com.key</span><br></pre></td></tr></table></figure><br>ps:在common name中填入网站域名，如<a href=\"http://www.example.com即可生成改站点的证书\">www.example.com即可生成改站点的证书</a>(这里一定要填入common name，不然生成的东西为空)</p>\n<p>第五步：生成签名请求：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -key www.example.com.pem -out www.example.com.csr</span><br></pre></td></tr></table></figure></p>\n<p>第六步：用CA进行签名：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl ca -policy policy_anything -days 1460 -cert ca.crt -keyfile ca.key -in www.example.com.csr -out www.example.com.crt</span><br></pre></td></tr></table></figure></p>\n<p>如果一切顺利，生成完成之后在demoCA下应该会看到如下子目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ls</span></span><br><span class=\"line\">ca.crt # 根证书</span><br><span class=\"line\">ca.key # CA私钥</span><br><span class=\"line\">www.example.com.crt # </span><br><span class=\"line\">www.example.com.csr</span><br><span class=\"line\">www.example.com.key</span><br><span class=\"line\">www.example.com.pem</span><br><span class=\"line\">demoCA\t\t\t</span><br></pre></td></tr></table></figure>\n<h5 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h5><p>如果遇到如下报错<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Using configuration from /private/etc/ssl/openssl.cnf</span><br><span class=\"line\">variable lookup failed for ca::default_ca</span><br><span class=\"line\">140735980385160:error:0E06D06C:configuration file routines:NCONF_get_string:no value:/BuildRoot/Library/Caches/com.apple.xbs/Sources/libressl/libressl-22/libressl/crypto/conf/conf_lib.c:323:group=ca name=default_ca</span><br></pre></td></tr></table></figure></p>\n<p>解决办法：将openssl安装目录下的openssl.cnf 拷贝到配置目录<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /usr/local/etc/openssl/openssl.cnf /private/etc/ssl/openssl.cnf</span><br></pre></td></tr></table></figure></p>\n<p>并修改其中的配置文件的dir的文件路径为之前创建的demoCA文件路径<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir &gt;&gt; = /Users/zsr/learn/epoos/sshkey/demoCA/ &gt; &gt;</span><br></pre></td></tr></table></figure></p>\n<p>至此，使用openssl生成本地证书的过程就结束了，接下来就只需要在nginx中配置一番就可以看到一个https的网站了。</p>\n<h4 id=\"2-生成证书之后nginx配置如下：\"><a href=\"#2-生成证书之后nginx配置如下：\" class=\"headerlink\" title=\"2.生成证书之后nginx配置如下：\"></a>2.生成证书之后nginx配置如下：</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 server # 使用nginx做普通http代理</span><br><span class=\"line\"> 2 &#123;</span><br><span class=\"line\"> 3     listen 80;</span><br><span class=\"line\"> 4     server_name www.example.com;</span><br><span class=\"line\"> 5     index index.html;</span><br><span class=\"line\"> 6     location /</span><br><span class=\"line\"> 7     &#123;</span><br><span class=\"line\"> 8         #proxy_pass http://10.242.22.138:8084/;</span><br><span class=\"line\"> 9         alias /Users/zsr/learn/example/;</span><br><span class=\"line\">10     &#125;</span><br><span class=\"line\">11     error_log /usr/local/etc/nginx/logs/error.log;</span><br><span class=\"line\">12 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">13 server # 使用nginx做普通https代理</span><br><span class=\"line\">14 &#123;</span><br><span class=\"line\">15   listen 443;</span><br><span class=\"line\">16   server_name www.example.com;</span><br><span class=\"line\">17   index index.html;</span><br><span class=\"line\">18   location /</span><br><span class=\"line\">19   &#123;</span><br><span class=\"line\">20     alias /Users/zsr/learn/example/;</span><br><span class=\"line\">21   &#125;</span><br><span class=\"line\">22   ssl on;</span><br><span class=\"line\">23   ssl_certificate /Users/zsr/learn/example/sshkey/www.example.com.crt</span><br><span class=\"line\">24   ssl_certificate_key /Users/zsr/learn/example/sshkey/www.example.com.key</span><br><span class=\"line\">25 &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"相关传送门：\"><a href=\"#相关传送门：\" class=\"headerlink\" title=\"相关传送门：\"></a>相关传送门：</h3><p>生成证书<br><a href=\"http://blog.creke.net/762.html\">http://blog.creke.net/762.html</a></p>\n<p>https介绍：<br><a href=\"http://wetest.qq.com/lab/view/110.html\">http://wetest.qq.com/lab/view/110.html</a></p>\n<p>知乎上的https介绍：<br><a href=\"https://zhuanlan.zhihu.com/p/26682342\">https://zhuanlan.zhihu.com/p/26682342</a></p>\n<p>简书上的介绍<br><a href=\"http://www.jianshu.com/p/7158568e4867\">http://www.jianshu.com/p/7158568e4867</a></p>\n<p>阮一峰系列</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2016/08/http.html\">http://www.ruanyifeng.com/blog/2016/08/http.html</a></p>\n"},{"title":"iphoneX 兼容","date":"2019-01-07T16:00:00.000Z","_content":"\niphone 齐刘海兼容，作为前端开发几乎是绕不过去的一道坎。\n很早之前就遇到过，这里记录一下其解决办法。\n\n大致思路就是：\n第一步：在 H5 页面头部加入 meta，设置如下：\n```html\n<meta name=\"viewport\" content=\"width=device-width, viewport-fit=cover\">\n```\n\n第二步：在 css 中空出一个安全距离。\n```css\npadding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS < 11.2 */\npadding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS >= 11.2 */\n```\n\n解释：\n当然，不一定要用上面的 padding，可以是margin、padding、postion 的 top、left 等等。\n具体视情况而定。\n\n其兼容关键在于下面两个属性。\n```css\nconstant(safe-area-inset-bottom)\nenv(safe-area-inset-bottom)\n```\n\nconstant() 和 env() 函数是 ios11 新增特性，webkit的一个 css 函数。\n用于设定安全区域的与边界的距离。\n有四个预定义变量。\n```html\nsafe-area-inset-left：安全区域距离左边边界距离\nsafe-area-inset-right：安全区域距离右边边界距离\nsafe-area-inset-top：安全区域距离顶部边界距离\nsafe-area-inset-bottom：安全区域距离底部边界距离\n```\n\n上面的方法与属性的组合目的就是计算出安全的边距。\n这个边距只针对需要边距的设备（如：iphonex）生效。\n\n有了这个边距，接下来我们不论是 margin、padding还是其他，只要能将这个边距空出来就能实现安全距离了。\n\n当然，有的时候我们还需要再安全距离的基础上多上一些距离，此时\n可以考虑用 css3 的 calc 属性\n\n**注意**\n通过 margin、padding、position 等空白出来的边距有时候会出现透明的情况。\n此时，如果我们不希望透明，我们可以通过设置一个 div 盒子，对其设置背景颜色，并使其置底。\n然后，在 div 盒子内部，通过对子元素设置 margin、padding **安全距离** 来实现不透明的安全边距。\n\n如下：\n```html\n<div class=\"safe-box\">\n  <div class=\"safe-child\"></div>\n</div>\n```\n```css\n.safe-box {\n  background: #fff;\n  position: fixed;\n  width: 100%;\n  bottom: 0;\n  left: 0;\n}\n.safe-child {\n  height: 30px;\n  padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS < 11.2 */\n  padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS >= 11.2 */\n}\n```\n\n总之，只要能拿到安全的边距，我们可以灵活的做任何处理。\n\n","source":"_posts/iphonex.md","raw":"---\ntitle: iphoneX 兼容\ndate: 2019/01/08\ntag: [iphonex, 齐刘海, css]\n---\n\niphone 齐刘海兼容，作为前端开发几乎是绕不过去的一道坎。\n很早之前就遇到过，这里记录一下其解决办法。\n\n大致思路就是：\n第一步：在 H5 页面头部加入 meta，设置如下：\n```html\n<meta name=\"viewport\" content=\"width=device-width, viewport-fit=cover\">\n```\n\n第二步：在 css 中空出一个安全距离。\n```css\npadding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS < 11.2 */\npadding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS >= 11.2 */\n```\n\n解释：\n当然，不一定要用上面的 padding，可以是margin、padding、postion 的 top、left 等等。\n具体视情况而定。\n\n其兼容关键在于下面两个属性。\n```css\nconstant(safe-area-inset-bottom)\nenv(safe-area-inset-bottom)\n```\n\nconstant() 和 env() 函数是 ios11 新增特性，webkit的一个 css 函数。\n用于设定安全区域的与边界的距离。\n有四个预定义变量。\n```html\nsafe-area-inset-left：安全区域距离左边边界距离\nsafe-area-inset-right：安全区域距离右边边界距离\nsafe-area-inset-top：安全区域距离顶部边界距离\nsafe-area-inset-bottom：安全区域距离底部边界距离\n```\n\n上面的方法与属性的组合目的就是计算出安全的边距。\n这个边距只针对需要边距的设备（如：iphonex）生效。\n\n有了这个边距，接下来我们不论是 margin、padding还是其他，只要能将这个边距空出来就能实现安全距离了。\n\n当然，有的时候我们还需要再安全距离的基础上多上一些距离，此时\n可以考虑用 css3 的 calc 属性\n\n**注意**\n通过 margin、padding、position 等空白出来的边距有时候会出现透明的情况。\n此时，如果我们不希望透明，我们可以通过设置一个 div 盒子，对其设置背景颜色，并使其置底。\n然后，在 div 盒子内部，通过对子元素设置 margin、padding **安全距离** 来实现不透明的安全边距。\n\n如下：\n```html\n<div class=\"safe-box\">\n  <div class=\"safe-child\"></div>\n</div>\n```\n```css\n.safe-box {\n  background: #fff;\n  position: fixed;\n  width: 100%;\n  bottom: 0;\n  left: 0;\n}\n.safe-child {\n  height: 30px;\n  padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS < 11.2 */\n  padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS >= 11.2 */\n}\n```\n\n总之，只要能拿到安全的边距，我们可以灵活的做任何处理。\n\n","slug":"iphonex","published":1,"updated":"2021-03-30T01:32:00.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufk000la0vzbb68avdz","content":"<p>iphone 齐刘海兼容，作为前端开发几乎是绕不过去的一道坎。<br>很早之前就遇到过，这里记录一下其解决办法。</p>\n<p>大致思路就是：<br>第一步：在 H5 页面头部加入 meta，设置如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, viewport-fit=cover&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>第二步：在 css 中空出一个安全距离。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">padding-bottom</span>: <span class=\"selector-tag\">constant</span>(<span class=\"selector-tag\">safe-area-inset-bottom</span>); <span class=\"comment\">/* 兼容 iOS &lt; 11.2 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">padding-bottom</span>: <span class=\"selector-tag\">env</span>(<span class=\"selector-tag\">safe-area-inset-bottom</span>); <span class=\"comment\">/* 兼容 iOS &gt;= 11.2 */</span></span><br></pre></td></tr></table></figure></p>\n<p>解释：<br>当然，不一定要用上面的 padding，可以是margin、padding、postion 的 top、left 等等。<br>具体视情况而定。</p>\n<p>其兼容关键在于下面两个属性。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">constant</span>(<span class=\"selector-tag\">safe-area-inset-bottom</span>)</span><br><span class=\"line\"><span class=\"selector-tag\">env</span>(<span class=\"selector-tag\">safe-area-inset-bottom</span>)</span><br></pre></td></tr></table></figure></p>\n<p>constant() 和 env() 函数是 ios11 新增特性，webkit的一个 css 函数。<br>用于设定安全区域的与边界的距离。<br>有四个预定义变量。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">safe-area-inset-left：安全区域距离左边边界距离</span><br><span class=\"line\">safe-area-inset-right：安全区域距离右边边界距离</span><br><span class=\"line\">safe-area-inset-top：安全区域距离顶部边界距离</span><br><span class=\"line\">safe-area-inset-bottom：安全区域距离底部边界距离</span><br></pre></td></tr></table></figure></p>\n<p>上面的方法与属性的组合目的就是计算出安全的边距。<br>这个边距只针对需要边距的设备（如：iphonex）生效。</p>\n<p>有了这个边距，接下来我们不论是 margin、padding还是其他，只要能将这个边距空出来就能实现安全距离了。</p>\n<p>当然，有的时候我们还需要再安全距离的基础上多上一些距离，此时<br>可以考虑用 css3 的 calc 属性</p>\n<p><strong>注意</strong><br>通过 margin、padding、position 等空白出来的边距有时候会出现透明的情况。<br>此时，如果我们不希望透明，我们可以通过设置一个 div 盒子，对其设置背景颜色，并使其置底。<br>然后，在 div 盒子内部，通过对子元素设置 margin、padding <strong>安全距离</strong> 来实现不透明的安全边距。</p>\n<p>如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;safe-box&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;safe-child&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.safe-box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.safe-child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"built_in\">constant</span>(safe-area-inset-bottom); <span class=\"comment\">/* 兼容 iOS &lt; 11.2 */</span></span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"built_in\">env</span>(safe-area-inset-bottom); <span class=\"comment\">/* 兼容 iOS &gt;= 11.2 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>总之，只要能拿到安全的边距，我们可以灵活的做任何处理。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>iphone 齐刘海兼容，作为前端开发几乎是绕不过去的一道坎。<br>很早之前就遇到过，这里记录一下其解决办法。</p>\n<p>大致思路就是：<br>第一步：在 H5 页面头部加入 meta，设置如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, viewport-fit=cover&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>第二步：在 css 中空出一个安全距离。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">padding-bottom</span>: <span class=\"selector-tag\">constant</span>(<span class=\"selector-tag\">safe-area-inset-bottom</span>); <span class=\"comment\">/* 兼容 iOS &lt; 11.2 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">padding-bottom</span>: <span class=\"selector-tag\">env</span>(<span class=\"selector-tag\">safe-area-inset-bottom</span>); <span class=\"comment\">/* 兼容 iOS &gt;= 11.2 */</span></span><br></pre></td></tr></table></figure></p>\n<p>解释：<br>当然，不一定要用上面的 padding，可以是margin、padding、postion 的 top、left 等等。<br>具体视情况而定。</p>\n<p>其兼容关键在于下面两个属性。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">constant</span>(<span class=\"selector-tag\">safe-area-inset-bottom</span>)</span><br><span class=\"line\"><span class=\"selector-tag\">env</span>(<span class=\"selector-tag\">safe-area-inset-bottom</span>)</span><br></pre></td></tr></table></figure></p>\n<p>constant() 和 env() 函数是 ios11 新增特性，webkit的一个 css 函数。<br>用于设定安全区域的与边界的距离。<br>有四个预定义变量。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">safe-area-inset-left：安全区域距离左边边界距离</span><br><span class=\"line\">safe-area-inset-right：安全区域距离右边边界距离</span><br><span class=\"line\">safe-area-inset-top：安全区域距离顶部边界距离</span><br><span class=\"line\">safe-area-inset-bottom：安全区域距离底部边界距离</span><br></pre></td></tr></table></figure></p>\n<p>上面的方法与属性的组合目的就是计算出安全的边距。<br>这个边距只针对需要边距的设备（如：iphonex）生效。</p>\n<p>有了这个边距，接下来我们不论是 margin、padding还是其他，只要能将这个边距空出来就能实现安全距离了。</p>\n<p>当然，有的时候我们还需要再安全距离的基础上多上一些距离，此时<br>可以考虑用 css3 的 calc 属性</p>\n<p><strong>注意</strong><br>通过 margin、padding、position 等空白出来的边距有时候会出现透明的情况。<br>此时，如果我们不希望透明，我们可以通过设置一个 div 盒子，对其设置背景颜色，并使其置底。<br>然后，在 div 盒子内部，通过对子元素设置 margin、padding <strong>安全距离</strong> 来实现不透明的安全边距。</p>\n<p>如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;safe-box&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;safe-child&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.safe-box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.safe-child</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"built_in\">constant</span>(safe-area-inset-bottom); <span class=\"comment\">/* 兼容 iOS &lt; 11.2 */</span></span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"built_in\">env</span>(safe-area-inset-bottom); <span class=\"comment\">/* 兼容 iOS &gt;= 11.2 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>总之，只要能拿到安全的边距，我们可以灵活的做任何处理。</p>\n"},{"title":"item2基础","date":"2020-07-23T16:00:00.000Z","_content":"\n## item2使用快捷键\n\n### 设置快捷键\n```html\nitem2 - Preferences - Profiles - keys\n在此设置界面可以设置唤起的快捷键\n也可以配置一些自定义的快捷键\n```\n\n### 设置皮肤\n```html\nitem2 - Preferences -Profiles - color\n```\n\n### 标签\n```html\n新建标签：command + t\n关闭标签：command + w\n切换标签：command + 数字 / command + 左右方向键\n切换全屏：command + enter\n查找：command + f\n```\n\n### 分屏\n```html\n垂直分屏：command + d\n水平分屏：command + shift + d\n切换屏幕：command + option + 方向键 command + [ 或 command + ]\n查看历史命令：command + ;\n查看剪贴板历史：command + shift + h\n```\n\n### 其它\n```html\n清除当前行：ctrl + u\n到行首：ctrl + a\n到行尾：ctrl + e\n前进后退：ctrl + f/b (相当于左右方向键)\n上一条命令：ctrl + p\n搜索命令历史：ctrl + r\n删除当前光标的字符：ctrl + d\n删除光标之前的字符：ctrl + h\n删除光标之前的单词：ctrl + w\n删除到文本末尾：ctrl + k\n交换光标处文本：ctrl + t\n清屏1：command + r 或者 ctrl + l (向上滚动到干净处，相当于翻页)\n清屏2：command + k (真正清除当前视口的数据)\n```\n","source":"_posts/item2.md","raw":"---\ntitle: item2基础\ntag: [item2]\ndate: 2020/07/24\ncategory: 笔记\n---\n\n## item2使用快捷键\n\n### 设置快捷键\n```html\nitem2 - Preferences - Profiles - keys\n在此设置界面可以设置唤起的快捷键\n也可以配置一些自定义的快捷键\n```\n\n### 设置皮肤\n```html\nitem2 - Preferences -Profiles - color\n```\n\n### 标签\n```html\n新建标签：command + t\n关闭标签：command + w\n切换标签：command + 数字 / command + 左右方向键\n切换全屏：command + enter\n查找：command + f\n```\n\n### 分屏\n```html\n垂直分屏：command + d\n水平分屏：command + shift + d\n切换屏幕：command + option + 方向键 command + [ 或 command + ]\n查看历史命令：command + ;\n查看剪贴板历史：command + shift + h\n```\n\n### 其它\n```html\n清除当前行：ctrl + u\n到行首：ctrl + a\n到行尾：ctrl + e\n前进后退：ctrl + f/b (相当于左右方向键)\n上一条命令：ctrl + p\n搜索命令历史：ctrl + r\n删除当前光标的字符：ctrl + d\n删除光标之前的字符：ctrl + h\n删除光标之前的单词：ctrl + w\n删除到文本末尾：ctrl + k\n交换光标处文本：ctrl + t\n清屏1：command + r 或者 ctrl + l (向上滚动到干净处，相当于翻页)\n清屏2：command + k (真正清除当前视口的数据)\n```\n","slug":"item2","published":1,"updated":"2021-03-30T01:32:00.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufl000ma0vz0yur31gh","content":"<h2 id=\"item2使用快捷键\"><a href=\"#item2使用快捷键\" class=\"headerlink\" title=\"item2使用快捷键\"></a>item2使用快捷键</h2><h3 id=\"设置快捷键\"><a href=\"#设置快捷键\" class=\"headerlink\" title=\"设置快捷键\"></a>设置快捷键</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item2 - Preferences - Profiles - keys</span><br><span class=\"line\">在此设置界面可以设置唤起的快捷键</span><br><span class=\"line\">也可以配置一些自定义的快捷键</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置皮肤\"><a href=\"#设置皮肤\" class=\"headerlink\" title=\"设置皮肤\"></a>设置皮肤</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item2 - Preferences -Profiles - color</span><br></pre></td></tr></table></figure>\n<h3 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">新建标签：command + t</span><br><span class=\"line\">关闭标签：command + w</span><br><span class=\"line\">切换标签：command + 数字 / command + 左右方向键</span><br><span class=\"line\">切换全屏：command + enter</span><br><span class=\"line\">查找：command + f</span><br></pre></td></tr></table></figure>\n<h3 id=\"分屏\"><a href=\"#分屏\" class=\"headerlink\" title=\"分屏\"></a>分屏</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">垂直分屏：command + d</span><br><span class=\"line\">水平分屏：command + shift + d</span><br><span class=\"line\">切换屏幕：command + option + 方向键 command + [ 或 command + ]</span><br><span class=\"line\">查看历史命令：command + ;</span><br><span class=\"line\">查看剪贴板历史：command + shift + h</span><br></pre></td></tr></table></figure>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">清除当前行：ctrl + u</span><br><span class=\"line\">到行首：ctrl + a</span><br><span class=\"line\">到行尾：ctrl + e</span><br><span class=\"line\">前进后退：ctrl + f/b (相当于左右方向键)</span><br><span class=\"line\">上一条命令：ctrl + p</span><br><span class=\"line\">搜索命令历史：ctrl + r</span><br><span class=\"line\">删除当前光标的字符：ctrl + d</span><br><span class=\"line\">删除光标之前的字符：ctrl + h</span><br><span class=\"line\">删除光标之前的单词：ctrl + w</span><br><span class=\"line\">删除到文本末尾：ctrl + k</span><br><span class=\"line\">交换光标处文本：ctrl + t</span><br><span class=\"line\">清屏1：command + r 或者 ctrl + l (向上滚动到干净处，相当于翻页)</span><br><span class=\"line\">清屏2：command + k (真正清除当前视口的数据)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"item2使用快捷键\"><a href=\"#item2使用快捷键\" class=\"headerlink\" title=\"item2使用快捷键\"></a>item2使用快捷键</h2><h3 id=\"设置快捷键\"><a href=\"#设置快捷键\" class=\"headerlink\" title=\"设置快捷键\"></a>设置快捷键</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item2 - Preferences - Profiles - keys</span><br><span class=\"line\">在此设置界面可以设置唤起的快捷键</span><br><span class=\"line\">也可以配置一些自定义的快捷键</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置皮肤\"><a href=\"#设置皮肤\" class=\"headerlink\" title=\"设置皮肤\"></a>设置皮肤</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item2 - Preferences -Profiles - color</span><br></pre></td></tr></table></figure>\n<h3 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">新建标签：command + t</span><br><span class=\"line\">关闭标签：command + w</span><br><span class=\"line\">切换标签：command + 数字 / command + 左右方向键</span><br><span class=\"line\">切换全屏：command + enter</span><br><span class=\"line\">查找：command + f</span><br></pre></td></tr></table></figure>\n<h3 id=\"分屏\"><a href=\"#分屏\" class=\"headerlink\" title=\"分屏\"></a>分屏</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">垂直分屏：command + d</span><br><span class=\"line\">水平分屏：command + shift + d</span><br><span class=\"line\">切换屏幕：command + option + 方向键 command + [ 或 command + ]</span><br><span class=\"line\">查看历史命令：command + ;</span><br><span class=\"line\">查看剪贴板历史：command + shift + h</span><br></pre></td></tr></table></figure>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">清除当前行：ctrl + u</span><br><span class=\"line\">到行首：ctrl + a</span><br><span class=\"line\">到行尾：ctrl + e</span><br><span class=\"line\">前进后退：ctrl + f/b (相当于左右方向键)</span><br><span class=\"line\">上一条命令：ctrl + p</span><br><span class=\"line\">搜索命令历史：ctrl + r</span><br><span class=\"line\">删除当前光标的字符：ctrl + d</span><br><span class=\"line\">删除光标之前的字符：ctrl + h</span><br><span class=\"line\">删除光标之前的单词：ctrl + w</span><br><span class=\"line\">删除到文本末尾：ctrl + k</span><br><span class=\"line\">交换光标处文本：ctrl + t</span><br><span class=\"line\">清屏1：command + r 或者 ctrl + l (向上滚动到干净处，相当于翻页)</span><br><span class=\"line\">清屏2：command + k (真正清除当前视口的数据)</span><br></pre></td></tr></table></figure>\n"},{"title":"在Osx环境下启动Apache","date":"2017-11-07T16:00:00.000Z","_content":"\n服务端语言千千万，java一直是后端开发的首选，如果后端语言是java，freemarker模板，则需要在本地启动apache-tomcat服务\n\n### 下面将配置过程做一下记录\n\n首先，**jdk安装**在osx下可以是可以多个版本的jdk共存的，并不会安装一个低版本的之后就覆盖了另一个版本\n通过下面的命令可以查看安装了那些jdk以及相应的安装目录\n``` shell\n/usr/libexec/java_home -V\n```\n\n结果：\n``` shell\nzsr:~ zsr$ /usr/libexec/java_home -V\nMatching Java Virtual Machines (2):\n    1.8.0_141, x86_64:\t\"Java SE 8\"\t/Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home\n    1.7.0_80, x86_64:\t\"Java SE 7\"\t/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home\n\n/Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home\n```\n\n可以看到，当前我的机器/Library/Java/JavaVirtualMachines目录下面有两个版本的jdk，默认使用的是高版本的这个。\n\n另外还可以通过\n``` shell\njava -version\n\n```\n命令查看运行的是哪个jdk版本\n\n---\n\n另外还需要**配置apache-tomcat**\n\n启动apache-tomcat也有一些特殊，是直接找到文件包\n\n``` shell\ncd ~/apache-tomcat-7.0.11/bin\nsh startup.sh\n```\n\n关闭服务\n\n``` shell\ncd ~/apache-tomcat-7.0.11/bin\nsh shutdown.sh\n```\n\n如果直接如上面这样运行可能不行，因为没有指定想应的java环境变量，因此还需要如下配置\n\n``` shell\ncd ~/apache-tomcat-7.0.11/bin\nvim setclasspath.sh\n```\n\n在文件中添加如下两个对应的jdk的位置路径\n``` shell\nexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home\nJRE_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre\n```\n\n\n\n\n\n\n\n\n","source":"_posts/javapath.md","raw":"---\ntitle: 在Osx环境下启动Apache\ndate: 2017/11/08\ntag: [java,apache,jdk]\ncategory: 技术\n---\n\n服务端语言千千万，java一直是后端开发的首选，如果后端语言是java，freemarker模板，则需要在本地启动apache-tomcat服务\n\n### 下面将配置过程做一下记录\n\n首先，**jdk安装**在osx下可以是可以多个版本的jdk共存的，并不会安装一个低版本的之后就覆盖了另一个版本\n通过下面的命令可以查看安装了那些jdk以及相应的安装目录\n``` shell\n/usr/libexec/java_home -V\n```\n\n结果：\n``` shell\nzsr:~ zsr$ /usr/libexec/java_home -V\nMatching Java Virtual Machines (2):\n    1.8.0_141, x86_64:\t\"Java SE 8\"\t/Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home\n    1.7.0_80, x86_64:\t\"Java SE 7\"\t/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home\n\n/Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home\n```\n\n可以看到，当前我的机器/Library/Java/JavaVirtualMachines目录下面有两个版本的jdk，默认使用的是高版本的这个。\n\n另外还可以通过\n``` shell\njava -version\n\n```\n命令查看运行的是哪个jdk版本\n\n---\n\n另外还需要**配置apache-tomcat**\n\n启动apache-tomcat也有一些特殊，是直接找到文件包\n\n``` shell\ncd ~/apache-tomcat-7.0.11/bin\nsh startup.sh\n```\n\n关闭服务\n\n``` shell\ncd ~/apache-tomcat-7.0.11/bin\nsh shutdown.sh\n```\n\n如果直接如上面这样运行可能不行，因为没有指定想应的java环境变量，因此还需要如下配置\n\n``` shell\ncd ~/apache-tomcat-7.0.11/bin\nvim setclasspath.sh\n```\n\n在文件中添加如下两个对应的jdk的位置路径\n``` shell\nexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home\nJRE_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre\n```\n\n\n\n\n\n\n\n\n","slug":"javapath","published":1,"updated":"2021-03-30T01:32:00.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufl000na0vzh60670d1","content":"<p>服务端语言千千万，java一直是后端开发的首选，如果后端语言是java，freemarker模板，则需要在本地启动apache-tomcat服务</p>\n<h3 id=\"下面将配置过程做一下记录\"><a href=\"#下面将配置过程做一下记录\" class=\"headerlink\" title=\"下面将配置过程做一下记录\"></a>下面将配置过程做一下记录</h3><p>首先，<strong>jdk安装</strong>在osx下可以是可以多个版本的jdk共存的，并不会安装一个低版本的之后就覆盖了另一个版本<br>通过下面的命令可以查看安装了那些jdk以及相应的安装目录<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/java_home -V</span><br></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zsr:~ zsr$ /usr/libexec/java_home -V</span><br><span class=\"line\">Matching Java Virtual Machines (2):</span><br><span class=\"line\">    1.8.0_141, x86_64:\t&quot;Java SE 8&quot;\t/Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home</span><br><span class=\"line\">    1.7.0_80, x86_64:\t&quot;Java SE 7&quot;\t/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home</span><br><span class=\"line\"></span><br><span class=\"line\">/Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，当前我的机器/Library/Java/JavaVirtualMachines目录下面有两个版本的jdk，默认使用的是高版本的这个。</p>\n<p>另外还可以通过<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -version</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>命令查看运行的是哪个jdk版本</p>\n<hr>\n<p>另外还需要<strong>配置apache-tomcat</strong></p>\n<p>启动apache-tomcat也有一些特殊，是直接找到文件包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/apache-tomcat-7.0.11/bin</span><br><span class=\"line\">sh startup.sh</span><br></pre></td></tr></table></figure>\n<p>关闭服务</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/apache-tomcat-7.0.11/bin</span><br><span class=\"line\">sh shutdown.sh</span><br></pre></td></tr></table></figure>\n<p>如果直接如上面这样运行可能不行，因为没有指定想应的java环境变量，因此还需要如下配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/apache-tomcat-7.0.11/bin</span><br><span class=\"line\">vim setclasspath.sh</span><br></pre></td></tr></table></figure>\n<p>在文件中添加如下两个对应的jdk的位置路径<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home</span><br><span class=\"line\">JRE_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>服务端语言千千万，java一直是后端开发的首选，如果后端语言是java，freemarker模板，则需要在本地启动apache-tomcat服务</p>\n<h3 id=\"下面将配置过程做一下记录\"><a href=\"#下面将配置过程做一下记录\" class=\"headerlink\" title=\"下面将配置过程做一下记录\"></a>下面将配置过程做一下记录</h3><p>首先，<strong>jdk安装</strong>在osx下可以是可以多个版本的jdk共存的，并不会安装一个低版本的之后就覆盖了另一个版本<br>通过下面的命令可以查看安装了那些jdk以及相应的安装目录<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/libexec/java_home -V</span><br></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zsr:~ zsr$ /usr/libexec/java_home -V</span><br><span class=\"line\">Matching Java Virtual Machines (2):</span><br><span class=\"line\">    1.8.0_141, x86_64:\t&quot;Java SE 8&quot;\t/Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home</span><br><span class=\"line\">    1.7.0_80, x86_64:\t&quot;Java SE 7&quot;\t/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home</span><br><span class=\"line\"></span><br><span class=\"line\">/Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，当前我的机器/Library/Java/JavaVirtualMachines目录下面有两个版本的jdk，默认使用的是高版本的这个。</p>\n<p>另外还可以通过<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -version</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>命令查看运行的是哪个jdk版本</p>\n<hr>\n<p>另外还需要<strong>配置apache-tomcat</strong></p>\n<p>启动apache-tomcat也有一些特殊，是直接找到文件包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/apache-tomcat-7.0.11/bin</span><br><span class=\"line\">sh startup.sh</span><br></pre></td></tr></table></figure>\n<p>关闭服务</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/apache-tomcat-7.0.11/bin</span><br><span class=\"line\">sh shutdown.sh</span><br></pre></td></tr></table></figure>\n<p>如果直接如上面这样运行可能不行，因为没有指定想应的java环境变量，因此还需要如下配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/apache-tomcat-7.0.11/bin</span><br><span class=\"line\">vim setclasspath.sh</span><br></pre></td></tr></table></figure>\n<p>在文件中添加如下两个对应的jdk的位置路径<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home</span><br><span class=\"line\">JRE_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Javascript数据类型","date":"2018-01-13T16:00:00.000Z","_content":"\nJavascript的基础知识。\n\nECMAScript 5的五种简单数据类型：Undefined、Null、Boolean、Number、String；\n\n另外还有一种es6新增的Symbol也是属于简单数据类型\n\n一种复杂数据类型： Object（Array、Function、RegExp、Date都属于 Object）\n\n除此之外还有特殊的类型，三种基本包装类型：Boolean、Number、String\n\n\n简单数据类型的值时保存在栈内存中的简单数据段，它们是按值访问的。\n\n复杂的数据类型（引用类型）的值是保存在堆内存中的对象，它的值时按照引用访问的。\n\n\n### 检测方法用typeof，打印出来分别是：\n```html\nundefined、boolean、string、number、object\n```\n\n### 常见类型判断方式\n```javascript\no = '';\nObject.prototype.toString.call(o).slice(8, -1) === 'String' # 判断字符串\no = NaN || o = 1;\nObject.prototype.toString.call(o).slice(8, -1) === 'Number' # 判断数值\no = null;\nObject.prototype.toString.call(o).slice(8, -1) === 'Null' # 判断为Null\no = undefined;\nObject.prototype.toString.call(o).slice(8, -1) === 'Undefined' # 判断为Undefined\no = true;\nObject.prototype.toString.call(o).slice(8, -1) === 'Boolean' # 判断为Boolean\nvar o = {};\nObject.prototype.toString.call(o).slice(8, -1) === 'Object' # 判断对象\no = [];\nObject.prototype.toString.call(o).slice(8, -1) === 'Array' # 判断数组\no = function(){};\nObject.prototype.toString.call(o).slice(8, -1) === 'Function' # 判断为Function\no = new Date();\nObject.prototype.toString.call(o).slice(8, -1) === 'Date' # 判断Date\no = new RegExp();\nObject.prototype.toString.call(o).slice(8, -1) === 'RegExp' # 判断RegExp\n\no = Symbol()\nObject.prototype.toString.call(o).slice(8, -1) === 'Symbol' # 判断Symbol\n```\n\n\n### 一些特殊的类型比较\n\n```javascript\ntypeof null // object ，特殊值null会被认为是空对象的引用\n\ntypeof NaN // number ，NaN是属于number类型的\n\nBoolean(NaN) // false\n\nnull == undefined // true，ECMAScript 规范认为，既然 null 和  undefined 的行为很相似，并且都表示 一个无效的值，那么它们所表示的内容也具有相似性\n\nnull === undefined // false\n\nundefined == 0 // false\n\nnull == 0 // false\n\nvar message;\nmessage === undefined // true;\n\n[] == [] // false，不相等，因为当两个值都是对象（引用值）时，比较的是两个引用值在内存中是否是同一个对象\n{} == {} // false，同上\n\n[] == false // true 隐式类型转换，全部转换为了0，0 == 0\n\nNaN == NaN // false\n```\n\n### 类型计算\n\n```javascript \n0.1+0.2 // 0.30000000000000004\n\nvar number = Number.MAX_VALUE + Number.MAX_VALUE;\nisFinite(number); // false isFinite这个函数在参数位于最小与最大值之间时会返回true\n```\n\n### 基本包装类型\n\n基本包装类型也是一种引用类型，除了拥有基本类型的特征外还拥有其特殊的特征，每当读取一个基本类型的值的时候，后台就会自动创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。\n\n```javascript\nvar str = 'abcdefg';\nvar newStr = str.substring(2);\n```\n\n本来str基本数据类型是没有方法的，但是，作为基本包装类型，后台自动创建了一个String类型的实例，在实例上调用指定的方法，最后销毁这个实例。\n\n```javascript\nvar str = new String('abcdefg');\nvar newStr = str.substring(2);\nstr = null;\n```\n\n\n\n\n\n\n\n","source":"_posts/js1.md","raw":"---\ntitle: Javascript数据类型\ndate: 2018/01/14\ntag: js\ncategory: 技术\n---\n\nJavascript的基础知识。\n\nECMAScript 5的五种简单数据类型：Undefined、Null、Boolean、Number、String；\n\n另外还有一种es6新增的Symbol也是属于简单数据类型\n\n一种复杂数据类型： Object（Array、Function、RegExp、Date都属于 Object）\n\n除此之外还有特殊的类型，三种基本包装类型：Boolean、Number、String\n\n\n简单数据类型的值时保存在栈内存中的简单数据段，它们是按值访问的。\n\n复杂的数据类型（引用类型）的值是保存在堆内存中的对象，它的值时按照引用访问的。\n\n\n### 检测方法用typeof，打印出来分别是：\n```html\nundefined、boolean、string、number、object\n```\n\n### 常见类型判断方式\n```javascript\no = '';\nObject.prototype.toString.call(o).slice(8, -1) === 'String' # 判断字符串\no = NaN || o = 1;\nObject.prototype.toString.call(o).slice(8, -1) === 'Number' # 判断数值\no = null;\nObject.prototype.toString.call(o).slice(8, -1) === 'Null' # 判断为Null\no = undefined;\nObject.prototype.toString.call(o).slice(8, -1) === 'Undefined' # 判断为Undefined\no = true;\nObject.prototype.toString.call(o).slice(8, -1) === 'Boolean' # 判断为Boolean\nvar o = {};\nObject.prototype.toString.call(o).slice(8, -1) === 'Object' # 判断对象\no = [];\nObject.prototype.toString.call(o).slice(8, -1) === 'Array' # 判断数组\no = function(){};\nObject.prototype.toString.call(o).slice(8, -1) === 'Function' # 判断为Function\no = new Date();\nObject.prototype.toString.call(o).slice(8, -1) === 'Date' # 判断Date\no = new RegExp();\nObject.prototype.toString.call(o).slice(8, -1) === 'RegExp' # 判断RegExp\n\no = Symbol()\nObject.prototype.toString.call(o).slice(8, -1) === 'Symbol' # 判断Symbol\n```\n\n\n### 一些特殊的类型比较\n\n```javascript\ntypeof null // object ，特殊值null会被认为是空对象的引用\n\ntypeof NaN // number ，NaN是属于number类型的\n\nBoolean(NaN) // false\n\nnull == undefined // true，ECMAScript 规范认为，既然 null 和  undefined 的行为很相似，并且都表示 一个无效的值，那么它们所表示的内容也具有相似性\n\nnull === undefined // false\n\nundefined == 0 // false\n\nnull == 0 // false\n\nvar message;\nmessage === undefined // true;\n\n[] == [] // false，不相等，因为当两个值都是对象（引用值）时，比较的是两个引用值在内存中是否是同一个对象\n{} == {} // false，同上\n\n[] == false // true 隐式类型转换，全部转换为了0，0 == 0\n\nNaN == NaN // false\n```\n\n### 类型计算\n\n```javascript \n0.1+0.2 // 0.30000000000000004\n\nvar number = Number.MAX_VALUE + Number.MAX_VALUE;\nisFinite(number); // false isFinite这个函数在参数位于最小与最大值之间时会返回true\n```\n\n### 基本包装类型\n\n基本包装类型也是一种引用类型，除了拥有基本类型的特征外还拥有其特殊的特征，每当读取一个基本类型的值的时候，后台就会自动创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。\n\n```javascript\nvar str = 'abcdefg';\nvar newStr = str.substring(2);\n```\n\n本来str基本数据类型是没有方法的，但是，作为基本包装类型，后台自动创建了一个String类型的实例，在实例上调用指定的方法，最后销毁这个实例。\n\n```javascript\nvar str = new String('abcdefg');\nvar newStr = str.substring(2);\nstr = null;\n```\n\n\n\n\n\n\n\n","slug":"js1","published":1,"updated":"2021-03-30T01:32:00.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufm000oa0vzgqycauqd","content":"<p>Javascript的基础知识。</p>\n<p>ECMAScript 5的五种简单数据类型：Undefined、Null、Boolean、Number、String；</p>\n<p>另外还有一种es6新增的Symbol也是属于简单数据类型</p>\n<p>一种复杂数据类型： Object（Array、Function、RegExp、Date都属于 Object）</p>\n<p>除此之外还有特殊的类型，三种基本包装类型：Boolean、Number、String</p>\n<p>简单数据类型的值时保存在栈内存中的简单数据段，它们是按值访问的。</p>\n<p>复杂的数据类型（引用类型）的值是保存在堆内存中的对象，它的值时按照引用访问的。</p>\n<h3 id=\"检测方法用typeof，打印出来分别是：\"><a href=\"#检测方法用typeof，打印出来分别是：\" class=\"headerlink\" title=\"检测方法用typeof，打印出来分别是：\"></a>检测方法用typeof，打印出来分别是：</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">undefined、boolean、string、number、object</span><br></pre></td></tr></table></figure>\n<h3 id=\"常见类型判断方式\"><a href=\"#常见类型判断方式\" class=\"headerlink\" title=\"常见类型判断方式\"></a>常见类型判断方式</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;String&#x27; # 判断字符串</span><br><span class=\"line\">o = <span class=\"literal\">NaN</span> || o = <span class=\"number\">1</span>;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Number&#x27; # 判断数值</span><br><span class=\"line\">o = <span class=\"literal\">null</span>;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Null&#x27; # 判断为Null</span><br><span class=\"line\">o = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Undefined&#x27; # 判断为Undefined</span><br><span class=\"line\">o = <span class=\"literal\">true</span>;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Boolean&#x27; # 判断为Boolean</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Object&#x27; # 判断对象</span><br><span class=\"line\">o = [];</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Array&#x27; # 判断数组</span><br><span class=\"line\">o = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Function&#x27; # 判断为Function</span><br><span class=\"line\">o = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Date&#x27; # 判断Date</span><br><span class=\"line\">o = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>();</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;RegExp&#x27; # 判断RegExp</span><br><span class=\"line\"></span><br><span class=\"line\">o = <span class=\"built_in\">Symbol</span>()</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Symbol&#x27; # 判断Symbol</span><br></pre></td></tr></table></figure>\n<h3 id=\"一些特殊的类型比较\"><a href=\"#一些特殊的类型比较\" class=\"headerlink\" title=\"一些特殊的类型比较\"></a>一些特殊的类型比较</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// object ，特殊值null会被认为是空对象的引用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">NaN</span> <span class=\"comment\">// number ，NaN是属于number类型的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"literal\">NaN</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// true，ECMAScript 规范认为，既然 null 和  undefined 的行为很相似，并且都表示 一个无效的值，那么它们所表示的内容也具有相似性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">undefined</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> message;</span><br><span class=\"line\">message === <span class=\"literal\">undefined</span> <span class=\"comment\">// true;</span></span><br><span class=\"line\"></span><br><span class=\"line\">[] == [] <span class=\"comment\">// false，不相等，因为当两个值都是对象（引用值）时，比较的是两个引用值在内存中是否是同一个对象</span></span><br><span class=\"line\">&#123;&#125; == &#123;&#125; <span class=\"comment\">// false，同上</span></span><br><span class=\"line\"></span><br><span class=\"line\">[] == <span class=\"literal\">false</span> <span class=\"comment\">// true 隐式类型转换，全部转换为了0，0 == 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类型计算\"><a href=\"#类型计算\" class=\"headerlink\" title=\"类型计算\"></a>类型计算</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span>+<span class=\"number\">0.2</span> <span class=\"comment\">// 0.30000000000000004</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"built_in\">Number</span>.MAX_VALUE + <span class=\"built_in\">Number</span>.MAX_VALUE;</span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(number); <span class=\"comment\">// false isFinite这个函数在参数位于最小与最大值之间时会返回true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"基本包装类型\"><a href=\"#基本包装类型\" class=\"headerlink\" title=\"基本包装类型\"></a>基本包装类型</h3><p>基本包装类型也是一种引用类型，除了拥有基本类型的特征外还拥有其特殊的特征，每当读取一个基本类型的值的时候，后台就会自动创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;abcdefg&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newStr = str.substring(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>本来str基本数据类型是没有方法的，但是，作为基本包装类型，后台自动创建了一个String类型的实例，在实例上调用指定的方法，最后销毁这个实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;abcdefg&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> newStr = str.substring(<span class=\"number\">2</span>);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Javascript的基础知识。</p>\n<p>ECMAScript 5的五种简单数据类型：Undefined、Null、Boolean、Number、String；</p>\n<p>另外还有一种es6新增的Symbol也是属于简单数据类型</p>\n<p>一种复杂数据类型： Object（Array、Function、RegExp、Date都属于 Object）</p>\n<p>除此之外还有特殊的类型，三种基本包装类型：Boolean、Number、String</p>\n<p>简单数据类型的值时保存在栈内存中的简单数据段，它们是按值访问的。</p>\n<p>复杂的数据类型（引用类型）的值是保存在堆内存中的对象，它的值时按照引用访问的。</p>\n<h3 id=\"检测方法用typeof，打印出来分别是：\"><a href=\"#检测方法用typeof，打印出来分别是：\" class=\"headerlink\" title=\"检测方法用typeof，打印出来分别是：\"></a>检测方法用typeof，打印出来分别是：</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">undefined、boolean、string、number、object</span><br></pre></td></tr></table></figure>\n<h3 id=\"常见类型判断方式\"><a href=\"#常见类型判断方式\" class=\"headerlink\" title=\"常见类型判断方式\"></a>常见类型判断方式</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;String&#x27; # 判断字符串</span><br><span class=\"line\">o = <span class=\"literal\">NaN</span> || o = <span class=\"number\">1</span>;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Number&#x27; # 判断数值</span><br><span class=\"line\">o = <span class=\"literal\">null</span>;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Null&#x27; # 判断为Null</span><br><span class=\"line\">o = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Undefined&#x27; # 判断为Undefined</span><br><span class=\"line\">o = <span class=\"literal\">true</span>;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Boolean&#x27; # 判断为Boolean</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Object&#x27; # 判断对象</span><br><span class=\"line\">o = [];</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Array&#x27; # 判断数组</span><br><span class=\"line\">o = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Function&#x27; # 判断为Function</span><br><span class=\"line\">o = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Date&#x27; # 判断Date</span><br><span class=\"line\">o = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>();</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;RegExp&#x27; # 判断RegExp</span><br><span class=\"line\"></span><br><span class=\"line\">o = <span class=\"built_in\">Symbol</span>()</span><br><span class=\"line\">Object.prototype.toString.call(o).slice(8, -1) === &#x27;Symbol&#x27; # 判断Symbol</span><br></pre></td></tr></table></figure>\n<h3 id=\"一些特殊的类型比较\"><a href=\"#一些特殊的类型比较\" class=\"headerlink\" title=\"一些特殊的类型比较\"></a>一些特殊的类型比较</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// object ，特殊值null会被认为是空对象的引用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">NaN</span> <span class=\"comment\">// number ，NaN是属于number类型的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"literal\">NaN</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// true，ECMAScript 规范认为，既然 null 和  undefined 的行为很相似，并且都表示 一个无效的值，那么它们所表示的内容也具有相似性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">undefined</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> message;</span><br><span class=\"line\">message === <span class=\"literal\">undefined</span> <span class=\"comment\">// true;</span></span><br><span class=\"line\"></span><br><span class=\"line\">[] == [] <span class=\"comment\">// false，不相等，因为当两个值都是对象（引用值）时，比较的是两个引用值在内存中是否是同一个对象</span></span><br><span class=\"line\">&#123;&#125; == &#123;&#125; <span class=\"comment\">// false，同上</span></span><br><span class=\"line\"></span><br><span class=\"line\">[] == <span class=\"literal\">false</span> <span class=\"comment\">// true 隐式类型转换，全部转换为了0，0 == 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类型计算\"><a href=\"#类型计算\" class=\"headerlink\" title=\"类型计算\"></a>类型计算</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span>+<span class=\"number\">0.2</span> <span class=\"comment\">// 0.30000000000000004</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> number = <span class=\"built_in\">Number</span>.MAX_VALUE + <span class=\"built_in\">Number</span>.MAX_VALUE;</span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(number); <span class=\"comment\">// false isFinite这个函数在参数位于最小与最大值之间时会返回true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"基本包装类型\"><a href=\"#基本包装类型\" class=\"headerlink\" title=\"基本包装类型\"></a>基本包装类型</h3><p>基本包装类型也是一种引用类型，除了拥有基本类型的特征外还拥有其特殊的特征，每当读取一个基本类型的值的时候，后台就会自动创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;abcdefg&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newStr = str.substring(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>本来str基本数据类型是没有方法的，但是，作为基本包装类型，后台自动创建了一个String类型的实例，在实例上调用指定的方法，最后销毁这个实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&#x27;abcdefg&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> newStr = str.substring(<span class=\"number\">2</span>);</span><br><span class=\"line\">str = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n"},{"title":"Javascript基本方法","date":"2018-01-14T16:00:00.000Z","_content":"\nJavascript的基础知识。\n\nECMAScript有几个常见的基本方法一直没怎么搞清楚，\n\n### 一、容易混淆的几个方法：split、slice、splice\n\n\n### split()\n\nsplit()方法用于将一个字符串分割成字符串数组\n```javascript\nvar str = 'abcdefg';\nvar strArr = str.split('');\nconsole.log(strArr); // [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n```\n\n### slice()\n\nslice()方法用于返回从数组中返回的元素，不会改变原数组\n```javascript\nvar arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\narr.slice(0, 1); // ['a']\narr.slice(2, 5); // ['c', 'd', 'e']\narr.slice(0); // 相当于深度拷贝数组\nvar str = 'abcdefg'; //也可以用于字符串\nstr.slice(2,5); // 'cde'\n```\n\n### splice()\n\nsplice() 用于对数组，删除添加和替换，会改变元素组\n```javascript\nvar arr = ['a', 'b', 'c', 'd', 'e'];\narr.splice(2, 5); // ['c', 'd', 'e']\n```\n\n\n### replace()正则\n\n```javascript\ntext = text.replace(/<wiki>(.+?)<\\/wiki>/g, function(match, contents, offset, input_string)\n    {\n        return \"<a href='wiki/\"+contents.replace(/ /g, '_')+\"'>\"+contents+\"</a>\";\n    }\n);\n```\n\n\n\n\n\n\n\n","source":"_posts/js2.md","raw":"---\ntitle: Javascript基本方法\ndate: 2018/01/15\ntag: js\ncategory: 技术\n---\n\nJavascript的基础知识。\n\nECMAScript有几个常见的基本方法一直没怎么搞清楚，\n\n### 一、容易混淆的几个方法：split、slice、splice\n\n\n### split()\n\nsplit()方法用于将一个字符串分割成字符串数组\n```javascript\nvar str = 'abcdefg';\nvar strArr = str.split('');\nconsole.log(strArr); // [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n```\n\n### slice()\n\nslice()方法用于返回从数组中返回的元素，不会改变原数组\n```javascript\nvar arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\narr.slice(0, 1); // ['a']\narr.slice(2, 5); // ['c', 'd', 'e']\narr.slice(0); // 相当于深度拷贝数组\nvar str = 'abcdefg'; //也可以用于字符串\nstr.slice(2,5); // 'cde'\n```\n\n### splice()\n\nsplice() 用于对数组，删除添加和替换，会改变元素组\n```javascript\nvar arr = ['a', 'b', 'c', 'd', 'e'];\narr.splice(2, 5); // ['c', 'd', 'e']\n```\n\n\n### replace()正则\n\n```javascript\ntext = text.replace(/<wiki>(.+?)<\\/wiki>/g, function(match, contents, offset, input_string)\n    {\n        return \"<a href='wiki/\"+contents.replace(/ /g, '_')+\"'>\"+contents+\"</a>\";\n    }\n);\n```\n\n\n\n\n\n\n\n","slug":"js2","published":1,"updated":"2021-03-30T01:32:00.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufm000pa0vz9aoyf2b7","content":"<p>Javascript的基础知识。</p>\n<p>ECMAScript有几个常见的基本方法一直没怎么搞清楚，</p>\n<h3 id=\"一、容易混淆的几个方法：split、slice、splice\"><a href=\"#一、容易混淆的几个方法：split、slice、splice\" class=\"headerlink\" title=\"一、容易混淆的几个方法：split、slice、splice\"></a>一、容易混淆的几个方法：split、slice、splice</h3><h3 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h3><p>split()方法用于将一个字符串分割成字符串数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;abcdefg&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> strArr = str.split(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strArr); <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice()\"></a>slice()</h3><p>slice()方法用于返回从数组中返回的元素，不会改变原数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;f&#x27;</span>, <span class=\"string\">&#x27;g&#x27;</span>];</span><br><span class=\"line\">arr.slice(<span class=\"number\">0</span>, <span class=\"number\">1</span>); <span class=\"comment\">// [&#x27;a&#x27;]</span></span><br><span class=\"line\">arr.slice(<span class=\"number\">2</span>, <span class=\"number\">5</span>); <span class=\"comment\">// [&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br><span class=\"line\">arr.slice(<span class=\"number\">0</span>); <span class=\"comment\">// 相当于深度拷贝数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;abcdefg&#x27;</span>; <span class=\"comment\">//也可以用于字符串</span></span><br><span class=\"line\">str.slice(<span class=\"number\">2</span>,<span class=\"number\">5</span>); <span class=\"comment\">// &#x27;cde&#x27;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice()\"></a>splice()</h3><p>splice() 用于对数组，删除添加和替换，会改变元素组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>];</span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>, <span class=\"number\">5</span>); <span class=\"comment\">// [&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"replace-正则\"><a href=\"#replace-正则\" class=\"headerlink\" title=\"replace()正则\"></a>replace()正则</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text = text.replace(<span class=\"regexp\">/&lt;wiki&gt;(.+?)&lt;\\/wiki&gt;/g</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">match, contents, offset, input_string</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&lt;a href=&#x27;wiki/&quot;</span>+contents.replace(<span class=\"regexp\">/ /g</span>, <span class=\"string\">&#x27;_&#x27;</span>)+<span class=\"string\">&quot;&#x27;&gt;&quot;</span>+contents+<span class=\"string\">&quot;&lt;/a&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Javascript的基础知识。</p>\n<p>ECMAScript有几个常见的基本方法一直没怎么搞清楚，</p>\n<h3 id=\"一、容易混淆的几个方法：split、slice、splice\"><a href=\"#一、容易混淆的几个方法：split、slice、splice\" class=\"headerlink\" title=\"一、容易混淆的几个方法：split、slice、splice\"></a>一、容易混淆的几个方法：split、slice、splice</h3><h3 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h3><p>split()方法用于将一个字符串分割成字符串数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;abcdefg&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> strArr = str.split(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strArr); <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice()\"></a>slice()</h3><p>slice()方法用于返回从数组中返回的元素，不会改变原数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;f&#x27;</span>, <span class=\"string\">&#x27;g&#x27;</span>];</span><br><span class=\"line\">arr.slice(<span class=\"number\">0</span>, <span class=\"number\">1</span>); <span class=\"comment\">// [&#x27;a&#x27;]</span></span><br><span class=\"line\">arr.slice(<span class=\"number\">2</span>, <span class=\"number\">5</span>); <span class=\"comment\">// [&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br><span class=\"line\">arr.slice(<span class=\"number\">0</span>); <span class=\"comment\">// 相当于深度拷贝数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;abcdefg&#x27;</span>; <span class=\"comment\">//也可以用于字符串</span></span><br><span class=\"line\">str.slice(<span class=\"number\">2</span>,<span class=\"number\">5</span>); <span class=\"comment\">// &#x27;cde&#x27;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice()\"></a>splice()</h3><p>splice() 用于对数组，删除添加和替换，会改变元素组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>];</span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>, <span class=\"number\">5</span>); <span class=\"comment\">// [&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"replace-正则\"><a href=\"#replace-正则\" class=\"headerlink\" title=\"replace()正则\"></a>replace()正则</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text = text.replace(<span class=\"regexp\">/&lt;wiki&gt;(.+?)&lt;\\/wiki&gt;/g</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">match, contents, offset, input_string</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&lt;a href=&#x27;wiki/&quot;</span>+contents.replace(<span class=\"regexp\">/ /g</span>, <span class=\"string\">&#x27;_&#x27;</span>)+<span class=\"string\">&quot;&#x27;&gt;&quot;</span>+contents+<span class=\"string\">&quot;&lt;/a&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n"},{"title":"AES加密和RSA加密","date":"2018-03-19T16:00:00.000Z","_content":"\n最近项目需要用到前端加密，某些特定的数据需要前端加密之后再传输到后端，然后后端再按照与前端约定好的方式进行解密。\n\n因此，在做项目的过程中也大概了解了一下常见的加密方式。\n\n加密算法分为单向加密和双向加密。\n单向加密包括MD5，SHA加密算法等等。单向加密算法是不可逆的，也就是无法将加密后的数据恢复成原始数据，除非采取碰撞攻击和穷举的方式。\n像是银行账户密码的存储，一般采用的就是单向加密的方式。\n双向加密是可逆的，存在密文的密钥，持有密文的一方可以根据密钥解密得到原始明文，一般用于发送方和接收方都能通过密钥获取明文的情况。\n双向加密包括对称加密和非对称加密。对称加密包括DES加密，AES加密等等，本文档介绍的主要是AES加密。而非对称加密包括RSA加密，ECC加密。\n\n\n### RSA加密\nRSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。\n其加密过程是：\n```html\n1、生成一对公私钥\n2、使用其中的公钥对需要加密的字符串进行加密\n3、使用私钥对加密后的数据进行解密\n```\n\n其中的关键在于私钥的保密性，利用公钥加密的数据只能公共唯一的私钥才能解密。\n\n\n##### DEMO\nhttps://www.epoos.com/demo/jsencrypt/rsa-demo.html\n\n\n### AES加密\nAES简介\n高级加密标准(AES,Advanced Encryption Standard)为最常见的#对称加密#算法(微信小程序加密传输就是用这个加密算法的)。\nAES加密（Advanced Encryption Standard，AES），又称 高级加密标准，AES的基本要求是，采用对称分组密码体制，AES加密数据块分组长度必须为128比特，密钥长度可以是128比特、192比特、256比特中的任意一个（如果数据块及密钥长度不足时，会补齐）。\n\n对称加密算法也就是加密和解密用相同的密钥,具体的加密流程如下图： \n![图片](http://zhoushirong.github.io/img/aes.png)\n\n##### DEMO\nhttps://www.epoos.com/demo/jsencrypt/aes-demo.html\n\n\n对于WEB开发来说，AES前端加密其实意义并不大，因为AES加密的过程就是将数据加盐之后以AES加密的方式进行加密。\n\n要想做到这些，首先就得将SALT以及DATA传输到前端。\n\n然而，这些数据放到了前端，那也就意味着对客户端的用户来说是可见的了\n\n这些数据在网络上进行传输的过程中被拦截了之后，数据也就将没有任何遮掩的暴露在攻击者眼前。\n\n<br>\n**RSA**加密倒是可以避免这个问题\n\n只要服务端将公钥传输到前端，前端拿到公钥之后以RSA加密方式对数据进行加密\n\n因为RSA公钥加密过的数据唯有唯一的私钥才能进行解密，因此即使用户的数据被拦截之后，仍然可以保证其私密性。\n\n但是由于RSA加密用的是非对称加密，这样如果对于大量的数据进行加密的时候就会很耗费性能\n\n因此如果是对于大量的数据进行加密，就需要用到对称加密和非对称加密共同来完成了。\n\n具体实现方式也是类似于[https](https://www.epoos.com/article/https)的传输方式\n\n```html\n使用非对称加密传递密钥\n拿到密钥之后使用对称加密的方式对数据进行加解密\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/jsencrypt.md","raw":"---\ntitle: AES加密和RSA加密\ndate: 2018/03/20\ntag: [AES,RSA,加密,安全]\ncategory: 技术\n---\n\n最近项目需要用到前端加密，某些特定的数据需要前端加密之后再传输到后端，然后后端再按照与前端约定好的方式进行解密。\n\n因此，在做项目的过程中也大概了解了一下常见的加密方式。\n\n加密算法分为单向加密和双向加密。\n单向加密包括MD5，SHA加密算法等等。单向加密算法是不可逆的，也就是无法将加密后的数据恢复成原始数据，除非采取碰撞攻击和穷举的方式。\n像是银行账户密码的存储，一般采用的就是单向加密的方式。\n双向加密是可逆的，存在密文的密钥，持有密文的一方可以根据密钥解密得到原始明文，一般用于发送方和接收方都能通过密钥获取明文的情况。\n双向加密包括对称加密和非对称加密。对称加密包括DES加密，AES加密等等，本文档介绍的主要是AES加密。而非对称加密包括RSA加密，ECC加密。\n\n\n### RSA加密\nRSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。\n其加密过程是：\n```html\n1、生成一对公私钥\n2、使用其中的公钥对需要加密的字符串进行加密\n3、使用私钥对加密后的数据进行解密\n```\n\n其中的关键在于私钥的保密性，利用公钥加密的数据只能公共唯一的私钥才能解密。\n\n\n##### DEMO\nhttps://www.epoos.com/demo/jsencrypt/rsa-demo.html\n\n\n### AES加密\nAES简介\n高级加密标准(AES,Advanced Encryption Standard)为最常见的#对称加密#算法(微信小程序加密传输就是用这个加密算法的)。\nAES加密（Advanced Encryption Standard，AES），又称 高级加密标准，AES的基本要求是，采用对称分组密码体制，AES加密数据块分组长度必须为128比特，密钥长度可以是128比特、192比特、256比特中的任意一个（如果数据块及密钥长度不足时，会补齐）。\n\n对称加密算法也就是加密和解密用相同的密钥,具体的加密流程如下图： \n![图片](http://zhoushirong.github.io/img/aes.png)\n\n##### DEMO\nhttps://www.epoos.com/demo/jsencrypt/aes-demo.html\n\n\n对于WEB开发来说，AES前端加密其实意义并不大，因为AES加密的过程就是将数据加盐之后以AES加密的方式进行加密。\n\n要想做到这些，首先就得将SALT以及DATA传输到前端。\n\n然而，这些数据放到了前端，那也就意味着对客户端的用户来说是可见的了\n\n这些数据在网络上进行传输的过程中被拦截了之后，数据也就将没有任何遮掩的暴露在攻击者眼前。\n\n<br>\n**RSA**加密倒是可以避免这个问题\n\n只要服务端将公钥传输到前端，前端拿到公钥之后以RSA加密方式对数据进行加密\n\n因为RSA公钥加密过的数据唯有唯一的私钥才能进行解密，因此即使用户的数据被拦截之后，仍然可以保证其私密性。\n\n但是由于RSA加密用的是非对称加密，这样如果对于大量的数据进行加密的时候就会很耗费性能\n\n因此如果是对于大量的数据进行加密，就需要用到对称加密和非对称加密共同来完成了。\n\n具体实现方式也是类似于[https](https://www.epoos.com/article/https)的传输方式\n\n```html\n使用非对称加密传递密钥\n拿到密钥之后使用对称加密的方式对数据进行加解密\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"jsencrypt","published":1,"updated":"2021-03-30T01:32:00.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufn000qa0vz2rjug1ot","content":"<p>最近项目需要用到前端加密，某些特定的数据需要前端加密之后再传输到后端，然后后端再按照与前端约定好的方式进行解密。</p>\n<p>因此，在做项目的过程中也大概了解了一下常见的加密方式。</p>\n<p>加密算法分为单向加密和双向加密。<br>单向加密包括MD5，SHA加密算法等等。单向加密算法是不可逆的，也就是无法将加密后的数据恢复成原始数据，除非采取碰撞攻击和穷举的方式。<br>像是银行账户密码的存储，一般采用的就是单向加密的方式。<br>双向加密是可逆的，存在密文的密钥，持有密文的一方可以根据密钥解密得到原始明文，一般用于发送方和接收方都能通过密钥获取明文的情况。<br>双向加密包括对称加密和非对称加密。对称加密包括DES加密，AES加密等等，本文档介绍的主要是AES加密。而非对称加密包括RSA加密，ECC加密。</p>\n<h3 id=\"RSA加密\"><a href=\"#RSA加密\" class=\"headerlink\" title=\"RSA加密\"></a>RSA加密</h3><p>RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。<br>其加密过程是：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、生成一对公私钥</span><br><span class=\"line\">2、使用其中的公钥对需要加密的字符串进行加密</span><br><span class=\"line\">3、使用私钥对加密后的数据进行解密</span><br></pre></td></tr></table></figure></p>\n<p>其中的关键在于私钥的保密性，利用公钥加密的数据只能公共唯一的私钥才能解密。</p>\n<h5 id=\"DEMO\"><a href=\"#DEMO\" class=\"headerlink\" title=\"DEMO\"></a>DEMO</h5><p><a href=\"https://www.epoos.com/demo/jsencrypt/rsa-demo.html\">https://www.epoos.com/demo/jsencrypt/rsa-demo.html</a></p>\n<h3 id=\"AES加密\"><a href=\"#AES加密\" class=\"headerlink\" title=\"AES加密\"></a>AES加密</h3><p>AES简介<br>高级加密标准(AES,Advanced Encryption Standard)为最常见的#对称加密#算法(微信小程序加密传输就是用这个加密算法的)。<br>AES加密（Advanced Encryption Standard，AES），又称 高级加密标准，AES的基本要求是，采用对称分组密码体制，AES加密数据块分组长度必须为128比特，密钥长度可以是128比特、192比特、256比特中的任意一个（如果数据块及密钥长度不足时，会补齐）。</p>\n<p>对称加密算法也就是加密和解密用相同的密钥,具体的加密流程如下图：<br><img src=\"http://zhoushirong.github.io/img/aes.png\" alt=\"图片\"></p>\n<h5 id=\"DEMO-1\"><a href=\"#DEMO-1\" class=\"headerlink\" title=\"DEMO\"></a>DEMO</h5><p><a href=\"https://www.epoos.com/demo/jsencrypt/aes-demo.html\">https://www.epoos.com/demo/jsencrypt/aes-demo.html</a></p>\n<p>对于WEB开发来说，AES前端加密其实意义并不大，因为AES加密的过程就是将数据加盐之后以AES加密的方式进行加密。</p>\n<p>要想做到这些，首先就得将SALT以及DATA传输到前端。</p>\n<p>然而，这些数据放到了前端，那也就意味着对客户端的用户来说是可见的了</p>\n<p>这些数据在网络上进行传输的过程中被拦截了之后，数据也就将没有任何遮掩的暴露在攻击者眼前。</p>\n<p><br><br><strong>RSA</strong>加密倒是可以避免这个问题</p>\n<p>只要服务端将公钥传输到前端，前端拿到公钥之后以RSA加密方式对数据进行加密</p>\n<p>因为RSA公钥加密过的数据唯有唯一的私钥才能进行解密，因此即使用户的数据被拦截之后，仍然可以保证其私密性。</p>\n<p>但是由于RSA加密用的是非对称加密，这样如果对于大量的数据进行加密的时候就会很耗费性能</p>\n<p>因此如果是对于大量的数据进行加密，就需要用到对称加密和非对称加密共同来完成了。</p>\n<p>具体实现方式也是类似于<a href=\"https://www.epoos.com/article/https\">https</a>的传输方式</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用非对称加密传递密钥</span><br><span class=\"line\">拿到密钥之后使用对称加密的方式对数据进行加解密</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>最近项目需要用到前端加密，某些特定的数据需要前端加密之后再传输到后端，然后后端再按照与前端约定好的方式进行解密。</p>\n<p>因此，在做项目的过程中也大概了解了一下常见的加密方式。</p>\n<p>加密算法分为单向加密和双向加密。<br>单向加密包括MD5，SHA加密算法等等。单向加密算法是不可逆的，也就是无法将加密后的数据恢复成原始数据，除非采取碰撞攻击和穷举的方式。<br>像是银行账户密码的存储，一般采用的就是单向加密的方式。<br>双向加密是可逆的，存在密文的密钥，持有密文的一方可以根据密钥解密得到原始明文，一般用于发送方和接收方都能通过密钥获取明文的情况。<br>双向加密包括对称加密和非对称加密。对称加密包括DES加密，AES加密等等，本文档介绍的主要是AES加密。而非对称加密包括RSA加密，ECC加密。</p>\n<h3 id=\"RSA加密\"><a href=\"#RSA加密\" class=\"headerlink\" title=\"RSA加密\"></a>RSA加密</h3><p>RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。<br>其加密过程是：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、生成一对公私钥</span><br><span class=\"line\">2、使用其中的公钥对需要加密的字符串进行加密</span><br><span class=\"line\">3、使用私钥对加密后的数据进行解密</span><br></pre></td></tr></table></figure></p>\n<p>其中的关键在于私钥的保密性，利用公钥加密的数据只能公共唯一的私钥才能解密。</p>\n<h5 id=\"DEMO\"><a href=\"#DEMO\" class=\"headerlink\" title=\"DEMO\"></a>DEMO</h5><p><a href=\"https://www.epoos.com/demo/jsencrypt/rsa-demo.html\">https://www.epoos.com/demo/jsencrypt/rsa-demo.html</a></p>\n<h3 id=\"AES加密\"><a href=\"#AES加密\" class=\"headerlink\" title=\"AES加密\"></a>AES加密</h3><p>AES简介<br>高级加密标准(AES,Advanced Encryption Standard)为最常见的#对称加密#算法(微信小程序加密传输就是用这个加密算法的)。<br>AES加密（Advanced Encryption Standard，AES），又称 高级加密标准，AES的基本要求是，采用对称分组密码体制，AES加密数据块分组长度必须为128比特，密钥长度可以是128比特、192比特、256比特中的任意一个（如果数据块及密钥长度不足时，会补齐）。</p>\n<p>对称加密算法也就是加密和解密用相同的密钥,具体的加密流程如下图：<br><img src=\"http://zhoushirong.github.io/img/aes.png\" alt=\"图片\"></p>\n<h5 id=\"DEMO-1\"><a href=\"#DEMO-1\" class=\"headerlink\" title=\"DEMO\"></a>DEMO</h5><p><a href=\"https://www.epoos.com/demo/jsencrypt/aes-demo.html\">https://www.epoos.com/demo/jsencrypt/aes-demo.html</a></p>\n<p>对于WEB开发来说，AES前端加密其实意义并不大，因为AES加密的过程就是将数据加盐之后以AES加密的方式进行加密。</p>\n<p>要想做到这些，首先就得将SALT以及DATA传输到前端。</p>\n<p>然而，这些数据放到了前端，那也就意味着对客户端的用户来说是可见的了</p>\n<p>这些数据在网络上进行传输的过程中被拦截了之后，数据也就将没有任何遮掩的暴露在攻击者眼前。</p>\n<p><br><br><strong>RSA</strong>加密倒是可以避免这个问题</p>\n<p>只要服务端将公钥传输到前端，前端拿到公钥之后以RSA加密方式对数据进行加密</p>\n<p>因为RSA公钥加密过的数据唯有唯一的私钥才能进行解密，因此即使用户的数据被拦截之后，仍然可以保证其私密性。</p>\n<p>但是由于RSA加密用的是非对称加密，这样如果对于大量的数据进行加密的时候就会很耗费性能</p>\n<p>因此如果是对于大量的数据进行加密，就需要用到对称加密和非对称加密共同来完成了。</p>\n<p>具体实现方式也是类似于<a href=\"https://www.epoos.com/article/https\">https</a>的传输方式</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用非对称加密传递密钥</span><br><span class=\"line\">拿到密钥之后使用对称加密的方式对数据进行加解密</span><br></pre></td></tr></table></figure>\n"},{"title":"常用Linux命令","date":"2016-12-29T16:00:00.000Z","_content":"\nLinux 是一种自由和开放源代码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布。在加上用户空间的应用程序之后，成为Linux操作系统。Linux也是自由软件和开放源代码软件发展中最著名的例子。\n作为一个前端或许很少用到linux，但是作为一个有理想、有道德、有激情的前端，linux是必须要了解的一项技能。尤其是立志成为全端（什么都会一点，什么都不精通）的前端工程师，更是需要知道了。\n\n下面记录一下linux服务器上经常会用到的基本操作，便于以后回来查阅。\n\n``` html\n# 超级用户\n\n$ 普通用户\n\n命令 [选项] [参数]\n```\n\n\n### 系统\n\n``` shell\n# uname -a               # 查看内核/操作系统/CPU信息\n# head -n 1 /etc/issue   # 查看操作系统版本\n# cat /proc/cpuinfo      # 查看CPU信息\n# hostname               # 查看计算机名\n# lspci -tv              # 列出所有PCI设备\n# lsusb -tv              # 列出所有USB设备\n# lsmod                  # 列出加载的内核模块\n# env                    # 查看环境变量\n```\n\n### 资源\n\n``` shell\n# free -m                # 查看内存使用量和交换区使用量\n# df -h                  # 查看各分区使用情况\n# du -sh <目录名>        # 查看指定目录的大小\n# grep MemTotal /proc/meminfo   # 查看内存总量\n# grep MemFree /proc/meminfo    # 查看空闲内存量\n# uptime                 # 查看系统运行时间、用户数、负载\n# cat /proc/loadavg      # 查看系统负载\n```\n\n### 磁盘和分区\n\n``` shell\n# mount | column -t      # 查看挂接的分区状态\n# fdisk -l               # 查看所有分区\n# swapon -s              # 查看所有交换分区\n# hdparm -i /dev/hda     # 查看磁盘参数(仅适用于IDE设备)\n# dmesg | grep IDE       # 查看启动时IDE设备检测状况\n```\n\n### 网络\n\n``` shell\n# ifconfig               # 查看所有网络接口的属性\n# iptables -L            # 查看防火墙设置\n# route -n               # 查看路由表\n# netstat -lntp          # 查看所有监听端口\n# netstat -antp          # 查看所有已经建立的连接\n# netstat -s             # 查看网络统计信息\n```\n\n### 进程\n\n``` shell\n# ps -ef                 # 查看所有进程\n# top                    # 实时显示进程状态\n```\n\n### 应用程序\n```shell\n# rpm -qa # 查看所有安装的软件包\n```\n### 用户\n\n``` shell\nw                      # 查看活动用户\nid <用户名>            # 查看指定用户信息\nlast                   # 查看用户登录日志\ncut -d: -f1 /etc/passwd   # 查看系统所有用户\ncut -d: -f1 /etc/group    # 查看系统所有组\ncrontab -l             # 查看当前用户的计划任务\n```\n\n\n### 登录\n\n```\nw 查询当前所有的登录用户\n\nwho 查询当前所有的登录用户\n\nlast 查询所有的登录信息\n\n/val/log —— 系统日志信息\n```\n\n### 服务\n\n``` shell\nchkconfig --list       # 列出所有系统服务\nchkconfig --list | grep on    # 列出所有启动的系统服务\n```\n\n### 程序\n\n``` shell\nrpm -qa                # 查看所有安装的软件包\n```\n\n### 查看CPU信息（型号） \n\n``` shell\ncat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c \n\ncat /proc/cpuinfo | grep physical | uniq -c \n \ngetconf LONG_BIT \n\ncat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l \n\ndmidecode | grep 'Processor Information' \n```\n\n### head tail cat awk grep vim \n\n```\ndmi 查看cpu信息\n\nchmod +x filename.sh\n\nchown —— 改变文件所属\n\n/etc/rc.local —— 开机启动配置\n\ncron —— 定时器相关\n```\n\n### 查看内存信息 \n\n``` shell\ncat /proc/meminfo \n\nuname -a \n\ncat /etc/issue | grep Linux \n```\n\n### 查看机器型号 \n\n``` shell\ndmidecode | grep \"Product Name\"  \n```\n\n查看网卡信息 \n\n``` shell\ndmesg | grep -i eth\n```\n\n### 显示文件列表\n\n``` shell\nls -a —— 显示隐藏文件  \n\nls -i —— 显示详细信息\n\nls -l —— 显示扩展名以及权限\n\nls -h —— 显示格式化列表\n\n对于文件前面的这一串字符串的意思：-rw-r--r--\n\n-表示文件类型\n\nrw-表示所有者u     \n\nr--\n\ng所属组\n\nr--\n\no其他人\n\nr读 w写 x执行\n```\n\n### linux查找功能\n\n``` shell\nlocate locate // 更新locate数据库 updatedb\n\nfind 范围 -name 文件名\n\nfind 范围 -iname 文件名（不区分大小写）\n\nfind 范围 -mtime 文件名 +10 （10天内修改的文件）a访问\n\nfind 范围 -size -15k (小于25k的文件) M兆\n\nfind 范围 -size +1k -a -size -50k (大于1k小于50k) -o或\n\n```\n\n\n### 帮助命令\n\n```\nmain 查看帮助文档\n\nhelp 获取内部命令\n```\n\n\n### 压缩与解压缩命令\n\n#### .zip .gz .bz2 \n\n``` html\n.zip 在 window 和 linux 通用  压缩文件命令为：zip 压缩文件名 源文件名 ； \n压缩文件夹命令为：zip -r 压缩文件名 源目录 ;解压命令将zip改为unzip即可\n```\n\n#### .tar.gz .tar.bz2 打包命令tar\n\n``` html\ntar -cvf 打包文件名 源文件 \n\n-c：打包 \n\n-v：显示过程 \n\n-f：指定打包后的文件名 \n\n-x：解打包 \n\n-z：压缩包名为.tar.gz \n\n-C：指定解压目录\n\n// 举例\n\ntar -zcvf packfiles.tar.gz packfiles\n\ntar -zxvf packfiles.tar.gz\n\ntar -zxvf packfiles.tar.gz -C ./dirs\n```\n\n-----------------------------------------------\n\n### 下面是shell相关部分\n\nshell是什么？\n\nshell是一个命令行解释器\n\n用户 ——》shell ——》内核 \n\n内核 ——》sell ——》用户\n\n\n#### 创建一个可执行文件 hello.sh\n\n``` shell\n#!/bin/bash\n\necho \"hello zsr !!!\"\n```\n\n#### 执行可执行文件\n\n``` shell\nchmod 755 hello.sh —— 给予文件可执行权限\n\n./hello.sh —— 执行可执行文件\n```\n\n\n\n``` html\necho $SHELL 查看当前的shell环境变量\n\n/etc/shells 查看当前shell支持的版本\n```\n\n### echo命令\n\n``` html\necho 选项 输出内容\n\n选项：-e 支持反斜杠控制的字符转换\n```\n\n### 创建可执行文件 hello.sh\n\n``` html\n#!/bin/bash\n#the first program\n\necho -e \"\\e[1;34m i live yellow \\e[0m\"\n```\n\n#### 执行可执行文件\n\n两个方法：\n\n#### 赋予执行权限再执行\n\n```\nchmod 755 hello.sh\n\n./hello.sh\n```\n\n#### 直接用bash执行\n\n```\nbash hello.sh\n```\n\n\n### bash的基本功能\n\n#### alias 设置命令别名\n\n```\nalias 查看已有的别名\n\nalias ll='ls -ilpa' 重命名显示文件详细信息的命令\n\nunalias 删除别名\n\n命令的生效顺序：绝对路径启动 》 别名 》 bash内部命令 》 $PATH环境变量定义的目录查找到的第一个命令\n```\n\n#### 常用快捷键\n\n```\nctl+c 强制终止当前命令\n\nctl+l 清屏\n\nctl+a 光标移到行首\n\nctl+e 光标移到行尾\n\nctl+u 从光标删除到行首\n\nctl+z 把命令放入后台\n\nctl+r 在历史命令中搜索\n```\n\n#### 历史命令\n\n```\nhistory 显示所有的历史命令\n\n保存位置在 ~/.bash_history文件里面\n\nhistory -c 清除历史命令\n```\n\n\n### 重定向\n\ndev目录 —— linux保存特殊文件的目录\n\n#### 输出重定向\n\n```\n命令 > 文件 —— 标准输出重定向\n\n命令 >> 文件 —— 追加重定向\n\n命令 2> 文件 —— 标准错误输出\n\n命令 2>> 文件 —— 追加标准错误输出\n\n命令 >> 文件 2>&1 —— 追加错误或者正确的命令\n\n命令 &> /dev/null —— 放弃查看命令执行结果\n\n命令 >> success.log 2 >> error.log —— 分别保存这两个正确和错误的信息\n```\n\n#### 输入重定向\n\n```\nwc 选项 文件名 —— 统计（ctl+d结束）\n\n- c 统计字节数。\n\n- l 统计行数。\n\n- w 统计字数。\n```\n\n\n#### 多命令顺序执行\n\n```\n命令1; 命令2 —— 多个命令顺序执行，命令之间没有任何逻辑关系\n\n命令1 && 命令2 —— 逻辑与关系\n\n命令1 || 命令2 —— 逻辑或关系 \n```\n\n### 管道符\n\n```\n命令1 | 命令2 —— 命令1的正确输出结果作为命令2的操作对象\n\neg:\n\nnetstat -an | grep \"ESTABLISHED\"\n```\n\n### 通配符\n\n```\n? —— 匹配任意字符\n\n* —— 匹配0个或多个任意字符\n\n[] —— 匹配中括号中任意一个字符\n\n\"\" —— 可以调用变量的值\n\n'' —— 所有特殊符号如 $ 都没有特殊含义\n\n` ` —— 反引号可以执行命令\n\n$(命令) —— 执行命令\n```\n\n### 远程拷贝\n\n```shell\nscp -r ./* admin@10.242.22.222:~/data1/ # scp将本地文件拷贝到远程机器\nrsync -a ../views/* ubuntu@10.220.220.222:~/data1/htdocs/index.epoos.com/views/ # rsync方式拷贝文件\n```\n\n\n\n### 相关链接《linux命令大全》\n\nhttp://man.linuxde.net/rsync\n\n","source":"_posts/linux.md","raw":"---\ntitle: 常用Linux命令\ndate: 2016/12/30\ntag: linux\ncategory: 技术\n---\n\nLinux 是一种自由和开放源代码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布。在加上用户空间的应用程序之后，成为Linux操作系统。Linux也是自由软件和开放源代码软件发展中最著名的例子。\n作为一个前端或许很少用到linux，但是作为一个有理想、有道德、有激情的前端，linux是必须要了解的一项技能。尤其是立志成为全端（什么都会一点，什么都不精通）的前端工程师，更是需要知道了。\n\n下面记录一下linux服务器上经常会用到的基本操作，便于以后回来查阅。\n\n``` html\n# 超级用户\n\n$ 普通用户\n\n命令 [选项] [参数]\n```\n\n\n### 系统\n\n``` shell\n# uname -a               # 查看内核/操作系统/CPU信息\n# head -n 1 /etc/issue   # 查看操作系统版本\n# cat /proc/cpuinfo      # 查看CPU信息\n# hostname               # 查看计算机名\n# lspci -tv              # 列出所有PCI设备\n# lsusb -tv              # 列出所有USB设备\n# lsmod                  # 列出加载的内核模块\n# env                    # 查看环境变量\n```\n\n### 资源\n\n``` shell\n# free -m                # 查看内存使用量和交换区使用量\n# df -h                  # 查看各分区使用情况\n# du -sh <目录名>        # 查看指定目录的大小\n# grep MemTotal /proc/meminfo   # 查看内存总量\n# grep MemFree /proc/meminfo    # 查看空闲内存量\n# uptime                 # 查看系统运行时间、用户数、负载\n# cat /proc/loadavg      # 查看系统负载\n```\n\n### 磁盘和分区\n\n``` shell\n# mount | column -t      # 查看挂接的分区状态\n# fdisk -l               # 查看所有分区\n# swapon -s              # 查看所有交换分区\n# hdparm -i /dev/hda     # 查看磁盘参数(仅适用于IDE设备)\n# dmesg | grep IDE       # 查看启动时IDE设备检测状况\n```\n\n### 网络\n\n``` shell\n# ifconfig               # 查看所有网络接口的属性\n# iptables -L            # 查看防火墙设置\n# route -n               # 查看路由表\n# netstat -lntp          # 查看所有监听端口\n# netstat -antp          # 查看所有已经建立的连接\n# netstat -s             # 查看网络统计信息\n```\n\n### 进程\n\n``` shell\n# ps -ef                 # 查看所有进程\n# top                    # 实时显示进程状态\n```\n\n### 应用程序\n```shell\n# rpm -qa # 查看所有安装的软件包\n```\n### 用户\n\n``` shell\nw                      # 查看活动用户\nid <用户名>            # 查看指定用户信息\nlast                   # 查看用户登录日志\ncut -d: -f1 /etc/passwd   # 查看系统所有用户\ncut -d: -f1 /etc/group    # 查看系统所有组\ncrontab -l             # 查看当前用户的计划任务\n```\n\n\n### 登录\n\n```\nw 查询当前所有的登录用户\n\nwho 查询当前所有的登录用户\n\nlast 查询所有的登录信息\n\n/val/log —— 系统日志信息\n```\n\n### 服务\n\n``` shell\nchkconfig --list       # 列出所有系统服务\nchkconfig --list | grep on    # 列出所有启动的系统服务\n```\n\n### 程序\n\n``` shell\nrpm -qa                # 查看所有安装的软件包\n```\n\n### 查看CPU信息（型号） \n\n``` shell\ncat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c \n\ncat /proc/cpuinfo | grep physical | uniq -c \n \ngetconf LONG_BIT \n\ncat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l \n\ndmidecode | grep 'Processor Information' \n```\n\n### head tail cat awk grep vim \n\n```\ndmi 查看cpu信息\n\nchmod +x filename.sh\n\nchown —— 改变文件所属\n\n/etc/rc.local —— 开机启动配置\n\ncron —— 定时器相关\n```\n\n### 查看内存信息 \n\n``` shell\ncat /proc/meminfo \n\nuname -a \n\ncat /etc/issue | grep Linux \n```\n\n### 查看机器型号 \n\n``` shell\ndmidecode | grep \"Product Name\"  \n```\n\n查看网卡信息 \n\n``` shell\ndmesg | grep -i eth\n```\n\n### 显示文件列表\n\n``` shell\nls -a —— 显示隐藏文件  \n\nls -i —— 显示详细信息\n\nls -l —— 显示扩展名以及权限\n\nls -h —— 显示格式化列表\n\n对于文件前面的这一串字符串的意思：-rw-r--r--\n\n-表示文件类型\n\nrw-表示所有者u     \n\nr--\n\ng所属组\n\nr--\n\no其他人\n\nr读 w写 x执行\n```\n\n### linux查找功能\n\n``` shell\nlocate locate // 更新locate数据库 updatedb\n\nfind 范围 -name 文件名\n\nfind 范围 -iname 文件名（不区分大小写）\n\nfind 范围 -mtime 文件名 +10 （10天内修改的文件）a访问\n\nfind 范围 -size -15k (小于25k的文件) M兆\n\nfind 范围 -size +1k -a -size -50k (大于1k小于50k) -o或\n\n```\n\n\n### 帮助命令\n\n```\nmain 查看帮助文档\n\nhelp 获取内部命令\n```\n\n\n### 压缩与解压缩命令\n\n#### .zip .gz .bz2 \n\n``` html\n.zip 在 window 和 linux 通用  压缩文件命令为：zip 压缩文件名 源文件名 ； \n压缩文件夹命令为：zip -r 压缩文件名 源目录 ;解压命令将zip改为unzip即可\n```\n\n#### .tar.gz .tar.bz2 打包命令tar\n\n``` html\ntar -cvf 打包文件名 源文件 \n\n-c：打包 \n\n-v：显示过程 \n\n-f：指定打包后的文件名 \n\n-x：解打包 \n\n-z：压缩包名为.tar.gz \n\n-C：指定解压目录\n\n// 举例\n\ntar -zcvf packfiles.tar.gz packfiles\n\ntar -zxvf packfiles.tar.gz\n\ntar -zxvf packfiles.tar.gz -C ./dirs\n```\n\n-----------------------------------------------\n\n### 下面是shell相关部分\n\nshell是什么？\n\nshell是一个命令行解释器\n\n用户 ——》shell ——》内核 \n\n内核 ——》sell ——》用户\n\n\n#### 创建一个可执行文件 hello.sh\n\n``` shell\n#!/bin/bash\n\necho \"hello zsr !!!\"\n```\n\n#### 执行可执行文件\n\n``` shell\nchmod 755 hello.sh —— 给予文件可执行权限\n\n./hello.sh —— 执行可执行文件\n```\n\n\n\n``` html\necho $SHELL 查看当前的shell环境变量\n\n/etc/shells 查看当前shell支持的版本\n```\n\n### echo命令\n\n``` html\necho 选项 输出内容\n\n选项：-e 支持反斜杠控制的字符转换\n```\n\n### 创建可执行文件 hello.sh\n\n``` html\n#!/bin/bash\n#the first program\n\necho -e \"\\e[1;34m i live yellow \\e[0m\"\n```\n\n#### 执行可执行文件\n\n两个方法：\n\n#### 赋予执行权限再执行\n\n```\nchmod 755 hello.sh\n\n./hello.sh\n```\n\n#### 直接用bash执行\n\n```\nbash hello.sh\n```\n\n\n### bash的基本功能\n\n#### alias 设置命令别名\n\n```\nalias 查看已有的别名\n\nalias ll='ls -ilpa' 重命名显示文件详细信息的命令\n\nunalias 删除别名\n\n命令的生效顺序：绝对路径启动 》 别名 》 bash内部命令 》 $PATH环境变量定义的目录查找到的第一个命令\n```\n\n#### 常用快捷键\n\n```\nctl+c 强制终止当前命令\n\nctl+l 清屏\n\nctl+a 光标移到行首\n\nctl+e 光标移到行尾\n\nctl+u 从光标删除到行首\n\nctl+z 把命令放入后台\n\nctl+r 在历史命令中搜索\n```\n\n#### 历史命令\n\n```\nhistory 显示所有的历史命令\n\n保存位置在 ~/.bash_history文件里面\n\nhistory -c 清除历史命令\n```\n\n\n### 重定向\n\ndev目录 —— linux保存特殊文件的目录\n\n#### 输出重定向\n\n```\n命令 > 文件 —— 标准输出重定向\n\n命令 >> 文件 —— 追加重定向\n\n命令 2> 文件 —— 标准错误输出\n\n命令 2>> 文件 —— 追加标准错误输出\n\n命令 >> 文件 2>&1 —— 追加错误或者正确的命令\n\n命令 &> /dev/null —— 放弃查看命令执行结果\n\n命令 >> success.log 2 >> error.log —— 分别保存这两个正确和错误的信息\n```\n\n#### 输入重定向\n\n```\nwc 选项 文件名 —— 统计（ctl+d结束）\n\n- c 统计字节数。\n\n- l 统计行数。\n\n- w 统计字数。\n```\n\n\n#### 多命令顺序执行\n\n```\n命令1; 命令2 —— 多个命令顺序执行，命令之间没有任何逻辑关系\n\n命令1 && 命令2 —— 逻辑与关系\n\n命令1 || 命令2 —— 逻辑或关系 \n```\n\n### 管道符\n\n```\n命令1 | 命令2 —— 命令1的正确输出结果作为命令2的操作对象\n\neg:\n\nnetstat -an | grep \"ESTABLISHED\"\n```\n\n### 通配符\n\n```\n? —— 匹配任意字符\n\n* —— 匹配0个或多个任意字符\n\n[] —— 匹配中括号中任意一个字符\n\n\"\" —— 可以调用变量的值\n\n'' —— 所有特殊符号如 $ 都没有特殊含义\n\n` ` —— 反引号可以执行命令\n\n$(命令) —— 执行命令\n```\n\n### 远程拷贝\n\n```shell\nscp -r ./* admin@10.242.22.222:~/data1/ # scp将本地文件拷贝到远程机器\nrsync -a ../views/* ubuntu@10.220.220.222:~/data1/htdocs/index.epoos.com/views/ # rsync方式拷贝文件\n```\n\n\n\n### 相关链接《linux命令大全》\n\nhttp://man.linuxde.net/rsync\n\n","slug":"linux","published":1,"updated":"2021-03-30T01:32:00.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufn000ra0vz1p9g9to9","content":"<p>Linux 是一种自由和开放源代码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布。在加上用户空间的应用程序之后，成为Linux操作系统。Linux也是自由软件和开放源代码软件发展中最著名的例子。<br>作为一个前端或许很少用到linux，但是作为一个有理想、有道德、有激情的前端，linux是必须要了解的一项技能。尤其是立志成为全端（什么都会一点，什么都不精通）的前端工程师，更是需要知道了。</p>\n<p>下面记录一下linux服务器上经常会用到的基本操作，便于以后回来查阅。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 超级用户</span><br><span class=\"line\"></span><br><span class=\"line\">$ 普通用户</span><br><span class=\"line\"></span><br><span class=\"line\">命令 [选项] [参数]</span><br></pre></td></tr></table></figure>\n<h3 id=\"系统\"><a href=\"#系统\" class=\"headerlink\" title=\"系统\"></a>系统</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> uname -a               <span class=\"comment\"># 查看内核/操作系统/CPU信息</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> head -n 1 /etc/issue   <span class=\"comment\"># 查看操作系统版本</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /proc/cpuinfo      <span class=\"comment\"># 查看CPU信息</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hostname               <span class=\"comment\"># 查看计算机名</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lspci -tv              <span class=\"comment\"># 列出所有PCI设备</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lsusb -tv              <span class=\"comment\"># 列出所有USB设备</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lsmod                  <span class=\"comment\"># 列出加载的内核模块</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> env                    <span class=\"comment\"># 查看环境变量</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> free -m                <span class=\"comment\"># 查看内存使用量和交换区使用量</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> df -h                  <span class=\"comment\"># 查看各分区使用情况</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> du -sh &lt;目录名&gt;        <span class=\"comment\"># 查看指定目录的大小</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> grep MemTotal /proc/meminfo   <span class=\"comment\"># 查看内存总量</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> grep MemFree /proc/meminfo    <span class=\"comment\"># 查看空闲内存量</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> uptime                 <span class=\"comment\"># 查看系统运行时间、用户数、负载</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /proc/loadavg      <span class=\"comment\"># 查看系统负载</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"磁盘和分区\"><a href=\"#磁盘和分区\" class=\"headerlink\" title=\"磁盘和分区\"></a>磁盘和分区</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mount | column -t      <span class=\"comment\"># 查看挂接的分区状态</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> fdisk -l               <span class=\"comment\"># 查看所有分区</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> swapon -s              <span class=\"comment\"># 查看所有交换分区</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hdparm -i /dev/hda     <span class=\"comment\"># 查看磁盘参数(仅适用于IDE设备)</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> dmesg | grep IDE       <span class=\"comment\"># 查看启动时IDE设备检测状况</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ifconfig               <span class=\"comment\"># 查看所有网络接口的属性</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> iptables -L            <span class=\"comment\"># 查看防火墙设置</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> route -n               <span class=\"comment\"># 查看路由表</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> netstat -lntp          <span class=\"comment\"># 查看所有监听端口</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> netstat -antp          <span class=\"comment\"># 查看所有已经建立的连接</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> netstat -s             <span class=\"comment\"># 查看网络统计信息</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ps -ef                 <span class=\"comment\"># 查看所有进程</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> top                    <span class=\"comment\"># 实时显示进程状态</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"应用程序\"><a href=\"#应用程序\" class=\"headerlink\" title=\"应用程序\"></a>应用程序</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rpm -qa <span class=\"comment\"># 查看所有安装的软件包</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"用户\"><a href=\"#用户\" class=\"headerlink\" title=\"用户\"></a>用户</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w                      # 查看活动用户</span><br><span class=\"line\">id &lt;用户名&gt;            # 查看指定用户信息</span><br><span class=\"line\">last                   # 查看用户登录日志</span><br><span class=\"line\">cut -d: -f1 /etc/passwd   # 查看系统所有用户</span><br><span class=\"line\">cut -d: -f1 /etc/group    # 查看系统所有组</span><br><span class=\"line\">crontab -l             # 查看当前用户的计划任务</span><br></pre></td></tr></table></figure>\n<h3 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w 查询当前所有的登录用户</span><br><span class=\"line\"></span><br><span class=\"line\">who 查询当前所有的登录用户</span><br><span class=\"line\"></span><br><span class=\"line\">last 查询所有的登录信息</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;val&#x2F;log —— 系统日志信息</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务\"><a href=\"#服务\" class=\"headerlink\" title=\"服务\"></a>服务</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chkconfig --list       # 列出所有系统服务</span><br><span class=\"line\">chkconfig --list | grep on    # 列出所有启动的系统服务</span><br></pre></td></tr></table></figure>\n<h3 id=\"程序\"><a href=\"#程序\" class=\"headerlink\" title=\"程序\"></a>程序</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qa                # 查看所有安装的软件包</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看CPU信息（型号）\"><a href=\"#查看CPU信息（型号）\" class=\"headerlink\" title=\"查看CPU信息（型号）\"></a>查看CPU信息（型号）</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c </span><br><span class=\"line\"></span><br><span class=\"line\">cat /proc/cpuinfo | grep physical | uniq -c </span><br><span class=\"line\"> </span><br><span class=\"line\">getconf LONG_BIT </span><br><span class=\"line\"></span><br><span class=\"line\">cat /proc/cpuinfo | grep flags | grep &#x27; lm &#x27; | wc -l </span><br><span class=\"line\"></span><br><span class=\"line\">dmidecode | grep &#x27;Processor Information&#x27; </span><br></pre></td></tr></table></figure>\n<h3 id=\"head-tail-cat-awk-grep-vim\"><a href=\"#head-tail-cat-awk-grep-vim\" class=\"headerlink\" title=\"head tail cat awk grep vim\"></a>head tail cat awk grep vim</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dmi 查看cpu信息</span><br><span class=\"line\"></span><br><span class=\"line\">chmod +x filename.sh</span><br><span class=\"line\"></span><br><span class=\"line\">chown —— 改变文件所属</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;etc&#x2F;rc.local —— 开机启动配置</span><br><span class=\"line\"></span><br><span class=\"line\">cron —— 定时器相关</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看内存信息\"><a href=\"#查看内存信息\" class=\"headerlink\" title=\"查看内存信息\"></a>查看内存信息</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/meminfo </span><br><span class=\"line\"></span><br><span class=\"line\">uname -a </span><br><span class=\"line\"></span><br><span class=\"line\">cat /etc/issue | grep Linux </span><br></pre></td></tr></table></figure>\n<h3 id=\"查看机器型号\"><a href=\"#查看机器型号\" class=\"headerlink\" title=\"查看机器型号\"></a>查看机器型号</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dmidecode | grep &quot;Product Name&quot;  </span><br></pre></td></tr></table></figure>\n<p>查看网卡信息 </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dmesg | grep -i eth</span><br></pre></td></tr></table></figure>\n<h3 id=\"显示文件列表\"><a href=\"#显示文件列表\" class=\"headerlink\" title=\"显示文件列表\"></a>显示文件列表</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -a —— 显示隐藏文件  </span><br><span class=\"line\"></span><br><span class=\"line\">ls -i —— 显示详细信息</span><br><span class=\"line\"></span><br><span class=\"line\">ls -l —— 显示扩展名以及权限</span><br><span class=\"line\"></span><br><span class=\"line\">ls -h —— 显示格式化列表</span><br><span class=\"line\"></span><br><span class=\"line\">对于文件前面的这一串字符串的意思：-rw-r--r--</span><br><span class=\"line\"></span><br><span class=\"line\">-表示文件类型</span><br><span class=\"line\"></span><br><span class=\"line\">rw-表示所有者u     </span><br><span class=\"line\"></span><br><span class=\"line\">r--</span><br><span class=\"line\"></span><br><span class=\"line\">g所属组</span><br><span class=\"line\"></span><br><span class=\"line\">r--</span><br><span class=\"line\"></span><br><span class=\"line\">o其他人</span><br><span class=\"line\"></span><br><span class=\"line\">r读 w写 x执行</span><br></pre></td></tr></table></figure>\n<h3 id=\"linux查找功能\"><a href=\"#linux查找功能\" class=\"headerlink\" title=\"linux查找功能\"></a>linux查找功能</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locate locate // 更新locate数据库 updatedb</span><br><span class=\"line\"></span><br><span class=\"line\">find 范围 -name 文件名</span><br><span class=\"line\"></span><br><span class=\"line\">find 范围 -iname 文件名（不区分大小写）</span><br><span class=\"line\"></span><br><span class=\"line\">find 范围 -mtime 文件名 +10 （10天内修改的文件）a访问</span><br><span class=\"line\"></span><br><span class=\"line\">find 范围 -size -15k (小于25k的文件) M兆</span><br><span class=\"line\"></span><br><span class=\"line\">find 范围 -size +1k -a -size -50k (大于1k小于50k) -o或</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"帮助命令\"><a href=\"#帮助命令\" class=\"headerlink\" title=\"帮助命令\"></a>帮助命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main 查看帮助文档</span><br><span class=\"line\"></span><br><span class=\"line\">help 获取内部命令</span><br></pre></td></tr></table></figure>\n<h3 id=\"压缩与解压缩命令\"><a href=\"#压缩与解压缩命令\" class=\"headerlink\" title=\"压缩与解压缩命令\"></a>压缩与解压缩命令</h3><h4 id=\"zip-gz-bz2\"><a href=\"#zip-gz-bz2\" class=\"headerlink\" title=\".zip .gz .bz2\"></a>.zip .gz .bz2</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.zip 在 window 和 linux 通用  压缩文件命令为：zip 压缩文件名 源文件名 ； </span><br><span class=\"line\">压缩文件夹命令为：zip -r 压缩文件名 源目录 ;解压命令将zip改为unzip即可</span><br></pre></td></tr></table></figure>\n<h4 id=\"tar-gz-tar-bz2-打包命令tar\"><a href=\"#tar-gz-tar-bz2-打包命令tar\" class=\"headerlink\" title=\".tar.gz .tar.bz2 打包命令tar\"></a>.tar.gz .tar.bz2 打包命令tar</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cvf 打包文件名 源文件 </span><br><span class=\"line\"></span><br><span class=\"line\">-c：打包 </span><br><span class=\"line\"></span><br><span class=\"line\">-v：显示过程 </span><br><span class=\"line\"></span><br><span class=\"line\">-f：指定打包后的文件名 </span><br><span class=\"line\"></span><br><span class=\"line\">-x：解打包 </span><br><span class=\"line\"></span><br><span class=\"line\">-z：压缩包名为.tar.gz </span><br><span class=\"line\"></span><br><span class=\"line\">-C：指定解压目录</span><br><span class=\"line\"></span><br><span class=\"line\">// 举例</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zcvf packfiles.tar.gz packfiles</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf packfiles.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf packfiles.tar.gz -C ./dirs</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"下面是shell相关部分\"><a href=\"#下面是shell相关部分\" class=\"headerlink\" title=\"下面是shell相关部分\"></a>下面是shell相关部分</h3><p>shell是什么？</p>\n<p>shell是一个命令行解释器</p>\n<p>用户 ——》shell ——》内核 </p>\n<p>内核 ——》sell ——》用户</p>\n<h4 id=\"创建一个可执行文件-hello-sh\"><a href=\"#创建一个可执行文件-hello-sh\" class=\"headerlink\" title=\"创建一个可执行文件 hello.sh\"></a>创建一个可执行文件 hello.sh</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;hello zsr !!!&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"执行可执行文件\"><a href=\"#执行可执行文件\" class=\"headerlink\" title=\"执行可执行文件\"></a>执行可执行文件</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 755 hello.sh —— 给予文件可执行权限</span><br><span class=\"line\"></span><br><span class=\"line\">./hello.sh —— 执行可执行文件</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $SHELL 查看当前的shell环境变量</span><br><span class=\"line\"></span><br><span class=\"line\">/etc/shells 查看当前shell支持的版本</span><br></pre></td></tr></table></figure>\n<h3 id=\"echo命令\"><a href=\"#echo命令\" class=\"headerlink\" title=\"echo命令\"></a>echo命令</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 选项 输出内容</span><br><span class=\"line\"></span><br><span class=\"line\">选项：-e 支持反斜杠控制的字符转换</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建可执行文件-hello-sh\"><a href=\"#创建可执行文件-hello-sh\" class=\"headerlink\" title=\"创建可执行文件 hello.sh\"></a>创建可执行文件 hello.sh</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#the first program</span><br><span class=\"line\"></span><br><span class=\"line\">echo -e &quot;\\e[1;34m i live yellow \\e[0m&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"执行可执行文件-1\"><a href=\"#执行可执行文件-1\" class=\"headerlink\" title=\"执行可执行文件\"></a>执行可执行文件</h4><p>两个方法：</p>\n<h4 id=\"赋予执行权限再执行\"><a href=\"#赋予执行权限再执行\" class=\"headerlink\" title=\"赋予执行权限再执行\"></a>赋予执行权限再执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 755 hello.sh</span><br><span class=\"line\"></span><br><span class=\"line\">.&#x2F;hello.sh</span><br></pre></td></tr></table></figure>\n<h4 id=\"直接用bash执行\"><a href=\"#直接用bash执行\" class=\"headerlink\" title=\"直接用bash执行\"></a>直接用bash执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash hello.sh</span><br></pre></td></tr></table></figure>\n<h3 id=\"bash的基本功能\"><a href=\"#bash的基本功能\" class=\"headerlink\" title=\"bash的基本功能\"></a>bash的基本功能</h3><h4 id=\"alias-设置命令别名\"><a href=\"#alias-设置命令别名\" class=\"headerlink\" title=\"alias 设置命令别名\"></a>alias 设置命令别名</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias 查看已有的别名</span><br><span class=\"line\"></span><br><span class=\"line\">alias ll&#x3D;&#39;ls -ilpa&#39; 重命名显示文件详细信息的命令</span><br><span class=\"line\"></span><br><span class=\"line\">unalias 删除别名</span><br><span class=\"line\"></span><br><span class=\"line\">命令的生效顺序：绝对路径启动 》 别名 》 bash内部命令 》 $PATH环境变量定义的目录查找到的第一个命令</span><br></pre></td></tr></table></figure>\n<h4 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctl+c 强制终止当前命令</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+l 清屏</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+a 光标移到行首</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+e 光标移到行尾</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+u 从光标删除到行首</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+z 把命令放入后台</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+r 在历史命令中搜索</span><br></pre></td></tr></table></figure>\n<h4 id=\"历史命令\"><a href=\"#历史命令\" class=\"headerlink\" title=\"历史命令\"></a>历史命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history 显示所有的历史命令</span><br><span class=\"line\"></span><br><span class=\"line\">保存位置在 ~&#x2F;.bash_history文件里面</span><br><span class=\"line\"></span><br><span class=\"line\">history -c 清除历史命令</span><br></pre></td></tr></table></figure>\n<h3 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h3><p>dev目录 —— linux保存特殊文件的目录</p>\n<h4 id=\"输出重定向\"><a href=\"#输出重定向\" class=\"headerlink\" title=\"输出重定向\"></a>输出重定向</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令 &gt; 文件 —— 标准输出重定向</span><br><span class=\"line\"></span><br><span class=\"line\">命令 &gt;&gt; 文件 —— 追加重定向</span><br><span class=\"line\"></span><br><span class=\"line\">命令 2&gt; 文件 —— 标准错误输出</span><br><span class=\"line\"></span><br><span class=\"line\">命令 2&gt;&gt; 文件 —— 追加标准错误输出</span><br><span class=\"line\"></span><br><span class=\"line\">命令 &gt;&gt; 文件 2&gt;&amp;1 —— 追加错误或者正确的命令</span><br><span class=\"line\"></span><br><span class=\"line\">命令 &amp;&gt; &#x2F;dev&#x2F;null —— 放弃查看命令执行结果</span><br><span class=\"line\"></span><br><span class=\"line\">命令 &gt;&gt; success.log 2 &gt;&gt; error.log —— 分别保存这两个正确和错误的信息</span><br></pre></td></tr></table></figure>\n<h4 id=\"输入重定向\"><a href=\"#输入重定向\" class=\"headerlink\" title=\"输入重定向\"></a>输入重定向</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wc 选项 文件名 —— 统计（ctl+d结束）</span><br><span class=\"line\"></span><br><span class=\"line\">- c 统计字节数。</span><br><span class=\"line\"></span><br><span class=\"line\">- l 统计行数。</span><br><span class=\"line\"></span><br><span class=\"line\">- w 统计字数。</span><br></pre></td></tr></table></figure>\n<h4 id=\"多命令顺序执行\"><a href=\"#多命令顺序执行\" class=\"headerlink\" title=\"多命令顺序执行\"></a>多命令顺序执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令1; 命令2 —— 多个命令顺序执行，命令之间没有任何逻辑关系</span><br><span class=\"line\"></span><br><span class=\"line\">命令1 &amp;&amp; 命令2 —— 逻辑与关系</span><br><span class=\"line\"></span><br><span class=\"line\">命令1 || 命令2 —— 逻辑或关系 </span><br></pre></td></tr></table></figure>\n<h3 id=\"管道符\"><a href=\"#管道符\" class=\"headerlink\" title=\"管道符\"></a>管道符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令1 | 命令2 —— 命令1的正确输出结果作为命令2的操作对象</span><br><span class=\"line\"></span><br><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\">netstat -an | grep &quot;ESTABLISHED&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">? —— 匹配任意字符</span><br><span class=\"line\"></span><br><span class=\"line\">* —— 匹配0个或多个任意字符</span><br><span class=\"line\"></span><br><span class=\"line\">[] —— 匹配中括号中任意一个字符</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;&quot; —— 可以调用变量的值</span><br><span class=\"line\"></span><br><span class=\"line\">&#39;&#39; —— 所有特殊符号如 $ 都没有特殊含义</span><br><span class=\"line\"></span><br><span class=\"line\">&#96; &#96; —— 反引号可以执行命令</span><br><span class=\"line\"></span><br><span class=\"line\">$(命令) —— 执行命令</span><br></pre></td></tr></table></figure>\n<h3 id=\"远程拷贝\"><a href=\"#远程拷贝\" class=\"headerlink\" title=\"远程拷贝\"></a>远程拷贝</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r ./* admin@10.242.22.222:~/data1/ # scp将本地文件拷贝到远程机器</span><br><span class=\"line\">rsync -a ../views/* ubuntu@10.220.220.222:~/data1/htdocs/index.epoos.com/views/ # rsync方式拷贝文件</span><br></pre></td></tr></table></figure>\n<h3 id=\"相关链接《linux命令大全》\"><a href=\"#相关链接《linux命令大全》\" class=\"headerlink\" title=\"相关链接《linux命令大全》\"></a>相关链接《linux命令大全》</h3><p><a href=\"http://man.linuxde.net/rsync\">http://man.linuxde.net/rsync</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Linux 是一种自由和开放源代码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布。在加上用户空间的应用程序之后，成为Linux操作系统。Linux也是自由软件和开放源代码软件发展中最著名的例子。<br>作为一个前端或许很少用到linux，但是作为一个有理想、有道德、有激情的前端，linux是必须要了解的一项技能。尤其是立志成为全端（什么都会一点，什么都不精通）的前端工程师，更是需要知道了。</p>\n<p>下面记录一下linux服务器上经常会用到的基本操作，便于以后回来查阅。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 超级用户</span><br><span class=\"line\"></span><br><span class=\"line\">$ 普通用户</span><br><span class=\"line\"></span><br><span class=\"line\">命令 [选项] [参数]</span><br></pre></td></tr></table></figure>\n<h3 id=\"系统\"><a href=\"#系统\" class=\"headerlink\" title=\"系统\"></a>系统</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> uname -a               <span class=\"comment\"># 查看内核/操作系统/CPU信息</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> head -n 1 /etc/issue   <span class=\"comment\"># 查看操作系统版本</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /proc/cpuinfo      <span class=\"comment\"># 查看CPU信息</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hostname               <span class=\"comment\"># 查看计算机名</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lspci -tv              <span class=\"comment\"># 列出所有PCI设备</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lsusb -tv              <span class=\"comment\"># 列出所有USB设备</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> lsmod                  <span class=\"comment\"># 列出加载的内核模块</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> env                    <span class=\"comment\"># 查看环境变量</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> free -m                <span class=\"comment\"># 查看内存使用量和交换区使用量</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> df -h                  <span class=\"comment\"># 查看各分区使用情况</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> du -sh &lt;目录名&gt;        <span class=\"comment\"># 查看指定目录的大小</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> grep MemTotal /proc/meminfo   <span class=\"comment\"># 查看内存总量</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> grep MemFree /proc/meminfo    <span class=\"comment\"># 查看空闲内存量</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> uptime                 <span class=\"comment\"># 查看系统运行时间、用户数、负载</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat /proc/loadavg      <span class=\"comment\"># 查看系统负载</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"磁盘和分区\"><a href=\"#磁盘和分区\" class=\"headerlink\" title=\"磁盘和分区\"></a>磁盘和分区</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mount | column -t      <span class=\"comment\"># 查看挂接的分区状态</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> fdisk -l               <span class=\"comment\"># 查看所有分区</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> swapon -s              <span class=\"comment\"># 查看所有交换分区</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hdparm -i /dev/hda     <span class=\"comment\"># 查看磁盘参数(仅适用于IDE设备)</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> dmesg | grep IDE       <span class=\"comment\"># 查看启动时IDE设备检测状况</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ifconfig               <span class=\"comment\"># 查看所有网络接口的属性</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> iptables -L            <span class=\"comment\"># 查看防火墙设置</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> route -n               <span class=\"comment\"># 查看路由表</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> netstat -lntp          <span class=\"comment\"># 查看所有监听端口</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> netstat -antp          <span class=\"comment\"># 查看所有已经建立的连接</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> netstat -s             <span class=\"comment\"># 查看网络统计信息</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ps -ef                 <span class=\"comment\"># 查看所有进程</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> top                    <span class=\"comment\"># 实时显示进程状态</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"应用程序\"><a href=\"#应用程序\" class=\"headerlink\" title=\"应用程序\"></a>应用程序</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rpm -qa <span class=\"comment\"># 查看所有安装的软件包</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"用户\"><a href=\"#用户\" class=\"headerlink\" title=\"用户\"></a>用户</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w                      # 查看活动用户</span><br><span class=\"line\">id &lt;用户名&gt;            # 查看指定用户信息</span><br><span class=\"line\">last                   # 查看用户登录日志</span><br><span class=\"line\">cut -d: -f1 /etc/passwd   # 查看系统所有用户</span><br><span class=\"line\">cut -d: -f1 /etc/group    # 查看系统所有组</span><br><span class=\"line\">crontab -l             # 查看当前用户的计划任务</span><br></pre></td></tr></table></figure>\n<h3 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w 查询当前所有的登录用户</span><br><span class=\"line\"></span><br><span class=\"line\">who 查询当前所有的登录用户</span><br><span class=\"line\"></span><br><span class=\"line\">last 查询所有的登录信息</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;val&#x2F;log —— 系统日志信息</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务\"><a href=\"#服务\" class=\"headerlink\" title=\"服务\"></a>服务</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chkconfig --list       # 列出所有系统服务</span><br><span class=\"line\">chkconfig --list | grep on    # 列出所有启动的系统服务</span><br></pre></td></tr></table></figure>\n<h3 id=\"程序\"><a href=\"#程序\" class=\"headerlink\" title=\"程序\"></a>程序</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qa                # 查看所有安装的软件包</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看CPU信息（型号）\"><a href=\"#查看CPU信息（型号）\" class=\"headerlink\" title=\"查看CPU信息（型号）\"></a>查看CPU信息（型号）</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c </span><br><span class=\"line\"></span><br><span class=\"line\">cat /proc/cpuinfo | grep physical | uniq -c </span><br><span class=\"line\"> </span><br><span class=\"line\">getconf LONG_BIT </span><br><span class=\"line\"></span><br><span class=\"line\">cat /proc/cpuinfo | grep flags | grep &#x27; lm &#x27; | wc -l </span><br><span class=\"line\"></span><br><span class=\"line\">dmidecode | grep &#x27;Processor Information&#x27; </span><br></pre></td></tr></table></figure>\n<h3 id=\"head-tail-cat-awk-grep-vim\"><a href=\"#head-tail-cat-awk-grep-vim\" class=\"headerlink\" title=\"head tail cat awk grep vim\"></a>head tail cat awk grep vim</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dmi 查看cpu信息</span><br><span class=\"line\"></span><br><span class=\"line\">chmod +x filename.sh</span><br><span class=\"line\"></span><br><span class=\"line\">chown —— 改变文件所属</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;etc&#x2F;rc.local —— 开机启动配置</span><br><span class=\"line\"></span><br><span class=\"line\">cron —— 定时器相关</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看内存信息\"><a href=\"#查看内存信息\" class=\"headerlink\" title=\"查看内存信息\"></a>查看内存信息</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/meminfo </span><br><span class=\"line\"></span><br><span class=\"line\">uname -a </span><br><span class=\"line\"></span><br><span class=\"line\">cat /etc/issue | grep Linux </span><br></pre></td></tr></table></figure>\n<h3 id=\"查看机器型号\"><a href=\"#查看机器型号\" class=\"headerlink\" title=\"查看机器型号\"></a>查看机器型号</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dmidecode | grep &quot;Product Name&quot;  </span><br></pre></td></tr></table></figure>\n<p>查看网卡信息 </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dmesg | grep -i eth</span><br></pre></td></tr></table></figure>\n<h3 id=\"显示文件列表\"><a href=\"#显示文件列表\" class=\"headerlink\" title=\"显示文件列表\"></a>显示文件列表</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -a —— 显示隐藏文件  </span><br><span class=\"line\"></span><br><span class=\"line\">ls -i —— 显示详细信息</span><br><span class=\"line\"></span><br><span class=\"line\">ls -l —— 显示扩展名以及权限</span><br><span class=\"line\"></span><br><span class=\"line\">ls -h —— 显示格式化列表</span><br><span class=\"line\"></span><br><span class=\"line\">对于文件前面的这一串字符串的意思：-rw-r--r--</span><br><span class=\"line\"></span><br><span class=\"line\">-表示文件类型</span><br><span class=\"line\"></span><br><span class=\"line\">rw-表示所有者u     </span><br><span class=\"line\"></span><br><span class=\"line\">r--</span><br><span class=\"line\"></span><br><span class=\"line\">g所属组</span><br><span class=\"line\"></span><br><span class=\"line\">r--</span><br><span class=\"line\"></span><br><span class=\"line\">o其他人</span><br><span class=\"line\"></span><br><span class=\"line\">r读 w写 x执行</span><br></pre></td></tr></table></figure>\n<h3 id=\"linux查找功能\"><a href=\"#linux查找功能\" class=\"headerlink\" title=\"linux查找功能\"></a>linux查找功能</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locate locate // 更新locate数据库 updatedb</span><br><span class=\"line\"></span><br><span class=\"line\">find 范围 -name 文件名</span><br><span class=\"line\"></span><br><span class=\"line\">find 范围 -iname 文件名（不区分大小写）</span><br><span class=\"line\"></span><br><span class=\"line\">find 范围 -mtime 文件名 +10 （10天内修改的文件）a访问</span><br><span class=\"line\"></span><br><span class=\"line\">find 范围 -size -15k (小于25k的文件) M兆</span><br><span class=\"line\"></span><br><span class=\"line\">find 范围 -size +1k -a -size -50k (大于1k小于50k) -o或</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"帮助命令\"><a href=\"#帮助命令\" class=\"headerlink\" title=\"帮助命令\"></a>帮助命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main 查看帮助文档</span><br><span class=\"line\"></span><br><span class=\"line\">help 获取内部命令</span><br></pre></td></tr></table></figure>\n<h3 id=\"压缩与解压缩命令\"><a href=\"#压缩与解压缩命令\" class=\"headerlink\" title=\"压缩与解压缩命令\"></a>压缩与解压缩命令</h3><h4 id=\"zip-gz-bz2\"><a href=\"#zip-gz-bz2\" class=\"headerlink\" title=\".zip .gz .bz2\"></a>.zip .gz .bz2</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.zip 在 window 和 linux 通用  压缩文件命令为：zip 压缩文件名 源文件名 ； </span><br><span class=\"line\">压缩文件夹命令为：zip -r 压缩文件名 源目录 ;解压命令将zip改为unzip即可</span><br></pre></td></tr></table></figure>\n<h4 id=\"tar-gz-tar-bz2-打包命令tar\"><a href=\"#tar-gz-tar-bz2-打包命令tar\" class=\"headerlink\" title=\".tar.gz .tar.bz2 打包命令tar\"></a>.tar.gz .tar.bz2 打包命令tar</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cvf 打包文件名 源文件 </span><br><span class=\"line\"></span><br><span class=\"line\">-c：打包 </span><br><span class=\"line\"></span><br><span class=\"line\">-v：显示过程 </span><br><span class=\"line\"></span><br><span class=\"line\">-f：指定打包后的文件名 </span><br><span class=\"line\"></span><br><span class=\"line\">-x：解打包 </span><br><span class=\"line\"></span><br><span class=\"line\">-z：压缩包名为.tar.gz </span><br><span class=\"line\"></span><br><span class=\"line\">-C：指定解压目录</span><br><span class=\"line\"></span><br><span class=\"line\">// 举例</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zcvf packfiles.tar.gz packfiles</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf packfiles.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf packfiles.tar.gz -C ./dirs</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"下面是shell相关部分\"><a href=\"#下面是shell相关部分\" class=\"headerlink\" title=\"下面是shell相关部分\"></a>下面是shell相关部分</h3><p>shell是什么？</p>\n<p>shell是一个命令行解释器</p>\n<p>用户 ——》shell ——》内核 </p>\n<p>内核 ——》sell ——》用户</p>\n<h4 id=\"创建一个可执行文件-hello-sh\"><a href=\"#创建一个可执行文件-hello-sh\" class=\"headerlink\" title=\"创建一个可执行文件 hello.sh\"></a>创建一个可执行文件 hello.sh</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;hello zsr !!!&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"执行可执行文件\"><a href=\"#执行可执行文件\" class=\"headerlink\" title=\"执行可执行文件\"></a>执行可执行文件</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 755 hello.sh —— 给予文件可执行权限</span><br><span class=\"line\"></span><br><span class=\"line\">./hello.sh —— 执行可执行文件</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $SHELL 查看当前的shell环境变量</span><br><span class=\"line\"></span><br><span class=\"line\">/etc/shells 查看当前shell支持的版本</span><br></pre></td></tr></table></figure>\n<h3 id=\"echo命令\"><a href=\"#echo命令\" class=\"headerlink\" title=\"echo命令\"></a>echo命令</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 选项 输出内容</span><br><span class=\"line\"></span><br><span class=\"line\">选项：-e 支持反斜杠控制的字符转换</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建可执行文件-hello-sh\"><a href=\"#创建可执行文件-hello-sh\" class=\"headerlink\" title=\"创建可执行文件 hello.sh\"></a>创建可执行文件 hello.sh</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#the first program</span><br><span class=\"line\"></span><br><span class=\"line\">echo -e &quot;\\e[1;34m i live yellow \\e[0m&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"执行可执行文件-1\"><a href=\"#执行可执行文件-1\" class=\"headerlink\" title=\"执行可执行文件\"></a>执行可执行文件</h4><p>两个方法：</p>\n<h4 id=\"赋予执行权限再执行\"><a href=\"#赋予执行权限再执行\" class=\"headerlink\" title=\"赋予执行权限再执行\"></a>赋予执行权限再执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 755 hello.sh</span><br><span class=\"line\"></span><br><span class=\"line\">.&#x2F;hello.sh</span><br></pre></td></tr></table></figure>\n<h4 id=\"直接用bash执行\"><a href=\"#直接用bash执行\" class=\"headerlink\" title=\"直接用bash执行\"></a>直接用bash执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash hello.sh</span><br></pre></td></tr></table></figure>\n<h3 id=\"bash的基本功能\"><a href=\"#bash的基本功能\" class=\"headerlink\" title=\"bash的基本功能\"></a>bash的基本功能</h3><h4 id=\"alias-设置命令别名\"><a href=\"#alias-设置命令别名\" class=\"headerlink\" title=\"alias 设置命令别名\"></a>alias 设置命令别名</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias 查看已有的别名</span><br><span class=\"line\"></span><br><span class=\"line\">alias ll&#x3D;&#39;ls -ilpa&#39; 重命名显示文件详细信息的命令</span><br><span class=\"line\"></span><br><span class=\"line\">unalias 删除别名</span><br><span class=\"line\"></span><br><span class=\"line\">命令的生效顺序：绝对路径启动 》 别名 》 bash内部命令 》 $PATH环境变量定义的目录查找到的第一个命令</span><br></pre></td></tr></table></figure>\n<h4 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctl+c 强制终止当前命令</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+l 清屏</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+a 光标移到行首</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+e 光标移到行尾</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+u 从光标删除到行首</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+z 把命令放入后台</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+r 在历史命令中搜索</span><br></pre></td></tr></table></figure>\n<h4 id=\"历史命令\"><a href=\"#历史命令\" class=\"headerlink\" title=\"历史命令\"></a>历史命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history 显示所有的历史命令</span><br><span class=\"line\"></span><br><span class=\"line\">保存位置在 ~&#x2F;.bash_history文件里面</span><br><span class=\"line\"></span><br><span class=\"line\">history -c 清除历史命令</span><br></pre></td></tr></table></figure>\n<h3 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h3><p>dev目录 —— linux保存特殊文件的目录</p>\n<h4 id=\"输出重定向\"><a href=\"#输出重定向\" class=\"headerlink\" title=\"输出重定向\"></a>输出重定向</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令 &gt; 文件 —— 标准输出重定向</span><br><span class=\"line\"></span><br><span class=\"line\">命令 &gt;&gt; 文件 —— 追加重定向</span><br><span class=\"line\"></span><br><span class=\"line\">命令 2&gt; 文件 —— 标准错误输出</span><br><span class=\"line\"></span><br><span class=\"line\">命令 2&gt;&gt; 文件 —— 追加标准错误输出</span><br><span class=\"line\"></span><br><span class=\"line\">命令 &gt;&gt; 文件 2&gt;&amp;1 —— 追加错误或者正确的命令</span><br><span class=\"line\"></span><br><span class=\"line\">命令 &amp;&gt; &#x2F;dev&#x2F;null —— 放弃查看命令执行结果</span><br><span class=\"line\"></span><br><span class=\"line\">命令 &gt;&gt; success.log 2 &gt;&gt; error.log —— 分别保存这两个正确和错误的信息</span><br></pre></td></tr></table></figure>\n<h4 id=\"输入重定向\"><a href=\"#输入重定向\" class=\"headerlink\" title=\"输入重定向\"></a>输入重定向</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wc 选项 文件名 —— 统计（ctl+d结束）</span><br><span class=\"line\"></span><br><span class=\"line\">- c 统计字节数。</span><br><span class=\"line\"></span><br><span class=\"line\">- l 统计行数。</span><br><span class=\"line\"></span><br><span class=\"line\">- w 统计字数。</span><br></pre></td></tr></table></figure>\n<h4 id=\"多命令顺序执行\"><a href=\"#多命令顺序执行\" class=\"headerlink\" title=\"多命令顺序执行\"></a>多命令顺序执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令1; 命令2 —— 多个命令顺序执行，命令之间没有任何逻辑关系</span><br><span class=\"line\"></span><br><span class=\"line\">命令1 &amp;&amp; 命令2 —— 逻辑与关系</span><br><span class=\"line\"></span><br><span class=\"line\">命令1 || 命令2 —— 逻辑或关系 </span><br></pre></td></tr></table></figure>\n<h3 id=\"管道符\"><a href=\"#管道符\" class=\"headerlink\" title=\"管道符\"></a>管道符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令1 | 命令2 —— 命令1的正确输出结果作为命令2的操作对象</span><br><span class=\"line\"></span><br><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\">netstat -an | grep &quot;ESTABLISHED&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">? —— 匹配任意字符</span><br><span class=\"line\"></span><br><span class=\"line\">* —— 匹配0个或多个任意字符</span><br><span class=\"line\"></span><br><span class=\"line\">[] —— 匹配中括号中任意一个字符</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;&quot; —— 可以调用变量的值</span><br><span class=\"line\"></span><br><span class=\"line\">&#39;&#39; —— 所有特殊符号如 $ 都没有特殊含义</span><br><span class=\"line\"></span><br><span class=\"line\">&#96; &#96; —— 反引号可以执行命令</span><br><span class=\"line\"></span><br><span class=\"line\">$(命令) —— 执行命令</span><br></pre></td></tr></table></figure>\n<h3 id=\"远程拷贝\"><a href=\"#远程拷贝\" class=\"headerlink\" title=\"远程拷贝\"></a>远程拷贝</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r ./* admin@10.242.22.222:~/data1/ # scp将本地文件拷贝到远程机器</span><br><span class=\"line\">rsync -a ../views/* ubuntu@10.220.220.222:~/data1/htdocs/index.epoos.com/views/ # rsync方式拷贝文件</span><br></pre></td></tr></table></figure>\n<h3 id=\"相关链接《linux命令大全》\"><a href=\"#相关链接《linux命令大全》\" class=\"headerlink\" title=\"相关链接《linux命令大全》\"></a>相关链接《linux命令大全》</h3><p><a href=\"http://man.linuxde.net/rsync\">http://man.linuxde.net/rsync</a></p>\n"},{"layout":"default","title":"Linux学习笔记(一)","date":"2018-06-05T13:51:11.000Z","_content":"\n接下来一段时间打算学一下linux\n学习来源书本《Linux命令行与shell脚本编程大全 第三版》\n\n\n#### Linux目录名称\n\n常见的目录均基于文件系统层级标准（FHS）。很多Linux发型版都遵循了FHS。\n因此，你可以在任何兼容FHS的Linux系统中很容易的查找文件\n\n```shell\n/sbin # 系统二进制目录，存放许多GNU管理员级工具\n/bin # 二进制目录，存放许多用户级别的GNU工具\n/usr # 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里\n\n/boot # 启动目录，存放启动文件\n/dev # 设备目录，Linux在这里创建设备节点\n/etc # 系统配置文件目录\n/home # 主目录，Linux在这里创建用户目录\n/lib # 库目录，存放系统和应用程序的库文件\n/media # 媒体目录，可移动媒体设备的常用挂载点\n/mnt # 挂载目录，另一个可移动媒体设备的常用挂载点\n/opt # 可选目录，常用于存放第三方软件包和数据文件\n/proc # 进程目录，存放现有硬件及当前进程的相关信息\n/root # root用户的主目录\n/run # 运行目录，存放系统运行时的运行时数据\n/srv # 服务目录，存放不能低服务的相关文件\n/sys # 系统目录，存放系统硬件信息的相关文件\n/tmp # 临时目录，可以在该目录中创建和删除临时工作文件\n/var # 可变目录，用以存放经常变化的文件，比如日志文件\n```\n\n#### 基本命令\n\n用的最多的几个基本文件查看操作命令，详细参数使用的时候去查\n\n```shell\ncd # 进入目录\nls # 列出\ncp # 拷贝\necho # 写入文件\ntouch # 创建文件\nln # 软连接\nmv # 重名了文件(夹)\nmkdir # 创建文件夹\nrm # 删除文件\nrmdir # 删除文件目录\nfile # 查看文件类型\ncat # 查看文件内容\nmore # 查看一页文件内容 cat升级版\nless # 查看一页文件内容 more升级版\ntail # 查看文件后n行的内容 可指定查看行数 tail -n file\nhead # 查看文件前n行的内容 和tail相反 head -n file\ncat -n access.log | tail -n 300 | head -n 10\n```\n\n\n#### 名词解释\n\nGNU计划：又称革奴计划，是由Richard Stallman在1983年9月27日公开发起的。它的目标是创建一套完全自由的操作系统。 ———— 百度百科\n\nGNU软件：GNU软件是通过GNU项目发布的软件，它是一种根据GNU软件包的README手册以及自由软件指南开发的，大多数GNU软件是免费分发的，但不是多有的都这样，然而，所有的GNU软件都必须是自由软件。 ———— 百度百科\n\nGCC：GNU编译器套件（GNU Compiler Collection）。\n包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）GCC的初衷是为GNU操作系统专门编写的一款编译器。 ———— 百度百科\n\n","source":"_posts/linux1.md","raw":"---\nlayout: default\ntitle: Linux学习笔记(一)\ndate: 2018-06-05 21:51:11\ntag: [linux, shell]\ncategory: 笔记\n---\n\n接下来一段时间打算学一下linux\n学习来源书本《Linux命令行与shell脚本编程大全 第三版》\n\n\n#### Linux目录名称\n\n常见的目录均基于文件系统层级标准（FHS）。很多Linux发型版都遵循了FHS。\n因此，你可以在任何兼容FHS的Linux系统中很容易的查找文件\n\n```shell\n/sbin # 系统二进制目录，存放许多GNU管理员级工具\n/bin # 二进制目录，存放许多用户级别的GNU工具\n/usr # 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里\n\n/boot # 启动目录，存放启动文件\n/dev # 设备目录，Linux在这里创建设备节点\n/etc # 系统配置文件目录\n/home # 主目录，Linux在这里创建用户目录\n/lib # 库目录，存放系统和应用程序的库文件\n/media # 媒体目录，可移动媒体设备的常用挂载点\n/mnt # 挂载目录，另一个可移动媒体设备的常用挂载点\n/opt # 可选目录，常用于存放第三方软件包和数据文件\n/proc # 进程目录，存放现有硬件及当前进程的相关信息\n/root # root用户的主目录\n/run # 运行目录，存放系统运行时的运行时数据\n/srv # 服务目录，存放不能低服务的相关文件\n/sys # 系统目录，存放系统硬件信息的相关文件\n/tmp # 临时目录，可以在该目录中创建和删除临时工作文件\n/var # 可变目录，用以存放经常变化的文件，比如日志文件\n```\n\n#### 基本命令\n\n用的最多的几个基本文件查看操作命令，详细参数使用的时候去查\n\n```shell\ncd # 进入目录\nls # 列出\ncp # 拷贝\necho # 写入文件\ntouch # 创建文件\nln # 软连接\nmv # 重名了文件(夹)\nmkdir # 创建文件夹\nrm # 删除文件\nrmdir # 删除文件目录\nfile # 查看文件类型\ncat # 查看文件内容\nmore # 查看一页文件内容 cat升级版\nless # 查看一页文件内容 more升级版\ntail # 查看文件后n行的内容 可指定查看行数 tail -n file\nhead # 查看文件前n行的内容 和tail相反 head -n file\ncat -n access.log | tail -n 300 | head -n 10\n```\n\n\n#### 名词解释\n\nGNU计划：又称革奴计划，是由Richard Stallman在1983年9月27日公开发起的。它的目标是创建一套完全自由的操作系统。 ———— 百度百科\n\nGNU软件：GNU软件是通过GNU项目发布的软件，它是一种根据GNU软件包的README手册以及自由软件指南开发的，大多数GNU软件是免费分发的，但不是多有的都这样，然而，所有的GNU软件都必须是自由软件。 ———— 百度百科\n\nGCC：GNU编译器套件（GNU Compiler Collection）。\n包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）GCC的初衷是为GNU操作系统专门编写的一款编译器。 ———— 百度百科\n\n","slug":"linux1","published":1,"updated":"2021-03-30T01:32:00.320Z","comments":1,"photos":[],"link":"","_id":"ckn2g7ufo000sa0vze7en19tb","content":"<p>接下来一段时间打算学一下linux<br>学习来源书本《Linux命令行与shell脚本编程大全 第三版》</p>\n<h4 id=\"Linux目录名称\"><a href=\"#Linux目录名称\" class=\"headerlink\" title=\"Linux目录名称\"></a>Linux目录名称</h4><p>常见的目录均基于文件系统层级标准（FHS）。很多Linux发型版都遵循了FHS。<br>因此，你可以在任何兼容FHS的Linux系统中很容易的查找文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sbin # 系统二进制目录，存放许多GNU管理员级工具</span><br><span class=\"line\">/bin # 二进制目录，存放许多用户级别的GNU工具</span><br><span class=\"line\">/usr # 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里</span><br><span class=\"line\"></span><br><span class=\"line\">/boot # 启动目录，存放启动文件</span><br><span class=\"line\">/dev # 设备目录，Linux在这里创建设备节点</span><br><span class=\"line\">/etc # 系统配置文件目录</span><br><span class=\"line\">/home # 主目录，Linux在这里创建用户目录</span><br><span class=\"line\">/lib # 库目录，存放系统和应用程序的库文件</span><br><span class=\"line\">/media # 媒体目录，可移动媒体设备的常用挂载点</span><br><span class=\"line\">/mnt # 挂载目录，另一个可移动媒体设备的常用挂载点</span><br><span class=\"line\">/opt # 可选目录，常用于存放第三方软件包和数据文件</span><br><span class=\"line\">/proc # 进程目录，存放现有硬件及当前进程的相关信息</span><br><span class=\"line\">/root # root用户的主目录</span><br><span class=\"line\">/run # 运行目录，存放系统运行时的运行时数据</span><br><span class=\"line\">/srv # 服务目录，存放不能低服务的相关文件</span><br><span class=\"line\">/sys # 系统目录，存放系统硬件信息的相关文件</span><br><span class=\"line\">/tmp # 临时目录，可以在该目录中创建和删除临时工作文件</span><br><span class=\"line\">/var # 可变目录，用以存放经常变化的文件，比如日志文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h4><p>用的最多的几个基本文件查看操作命令，详细参数使用的时候去查</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd # 进入目录</span><br><span class=\"line\">ls # 列出</span><br><span class=\"line\">cp # 拷贝</span><br><span class=\"line\">echo # 写入文件</span><br><span class=\"line\">touch # 创建文件</span><br><span class=\"line\">ln # 软连接</span><br><span class=\"line\">mv # 重名了文件(夹)</span><br><span class=\"line\">mkdir # 创建文件夹</span><br><span class=\"line\">rm # 删除文件</span><br><span class=\"line\">rmdir # 删除文件目录</span><br><span class=\"line\">file # 查看文件类型</span><br><span class=\"line\">cat # 查看文件内容</span><br><span class=\"line\">more # 查看一页文件内容 cat升级版</span><br><span class=\"line\">less # 查看一页文件内容 more升级版</span><br><span class=\"line\">tail # 查看文件后n行的内容 可指定查看行数 tail -n file</span><br><span class=\"line\">head # 查看文件前n行的内容 和tail相反 head -n file</span><br><span class=\"line\">cat -n access.log | tail -n 300 | head -n 10</span><br></pre></td></tr></table></figure>\n<h4 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h4><p>GNU计划：又称革奴计划，是由Richard Stallman在1983年9月27日公开发起的。它的目标是创建一套完全自由的操作系统。 ———— 百度百科</p>\n<p>GNU软件：GNU软件是通过GNU项目发布的软件，它是一种根据GNU软件包的README手册以及自由软件指南开发的，大多数GNU软件是免费分发的，但不是多有的都这样，然而，所有的GNU软件都必须是自由软件。 ———— 百度百科</p>\n<p>GCC：GNU编译器套件（GNU Compiler Collection）。<br>包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）GCC的初衷是为GNU操作系统专门编写的一款编译器。 ———— 百度百科</p>\n","site":{"data":{}},"excerpt":"","more":"<p>接下来一段时间打算学一下linux<br>学习来源书本《Linux命令行与shell脚本编程大全 第三版》</p>\n<h4 id=\"Linux目录名称\"><a href=\"#Linux目录名称\" class=\"headerlink\" title=\"Linux目录名称\"></a>Linux目录名称</h4><p>常见的目录均基于文件系统层级标准（FHS）。很多Linux发型版都遵循了FHS。<br>因此，你可以在任何兼容FHS的Linux系统中很容易的查找文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sbin # 系统二进制目录，存放许多GNU管理员级工具</span><br><span class=\"line\">/bin # 二进制目录，存放许多用户级别的GNU工具</span><br><span class=\"line\">/usr # 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里</span><br><span class=\"line\"></span><br><span class=\"line\">/boot # 启动目录，存放启动文件</span><br><span class=\"line\">/dev # 设备目录，Linux在这里创建设备节点</span><br><span class=\"line\">/etc # 系统配置文件目录</span><br><span class=\"line\">/home # 主目录，Linux在这里创建用户目录</span><br><span class=\"line\">/lib # 库目录，存放系统和应用程序的库文件</span><br><span class=\"line\">/media # 媒体目录，可移动媒体设备的常用挂载点</span><br><span class=\"line\">/mnt # 挂载目录，另一个可移动媒体设备的常用挂载点</span><br><span class=\"line\">/opt # 可选目录，常用于存放第三方软件包和数据文件</span><br><span class=\"line\">/proc # 进程目录，存放现有硬件及当前进程的相关信息</span><br><span class=\"line\">/root # root用户的主目录</span><br><span class=\"line\">/run # 运行目录，存放系统运行时的运行时数据</span><br><span class=\"line\">/srv # 服务目录，存放不能低服务的相关文件</span><br><span class=\"line\">/sys # 系统目录，存放系统硬件信息的相关文件</span><br><span class=\"line\">/tmp # 临时目录，可以在该目录中创建和删除临时工作文件</span><br><span class=\"line\">/var # 可变目录，用以存放经常变化的文件，比如日志文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h4><p>用的最多的几个基本文件查看操作命令，详细参数使用的时候去查</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd # 进入目录</span><br><span class=\"line\">ls # 列出</span><br><span class=\"line\">cp # 拷贝</span><br><span class=\"line\">echo # 写入文件</span><br><span class=\"line\">touch # 创建文件</span><br><span class=\"line\">ln # 软连接</span><br><span class=\"line\">mv # 重名了文件(夹)</span><br><span class=\"line\">mkdir # 创建文件夹</span><br><span class=\"line\">rm # 删除文件</span><br><span class=\"line\">rmdir # 删除文件目录</span><br><span class=\"line\">file # 查看文件类型</span><br><span class=\"line\">cat # 查看文件内容</span><br><span class=\"line\">more # 查看一页文件内容 cat升级版</span><br><span class=\"line\">less # 查看一页文件内容 more升级版</span><br><span class=\"line\">tail # 查看文件后n行的内容 可指定查看行数 tail -n file</span><br><span class=\"line\">head # 查看文件前n行的内容 和tail相反 head -n file</span><br><span class=\"line\">cat -n access.log | tail -n 300 | head -n 10</span><br></pre></td></tr></table></figure>\n<h4 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h4><p>GNU计划：又称革奴计划，是由Richard Stallman在1983年9月27日公开发起的。它的目标是创建一套完全自由的操作系统。 ———— 百度百科</p>\n<p>GNU软件：GNU软件是通过GNU项目发布的软件，它是一种根据GNU软件包的README手册以及自由软件指南开发的，大多数GNU软件是免费分发的，但不是多有的都这样，然而，所有的GNU软件都必须是自由软件。 ———— 百度百科</p>\n<p>GCC：GNU编译器套件（GNU Compiler Collection）。<br>包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）GCC的初衷是为GNU操作系统专门编写的一款编译器。 ———— 百度百科</p>\n"},{"layout":"default","title":"Linux学习笔记(二)","date":"2018-06-05T13:51:11.000Z","_content":"\n接下来一段时间打算学一下linux\n学习来源书本《Linux命令行与shell脚本编程大全 第三版》\n\n\n### 一、进程管理\n\n##### ps命令\n\nps 命令默认会显示运行在当前控制台下的属于当前用户端的进程，显示的选项\n```shell\nUID # 启动这些进程的用户\nPPID # 父进程的进程号\nCMD # 启动程序的名称\nPID # process ID 进程id\nTTY # 运行在哪个终端\nTIME # 已占用的CPU时间\n```\n\n常用参数 ps -xx\n```shell\n-e # 显示所有进程\n-f # 显示完整格式的输出\n-w # 采用宽输出模式，不限宽度显示\n-l # 显示任务信息\n```\n\n##### top命令\n\n```shell\ntop # ps命令是查看某一时刻的信息，如果想要查看进程占用资源的趋势则需要用到top命令\n```\n\n##### kill killall命令\n\nkill命令可通过进程ID(PID)给进程发信号。\n\n```shell\nkill $pid # 杀掉进程id为pid的进程\n```\n\nkillall # killall命令支持通过进程名而不是PID来结束进程，也支持通配符\n以root身份执行此命令当小心，很可能会误杀重要的系统进程\n\n```shell\n# eg：\nkillall http* # 杀掉所有以http开头的进程\n```\n\n### 二、监测磁盘空间\n\nlinux文件系统将所有的磁盘都并入一个虚拟目录下。\n在使用新的存储媒体之前，需要把它放到虚拟目录下。这项工作称为 ———— 挂载\n\n一般情况，新发布的图形化桌面环境都会自动挂载特定类型的可移动存储媒体（可移动存储媒体指的是可从PC上轻易移除的媒体，比如软盘和U盘）\n\n##### mount命令\n\n用mount命令查看机器上的挂载信息\n\n```shell\nmount # 输出当前系统上挂载的设备 (设备文件名、挂载点、文件系统类型、已挂载媒体的访问状态)\n```\nmount挂载的文件举例，eg:\n```html\n/dev/disk2s1 on /Volumes/网易POPO (hfs, local, nodev, nosuid, read-only, noowners, quarantine, mounted by zsr)\n```\n\n使用 mount 命令手动挂载设备\n\n```shell\nmount -t type device directory\n```\n\n**type**\ntype 参数指定了磁盘被格式化的文件系统类型，linux可识别非常多的文件系统类型\n如果是需要和windows PC共用这些存储设备，通常得使用下列的文件系统类型\n\n```html\nvfat: windows长文件系统。\nntfs: windows NT、XP、Vista以及windows7中广泛使用的高级文件系统\niso9660: 标准CD-ROM文件系统\n```\n大多数U盘和软盘会被格式化成vfat文件系统。而数据CD则必须使用iso9660文件系统类型\n\n**device**\ndevice参数指定了改存储设备的设备文件的位置\n\n**directory**\ndirectory参数指定了挂载点在虚拟目录中的位置\n\n\n如：手动将U盘 /dev/sdb1 挂载到 /media/disk 可以使用下面的命令\n\n```shell\nmount -t ntfs /dev/sdb1 /media/disk\n```\n\n挂载之后root用户就可以使用该设备的所有访问权限了，其它用户访问，需要设置目录的访问权限\n\n\n##### umount命令\n\n从Linux系统上移除一个可移动设备时，不能直接从系统上移除而应该先卸载\n\n```shell\numount [directory | device]\n```\n\n##### df命令\n\ndf命令可以很方便的查看所有已挂载的磁盘的使用情况\n\n```shell\ndf\ndf -h # 把输出中的磁盘空间按照用户易读的形式显示\n```\ndu命令可以指定显示某个特定目录的磁盘使用情况。可以很容易发现哪个磁盘的存储空间快没了。\n\n```shell\ndu # 默认当前目录\ndu /path # 指定目录\ndu -c # 显示所有已累出文件的总大小\ndu -h # 把输出中的磁盘空间按照用户易读的形式显示\ndu -s # 输出每个参数的总计，如显示目录的总大小\n```\n\n\n### 三、处理数据文件\n\n##### sort命令排序数据\n\nsort 命令按照回话指定的默认语言的排序规则对文本文件中的数据进行排序。默认情况下，sort命令会把数据当做字符来执行标准的字符排序。\n```shell\nsort file # 标准字符排序方式\nsort -n file # 把数字识别成数字而不是字符\nsort -M file # 自动识别三个字符的月份名，并排序\nsort -b # 排序时忽略起始的空白\nsort -d # 仅考虑空白和字母，不考虑特殊字符\nsort -f # 默认会将大写字母排在前面，这个参数会胡烈大小写\nsort file -o newfile # 将排序结果写出到指定文件\nsort -r # 反序排序\nsort -k (--key=POS1[,POS2]) # 排序从POS1位置开始，如果指定了POS2，则到POS2位置结束\nsort -t # 指定一个用来区分键位置的字符\n```\n\n其中-t和-k对按照字段分割的数据进行排序非常有用，比如：\n对字符串 ‘abcd:cdef:dddd:xxxxxx’，以':'分割，然后取第三个字段dddd进行排序：\n\n```shell\nsort -t ':' -k 3 -n /etc/file   # \n```\n\n综合运用，将当前目录的文件(夹)大小安照降序输出\n\n```shell\ndu -sh * | sort -nr # | 为管道命令，将du的输出重定向到sort命令\n```\n\n##### grep命令搜索数据\n\ngrep命令就是从输入或者指定文件中查找包含指定字符的行\n\n```shell\ngrep xxx file # 搜索某文件(file)中的字段(xxx)所在的那一行数据\ngrep -v xxx file # 反向搜索，返回不匹配的所有行\ngrep -n # 输出包含行号\ngrep -c # 输出匹配的总行数\ngrep [abcdefghxx] # 正则匹配搜索\n```\n\n##### 压缩数据\n\nlinux包含了多种文件压缩工具\n\n```html\n工具         文件扩展名     描述\nbzip2       .bz2          \ncompress    .Z           最初的Unix文件压缩工具，快没人用了\ngzip        .gz          GNU压缩工具，linux最常用的压缩工具\nzip         .zip         Windows上的ePKZIP工具的Unix实现\n```\n\ngzip软件包是GNU项目的产物，这个软件包含有下面的工具\n\n```html\ngzip 用来压缩文件\ngzcat 用来查看压缩过的文本文件的内容\ngunzip 用来解压文件\n```\n\n```shell\ngzip ./*  # 将当前目录下的所有文件进行压缩，（会替换源文件）\ngunzip ./* # 解压当前目录下的所有.gz文件\n```\n\n**tar**\n虽然zip命令能够很好的将单个文件压缩归档，但是它不是Unix和Linux中的标准归档工具。\n目前Linux和Unix用的最广泛的归档工具是tar命令。\n\n```shell\ntar function [options] object1 object2 ...\ntar -c # 创建一个新的归档文件\ntar -v # 在处理文件时显示文件\ntar -f # 输出结果到文件或设备\ntar -t # 列出已有的tar归档文件的内容\ntar -x # 从已有的归档文件中提取文件\ntar -z # 将输出重定向给gzip命令来压缩内容\n```\n\n```shell\ntar -cvf txt.tar 1.txt 2.txt 3.txt # 压缩\ntar -zxvf txt.tar # 解压\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/linux2.md","raw":"---\nlayout: default\ntitle: Linux学习笔记(二)\ndate: 2018-06-05 21:51:11\ntag: [linux, shell]\ncategory: 笔记\n---\n\n接下来一段时间打算学一下linux\n学习来源书本《Linux命令行与shell脚本编程大全 第三版》\n\n\n### 一、进程管理\n\n##### ps命令\n\nps 命令默认会显示运行在当前控制台下的属于当前用户端的进程，显示的选项\n```shell\nUID # 启动这些进程的用户\nPPID # 父进程的进程号\nCMD # 启动程序的名称\nPID # process ID 进程id\nTTY # 运行在哪个终端\nTIME # 已占用的CPU时间\n```\n\n常用参数 ps -xx\n```shell\n-e # 显示所有进程\n-f # 显示完整格式的输出\n-w # 采用宽输出模式，不限宽度显示\n-l # 显示任务信息\n```\n\n##### top命令\n\n```shell\ntop # ps命令是查看某一时刻的信息，如果想要查看进程占用资源的趋势则需要用到top命令\n```\n\n##### kill killall命令\n\nkill命令可通过进程ID(PID)给进程发信号。\n\n```shell\nkill $pid # 杀掉进程id为pid的进程\n```\n\nkillall # killall命令支持通过进程名而不是PID来结束进程，也支持通配符\n以root身份执行此命令当小心，很可能会误杀重要的系统进程\n\n```shell\n# eg：\nkillall http* # 杀掉所有以http开头的进程\n```\n\n### 二、监测磁盘空间\n\nlinux文件系统将所有的磁盘都并入一个虚拟目录下。\n在使用新的存储媒体之前，需要把它放到虚拟目录下。这项工作称为 ———— 挂载\n\n一般情况，新发布的图形化桌面环境都会自动挂载特定类型的可移动存储媒体（可移动存储媒体指的是可从PC上轻易移除的媒体，比如软盘和U盘）\n\n##### mount命令\n\n用mount命令查看机器上的挂载信息\n\n```shell\nmount # 输出当前系统上挂载的设备 (设备文件名、挂载点、文件系统类型、已挂载媒体的访问状态)\n```\nmount挂载的文件举例，eg:\n```html\n/dev/disk2s1 on /Volumes/网易POPO (hfs, local, nodev, nosuid, read-only, noowners, quarantine, mounted by zsr)\n```\n\n使用 mount 命令手动挂载设备\n\n```shell\nmount -t type device directory\n```\n\n**type**\ntype 参数指定了磁盘被格式化的文件系统类型，linux可识别非常多的文件系统类型\n如果是需要和windows PC共用这些存储设备，通常得使用下列的文件系统类型\n\n```html\nvfat: windows长文件系统。\nntfs: windows NT、XP、Vista以及windows7中广泛使用的高级文件系统\niso9660: 标准CD-ROM文件系统\n```\n大多数U盘和软盘会被格式化成vfat文件系统。而数据CD则必须使用iso9660文件系统类型\n\n**device**\ndevice参数指定了改存储设备的设备文件的位置\n\n**directory**\ndirectory参数指定了挂载点在虚拟目录中的位置\n\n\n如：手动将U盘 /dev/sdb1 挂载到 /media/disk 可以使用下面的命令\n\n```shell\nmount -t ntfs /dev/sdb1 /media/disk\n```\n\n挂载之后root用户就可以使用该设备的所有访问权限了，其它用户访问，需要设置目录的访问权限\n\n\n##### umount命令\n\n从Linux系统上移除一个可移动设备时，不能直接从系统上移除而应该先卸载\n\n```shell\numount [directory | device]\n```\n\n##### df命令\n\ndf命令可以很方便的查看所有已挂载的磁盘的使用情况\n\n```shell\ndf\ndf -h # 把输出中的磁盘空间按照用户易读的形式显示\n```\ndu命令可以指定显示某个特定目录的磁盘使用情况。可以很容易发现哪个磁盘的存储空间快没了。\n\n```shell\ndu # 默认当前目录\ndu /path # 指定目录\ndu -c # 显示所有已累出文件的总大小\ndu -h # 把输出中的磁盘空间按照用户易读的形式显示\ndu -s # 输出每个参数的总计，如显示目录的总大小\n```\n\n\n### 三、处理数据文件\n\n##### sort命令排序数据\n\nsort 命令按照回话指定的默认语言的排序规则对文本文件中的数据进行排序。默认情况下，sort命令会把数据当做字符来执行标准的字符排序。\n```shell\nsort file # 标准字符排序方式\nsort -n file # 把数字识别成数字而不是字符\nsort -M file # 自动识别三个字符的月份名，并排序\nsort -b # 排序时忽略起始的空白\nsort -d # 仅考虑空白和字母，不考虑特殊字符\nsort -f # 默认会将大写字母排在前面，这个参数会胡烈大小写\nsort file -o newfile # 将排序结果写出到指定文件\nsort -r # 反序排序\nsort -k (--key=POS1[,POS2]) # 排序从POS1位置开始，如果指定了POS2，则到POS2位置结束\nsort -t # 指定一个用来区分键位置的字符\n```\n\n其中-t和-k对按照字段分割的数据进行排序非常有用，比如：\n对字符串 ‘abcd:cdef:dddd:xxxxxx’，以':'分割，然后取第三个字段dddd进行排序：\n\n```shell\nsort -t ':' -k 3 -n /etc/file   # \n```\n\n综合运用，将当前目录的文件(夹)大小安照降序输出\n\n```shell\ndu -sh * | sort -nr # | 为管道命令，将du的输出重定向到sort命令\n```\n\n##### grep命令搜索数据\n\ngrep命令就是从输入或者指定文件中查找包含指定字符的行\n\n```shell\ngrep xxx file # 搜索某文件(file)中的字段(xxx)所在的那一行数据\ngrep -v xxx file # 反向搜索，返回不匹配的所有行\ngrep -n # 输出包含行号\ngrep -c # 输出匹配的总行数\ngrep [abcdefghxx] # 正则匹配搜索\n```\n\n##### 压缩数据\n\nlinux包含了多种文件压缩工具\n\n```html\n工具         文件扩展名     描述\nbzip2       .bz2          \ncompress    .Z           最初的Unix文件压缩工具，快没人用了\ngzip        .gz          GNU压缩工具，linux最常用的压缩工具\nzip         .zip         Windows上的ePKZIP工具的Unix实现\n```\n\ngzip软件包是GNU项目的产物，这个软件包含有下面的工具\n\n```html\ngzip 用来压缩文件\ngzcat 用来查看压缩过的文本文件的内容\ngunzip 用来解压文件\n```\n\n```shell\ngzip ./*  # 将当前目录下的所有文件进行压缩，（会替换源文件）\ngunzip ./* # 解压当前目录下的所有.gz文件\n```\n\n**tar**\n虽然zip命令能够很好的将单个文件压缩归档，但是它不是Unix和Linux中的标准归档工具。\n目前Linux和Unix用的最广泛的归档工具是tar命令。\n\n```shell\ntar function [options] object1 object2 ...\ntar -c # 创建一个新的归档文件\ntar -v # 在处理文件时显示文件\ntar -f # 输出结果到文件或设备\ntar -t # 列出已有的tar归档文件的内容\ntar -x # 从已有的归档文件中提取文件\ntar -z # 将输出重定向给gzip命令来压缩内容\n```\n\n```shell\ntar -cvf txt.tar 1.txt 2.txt 3.txt # 压缩\ntar -zxvf txt.tar # 解压\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"linux2","published":1,"updated":"2021-03-30T01:32:00.320Z","comments":1,"photos":[],"link":"","_id":"ckn2g7ufp000ta0vz3ok76jev","content":"<p>接下来一段时间打算学一下linux<br>学习来源书本《Linux命令行与shell脚本编程大全 第三版》</p>\n<h3 id=\"一、进程管理\"><a href=\"#一、进程管理\" class=\"headerlink\" title=\"一、进程管理\"></a>一、进程管理</h3><h5 id=\"ps命令\"><a href=\"#ps命令\" class=\"headerlink\" title=\"ps命令\"></a>ps命令</h5><p>ps 命令默认会显示运行在当前控制台下的属于当前用户端的进程，显示的选项<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UID # 启动这些进程的用户</span><br><span class=\"line\">PPID # 父进程的进程号</span><br><span class=\"line\">CMD # 启动程序的名称</span><br><span class=\"line\">PID # process ID 进程id</span><br><span class=\"line\">TTY # 运行在哪个终端</span><br><span class=\"line\">TIME # 已占用的CPU时间</span><br></pre></td></tr></table></figure></p>\n<p>常用参数 ps -xx<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-e # 显示所有进程</span><br><span class=\"line\">-f # 显示完整格式的输出</span><br><span class=\"line\">-w # 采用宽输出模式，不限宽度显示</span><br><span class=\"line\">-l # 显示任务信息</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"top命令\"><a href=\"#top命令\" class=\"headerlink\" title=\"top命令\"></a>top命令</h5><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top # ps命令是查看某一时刻的信息，如果想要查看进程占用资源的趋势则需要用到top命令</span><br></pre></td></tr></table></figure>\n<h5 id=\"kill-killall命令\"><a href=\"#kill-killall命令\" class=\"headerlink\" title=\"kill killall命令\"></a>kill killall命令</h5><p>kill命令可通过进程ID(PID)给进程发信号。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill $pid # 杀掉进程id为pid的进程</span><br></pre></td></tr></table></figure>\n<p>killall # killall命令支持通过进程名而不是PID来结束进程，也支持通配符<br>以root身份执行此命令当小心，很可能会误杀重要的系统进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> eg：</span></span><br><span class=\"line\">killall http* # 杀掉所有以http开头的进程</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、监测磁盘空间\"><a href=\"#二、监测磁盘空间\" class=\"headerlink\" title=\"二、监测磁盘空间\"></a>二、监测磁盘空间</h3><p>linux文件系统将所有的磁盘都并入一个虚拟目录下。<br>在使用新的存储媒体之前，需要把它放到虚拟目录下。这项工作称为 ———— 挂载</p>\n<p>一般情况，新发布的图形化桌面环境都会自动挂载特定类型的可移动存储媒体（可移动存储媒体指的是可从PC上轻易移除的媒体，比如软盘和U盘）</p>\n<h5 id=\"mount命令\"><a href=\"#mount命令\" class=\"headerlink\" title=\"mount命令\"></a>mount命令</h5><p>用mount命令查看机器上的挂载信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount # 输出当前系统上挂载的设备 (设备文件名、挂载点、文件系统类型、已挂载媒体的访问状态)</span><br></pre></td></tr></table></figure>\n<p>mount挂载的文件举例，eg:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/dev/disk2s1 on /Volumes/网易POPO (hfs, local, nodev, nosuid, read-only, noowners, quarantine, mounted by zsr)</span><br></pre></td></tr></table></figure></p>\n<p>使用 mount 命令手动挂载设备</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t type device directory</span><br></pre></td></tr></table></figure>\n<p><strong>type</strong><br>type 参数指定了磁盘被格式化的文件系统类型，linux可识别非常多的文件系统类型<br>如果是需要和windows PC共用这些存储设备，通常得使用下列的文件系统类型</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vfat: windows长文件系统。</span><br><span class=\"line\">ntfs: windows NT、XP、Vista以及windows7中广泛使用的高级文件系统</span><br><span class=\"line\">iso9660: 标准CD-ROM文件系统</span><br></pre></td></tr></table></figure>\n<p>大多数U盘和软盘会被格式化成vfat文件系统。而数据CD则必须使用iso9660文件系统类型</p>\n<p><strong>device</strong><br>device参数指定了改存储设备的设备文件的位置</p>\n<p><strong>directory</strong><br>directory参数指定了挂载点在虚拟目录中的位置</p>\n<p>如：手动将U盘 /dev/sdb1 挂载到 /media/disk 可以使用下面的命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t ntfs /dev/sdb1 /media/disk</span><br></pre></td></tr></table></figure>\n<p>挂载之后root用户就可以使用该设备的所有访问权限了，其它用户访问，需要设置目录的访问权限</p>\n<h5 id=\"umount命令\"><a href=\"#umount命令\" class=\"headerlink\" title=\"umount命令\"></a>umount命令</h5><p>从Linux系统上移除一个可移动设备时，不能直接从系统上移除而应该先卸载</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">umount [directory | device]</span><br></pre></td></tr></table></figure>\n<h5 id=\"df命令\"><a href=\"#df命令\" class=\"headerlink\" title=\"df命令\"></a>df命令</h5><p>df命令可以很方便的查看所有已挂载的磁盘的使用情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df</span><br><span class=\"line\">df -h # 把输出中的磁盘空间按照用户易读的形式显示</span><br></pre></td></tr></table></figure>\n<p>du命令可以指定显示某个特定目录的磁盘使用情况。可以很容易发现哪个磁盘的存储空间快没了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du # 默认当前目录</span><br><span class=\"line\">du /path # 指定目录</span><br><span class=\"line\">du -c # 显示所有已累出文件的总大小</span><br><span class=\"line\">du -h # 把输出中的磁盘空间按照用户易读的形式显示</span><br><span class=\"line\">du -s # 输出每个参数的总计，如显示目录的总大小</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、处理数据文件\"><a href=\"#三、处理数据文件\" class=\"headerlink\" title=\"三、处理数据文件\"></a>三、处理数据文件</h3><h5 id=\"sort命令排序数据\"><a href=\"#sort命令排序数据\" class=\"headerlink\" title=\"sort命令排序数据\"></a>sort命令排序数据</h5><p>sort 命令按照回话指定的默认语言的排序规则对文本文件中的数据进行排序。默认情况下，sort命令会把数据当做字符来执行标准的字符排序。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort file # 标准字符排序方式</span><br><span class=\"line\">sort -n file # 把数字识别成数字而不是字符</span><br><span class=\"line\">sort -M file # 自动识别三个字符的月份名，并排序</span><br><span class=\"line\">sort -b # 排序时忽略起始的空白</span><br><span class=\"line\">sort -d # 仅考虑空白和字母，不考虑特殊字符</span><br><span class=\"line\">sort -f # 默认会将大写字母排在前面，这个参数会胡烈大小写</span><br><span class=\"line\">sort file -o newfile # 将排序结果写出到指定文件</span><br><span class=\"line\">sort -r # 反序排序</span><br><span class=\"line\">sort -k (--key=POS1[,POS2]) # 排序从POS1位置开始，如果指定了POS2，则到POS2位置结束</span><br><span class=\"line\">sort -t # 指定一个用来区分键位置的字符</span><br></pre></td></tr></table></figure></p>\n<p>其中-t和-k对按照字段分割的数据进行排序非常有用，比如：<br>对字符串 ‘abcd:cdef:dddd:xxxxxx’，以’:’分割，然后取第三个字段dddd进行排序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort -t &#x27;:&#x27; -k 3 -n /etc/file   # </span><br></pre></td></tr></table></figure>\n<p>综合运用，将当前目录的文件(夹)大小安照降序输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du -sh * | sort -nr # | 为管道命令，将du的输出重定向到sort命令</span><br></pre></td></tr></table></figure>\n<h5 id=\"grep命令搜索数据\"><a href=\"#grep命令搜索数据\" class=\"headerlink\" title=\"grep命令搜索数据\"></a>grep命令搜索数据</h5><p>grep命令就是从输入或者指定文件中查找包含指定字符的行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep xxx file # 搜索某文件(file)中的字段(xxx)所在的那一行数据</span><br><span class=\"line\">grep -v xxx file # 反向搜索，返回不匹配的所有行</span><br><span class=\"line\">grep -n # 输出包含行号</span><br><span class=\"line\">grep -c # 输出匹配的总行数</span><br><span class=\"line\">grep [abcdefghxx] # 正则匹配搜索</span><br></pre></td></tr></table></figure>\n<h5 id=\"压缩数据\"><a href=\"#压缩数据\" class=\"headerlink\" title=\"压缩数据\"></a>压缩数据</h5><p>linux包含了多种文件压缩工具</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">工具         文件扩展名     描述</span><br><span class=\"line\">bzip2       .bz2          </span><br><span class=\"line\">compress    .Z           最初的Unix文件压缩工具，快没人用了</span><br><span class=\"line\">gzip        .gz          GNU压缩工具，linux最常用的压缩工具</span><br><span class=\"line\">zip         .zip         Windows上的ePKZIP工具的Unix实现</span><br></pre></td></tr></table></figure>\n<p>gzip软件包是GNU项目的产物，这个软件包含有下面的工具</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gzip 用来压缩文件</span><br><span class=\"line\">gzcat 用来查看压缩过的文本文件的内容</span><br><span class=\"line\">gunzip 用来解压文件</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gzip ./*  # 将当前目录下的所有文件进行压缩，（会替换源文件）</span><br><span class=\"line\">gunzip ./* # 解压当前目录下的所有.gz文件</span><br></pre></td></tr></table></figure>\n<p><strong>tar</strong><br>虽然zip命令能够很好的将单个文件压缩归档，但是它不是Unix和Linux中的标准归档工具。<br>目前Linux和Unix用的最广泛的归档工具是tar命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar function [options] object1 object2 ...</span><br><span class=\"line\">tar -c # 创建一个新的归档文件</span><br><span class=\"line\">tar -v # 在处理文件时显示文件</span><br><span class=\"line\">tar -f # 输出结果到文件或设备</span><br><span class=\"line\">tar -t # 列出已有的tar归档文件的内容</span><br><span class=\"line\">tar -x # 从已有的归档文件中提取文件</span><br><span class=\"line\">tar -z # 将输出重定向给gzip命令来压缩内容</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cvf txt.tar 1.txt 2.txt 3.txt # 压缩</span><br><span class=\"line\">tar -zxvf txt.tar # 解压</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>接下来一段时间打算学一下linux<br>学习来源书本《Linux命令行与shell脚本编程大全 第三版》</p>\n<h3 id=\"一、进程管理\"><a href=\"#一、进程管理\" class=\"headerlink\" title=\"一、进程管理\"></a>一、进程管理</h3><h5 id=\"ps命令\"><a href=\"#ps命令\" class=\"headerlink\" title=\"ps命令\"></a>ps命令</h5><p>ps 命令默认会显示运行在当前控制台下的属于当前用户端的进程，显示的选项<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UID # 启动这些进程的用户</span><br><span class=\"line\">PPID # 父进程的进程号</span><br><span class=\"line\">CMD # 启动程序的名称</span><br><span class=\"line\">PID # process ID 进程id</span><br><span class=\"line\">TTY # 运行在哪个终端</span><br><span class=\"line\">TIME # 已占用的CPU时间</span><br></pre></td></tr></table></figure></p>\n<p>常用参数 ps -xx<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-e # 显示所有进程</span><br><span class=\"line\">-f # 显示完整格式的输出</span><br><span class=\"line\">-w # 采用宽输出模式，不限宽度显示</span><br><span class=\"line\">-l # 显示任务信息</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"top命令\"><a href=\"#top命令\" class=\"headerlink\" title=\"top命令\"></a>top命令</h5><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top # ps命令是查看某一时刻的信息，如果想要查看进程占用资源的趋势则需要用到top命令</span><br></pre></td></tr></table></figure>\n<h5 id=\"kill-killall命令\"><a href=\"#kill-killall命令\" class=\"headerlink\" title=\"kill killall命令\"></a>kill killall命令</h5><p>kill命令可通过进程ID(PID)给进程发信号。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill $pid # 杀掉进程id为pid的进程</span><br></pre></td></tr></table></figure>\n<p>killall # killall命令支持通过进程名而不是PID来结束进程，也支持通配符<br>以root身份执行此命令当小心，很可能会误杀重要的系统进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> eg：</span></span><br><span class=\"line\">killall http* # 杀掉所有以http开头的进程</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、监测磁盘空间\"><a href=\"#二、监测磁盘空间\" class=\"headerlink\" title=\"二、监测磁盘空间\"></a>二、监测磁盘空间</h3><p>linux文件系统将所有的磁盘都并入一个虚拟目录下。<br>在使用新的存储媒体之前，需要把它放到虚拟目录下。这项工作称为 ———— 挂载</p>\n<p>一般情况，新发布的图形化桌面环境都会自动挂载特定类型的可移动存储媒体（可移动存储媒体指的是可从PC上轻易移除的媒体，比如软盘和U盘）</p>\n<h5 id=\"mount命令\"><a href=\"#mount命令\" class=\"headerlink\" title=\"mount命令\"></a>mount命令</h5><p>用mount命令查看机器上的挂载信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount # 输出当前系统上挂载的设备 (设备文件名、挂载点、文件系统类型、已挂载媒体的访问状态)</span><br></pre></td></tr></table></figure>\n<p>mount挂载的文件举例，eg:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/dev/disk2s1 on /Volumes/网易POPO (hfs, local, nodev, nosuid, read-only, noowners, quarantine, mounted by zsr)</span><br></pre></td></tr></table></figure></p>\n<p>使用 mount 命令手动挂载设备</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t type device directory</span><br></pre></td></tr></table></figure>\n<p><strong>type</strong><br>type 参数指定了磁盘被格式化的文件系统类型，linux可识别非常多的文件系统类型<br>如果是需要和windows PC共用这些存储设备，通常得使用下列的文件系统类型</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vfat: windows长文件系统。</span><br><span class=\"line\">ntfs: windows NT、XP、Vista以及windows7中广泛使用的高级文件系统</span><br><span class=\"line\">iso9660: 标准CD-ROM文件系统</span><br></pre></td></tr></table></figure>\n<p>大多数U盘和软盘会被格式化成vfat文件系统。而数据CD则必须使用iso9660文件系统类型</p>\n<p><strong>device</strong><br>device参数指定了改存储设备的设备文件的位置</p>\n<p><strong>directory</strong><br>directory参数指定了挂载点在虚拟目录中的位置</p>\n<p>如：手动将U盘 /dev/sdb1 挂载到 /media/disk 可以使用下面的命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t ntfs /dev/sdb1 /media/disk</span><br></pre></td></tr></table></figure>\n<p>挂载之后root用户就可以使用该设备的所有访问权限了，其它用户访问，需要设置目录的访问权限</p>\n<h5 id=\"umount命令\"><a href=\"#umount命令\" class=\"headerlink\" title=\"umount命令\"></a>umount命令</h5><p>从Linux系统上移除一个可移动设备时，不能直接从系统上移除而应该先卸载</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">umount [directory | device]</span><br></pre></td></tr></table></figure>\n<h5 id=\"df命令\"><a href=\"#df命令\" class=\"headerlink\" title=\"df命令\"></a>df命令</h5><p>df命令可以很方便的查看所有已挂载的磁盘的使用情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df</span><br><span class=\"line\">df -h # 把输出中的磁盘空间按照用户易读的形式显示</span><br></pre></td></tr></table></figure>\n<p>du命令可以指定显示某个特定目录的磁盘使用情况。可以很容易发现哪个磁盘的存储空间快没了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du # 默认当前目录</span><br><span class=\"line\">du /path # 指定目录</span><br><span class=\"line\">du -c # 显示所有已累出文件的总大小</span><br><span class=\"line\">du -h # 把输出中的磁盘空间按照用户易读的形式显示</span><br><span class=\"line\">du -s # 输出每个参数的总计，如显示目录的总大小</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、处理数据文件\"><a href=\"#三、处理数据文件\" class=\"headerlink\" title=\"三、处理数据文件\"></a>三、处理数据文件</h3><h5 id=\"sort命令排序数据\"><a href=\"#sort命令排序数据\" class=\"headerlink\" title=\"sort命令排序数据\"></a>sort命令排序数据</h5><p>sort 命令按照回话指定的默认语言的排序规则对文本文件中的数据进行排序。默认情况下，sort命令会把数据当做字符来执行标准的字符排序。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort file # 标准字符排序方式</span><br><span class=\"line\">sort -n file # 把数字识别成数字而不是字符</span><br><span class=\"line\">sort -M file # 自动识别三个字符的月份名，并排序</span><br><span class=\"line\">sort -b # 排序时忽略起始的空白</span><br><span class=\"line\">sort -d # 仅考虑空白和字母，不考虑特殊字符</span><br><span class=\"line\">sort -f # 默认会将大写字母排在前面，这个参数会胡烈大小写</span><br><span class=\"line\">sort file -o newfile # 将排序结果写出到指定文件</span><br><span class=\"line\">sort -r # 反序排序</span><br><span class=\"line\">sort -k (--key=POS1[,POS2]) # 排序从POS1位置开始，如果指定了POS2，则到POS2位置结束</span><br><span class=\"line\">sort -t # 指定一个用来区分键位置的字符</span><br></pre></td></tr></table></figure></p>\n<p>其中-t和-k对按照字段分割的数据进行排序非常有用，比如：<br>对字符串 ‘abcd:cdef:dddd:xxxxxx’，以’:’分割，然后取第三个字段dddd进行排序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort -t &#x27;:&#x27; -k 3 -n /etc/file   # </span><br></pre></td></tr></table></figure>\n<p>综合运用，将当前目录的文件(夹)大小安照降序输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du -sh * | sort -nr # | 为管道命令，将du的输出重定向到sort命令</span><br></pre></td></tr></table></figure>\n<h5 id=\"grep命令搜索数据\"><a href=\"#grep命令搜索数据\" class=\"headerlink\" title=\"grep命令搜索数据\"></a>grep命令搜索数据</h5><p>grep命令就是从输入或者指定文件中查找包含指定字符的行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep xxx file # 搜索某文件(file)中的字段(xxx)所在的那一行数据</span><br><span class=\"line\">grep -v xxx file # 反向搜索，返回不匹配的所有行</span><br><span class=\"line\">grep -n # 输出包含行号</span><br><span class=\"line\">grep -c # 输出匹配的总行数</span><br><span class=\"line\">grep [abcdefghxx] # 正则匹配搜索</span><br></pre></td></tr></table></figure>\n<h5 id=\"压缩数据\"><a href=\"#压缩数据\" class=\"headerlink\" title=\"压缩数据\"></a>压缩数据</h5><p>linux包含了多种文件压缩工具</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">工具         文件扩展名     描述</span><br><span class=\"line\">bzip2       .bz2          </span><br><span class=\"line\">compress    .Z           最初的Unix文件压缩工具，快没人用了</span><br><span class=\"line\">gzip        .gz          GNU压缩工具，linux最常用的压缩工具</span><br><span class=\"line\">zip         .zip         Windows上的ePKZIP工具的Unix实现</span><br></pre></td></tr></table></figure>\n<p>gzip软件包是GNU项目的产物，这个软件包含有下面的工具</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gzip 用来压缩文件</span><br><span class=\"line\">gzcat 用来查看压缩过的文本文件的内容</span><br><span class=\"line\">gunzip 用来解压文件</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gzip ./*  # 将当前目录下的所有文件进行压缩，（会替换源文件）</span><br><span class=\"line\">gunzip ./* # 解压当前目录下的所有.gz文件</span><br></pre></td></tr></table></figure>\n<p><strong>tar</strong><br>虽然zip命令能够很好的将单个文件压缩归档，但是它不是Unix和Linux中的标准归档工具。<br>目前Linux和Unix用的最广泛的归档工具是tar命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar function [options] object1 object2 ...</span><br><span class=\"line\">tar -c # 创建一个新的归档文件</span><br><span class=\"line\">tar -v # 在处理文件时显示文件</span><br><span class=\"line\">tar -f # 输出结果到文件或设备</span><br><span class=\"line\">tar -t # 列出已有的tar归档文件的内容</span><br><span class=\"line\">tar -x # 从已有的归档文件中提取文件</span><br><span class=\"line\">tar -z # 将输出重定向给gzip命令来压缩内容</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cvf txt.tar 1.txt 2.txt 3.txt # 压缩</span><br><span class=\"line\">tar -zxvf txt.tar # 解压</span><br></pre></td></tr></table></figure>\n"},{"layout":"default","title":"Linux学习笔记(三)","date":"2018-06-10T02:39:00.000Z","_content":"\n接下来一段时间打算学一下linux\n学习来源书本《Linux命令行与shell脚本编程大全 第三版》\n\n\n### 一、SHELL与BASH简介\n\n**SHELL** 不单单是一种CLI。它是一个时刻都在运行的复杂交互式程序。\nshell 是用户和 Linux(Linux内核)之间的接口程序。你在控制台输入的每一个命令都是由shell解释之后再传给Linux内核的。\nshell 是一个命令语言解释器。\n\n**SH** (Bourne shell) 是一个早期的重要 shell，是UNIX标准的默认 shell\n\n**BASH** (GNU Bourne-Again Shell) 是一个为 GNU 计划编写的Unix shell。\nBASH 是 GNU 组织开发和推广的一个项目。\n\nBASH 是大多数Linux系统以及Mac OSX默认的shell\nBASH 的命令语法是Bourne shell命令语法的超集\n\n除此之外，还有很多shell，可通过如下方式查看本机安装的shell\n\n```shell\ncat /etc/shells\n```\n\n输出如下：\n\n```html\n/bin/dash\n/bin/rbash\n/bin/bash\n/bin/csh\n/bin/ksh\n/bin/sh\n/bin/tcsh\n/bin/zsh\n```\n\n\n\n\n##### 默认SHELL类型\n\n系统启动什么样的shell程序取决于个人用户ID配置。\n在/etc/passwd文件中，在用户ID记录的第七个字段中列出了默认的shell程序。\n\neg：\n\n```shell\ncat /etc/passwd\nnobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false\nroot:*:0:0:System Administrator:/var/root:/bin/sh\ndaemon:*:1:1:System Services:/var/root:/usr/bin/false\n...\n```\n\n比如上面的root用户配置的默认shell程序为/bin/sh\n\n或通过如下方式直接查看：\n\n```shell\nls -l /bin/sh\n-r-xr-xr-x  1 root  wheel  618512 10 26  2017 /bin/sh\n```\n\n可直接通过输入bash命令进入相应的shell解释程序\n\neg:\n```shell\nzsr :: / % sh\nsh-3.2$ exit\nexit\nzsr :: / % bash\nbash-3.2$ exit\nexit\n```\n\n### shell的父子关系\n\nshell也是需要程序来运行的，运行shell的程序就是父shell\n\neg：\n```shell\nzsr :: ~ ‹master*› % ps -f\n  UID   PID  PPID   C STIME   TTY           TIME CMD\n  501 68216   324   0 11:27上午 ttys000    0:00.04 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp zsr\n  501 68218 68217   0 11:27上午 ttys000    0:00.48 -zsh\nzsr :: ~ ‹master*› % bash\nbash-3.2$ ps -f\n  UID   PID  PPID   C STIME   TTY           TIME CMD\n  501 68216   324   0 11:27上午 ttys000    0:00.04 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp zsr\n  501 68218 68217   0 11:27上午 ttys000    0:00.48 -zsh\n  501 68553 68218   0 11:27上午 ttys000    0:00.01 bash\nbash-3.2$\n```\n上面运行bash之后，在运行ps -f ，此时，使用zsh运行bash，zsh就是bash的父shell。\n可循环创建子shell。\n\n\n#####  进程列表\n\n进程列表是一种命令分组。\n\n可以在一行中指定要依次运行的一系列命令。可以通过命令列表来实现，只需要在命令之间加入分号即可。\n\n```shell\npwd; ls; pwd; ls; echo $BASH_SUBSHELL\n{pwd; ls; pwd; ls; echo $BASH_SUBSHELL;} # 花括号不会成为进程列表\n(pwd; ls; pwd; ls; echo $BASH_SUBSHELL;) # 将命令列表用括号起来能成为进程列表\n```\n\n在shell脚本中，经常使用子shell进行多shell处理。\n\n**后台模式** 在后台模式中运行的命令可以在处理命令的同事让出CLI。\n\n```shell\nsleep 10 # 此命令会让进程等待10秒，在这个期间会话是不可用的\nsleep 10& # 在命令后面加‘&’，能让程序进入后台运行\nps -f # 查看后台运行的进程\njobs -l # 查看后台运行的进程 -l 参数显示更多信息\ncoproc sleep 10 # 协程，1.在后台生成子shell；2.在子shell中执行命令\ncoproc copname { sleep 10; } # copname，自定义协程名称，多个协程的时候用到\n```\n\n##### SHELL内建命令\n\n**内建命令** 已经和shell编译成了一体，作为shell工具的组成部分存在，不需要借助外部程序文件来运行。\n\n**外部命令** 有时候也被称作文件系统命令，是存在于bash shell之外的程序。\n它们并不是shell程序的一部分。\n外部命令程序通常位于/bin、/usr/bin、/sbin 或 /usr/sbin中。\n\n```shell\n$ which ps # 查看ps命令的位置\n/bin/ps # 输出路径，表示ps为外部命令\n$ type ps # 查看ps命令的类型\nps is /bin/ps \n\n$ which cd\ncd: shell built-in command # 表示cd为内部命令\n$ type cd\ncd is a shell builtin # 表示cd为内部命令\n\n$ type -a echo # echo命令既有内建命令，也有外部命令\necho is a shell builtin\necho is /bin/echo\n```\n\n当执行外部命令时，会创建出一个子进程。这种操作被称为衍生(forking)。\n当进程必须执行衍生操作时，它需要花费时间和精力来设置子进程的环境。\n所以，外部命令多少还是有些代价的。\n\n##### history\n\nhistory命令能够查看所有的shell命令历史\nhistory 历史记录保存在隐藏文件.bash_history中，位于用户的主目录中。\n需要注意的是，bash命令的历史记录是先保存在内存中的，当shell退出时才会写入到历史文件中\n\n```shell\nhistory\n!100 # 可执行历史中命令号为100的命令\n!！ # 可执行历史中上一条命令\n```\n\n\n##### alias\n\nalias命令可以为命令创建别名\n\n```shell\nalias # 查看已经创建的别名\nalias ll='ls -al' # 执行ll表示执行ls -al\n```\n\n别名只在当前的shell进程中有效，若是想全局设置，需要修改环境变量。\n\n环境变量请关注下一节。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/linux3.md","raw":"---\nlayout: default\ntitle: Linux学习笔记(三)\ndate: 2018-06-10 10:39:00\ntag: [linux, shell]\ncategory: 笔记\n---\n\n接下来一段时间打算学一下linux\n学习来源书本《Linux命令行与shell脚本编程大全 第三版》\n\n\n### 一、SHELL与BASH简介\n\n**SHELL** 不单单是一种CLI。它是一个时刻都在运行的复杂交互式程序。\nshell 是用户和 Linux(Linux内核)之间的接口程序。你在控制台输入的每一个命令都是由shell解释之后再传给Linux内核的。\nshell 是一个命令语言解释器。\n\n**SH** (Bourne shell) 是一个早期的重要 shell，是UNIX标准的默认 shell\n\n**BASH** (GNU Bourne-Again Shell) 是一个为 GNU 计划编写的Unix shell。\nBASH 是 GNU 组织开发和推广的一个项目。\n\nBASH 是大多数Linux系统以及Mac OSX默认的shell\nBASH 的命令语法是Bourne shell命令语法的超集\n\n除此之外，还有很多shell，可通过如下方式查看本机安装的shell\n\n```shell\ncat /etc/shells\n```\n\n输出如下：\n\n```html\n/bin/dash\n/bin/rbash\n/bin/bash\n/bin/csh\n/bin/ksh\n/bin/sh\n/bin/tcsh\n/bin/zsh\n```\n\n\n\n\n##### 默认SHELL类型\n\n系统启动什么样的shell程序取决于个人用户ID配置。\n在/etc/passwd文件中，在用户ID记录的第七个字段中列出了默认的shell程序。\n\neg：\n\n```shell\ncat /etc/passwd\nnobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false\nroot:*:0:0:System Administrator:/var/root:/bin/sh\ndaemon:*:1:1:System Services:/var/root:/usr/bin/false\n...\n```\n\n比如上面的root用户配置的默认shell程序为/bin/sh\n\n或通过如下方式直接查看：\n\n```shell\nls -l /bin/sh\n-r-xr-xr-x  1 root  wheel  618512 10 26  2017 /bin/sh\n```\n\n可直接通过输入bash命令进入相应的shell解释程序\n\neg:\n```shell\nzsr :: / % sh\nsh-3.2$ exit\nexit\nzsr :: / % bash\nbash-3.2$ exit\nexit\n```\n\n### shell的父子关系\n\nshell也是需要程序来运行的，运行shell的程序就是父shell\n\neg：\n```shell\nzsr :: ~ ‹master*› % ps -f\n  UID   PID  PPID   C STIME   TTY           TIME CMD\n  501 68216   324   0 11:27上午 ttys000    0:00.04 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp zsr\n  501 68218 68217   0 11:27上午 ttys000    0:00.48 -zsh\nzsr :: ~ ‹master*› % bash\nbash-3.2$ ps -f\n  UID   PID  PPID   C STIME   TTY           TIME CMD\n  501 68216   324   0 11:27上午 ttys000    0:00.04 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp zsr\n  501 68218 68217   0 11:27上午 ttys000    0:00.48 -zsh\n  501 68553 68218   0 11:27上午 ttys000    0:00.01 bash\nbash-3.2$\n```\n上面运行bash之后，在运行ps -f ，此时，使用zsh运行bash，zsh就是bash的父shell。\n可循环创建子shell。\n\n\n#####  进程列表\n\n进程列表是一种命令分组。\n\n可以在一行中指定要依次运行的一系列命令。可以通过命令列表来实现，只需要在命令之间加入分号即可。\n\n```shell\npwd; ls; pwd; ls; echo $BASH_SUBSHELL\n{pwd; ls; pwd; ls; echo $BASH_SUBSHELL;} # 花括号不会成为进程列表\n(pwd; ls; pwd; ls; echo $BASH_SUBSHELL;) # 将命令列表用括号起来能成为进程列表\n```\n\n在shell脚本中，经常使用子shell进行多shell处理。\n\n**后台模式** 在后台模式中运行的命令可以在处理命令的同事让出CLI。\n\n```shell\nsleep 10 # 此命令会让进程等待10秒，在这个期间会话是不可用的\nsleep 10& # 在命令后面加‘&’，能让程序进入后台运行\nps -f # 查看后台运行的进程\njobs -l # 查看后台运行的进程 -l 参数显示更多信息\ncoproc sleep 10 # 协程，1.在后台生成子shell；2.在子shell中执行命令\ncoproc copname { sleep 10; } # copname，自定义协程名称，多个协程的时候用到\n```\n\n##### SHELL内建命令\n\n**内建命令** 已经和shell编译成了一体，作为shell工具的组成部分存在，不需要借助外部程序文件来运行。\n\n**外部命令** 有时候也被称作文件系统命令，是存在于bash shell之外的程序。\n它们并不是shell程序的一部分。\n外部命令程序通常位于/bin、/usr/bin、/sbin 或 /usr/sbin中。\n\n```shell\n$ which ps # 查看ps命令的位置\n/bin/ps # 输出路径，表示ps为外部命令\n$ type ps # 查看ps命令的类型\nps is /bin/ps \n\n$ which cd\ncd: shell built-in command # 表示cd为内部命令\n$ type cd\ncd is a shell builtin # 表示cd为内部命令\n\n$ type -a echo # echo命令既有内建命令，也有外部命令\necho is a shell builtin\necho is /bin/echo\n```\n\n当执行外部命令时，会创建出一个子进程。这种操作被称为衍生(forking)。\n当进程必须执行衍生操作时，它需要花费时间和精力来设置子进程的环境。\n所以，外部命令多少还是有些代价的。\n\n##### history\n\nhistory命令能够查看所有的shell命令历史\nhistory 历史记录保存在隐藏文件.bash_history中，位于用户的主目录中。\n需要注意的是，bash命令的历史记录是先保存在内存中的，当shell退出时才会写入到历史文件中\n\n```shell\nhistory\n!100 # 可执行历史中命令号为100的命令\n!！ # 可执行历史中上一条命令\n```\n\n\n##### alias\n\nalias命令可以为命令创建别名\n\n```shell\nalias # 查看已经创建的别名\nalias ll='ls -al' # 执行ll表示执行ls -al\n```\n\n别名只在当前的shell进程中有效，若是想全局设置，需要修改环境变量。\n\n环境变量请关注下一节。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"linux3","published":1,"updated":"2021-03-30T01:32:00.320Z","comments":1,"photos":[],"link":"","_id":"ckn2g7ufp000ua0vzfcey6ssp","content":"<p>接下来一段时间打算学一下linux<br>学习来源书本《Linux命令行与shell脚本编程大全 第三版》</p>\n<h3 id=\"一、SHELL与BASH简介\"><a href=\"#一、SHELL与BASH简介\" class=\"headerlink\" title=\"一、SHELL与BASH简介\"></a>一、SHELL与BASH简介</h3><p><strong>SHELL</strong> 不单单是一种CLI。它是一个时刻都在运行的复杂交互式程序。<br>shell 是用户和 Linux(Linux内核)之间的接口程序。你在控制台输入的每一个命令都是由shell解释之后再传给Linux内核的。<br>shell 是一个命令语言解释器。</p>\n<p><strong>SH</strong> (Bourne shell) 是一个早期的重要 shell，是UNIX标准的默认 shell</p>\n<p><strong>BASH</strong> (GNU Bourne-Again Shell) 是一个为 GNU 计划编写的Unix shell。<br>BASH 是 GNU 组织开发和推广的一个项目。</p>\n<p>BASH 是大多数Linux系统以及Mac OSX默认的shell<br>BASH 的命令语法是Bourne shell命令语法的超集</p>\n<p>除此之外，还有很多shell，可通过如下方式查看本机安装的shell</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /etc/shells</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bin/dash</span><br><span class=\"line\">/bin/rbash</span><br><span class=\"line\">/bin/bash</span><br><span class=\"line\">/bin/csh</span><br><span class=\"line\">/bin/ksh</span><br><span class=\"line\">/bin/sh</span><br><span class=\"line\">/bin/tcsh</span><br><span class=\"line\">/bin/zsh</span><br></pre></td></tr></table></figure>\n<h5 id=\"默认SHELL类型\"><a href=\"#默认SHELL类型\" class=\"headerlink\" title=\"默认SHELL类型\"></a>默认SHELL类型</h5><p>系统启动什么样的shell程序取决于个人用户ID配置。<br>在/etc/passwd文件中，在用户ID记录的第七个字段中列出了默认的shell程序。</p>\n<p>eg：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /etc/passwd</span><br><span class=\"line\">nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false</span><br><span class=\"line\">root:*:0:0:System Administrator:/var/root:/bin/sh</span><br><span class=\"line\">daemon:*:1:1:System Services:/var/root:/usr/bin/false</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>比如上面的root用户配置的默认shell程序为/bin/sh</p>\n<p>或通过如下方式直接查看：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l /bin/sh</span><br><span class=\"line\">-r-xr-xr-x  1 root  wheel  618512 10 26  2017 /bin/sh</span><br></pre></td></tr></table></figure>\n<p>可直接通过输入bash命令进入相应的shell解释程序</p>\n<p>eg:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zsr :: / % sh</span><br><span class=\"line\">sh-3.2$ exit</span><br><span class=\"line\">exit</span><br><span class=\"line\">zsr :: / % bash</span><br><span class=\"line\">bash-3.2$ exit</span><br><span class=\"line\">exit</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"shell的父子关系\"><a href=\"#shell的父子关系\" class=\"headerlink\" title=\"shell的父子关系\"></a>shell的父子关系</h3><p>shell也是需要程序来运行的，运行shell的程序就是父shell</p>\n<p>eg：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zsr :: ~ ‹master*› % ps -f</span><br><span class=\"line\">  UID   PID  PPID   C STIME   TTY           TIME CMD</span><br><span class=\"line\">  501 68216   324   0 11:27上午 ttys000    0:00.04 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp zsr</span><br><span class=\"line\">  501 68218 68217   0 11:27上午 ttys000    0:00.48 -zsh</span><br><span class=\"line\">zsr :: ~ ‹master*› % bash</span><br><span class=\"line\">bash-3.2$ ps -f</span><br><span class=\"line\">  UID   PID  PPID   C STIME   TTY           TIME CMD</span><br><span class=\"line\">  501 68216   324   0 11:27上午 ttys000    0:00.04 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp zsr</span><br><span class=\"line\">  501 68218 68217   0 11:27上午 ttys000    0:00.48 -zsh</span><br><span class=\"line\">  501 68553 68218   0 11:27上午 ttys000    0:00.01 bash</span><br><span class=\"line\">bash-3.2$</span><br></pre></td></tr></table></figure><br>上面运行bash之后，在运行ps -f ，此时，使用zsh运行bash，zsh就是bash的父shell。<br>可循环创建子shell。</p>\n<h5 id=\"进程列表\"><a href=\"#进程列表\" class=\"headerlink\" title=\"进程列表\"></a>进程列表</h5><p>进程列表是一种命令分组。</p>\n<p>可以在一行中指定要依次运行的一系列命令。可以通过命令列表来实现，只需要在命令之间加入分号即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd; ls; pwd; ls; echo $BASH_SUBSHELL</span><br><span class=\"line\">&#123;pwd; ls; pwd; ls; echo $BASH_SUBSHELL;&#125; # 花括号不会成为进程列表</span><br><span class=\"line\">(pwd; ls; pwd; ls; echo $BASH_SUBSHELL;) # 将命令列表用括号起来能成为进程列表</span><br></pre></td></tr></table></figure>\n<p>在shell脚本中，经常使用子shell进行多shell处理。</p>\n<p><strong>后台模式</strong> 在后台模式中运行的命令可以在处理命令的同事让出CLI。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sleep 10 # 此命令会让进程等待10秒，在这个期间会话是不可用的</span><br><span class=\"line\">sleep 10&amp; # 在命令后面加‘&amp;’，能让程序进入后台运行</span><br><span class=\"line\">ps -f # 查看后台运行的进程</span><br><span class=\"line\">jobs -l # 查看后台运行的进程 -l 参数显示更多信息</span><br><span class=\"line\">coproc sleep 10 # 协程，1.在后台生成子shell；2.在子shell中执行命令</span><br><span class=\"line\">coproc copname &#123; sleep 10; &#125; # copname，自定义协程名称，多个协程的时候用到</span><br></pre></td></tr></table></figure>\n<h5 id=\"SHELL内建命令\"><a href=\"#SHELL内建命令\" class=\"headerlink\" title=\"SHELL内建命令\"></a>SHELL内建命令</h5><p><strong>内建命令</strong> 已经和shell编译成了一体，作为shell工具的组成部分存在，不需要借助外部程序文件来运行。</p>\n<p><strong>外部命令</strong> 有时候也被称作文件系统命令，是存在于bash shell之外的程序。<br>它们并不是shell程序的一部分。<br>外部命令程序通常位于/bin、/usr/bin、/sbin 或 /usr/sbin中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">which</span> ps <span class=\"comment\"># 查看ps命令的位置</span></span></span><br><span class=\"line\">/bin/ps # 输出路径，表示ps为外部命令</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">type</span> ps <span class=\"comment\"># 查看ps命令的类型</span></span></span><br><span class=\"line\">ps is /bin/ps </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">which</span> <span class=\"built_in\">cd</span></span></span><br><span class=\"line\">cd: shell built-in command # 表示cd为内部命令</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">type</span> <span class=\"built_in\">cd</span></span></span><br><span class=\"line\">cd is a shell builtin # 表示cd为内部命令</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">type</span> -a <span class=\"built_in\">echo</span> <span class=\"comment\"># echo命令既有内建命令，也有外部命令</span></span></span><br><span class=\"line\">echo is a shell builtin</span><br><span class=\"line\">echo is /bin/echo</span><br></pre></td></tr></table></figure>\n<p>当执行外部命令时，会创建出一个子进程。这种操作被称为衍生(forking)。<br>当进程必须执行衍生操作时，它需要花费时间和精力来设置子进程的环境。<br>所以，外部命令多少还是有些代价的。</p>\n<h5 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h5><p>history命令能够查看所有的shell命令历史<br>history 历史记录保存在隐藏文件.bash_history中，位于用户的主目录中。<br>需要注意的是，bash命令的历史记录是先保存在内存中的，当shell退出时才会写入到历史文件中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history</span><br><span class=\"line\">!100 # 可执行历史中命令号为100的命令</span><br><span class=\"line\">!！ # 可执行历史中上一条命令</span><br></pre></td></tr></table></figure>\n<h5 id=\"alias\"><a href=\"#alias\" class=\"headerlink\" title=\"alias\"></a>alias</h5><p>alias命令可以为命令创建别名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias # 查看已经创建的别名</span><br><span class=\"line\">alias ll=&#x27;ls -al&#x27; # 执行ll表示执行ls -al</span><br></pre></td></tr></table></figure>\n<p>别名只在当前的shell进程中有效，若是想全局设置，需要修改环境变量。</p>\n<p>环境变量请关注下一节。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>接下来一段时间打算学一下linux<br>学习来源书本《Linux命令行与shell脚本编程大全 第三版》</p>\n<h3 id=\"一、SHELL与BASH简介\"><a href=\"#一、SHELL与BASH简介\" class=\"headerlink\" title=\"一、SHELL与BASH简介\"></a>一、SHELL与BASH简介</h3><p><strong>SHELL</strong> 不单单是一种CLI。它是一个时刻都在运行的复杂交互式程序。<br>shell 是用户和 Linux(Linux内核)之间的接口程序。你在控制台输入的每一个命令都是由shell解释之后再传给Linux内核的。<br>shell 是一个命令语言解释器。</p>\n<p><strong>SH</strong> (Bourne shell) 是一个早期的重要 shell，是UNIX标准的默认 shell</p>\n<p><strong>BASH</strong> (GNU Bourne-Again Shell) 是一个为 GNU 计划编写的Unix shell。<br>BASH 是 GNU 组织开发和推广的一个项目。</p>\n<p>BASH 是大多数Linux系统以及Mac OSX默认的shell<br>BASH 的命令语法是Bourne shell命令语法的超集</p>\n<p>除此之外，还有很多shell，可通过如下方式查看本机安装的shell</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /etc/shells</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bin/dash</span><br><span class=\"line\">/bin/rbash</span><br><span class=\"line\">/bin/bash</span><br><span class=\"line\">/bin/csh</span><br><span class=\"line\">/bin/ksh</span><br><span class=\"line\">/bin/sh</span><br><span class=\"line\">/bin/tcsh</span><br><span class=\"line\">/bin/zsh</span><br></pre></td></tr></table></figure>\n<h5 id=\"默认SHELL类型\"><a href=\"#默认SHELL类型\" class=\"headerlink\" title=\"默认SHELL类型\"></a>默认SHELL类型</h5><p>系统启动什么样的shell程序取决于个人用户ID配置。<br>在/etc/passwd文件中，在用户ID记录的第七个字段中列出了默认的shell程序。</p>\n<p>eg：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /etc/passwd</span><br><span class=\"line\">nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false</span><br><span class=\"line\">root:*:0:0:System Administrator:/var/root:/bin/sh</span><br><span class=\"line\">daemon:*:1:1:System Services:/var/root:/usr/bin/false</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>比如上面的root用户配置的默认shell程序为/bin/sh</p>\n<p>或通过如下方式直接查看：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l /bin/sh</span><br><span class=\"line\">-r-xr-xr-x  1 root  wheel  618512 10 26  2017 /bin/sh</span><br></pre></td></tr></table></figure>\n<p>可直接通过输入bash命令进入相应的shell解释程序</p>\n<p>eg:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zsr :: / % sh</span><br><span class=\"line\">sh-3.2$ exit</span><br><span class=\"line\">exit</span><br><span class=\"line\">zsr :: / % bash</span><br><span class=\"line\">bash-3.2$ exit</span><br><span class=\"line\">exit</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"shell的父子关系\"><a href=\"#shell的父子关系\" class=\"headerlink\" title=\"shell的父子关系\"></a>shell的父子关系</h3><p>shell也是需要程序来运行的，运行shell的程序就是父shell</p>\n<p>eg：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zsr :: ~ ‹master*› % ps -f</span><br><span class=\"line\">  UID   PID  PPID   C STIME   TTY           TIME CMD</span><br><span class=\"line\">  501 68216   324   0 11:27上午 ttys000    0:00.04 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp zsr</span><br><span class=\"line\">  501 68218 68217   0 11:27上午 ttys000    0:00.48 -zsh</span><br><span class=\"line\">zsr :: ~ ‹master*› % bash</span><br><span class=\"line\">bash-3.2$ ps -f</span><br><span class=\"line\">  UID   PID  PPID   C STIME   TTY           TIME CMD</span><br><span class=\"line\">  501 68216   324   0 11:27上午 ttys000    0:00.04 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp zsr</span><br><span class=\"line\">  501 68218 68217   0 11:27上午 ttys000    0:00.48 -zsh</span><br><span class=\"line\">  501 68553 68218   0 11:27上午 ttys000    0:00.01 bash</span><br><span class=\"line\">bash-3.2$</span><br></pre></td></tr></table></figure><br>上面运行bash之后，在运行ps -f ，此时，使用zsh运行bash，zsh就是bash的父shell。<br>可循环创建子shell。</p>\n<h5 id=\"进程列表\"><a href=\"#进程列表\" class=\"headerlink\" title=\"进程列表\"></a>进程列表</h5><p>进程列表是一种命令分组。</p>\n<p>可以在一行中指定要依次运行的一系列命令。可以通过命令列表来实现，只需要在命令之间加入分号即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd; ls; pwd; ls; echo $BASH_SUBSHELL</span><br><span class=\"line\">&#123;pwd; ls; pwd; ls; echo $BASH_SUBSHELL;&#125; # 花括号不会成为进程列表</span><br><span class=\"line\">(pwd; ls; pwd; ls; echo $BASH_SUBSHELL;) # 将命令列表用括号起来能成为进程列表</span><br></pre></td></tr></table></figure>\n<p>在shell脚本中，经常使用子shell进行多shell处理。</p>\n<p><strong>后台模式</strong> 在后台模式中运行的命令可以在处理命令的同事让出CLI。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sleep 10 # 此命令会让进程等待10秒，在这个期间会话是不可用的</span><br><span class=\"line\">sleep 10&amp; # 在命令后面加‘&amp;’，能让程序进入后台运行</span><br><span class=\"line\">ps -f # 查看后台运行的进程</span><br><span class=\"line\">jobs -l # 查看后台运行的进程 -l 参数显示更多信息</span><br><span class=\"line\">coproc sleep 10 # 协程，1.在后台生成子shell；2.在子shell中执行命令</span><br><span class=\"line\">coproc copname &#123; sleep 10; &#125; # copname，自定义协程名称，多个协程的时候用到</span><br></pre></td></tr></table></figure>\n<h5 id=\"SHELL内建命令\"><a href=\"#SHELL内建命令\" class=\"headerlink\" title=\"SHELL内建命令\"></a>SHELL内建命令</h5><p><strong>内建命令</strong> 已经和shell编译成了一体，作为shell工具的组成部分存在，不需要借助外部程序文件来运行。</p>\n<p><strong>外部命令</strong> 有时候也被称作文件系统命令，是存在于bash shell之外的程序。<br>它们并不是shell程序的一部分。<br>外部命令程序通常位于/bin、/usr/bin、/sbin 或 /usr/sbin中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">which</span> ps <span class=\"comment\"># 查看ps命令的位置</span></span></span><br><span class=\"line\">/bin/ps # 输出路径，表示ps为外部命令</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">type</span> ps <span class=\"comment\"># 查看ps命令的类型</span></span></span><br><span class=\"line\">ps is /bin/ps </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">which</span> <span class=\"built_in\">cd</span></span></span><br><span class=\"line\">cd: shell built-in command # 表示cd为内部命令</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">type</span> <span class=\"built_in\">cd</span></span></span><br><span class=\"line\">cd is a shell builtin # 表示cd为内部命令</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">type</span> -a <span class=\"built_in\">echo</span> <span class=\"comment\"># echo命令既有内建命令，也有外部命令</span></span></span><br><span class=\"line\">echo is a shell builtin</span><br><span class=\"line\">echo is /bin/echo</span><br></pre></td></tr></table></figure>\n<p>当执行外部命令时，会创建出一个子进程。这种操作被称为衍生(forking)。<br>当进程必须执行衍生操作时，它需要花费时间和精力来设置子进程的环境。<br>所以，外部命令多少还是有些代价的。</p>\n<h5 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h5><p>history命令能够查看所有的shell命令历史<br>history 历史记录保存在隐藏文件.bash_history中，位于用户的主目录中。<br>需要注意的是，bash命令的历史记录是先保存在内存中的，当shell退出时才会写入到历史文件中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history</span><br><span class=\"line\">!100 # 可执行历史中命令号为100的命令</span><br><span class=\"line\">!！ # 可执行历史中上一条命令</span><br></pre></td></tr></table></figure>\n<h5 id=\"alias\"><a href=\"#alias\" class=\"headerlink\" title=\"alias\"></a>alias</h5><p>alias命令可以为命令创建别名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias # 查看已经创建的别名</span><br><span class=\"line\">alias ll=&#x27;ls -al&#x27; # 执行ll表示执行ls -al</span><br></pre></td></tr></table></figure>\n<p>别名只在当前的shell进程中有效，若是想全局设置，需要修改环境变量。</p>\n<p>环境变量请关注下一节。</p>\n"},{"layout":"default","title":"Linux学习笔记(四)","date":"2018-06-13T16:00:00.000Z","_content":"\n接下来一段时间打算学一下linux\n学习来源书本《Linux命令行与shell脚本编程大全 第三版》\n\n\n### 一、SHELL环境变量\n\nbash shell用一个叫做环境变量(environment variable)的特性来存储有关shell会话和工作环境的信息。（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。\n\n在bash shell中，环境变量分为两类：\n```html\n全局变量：对于shell会话和所有生成的子shell都是可见的。可用来进行父子shell程序通信。\n局部变量：只对创建它们的shell可见。\n```\n\n#### 全局环境变量\n\n```shell\nenv # 打印出所有的全局变量\nprintenv # 同上\nprintenv {变量名} # 打印出特定环境变量\necho ${变量名} # 同上\n```\n\nps：在echo命令中，在变量名前加 $ 不仅能够显示变量当前的值，还能让变量作为命令行参数。\n\neg:\n\n```shell\necho $HOME # 打印出HOME的值\nls $HOME # ls HOME值目录下的文件列表\n```\n\n#### 局部环境变量\n\nLinux系统默认定义了标准的局部环境变量。\n除此之外，用户也可以定义自己的局部变量，这些变量被称为 **用户定义局部变量**。\n\n和全局变量不一样，Linux系统没有一个只显示局部环境变量的命令。\n\n\n```shell\nset # 会显示某个特定进程设置的所有环境变量（包括全局、局部、用户定义局部变量）\nsomekey=somevalue # 定义用户局部变量。注意:等号两边不能有空格、不能再子shell中引用\n```\n\n#### 用户自定义全局环境变量\n\n很显然系统自带的全局环境变量、自带的局部环境变量以及用户定义局部变量并不能满足父子shell进程之间的通讯\n因此，linux还允许用户设置自定义全局变量。\n\n```shell\nsomekey=somevalue # 先创建一个局部环境变量\nexport somekey # 再通过export将其导入到全局变量变量。注意：不需要$符号。\n\nexport somekey=somevalue # 一键创建全局环境变量\n```\n特别注意：\n1.在父进程中修改的全局变量会影响子进程中的该变量；\n2.但是在子进程中修改该变量不会影响到父进程中的该变量。即使再通过export导出也不会影响父进程，只会影响当前子进程的子进程。\n\n删除环境变量\n```shell\nunset somekey # 删除环境变量。注意：不需要$符号\n```\n\n注意：同创建环境变量一样，子进程中删除在父进程中export导出的全局环境变量不会影响到父进程。\n\n#### 设置PATH环境变量\n\n当在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序。\nPATH环境变量定义了用于进行命令和程序查找的目录。\n\neg:\n```shell\n$ echo $PATH # 输出系统环境变量\n/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Wireshark.app/Contents/MacOS:/usr/local/mysql/bin\n```\n执行某个命令的时候，系统会依次从上面输出的6个目录中，查找可执行命令的程序。如果找不到就会报错。\n\n用户添加自己的命令到系统环境变量中只需要使用如下命令，将可执行文件目录添加到原有的系统环境变量PATH后面。\n\n```shell\n$ PATH=$PATH:/home/xxx/scripts/bin\n```\n\n#### 可持续使用的自定义系统环境变量\n\n自定义变量的方法可以按照前面说的定义用户局部系统变量、或者用export导出为全局系统变量。\n但是，这种方式创建的变量是临时的，当前shell进程结束之后就会失效。\n\n要想永久的保存自定义变量，可以根据shell的启动过程，修改其启动时需要读取命令的文件。\n如下面几个文件。\n\n```shell\n/etc/profile # 系统默认的bash shell主启动文件，系统上每个用户登录都会执行此文件\n~/.bash_profile\n~/.bashrc\n~/.bash_login\n~/.profile\n```\n\nshell会按照下列顺序，运行第一个被找到的问题件，找到之后则忽略后面的\n\n```shell\n~/.bash_profile\n~/.bash_login\n~/.profile\n```\n\n注意：这个列表中没有~/.bashrc文件，这是因为该文件往往是在其它文件(如：.profile，也可能是.bash_profile)中被执行的。\n\n#### 交互式shell进程\n\n如果你的bash shell不是登录系统时启动的，那么你启动的shell叫做交互式shell。\n交互式shell不会像登录shell一样运行，但它依然提供了命令行提示符来输入命令。\n通俗来说，就是在终端，shell等待用户输入，然后执行用户输入的命令。\n\n#### 非交互式shell\n\n系统执行shell脚本时用的就是非交互式shell。不同于交互式shell的地方在于它没有命令行提示符。\n这种模式下，shell不会与用户进行交互，执行完shell script脚本 shell也就终止了。\n\n**交互式shell和非交互式shell的区别在于：**\n如果bash是作为交互式shell启动的，它就不会访问/etc/profile文件，只会检查用户HOME目录中的.bashrc文件。\n非交互式shell，当启动进程时，它会检查这个BASH_SHELL环境变量，读取的是环境变量所指定的配置文件。\n（BASH_SHELL这个环境变量默认情况下并未设置）\n\n\n#### login bash\n\n登录shell可以让用户与计算机交流\n\n#### no login bash\n\n非登录shell不可用让用户与计算机交流。\n比如用linux服务器搭建一个ftl服务器，并且创建了很多用户，那么可以将这些用户设置为nologin shell。\n这样，这些用户仅仅可以使用ftl服务，不能用来登录Linux主机，保证了安全性。\n\n关于用户的默认登录shell是在 /etc/passwd 文件中记录的。此文件中每一行就是一个用户，每行以冒号分割字段，其中最后一个字段表示的是用户默认登录使用的shell。\n\n#### 环境变量持久保存两个方法。\n\n1.将个人环境变量设置放在/etc/profile.d目录中，创建一个.sh结尾的文件，将所有新的或者修改过的全局环境变量设置放在这个文件中。\n2.放在~/.bashrc文件中。\n\n#### 数组变量\n\n环境变量可作为数组使用。\n数组是能够存储多个值的变量。\n这些值可以单独引用，也可以作为整个数组来引用。\n\n```shell\n$ somekey=(one two three four five)\n$ echo $somekey\none two three four five\n$ echo ${somekey[2]}\nthree # 这里有问题，mac上输出的是‘two’ ！！！，linux虚拟机上输出是‘three’！！！\n$ echo ${somekey[*]} # 输出全部，mac上可以不用{}，用此属性需谨慎。\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 附录 - 默认环境变量\n\n##### bash shell 支持的Bourne变量\n变量|描述\n-|-\nCDPATH | 冒号分隔的目录列表，作为cd命令的搜索\nHOME | 当前用户的主目录\nIFS | sell用来将文本字符串分割成字段的一系列字符\nMAIL | 当前用户收件箱的文件名(bash shell会检查这个文件，看看有没有新的邮件）\nMAILPATH | 冒号分隔的当前用户收件箱的文件名列表(bash shell会检查列表中的每个文件，看看有没有新邮件）\nOPTARG | getopts命令处理的最后一个选项参数值\nOPTIND | getopts命令处理的最后一个选项参数的索引号\nPATH | shell查找命令的目录列表，由冒号分隔\nPS1 | shell命令行界面的主提示符\nPS2 | sell命令行界面的次提示符\n\n\n##### bash shell环境变量\n\n除了默认的Bourme的环境变量，bash shell还提供一此 自有的变量\n\n变量 | 描述\n-|-\nBASH | 当前shel实例的全路径名\nBASH_ALIASES | 含有当前已设置别名的关联数组\nBASH_ARGC | 含有传入子函数或shel脚本的参数总数的数组变量 \nBASH_ARCV | 含有传入子函数或shell脚本的参数的数组变量 \nBASH_CMDS | 关联数组，包含shell执行过的命令的所在位置 \nBASH_COMMAND  | shell正在执行的命令或马上就执行的命令 \nBASH_ENV | 设置了的话，每个bash脚本会在运行前先尝试运行该变量定义的启动文件 \nBASH_EXECUTION_STRING | 使用bash -c选项传递过来的命令 \nBASH_LINENO | 含有当前执行的shell函数的源代码行号的数组变量 \nBASH_REMATCH | 只读数组，在使用正则表达式的比较运算符=~进行肯定匹配(positive match)时， 包含了匹配到的模式和子模式 \nBASH_SOURCE | 含有当前正在执行的hel函数所在源文件名的数组变量 \nBASH_SUBSHELL | 当前子shell环境的嵌套级别(初始值是0) \nBASH_VERSINFO | 含有当前运行的bash shell的主版本号和次版本号的数组变量 \nBASH_VERSION | 当前运行的bash shell的版本号 \nBASH_XTRACEFD | 若设置成了有效的文件描述符(0,1,2)则'set -x' 调试选项生成的跟踪输出可被重定向。通常用来将跟踪输出到一个文件中 \nBASHOPTS | 当前启用的bash shell选项的列表 \nBASHPID | 当前bash进程的PID \nCOLUMNS | 当前bash shell实例所用终端的宽度 \nCOMP_CWORD | COMP_WORDS变量的索引值，后者含有当前光标的位置 \nCOMP_LINE | 当前命令行 \nCOMP_POINT | 当前光标位置相对于当前命令起始的索引 \nCOMP_KEY | 用来调用shell函数补全功能的最后一个键 \nCOMP_TYPE | 一个整数值，表示所尝试的补全类型，用以完成shell函数补全 \nCOMP_WORDBREAKS | Readline库中用于单词补全的词分隔字符 \nCOMP_WORDS | 含有当前命令行所有单词的数组变量 \nCOMPREPLY | 含有由shell函数生成的可能填充代码的数组变量 \nCOPROC | 占用未命名的协进程的I/O文件描述符的数组变量 \nDIRSTACK | 含有目录栈当前内容的数组变量 \nEMACS | 设置为't' 时，表明emacs shell缓冲区正在工作，而行编辑功能被禁止 \nENV | 如果设置了该环境变量，在bash shell脚本运行之前会先执行已定义的启动文件(仅用于当bash shell以IPOSIX模式被调用时) \nEUID | 当前用户的有效用户ID (数字形式) \nFCEDIT | 供fc命令使用的默认编辑器 \nFIGNORE | 在进行文件名补全时可以忽略后缀名列表，由冒号分隔 \nFUNCNAME | 当前执行的shell函数的名称\n\n**续**\n\n变量 | 描述\n-|-\nFUNCNEST | 当设置成非零值时，表示所允许的最大函数嵌套级数(一旦超出，当前命令即被终止）\nGLOBIGNORE | 冒号分隔的模式列表，定义了在进行文件名扩展时可以忽略的一组文件名\nGROUPS | 含有当前用户属组列表的数组变量\nhistchars | 控制历史记录扩展，最多可有3个字符\nHISTCMD | 当前命令在历史记录中的编号\nHISICONTROL | 控制哪些命令留在历史记录列表中\nHISTFILE | 保存shell历史记录列表的文件名(默认是bash history)\nhISTFILESIZe | 最多在历史文件中存多少行\nHISTTIMEFORMAT | 如果设置了且非空，就用作格式化字符串，以显示bash历史中每条命令的时间戳\nHISTIGNORE | 由冒号分隔的模式列表，用来决定历史文件中哪些命令会被忽略\nHISTSIZE | 最多在历史文件中存多少条命令\nHOSTFILE | shell在补全主机名时读取的文件名称\nHOSTNAME | 当前主机的名称\nHOSTTYPE | 当前运行bash shell的机器\nIGNOREEOF | sell在退出前必须收到连续的BOF字符的数量(如果这个值不存在，默认是1)\nINPUTRC | Readline 初始化文件名(默认是.inputrc)\nLANG | shell的语言环境类别\nLC_ALL | 定义了一个语言环境类别，能够覆盖LANG变量\nLC_COLLATE | 设置对字符串排序时用的排序规则\nLC_CTYPE | 决定如何解释出现在文件名扩展和模式匹配中的字符\nLC_MESSAGES | 在解释前面带有S的双引号字符串时，该环境变量决定了所采用的语言环境设置\nLC_NUMERIC | 决定着格式化数字时采用的语言环境设置\nLINENO | 当前执行的脚本的行号\nLINES | 定义了终端上可见的行数\nMACHTYPE | 用“CPU-公司-系统”(CPU-company-system) 格式定义的系统类利\nMAPFILE | 一个数组变量， 当mapfile命令未指定数组变量作为参数时，它存储了了mapfile所读入的文本\nMAILCHECK | shell查看新邮件的频率(以秒为单位，默认值是60)\nOLDPWD | shell之前的工作目录\nOPTERR | 设置为1时，bash sell会显示getopts命令产生的错误\nOSTYPE | 定义shell所在的操作系统\nPIPESTATUS | 含有前台进程的退出状态列表的数组变量\nPOSIXLY_CORRECT | 设置了的话，bas会以POSsx模式启动\nPPID | bash sell父进程的PID\nPROMPT_COMMAND | 设置了的话，在命令行主提示符显示之前会执行这条命令\nPROMPT_DIRTRIM | 用来定义当启用了\\w或\\W提示符字符串转义时显示的尾部目录名的数量。被删除的目录名会用一组英文句点替换\nPS3 | select命令的提示符\nPS4 | 如果使用了bash的一x选项，在命令行之前显示的提示信息\nPWD | 当前工作目录\nRANDOM | 返回一个0~ 32767的随机数(对其的赋值可作为随机数生成器的种子)\nREADLINE_LINE | 当使用bind -x命令时，存储Readline缓冲区的内容\nREADLINE_POINT | 当使用bind -x命 令时，表示Readine缓冲区内容插人点的当前位置\nREPLY | read命令的默认变量\nSECONDS | 自从shell启动到现在的秒数(对其赋值将会重置计数器)\nSHELL | bash shell的全路径名\nSHELLOPTS | 已启用bash shell选项列表，列表项之间以冒号分隔\nSHLVL | shell的层级;每次启动一个新bash shell,该值增加1\nTIMEFORMAT | 指定了shell的时间显示格式\nTMOUT | select和read命令在没输人的情况下等待多久(以秒为单位)。默认值为0，表示无限长\nTMPDIR | 目录名，保存bash shell创建的临时文件\nUID | 当前用户的真实用户ID (数字形式)\n\n\n\n\n\n\n\n","source":"_posts/linux4.md","raw":"---\nlayout: default\ntitle: Linux学习笔记(四)\ndate: 2018-06-14\ntag: [linux, shell]\ncategory: 笔记\n---\n\n接下来一段时间打算学一下linux\n学习来源书本《Linux命令行与shell脚本编程大全 第三版》\n\n\n### 一、SHELL环境变量\n\nbash shell用一个叫做环境变量(environment variable)的特性来存储有关shell会话和工作环境的信息。（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。\n\n在bash shell中，环境变量分为两类：\n```html\n全局变量：对于shell会话和所有生成的子shell都是可见的。可用来进行父子shell程序通信。\n局部变量：只对创建它们的shell可见。\n```\n\n#### 全局环境变量\n\n```shell\nenv # 打印出所有的全局变量\nprintenv # 同上\nprintenv {变量名} # 打印出特定环境变量\necho ${变量名} # 同上\n```\n\nps：在echo命令中，在变量名前加 $ 不仅能够显示变量当前的值，还能让变量作为命令行参数。\n\neg:\n\n```shell\necho $HOME # 打印出HOME的值\nls $HOME # ls HOME值目录下的文件列表\n```\n\n#### 局部环境变量\n\nLinux系统默认定义了标准的局部环境变量。\n除此之外，用户也可以定义自己的局部变量，这些变量被称为 **用户定义局部变量**。\n\n和全局变量不一样，Linux系统没有一个只显示局部环境变量的命令。\n\n\n```shell\nset # 会显示某个特定进程设置的所有环境变量（包括全局、局部、用户定义局部变量）\nsomekey=somevalue # 定义用户局部变量。注意:等号两边不能有空格、不能再子shell中引用\n```\n\n#### 用户自定义全局环境变量\n\n很显然系统自带的全局环境变量、自带的局部环境变量以及用户定义局部变量并不能满足父子shell进程之间的通讯\n因此，linux还允许用户设置自定义全局变量。\n\n```shell\nsomekey=somevalue # 先创建一个局部环境变量\nexport somekey # 再通过export将其导入到全局变量变量。注意：不需要$符号。\n\nexport somekey=somevalue # 一键创建全局环境变量\n```\n特别注意：\n1.在父进程中修改的全局变量会影响子进程中的该变量；\n2.但是在子进程中修改该变量不会影响到父进程中的该变量。即使再通过export导出也不会影响父进程，只会影响当前子进程的子进程。\n\n删除环境变量\n```shell\nunset somekey # 删除环境变量。注意：不需要$符号\n```\n\n注意：同创建环境变量一样，子进程中删除在父进程中export导出的全局环境变量不会影响到父进程。\n\n#### 设置PATH环境变量\n\n当在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序。\nPATH环境变量定义了用于进行命令和程序查找的目录。\n\neg:\n```shell\n$ echo $PATH # 输出系统环境变量\n/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Wireshark.app/Contents/MacOS:/usr/local/mysql/bin\n```\n执行某个命令的时候，系统会依次从上面输出的6个目录中，查找可执行命令的程序。如果找不到就会报错。\n\n用户添加自己的命令到系统环境变量中只需要使用如下命令，将可执行文件目录添加到原有的系统环境变量PATH后面。\n\n```shell\n$ PATH=$PATH:/home/xxx/scripts/bin\n```\n\n#### 可持续使用的自定义系统环境变量\n\n自定义变量的方法可以按照前面说的定义用户局部系统变量、或者用export导出为全局系统变量。\n但是，这种方式创建的变量是临时的，当前shell进程结束之后就会失效。\n\n要想永久的保存自定义变量，可以根据shell的启动过程，修改其启动时需要读取命令的文件。\n如下面几个文件。\n\n```shell\n/etc/profile # 系统默认的bash shell主启动文件，系统上每个用户登录都会执行此文件\n~/.bash_profile\n~/.bashrc\n~/.bash_login\n~/.profile\n```\n\nshell会按照下列顺序，运行第一个被找到的问题件，找到之后则忽略后面的\n\n```shell\n~/.bash_profile\n~/.bash_login\n~/.profile\n```\n\n注意：这个列表中没有~/.bashrc文件，这是因为该文件往往是在其它文件(如：.profile，也可能是.bash_profile)中被执行的。\n\n#### 交互式shell进程\n\n如果你的bash shell不是登录系统时启动的，那么你启动的shell叫做交互式shell。\n交互式shell不会像登录shell一样运行，但它依然提供了命令行提示符来输入命令。\n通俗来说，就是在终端，shell等待用户输入，然后执行用户输入的命令。\n\n#### 非交互式shell\n\n系统执行shell脚本时用的就是非交互式shell。不同于交互式shell的地方在于它没有命令行提示符。\n这种模式下，shell不会与用户进行交互，执行完shell script脚本 shell也就终止了。\n\n**交互式shell和非交互式shell的区别在于：**\n如果bash是作为交互式shell启动的，它就不会访问/etc/profile文件，只会检查用户HOME目录中的.bashrc文件。\n非交互式shell，当启动进程时，它会检查这个BASH_SHELL环境变量，读取的是环境变量所指定的配置文件。\n（BASH_SHELL这个环境变量默认情况下并未设置）\n\n\n#### login bash\n\n登录shell可以让用户与计算机交流\n\n#### no login bash\n\n非登录shell不可用让用户与计算机交流。\n比如用linux服务器搭建一个ftl服务器，并且创建了很多用户，那么可以将这些用户设置为nologin shell。\n这样，这些用户仅仅可以使用ftl服务，不能用来登录Linux主机，保证了安全性。\n\n关于用户的默认登录shell是在 /etc/passwd 文件中记录的。此文件中每一行就是一个用户，每行以冒号分割字段，其中最后一个字段表示的是用户默认登录使用的shell。\n\n#### 环境变量持久保存两个方法。\n\n1.将个人环境变量设置放在/etc/profile.d目录中，创建一个.sh结尾的文件，将所有新的或者修改过的全局环境变量设置放在这个文件中。\n2.放在~/.bashrc文件中。\n\n#### 数组变量\n\n环境变量可作为数组使用。\n数组是能够存储多个值的变量。\n这些值可以单独引用，也可以作为整个数组来引用。\n\n```shell\n$ somekey=(one two three four five)\n$ echo $somekey\none two three four five\n$ echo ${somekey[2]}\nthree # 这里有问题，mac上输出的是‘two’ ！！！，linux虚拟机上输出是‘three’！！！\n$ echo ${somekey[*]} # 输出全部，mac上可以不用{}，用此属性需谨慎。\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 附录 - 默认环境变量\n\n##### bash shell 支持的Bourne变量\n变量|描述\n-|-\nCDPATH | 冒号分隔的目录列表，作为cd命令的搜索\nHOME | 当前用户的主目录\nIFS | sell用来将文本字符串分割成字段的一系列字符\nMAIL | 当前用户收件箱的文件名(bash shell会检查这个文件，看看有没有新的邮件）\nMAILPATH | 冒号分隔的当前用户收件箱的文件名列表(bash shell会检查列表中的每个文件，看看有没有新邮件）\nOPTARG | getopts命令处理的最后一个选项参数值\nOPTIND | getopts命令处理的最后一个选项参数的索引号\nPATH | shell查找命令的目录列表，由冒号分隔\nPS1 | shell命令行界面的主提示符\nPS2 | sell命令行界面的次提示符\n\n\n##### bash shell环境变量\n\n除了默认的Bourme的环境变量，bash shell还提供一此 自有的变量\n\n变量 | 描述\n-|-\nBASH | 当前shel实例的全路径名\nBASH_ALIASES | 含有当前已设置别名的关联数组\nBASH_ARGC | 含有传入子函数或shel脚本的参数总数的数组变量 \nBASH_ARCV | 含有传入子函数或shell脚本的参数的数组变量 \nBASH_CMDS | 关联数组，包含shell执行过的命令的所在位置 \nBASH_COMMAND  | shell正在执行的命令或马上就执行的命令 \nBASH_ENV | 设置了的话，每个bash脚本会在运行前先尝试运行该变量定义的启动文件 \nBASH_EXECUTION_STRING | 使用bash -c选项传递过来的命令 \nBASH_LINENO | 含有当前执行的shell函数的源代码行号的数组变量 \nBASH_REMATCH | 只读数组，在使用正则表达式的比较运算符=~进行肯定匹配(positive match)时， 包含了匹配到的模式和子模式 \nBASH_SOURCE | 含有当前正在执行的hel函数所在源文件名的数组变量 \nBASH_SUBSHELL | 当前子shell环境的嵌套级别(初始值是0) \nBASH_VERSINFO | 含有当前运行的bash shell的主版本号和次版本号的数组变量 \nBASH_VERSION | 当前运行的bash shell的版本号 \nBASH_XTRACEFD | 若设置成了有效的文件描述符(0,1,2)则'set -x' 调试选项生成的跟踪输出可被重定向。通常用来将跟踪输出到一个文件中 \nBASHOPTS | 当前启用的bash shell选项的列表 \nBASHPID | 当前bash进程的PID \nCOLUMNS | 当前bash shell实例所用终端的宽度 \nCOMP_CWORD | COMP_WORDS变量的索引值，后者含有当前光标的位置 \nCOMP_LINE | 当前命令行 \nCOMP_POINT | 当前光标位置相对于当前命令起始的索引 \nCOMP_KEY | 用来调用shell函数补全功能的最后一个键 \nCOMP_TYPE | 一个整数值，表示所尝试的补全类型，用以完成shell函数补全 \nCOMP_WORDBREAKS | Readline库中用于单词补全的词分隔字符 \nCOMP_WORDS | 含有当前命令行所有单词的数组变量 \nCOMPREPLY | 含有由shell函数生成的可能填充代码的数组变量 \nCOPROC | 占用未命名的协进程的I/O文件描述符的数组变量 \nDIRSTACK | 含有目录栈当前内容的数组变量 \nEMACS | 设置为't' 时，表明emacs shell缓冲区正在工作，而行编辑功能被禁止 \nENV | 如果设置了该环境变量，在bash shell脚本运行之前会先执行已定义的启动文件(仅用于当bash shell以IPOSIX模式被调用时) \nEUID | 当前用户的有效用户ID (数字形式) \nFCEDIT | 供fc命令使用的默认编辑器 \nFIGNORE | 在进行文件名补全时可以忽略后缀名列表，由冒号分隔 \nFUNCNAME | 当前执行的shell函数的名称\n\n**续**\n\n变量 | 描述\n-|-\nFUNCNEST | 当设置成非零值时，表示所允许的最大函数嵌套级数(一旦超出，当前命令即被终止）\nGLOBIGNORE | 冒号分隔的模式列表，定义了在进行文件名扩展时可以忽略的一组文件名\nGROUPS | 含有当前用户属组列表的数组变量\nhistchars | 控制历史记录扩展，最多可有3个字符\nHISTCMD | 当前命令在历史记录中的编号\nHISICONTROL | 控制哪些命令留在历史记录列表中\nHISTFILE | 保存shell历史记录列表的文件名(默认是bash history)\nhISTFILESIZe | 最多在历史文件中存多少行\nHISTTIMEFORMAT | 如果设置了且非空，就用作格式化字符串，以显示bash历史中每条命令的时间戳\nHISTIGNORE | 由冒号分隔的模式列表，用来决定历史文件中哪些命令会被忽略\nHISTSIZE | 最多在历史文件中存多少条命令\nHOSTFILE | shell在补全主机名时读取的文件名称\nHOSTNAME | 当前主机的名称\nHOSTTYPE | 当前运行bash shell的机器\nIGNOREEOF | sell在退出前必须收到连续的BOF字符的数量(如果这个值不存在，默认是1)\nINPUTRC | Readline 初始化文件名(默认是.inputrc)\nLANG | shell的语言环境类别\nLC_ALL | 定义了一个语言环境类别，能够覆盖LANG变量\nLC_COLLATE | 设置对字符串排序时用的排序规则\nLC_CTYPE | 决定如何解释出现在文件名扩展和模式匹配中的字符\nLC_MESSAGES | 在解释前面带有S的双引号字符串时，该环境变量决定了所采用的语言环境设置\nLC_NUMERIC | 决定着格式化数字时采用的语言环境设置\nLINENO | 当前执行的脚本的行号\nLINES | 定义了终端上可见的行数\nMACHTYPE | 用“CPU-公司-系统”(CPU-company-system) 格式定义的系统类利\nMAPFILE | 一个数组变量， 当mapfile命令未指定数组变量作为参数时，它存储了了mapfile所读入的文本\nMAILCHECK | shell查看新邮件的频率(以秒为单位，默认值是60)\nOLDPWD | shell之前的工作目录\nOPTERR | 设置为1时，bash sell会显示getopts命令产生的错误\nOSTYPE | 定义shell所在的操作系统\nPIPESTATUS | 含有前台进程的退出状态列表的数组变量\nPOSIXLY_CORRECT | 设置了的话，bas会以POSsx模式启动\nPPID | bash sell父进程的PID\nPROMPT_COMMAND | 设置了的话，在命令行主提示符显示之前会执行这条命令\nPROMPT_DIRTRIM | 用来定义当启用了\\w或\\W提示符字符串转义时显示的尾部目录名的数量。被删除的目录名会用一组英文句点替换\nPS3 | select命令的提示符\nPS4 | 如果使用了bash的一x选项，在命令行之前显示的提示信息\nPWD | 当前工作目录\nRANDOM | 返回一个0~ 32767的随机数(对其的赋值可作为随机数生成器的种子)\nREADLINE_LINE | 当使用bind -x命令时，存储Readline缓冲区的内容\nREADLINE_POINT | 当使用bind -x命 令时，表示Readine缓冲区内容插人点的当前位置\nREPLY | read命令的默认变量\nSECONDS | 自从shell启动到现在的秒数(对其赋值将会重置计数器)\nSHELL | bash shell的全路径名\nSHELLOPTS | 已启用bash shell选项列表，列表项之间以冒号分隔\nSHLVL | shell的层级;每次启动一个新bash shell,该值增加1\nTIMEFORMAT | 指定了shell的时间显示格式\nTMOUT | select和read命令在没输人的情况下等待多久(以秒为单位)。默认值为0，表示无限长\nTMPDIR | 目录名，保存bash shell创建的临时文件\nUID | 当前用户的真实用户ID (数字形式)\n\n\n\n\n\n\n\n","slug":"linux4","published":1,"updated":"2021-03-30T01:32:00.320Z","comments":1,"photos":[],"link":"","_id":"ckn2g7ufq000va0vz9n135ldb","content":"<p>接下来一段时间打算学一下linux<br>学习来源书本《Linux命令行与shell脚本编程大全 第三版》</p>\n<h3 id=\"一、SHELL环境变量\"><a href=\"#一、SHELL环境变量\" class=\"headerlink\" title=\"一、SHELL环境变量\"></a>一、SHELL环境变量</h3><p>bash shell用一个叫做环境变量(environment variable)的特性来存储有关shell会话和工作环境的信息。（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。</p>\n<p>在bash shell中，环境变量分为两类：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">全局变量：对于shell会话和所有生成的子shell都是可见的。可用来进行父子shell程序通信。</span><br><span class=\"line\">局部变量：只对创建它们的shell可见。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"全局环境变量\"><a href=\"#全局环境变量\" class=\"headerlink\" title=\"全局环境变量\"></a>全局环境变量</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env # 打印出所有的全局变量</span><br><span class=\"line\">printenv # 同上</span><br><span class=\"line\">printenv &#123;变量名&#125; # 打印出特定环境变量</span><br><span class=\"line\">echo $&#123;变量名&#125; # 同上</span><br></pre></td></tr></table></figure>\n<p>ps：在echo命令中，在变量名前加 $ 不仅能够显示变量当前的值，还能让变量作为命令行参数。</p>\n<p>eg:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $HOME # 打印出HOME的值</span><br><span class=\"line\">ls $HOME # ls HOME值目录下的文件列表</span><br></pre></td></tr></table></figure>\n<h4 id=\"局部环境变量\"><a href=\"#局部环境变量\" class=\"headerlink\" title=\"局部环境变量\"></a>局部环境变量</h4><p>Linux系统默认定义了标准的局部环境变量。<br>除此之外，用户也可以定义自己的局部变量，这些变量被称为 <strong>用户定义局部变量</strong>。</p>\n<p>和全局变量不一样，Linux系统没有一个只显示局部环境变量的命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set # 会显示某个特定进程设置的所有环境变量（包括全局、局部、用户定义局部变量）</span><br><span class=\"line\">somekey=somevalue # 定义用户局部变量。注意:等号两边不能有空格、不能再子shell中引用</span><br></pre></td></tr></table></figure>\n<h4 id=\"用户自定义全局环境变量\"><a href=\"#用户自定义全局环境变量\" class=\"headerlink\" title=\"用户自定义全局环境变量\"></a>用户自定义全局环境变量</h4><p>很显然系统自带的全局环境变量、自带的局部环境变量以及用户定义局部变量并不能满足父子shell进程之间的通讯<br>因此，linux还允许用户设置自定义全局变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somekey=somevalue # 先创建一个局部环境变量</span><br><span class=\"line\">export somekey # 再通过export将其导入到全局变量变量。注意：不需要$符号。</span><br><span class=\"line\"></span><br><span class=\"line\">export somekey=somevalue # 一键创建全局环境变量</span><br></pre></td></tr></table></figure>\n<p>特别注意：<br>1.在父进程中修改的全局变量会影响子进程中的该变量；<br>2.但是在子进程中修改该变量不会影响到父进程中的该变量。即使再通过export导出也不会影响父进程，只会影响当前子进程的子进程。</p>\n<p>删除环境变量<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unset somekey # 删除环境变量。注意：不需要$符号</span><br></pre></td></tr></table></figure></p>\n<p>注意：同创建环境变量一样，子进程中删除在父进程中export导出的全局环境变量不会影响到父进程。</p>\n<h4 id=\"设置PATH环境变量\"><a href=\"#设置PATH环境变量\" class=\"headerlink\" title=\"设置PATH环境变量\"></a>设置PATH环境变量</h4><p>当在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序。<br>PATH环境变量定义了用于进行命令和程序查找的目录。</p>\n<p>eg:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$PATH</span> <span class=\"comment\"># 输出系统环境变量</span></span></span><br><span class=\"line\">/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Wireshark.app/Contents/MacOS:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure><br>执行某个命令的时候，系统会依次从上面输出的6个目录中，查找可执行命令的程序。如果找不到就会报错。</p>\n<p>用户添加自己的命令到系统环境变量中只需要使用如下命令，将可执行文件目录添加到原有的系统环境变量PATH后面。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> PATH=<span class=\"variable\">$PATH</span>:/home/xxx/scripts/bin</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"可持续使用的自定义系统环境变量\"><a href=\"#可持续使用的自定义系统环境变量\" class=\"headerlink\" title=\"可持续使用的自定义系统环境变量\"></a>可持续使用的自定义系统环境变量</h4><p>自定义变量的方法可以按照前面说的定义用户局部系统变量、或者用export导出为全局系统变量。<br>但是，这种方式创建的变量是临时的，当前shell进程结束之后就会失效。</p>\n<p>要想永久的保存自定义变量，可以根据shell的启动过程，修改其启动时需要读取命令的文件。<br>如下面几个文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/profile # 系统默认的bash shell主启动文件，系统上每个用户登录都会执行此文件</span><br><span class=\"line\">~/.bash_profile</span><br><span class=\"line\">~/.bashrc</span><br><span class=\"line\">~/.bash_login</span><br><span class=\"line\">~/.profile</span><br></pre></td></tr></table></figure>\n<p>shell会按照下列顺序，运行第一个被找到的问题件，找到之后则忽略后面的</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.bash_profile</span><br><span class=\"line\">~/.bash_login</span><br><span class=\"line\">~/.profile</span><br></pre></td></tr></table></figure>\n<p>注意：这个列表中没有~/.bashrc文件，这是因为该文件往往是在其它文件(如：.profile，也可能是.bash_profile)中被执行的。</p>\n<h4 id=\"交互式shell进程\"><a href=\"#交互式shell进程\" class=\"headerlink\" title=\"交互式shell进程\"></a>交互式shell进程</h4><p>如果你的bash shell不是登录系统时启动的，那么你启动的shell叫做交互式shell。<br>交互式shell不会像登录shell一样运行，但它依然提供了命令行提示符来输入命令。<br>通俗来说，就是在终端，shell等待用户输入，然后执行用户输入的命令。</p>\n<h4 id=\"非交互式shell\"><a href=\"#非交互式shell\" class=\"headerlink\" title=\"非交互式shell\"></a>非交互式shell</h4><p>系统执行shell脚本时用的就是非交互式shell。不同于交互式shell的地方在于它没有命令行提示符。<br>这种模式下，shell不会与用户进行交互，执行完shell script脚本 shell也就终止了。</p>\n<p><strong>交互式shell和非交互式shell的区别在于：</strong><br>如果bash是作为交互式shell启动的，它就不会访问/etc/profile文件，只会检查用户HOME目录中的.bashrc文件。<br>非交互式shell，当启动进程时，它会检查这个BASH_SHELL环境变量，读取的是环境变量所指定的配置文件。<br>（BASH_SHELL这个环境变量默认情况下并未设置）</p>\n<h4 id=\"login-bash\"><a href=\"#login-bash\" class=\"headerlink\" title=\"login bash\"></a>login bash</h4><p>登录shell可以让用户与计算机交流</p>\n<h4 id=\"no-login-bash\"><a href=\"#no-login-bash\" class=\"headerlink\" title=\"no login bash\"></a>no login bash</h4><p>非登录shell不可用让用户与计算机交流。<br>比如用linux服务器搭建一个ftl服务器，并且创建了很多用户，那么可以将这些用户设置为nologin shell。<br>这样，这些用户仅仅可以使用ftl服务，不能用来登录Linux主机，保证了安全性。</p>\n<p>关于用户的默认登录shell是在 /etc/passwd 文件中记录的。此文件中每一行就是一个用户，每行以冒号分割字段，其中最后一个字段表示的是用户默认登录使用的shell。</p>\n<h4 id=\"环境变量持久保存两个方法。\"><a href=\"#环境变量持久保存两个方法。\" class=\"headerlink\" title=\"环境变量持久保存两个方法。\"></a>环境变量持久保存两个方法。</h4><p>1.将个人环境变量设置放在/etc/profile.d目录中，创建一个.sh结尾的文件，将所有新的或者修改过的全局环境变量设置放在这个文件中。<br>2.放在~/.bashrc文件中。</p>\n<h4 id=\"数组变量\"><a href=\"#数组变量\" class=\"headerlink\" title=\"数组变量\"></a>数组变量</h4><p>环境变量可作为数组使用。<br>数组是能够存储多个值的变量。<br>这些值可以单独引用，也可以作为整个数组来引用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> somekey=(one two three four five)</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$somekey</span></span></span><br><span class=\"line\">one two three four five</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;somekey[2]&#125;</span></span></span><br><span class=\"line\">three # 这里有问题，mac上输出的是‘two’ ！！！，linux虚拟机上输出是‘three’！！！</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;somekey[*]&#125;</span> <span class=\"comment\"># 输出全部，mac上可以不用&#123;&#125;，用此属性需谨慎。</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"附录-默认环境变量\"><a href=\"#附录-默认环境变量\" class=\"headerlink\" title=\"附录 - 默认环境变量\"></a>附录 - 默认环境变量</h3><h5 id=\"bash-shell-支持的Bourne变量\"><a href=\"#bash-shell-支持的Bourne变量\" class=\"headerlink\" title=\"bash shell 支持的Bourne变量\"></a>bash shell 支持的Bourne变量</h5><table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CDPATH</td>\n<td>冒号分隔的目录列表，作为cd命令的搜索</td>\n</tr>\n<tr>\n<td>HOME</td>\n<td>当前用户的主目录</td>\n</tr>\n<tr>\n<td>IFS</td>\n<td>sell用来将文本字符串分割成字段的一系列字符</td>\n</tr>\n<tr>\n<td>MAIL</td>\n<td>当前用户收件箱的文件名(bash shell会检查这个文件，看看有没有新的邮件）</td>\n</tr>\n<tr>\n<td>MAILPATH</td>\n<td>冒号分隔的当前用户收件箱的文件名列表(bash shell会检查列表中的每个文件，看看有没有新邮件）</td>\n</tr>\n<tr>\n<td>OPTARG</td>\n<td>getopts命令处理的最后一个选项参数值</td>\n</tr>\n<tr>\n<td>OPTIND</td>\n<td>getopts命令处理的最后一个选项参数的索引号</td>\n</tr>\n<tr>\n<td>PATH</td>\n<td>shell查找命令的目录列表，由冒号分隔</td>\n</tr>\n<tr>\n<td>PS1</td>\n<td>shell命令行界面的主提示符</td>\n</tr>\n<tr>\n<td>PS2</td>\n<td>sell命令行界面的次提示符</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"bash-shell环境变量\"><a href=\"#bash-shell环境变量\" class=\"headerlink\" title=\"bash shell环境变量\"></a>bash shell环境变量</h5><p>除了默认的Bourme的环境变量，bash shell还提供一此 自有的变量</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BASH</td>\n<td>当前shel实例的全路径名</td>\n</tr>\n<tr>\n<td>BASH_ALIASES</td>\n<td>含有当前已设置别名的关联数组</td>\n</tr>\n<tr>\n<td>BASH_ARGC</td>\n<td>含有传入子函数或shel脚本的参数总数的数组变量 </td>\n</tr>\n<tr>\n<td>BASH_ARCV</td>\n<td>含有传入子函数或shell脚本的参数的数组变量 </td>\n</tr>\n<tr>\n<td>BASH_CMDS</td>\n<td>关联数组，包含shell执行过的命令的所在位置 </td>\n</tr>\n<tr>\n<td>BASH_COMMAND</td>\n<td>shell正在执行的命令或马上就执行的命令 </td>\n</tr>\n<tr>\n<td>BASH_ENV</td>\n<td>设置了的话，每个bash脚本会在运行前先尝试运行该变量定义的启动文件 </td>\n</tr>\n<tr>\n<td>BASH_EXECUTION_STRING</td>\n<td>使用bash -c选项传递过来的命令 </td>\n</tr>\n<tr>\n<td>BASH_LINENO</td>\n<td>含有当前执行的shell函数的源代码行号的数组变量 </td>\n</tr>\n<tr>\n<td>BASH_REMATCH</td>\n<td>只读数组，在使用正则表达式的比较运算符=~进行肯定匹配(positive match)时， 包含了匹配到的模式和子模式 </td>\n</tr>\n<tr>\n<td>BASH_SOURCE</td>\n<td>含有当前正在执行的hel函数所在源文件名的数组变量 </td>\n</tr>\n<tr>\n<td>BASH_SUBSHELL</td>\n<td>当前子shell环境的嵌套级别(初始值是0) </td>\n</tr>\n<tr>\n<td>BASH_VERSINFO</td>\n<td>含有当前运行的bash shell的主版本号和次版本号的数组变量 </td>\n</tr>\n<tr>\n<td>BASH_VERSION</td>\n<td>当前运行的bash shell的版本号 </td>\n</tr>\n<tr>\n<td>BASH_XTRACEFD</td>\n<td>若设置成了有效的文件描述符(0,1,2)则’set -x’ 调试选项生成的跟踪输出可被重定向。通常用来将跟踪输出到一个文件中 </td>\n</tr>\n<tr>\n<td>BASHOPTS</td>\n<td>当前启用的bash shell选项的列表 </td>\n</tr>\n<tr>\n<td>BASHPID</td>\n<td>当前bash进程的PID </td>\n</tr>\n<tr>\n<td>COLUMNS</td>\n<td>当前bash shell实例所用终端的宽度 </td>\n</tr>\n<tr>\n<td>COMP_CWORD</td>\n<td>COMP_WORDS变量的索引值，后者含有当前光标的位置 </td>\n</tr>\n<tr>\n<td>COMP_LINE</td>\n<td>当前命令行 </td>\n</tr>\n<tr>\n<td>COMP_POINT</td>\n<td>当前光标位置相对于当前命令起始的索引 </td>\n</tr>\n<tr>\n<td>COMP_KEY</td>\n<td>用来调用shell函数补全功能的最后一个键 </td>\n</tr>\n<tr>\n<td>COMP_TYPE</td>\n<td>一个整数值，表示所尝试的补全类型，用以完成shell函数补全 </td>\n</tr>\n<tr>\n<td>COMP_WORDBREAKS</td>\n<td>Readline库中用于单词补全的词分隔字符 </td>\n</tr>\n<tr>\n<td>COMP_WORDS</td>\n<td>含有当前命令行所有单词的数组变量 </td>\n</tr>\n<tr>\n<td>COMPREPLY</td>\n<td>含有由shell函数生成的可能填充代码的数组变量 </td>\n</tr>\n<tr>\n<td>COPROC</td>\n<td>占用未命名的协进程的I/O文件描述符的数组变量 </td>\n</tr>\n<tr>\n<td>DIRSTACK</td>\n<td>含有目录栈当前内容的数组变量 </td>\n</tr>\n<tr>\n<td>EMACS</td>\n<td>设置为’t’ 时，表明emacs shell缓冲区正在工作，而行编辑功能被禁止 </td>\n</tr>\n<tr>\n<td>ENV</td>\n<td>如果设置了该环境变量，在bash shell脚本运行之前会先执行已定义的启动文件(仅用于当bash shell以IPOSIX模式被调用时) </td>\n</tr>\n<tr>\n<td>EUID</td>\n<td>当前用户的有效用户ID (数字形式) </td>\n</tr>\n<tr>\n<td>FCEDIT</td>\n<td>供fc命令使用的默认编辑器 </td>\n</tr>\n<tr>\n<td>FIGNORE</td>\n<td>在进行文件名补全时可以忽略后缀名列表，由冒号分隔 </td>\n</tr>\n<tr>\n<td>FUNCNAME</td>\n<td>当前执行的shell函数的名称</td>\n</tr>\n</tbody>\n</table>\n<p><strong>续</strong></p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FUNCNEST</td>\n<td>当设置成非零值时，表示所允许的最大函数嵌套级数(一旦超出，当前命令即被终止）</td>\n</tr>\n<tr>\n<td>GLOBIGNORE</td>\n<td>冒号分隔的模式列表，定义了在进行文件名扩展时可以忽略的一组文件名</td>\n</tr>\n<tr>\n<td>GROUPS</td>\n<td>含有当前用户属组列表的数组变量</td>\n</tr>\n<tr>\n<td>histchars</td>\n<td>控制历史记录扩展，最多可有3个字符</td>\n</tr>\n<tr>\n<td>HISTCMD</td>\n<td>当前命令在历史记录中的编号</td>\n</tr>\n<tr>\n<td>HISICONTROL</td>\n<td>控制哪些命令留在历史记录列表中</td>\n</tr>\n<tr>\n<td>HISTFILE</td>\n<td>保存shell历史记录列表的文件名(默认是bash history)</td>\n</tr>\n<tr>\n<td>hISTFILESIZe</td>\n<td>最多在历史文件中存多少行</td>\n</tr>\n<tr>\n<td>HISTTIMEFORMAT</td>\n<td>如果设置了且非空，就用作格式化字符串，以显示bash历史中每条命令的时间戳</td>\n</tr>\n<tr>\n<td>HISTIGNORE</td>\n<td>由冒号分隔的模式列表，用来决定历史文件中哪些命令会被忽略</td>\n</tr>\n<tr>\n<td>HISTSIZE</td>\n<td>最多在历史文件中存多少条命令</td>\n</tr>\n<tr>\n<td>HOSTFILE</td>\n<td>shell在补全主机名时读取的文件名称</td>\n</tr>\n<tr>\n<td>HOSTNAME</td>\n<td>当前主机的名称</td>\n</tr>\n<tr>\n<td>HOSTTYPE</td>\n<td>当前运行bash shell的机器</td>\n</tr>\n<tr>\n<td>IGNOREEOF</td>\n<td>sell在退出前必须收到连续的BOF字符的数量(如果这个值不存在，默认是1)</td>\n</tr>\n<tr>\n<td>INPUTRC</td>\n<td>Readline 初始化文件名(默认是.inputrc)</td>\n</tr>\n<tr>\n<td>LANG</td>\n<td>shell的语言环境类别</td>\n</tr>\n<tr>\n<td>LC_ALL</td>\n<td>定义了一个语言环境类别，能够覆盖LANG变量</td>\n</tr>\n<tr>\n<td>LC_COLLATE</td>\n<td>设置对字符串排序时用的排序规则</td>\n</tr>\n<tr>\n<td>LC_CTYPE</td>\n<td>决定如何解释出现在文件名扩展和模式匹配中的字符</td>\n</tr>\n<tr>\n<td>LC_MESSAGES</td>\n<td>在解释前面带有S的双引号字符串时，该环境变量决定了所采用的语言环境设置</td>\n</tr>\n<tr>\n<td>LC_NUMERIC</td>\n<td>决定着格式化数字时采用的语言环境设置</td>\n</tr>\n<tr>\n<td>LINENO</td>\n<td>当前执行的脚本的行号</td>\n</tr>\n<tr>\n<td>LINES</td>\n<td>定义了终端上可见的行数</td>\n</tr>\n<tr>\n<td>MACHTYPE</td>\n<td>用“CPU-公司-系统”(CPU-company-system) 格式定义的系统类利</td>\n</tr>\n<tr>\n<td>MAPFILE</td>\n<td>一个数组变量， 当mapfile命令未指定数组变量作为参数时，它存储了了mapfile所读入的文本</td>\n</tr>\n<tr>\n<td>MAILCHECK</td>\n<td>shell查看新邮件的频率(以秒为单位，默认值是60)</td>\n</tr>\n<tr>\n<td>OLDPWD</td>\n<td>shell之前的工作目录</td>\n</tr>\n<tr>\n<td>OPTERR</td>\n<td>设置为1时，bash sell会显示getopts命令产生的错误</td>\n</tr>\n<tr>\n<td>OSTYPE</td>\n<td>定义shell所在的操作系统</td>\n</tr>\n<tr>\n<td>PIPESTATUS</td>\n<td>含有前台进程的退出状态列表的数组变量</td>\n</tr>\n<tr>\n<td>POSIXLY_CORRECT</td>\n<td>设置了的话，bas会以POSsx模式启动</td>\n</tr>\n<tr>\n<td>PPID</td>\n<td>bash sell父进程的PID</td>\n</tr>\n<tr>\n<td>PROMPT_COMMAND</td>\n<td>设置了的话，在命令行主提示符显示之前会执行这条命令</td>\n</tr>\n<tr>\n<td>PROMPT_DIRTRIM</td>\n<td>用来定义当启用了\\w或\\W提示符字符串转义时显示的尾部目录名的数量。被删除的目录名会用一组英文句点替换</td>\n</tr>\n<tr>\n<td>PS3</td>\n<td>select命令的提示符</td>\n</tr>\n<tr>\n<td>PS4</td>\n<td>如果使用了bash的一x选项，在命令行之前显示的提示信息</td>\n</tr>\n<tr>\n<td>PWD</td>\n<td>当前工作目录</td>\n</tr>\n<tr>\n<td>RANDOM</td>\n<td>返回一个0~ 32767的随机数(对其的赋值可作为随机数生成器的种子)</td>\n</tr>\n<tr>\n<td>READLINE_LINE</td>\n<td>当使用bind -x命令时，存储Readline缓冲区的内容</td>\n</tr>\n<tr>\n<td>READLINE_POINT</td>\n<td>当使用bind -x命 令时，表示Readine缓冲区内容插人点的当前位置</td>\n</tr>\n<tr>\n<td>REPLY</td>\n<td>read命令的默认变量</td>\n</tr>\n<tr>\n<td>SECONDS</td>\n<td>自从shell启动到现在的秒数(对其赋值将会重置计数器)</td>\n</tr>\n<tr>\n<td>SHELL</td>\n<td>bash shell的全路径名</td>\n</tr>\n<tr>\n<td>SHELLOPTS</td>\n<td>已启用bash shell选项列表，列表项之间以冒号分隔</td>\n</tr>\n<tr>\n<td>SHLVL</td>\n<td>shell的层级;每次启动一个新bash shell,该值增加1</td>\n</tr>\n<tr>\n<td>TIMEFORMAT</td>\n<td>指定了shell的时间显示格式</td>\n</tr>\n<tr>\n<td>TMOUT</td>\n<td>select和read命令在没输人的情况下等待多久(以秒为单位)。默认值为0，表示无限长</td>\n</tr>\n<tr>\n<td>TMPDIR</td>\n<td>目录名，保存bash shell创建的临时文件</td>\n</tr>\n<tr>\n<td>UID</td>\n<td>当前用户的真实用户ID (数字形式)</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<p>接下来一段时间打算学一下linux<br>学习来源书本《Linux命令行与shell脚本编程大全 第三版》</p>\n<h3 id=\"一、SHELL环境变量\"><a href=\"#一、SHELL环境变量\" class=\"headerlink\" title=\"一、SHELL环境变量\"></a>一、SHELL环境变量</h3><p>bash shell用一个叫做环境变量(environment variable)的特性来存储有关shell会话和工作环境的信息。（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。</p>\n<p>在bash shell中，环境变量分为两类：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">全局变量：对于shell会话和所有生成的子shell都是可见的。可用来进行父子shell程序通信。</span><br><span class=\"line\">局部变量：只对创建它们的shell可见。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"全局环境变量\"><a href=\"#全局环境变量\" class=\"headerlink\" title=\"全局环境变量\"></a>全局环境变量</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env # 打印出所有的全局变量</span><br><span class=\"line\">printenv # 同上</span><br><span class=\"line\">printenv &#123;变量名&#125; # 打印出特定环境变量</span><br><span class=\"line\">echo $&#123;变量名&#125; # 同上</span><br></pre></td></tr></table></figure>\n<p>ps：在echo命令中，在变量名前加 $ 不仅能够显示变量当前的值，还能让变量作为命令行参数。</p>\n<p>eg:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $HOME # 打印出HOME的值</span><br><span class=\"line\">ls $HOME # ls HOME值目录下的文件列表</span><br></pre></td></tr></table></figure>\n<h4 id=\"局部环境变量\"><a href=\"#局部环境变量\" class=\"headerlink\" title=\"局部环境变量\"></a>局部环境变量</h4><p>Linux系统默认定义了标准的局部环境变量。<br>除此之外，用户也可以定义自己的局部变量，这些变量被称为 <strong>用户定义局部变量</strong>。</p>\n<p>和全局变量不一样，Linux系统没有一个只显示局部环境变量的命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set # 会显示某个特定进程设置的所有环境变量（包括全局、局部、用户定义局部变量）</span><br><span class=\"line\">somekey=somevalue # 定义用户局部变量。注意:等号两边不能有空格、不能再子shell中引用</span><br></pre></td></tr></table></figure>\n<h4 id=\"用户自定义全局环境变量\"><a href=\"#用户自定义全局环境变量\" class=\"headerlink\" title=\"用户自定义全局环境变量\"></a>用户自定义全局环境变量</h4><p>很显然系统自带的全局环境变量、自带的局部环境变量以及用户定义局部变量并不能满足父子shell进程之间的通讯<br>因此，linux还允许用户设置自定义全局变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somekey=somevalue # 先创建一个局部环境变量</span><br><span class=\"line\">export somekey # 再通过export将其导入到全局变量变量。注意：不需要$符号。</span><br><span class=\"line\"></span><br><span class=\"line\">export somekey=somevalue # 一键创建全局环境变量</span><br></pre></td></tr></table></figure>\n<p>特别注意：<br>1.在父进程中修改的全局变量会影响子进程中的该变量；<br>2.但是在子进程中修改该变量不会影响到父进程中的该变量。即使再通过export导出也不会影响父进程，只会影响当前子进程的子进程。</p>\n<p>删除环境变量<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unset somekey # 删除环境变量。注意：不需要$符号</span><br></pre></td></tr></table></figure></p>\n<p>注意：同创建环境变量一样，子进程中删除在父进程中export导出的全局环境变量不会影响到父进程。</p>\n<h4 id=\"设置PATH环境变量\"><a href=\"#设置PATH环境变量\" class=\"headerlink\" title=\"设置PATH环境变量\"></a>设置PATH环境变量</h4><p>当在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序。<br>PATH环境变量定义了用于进行命令和程序查找的目录。</p>\n<p>eg:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$PATH</span> <span class=\"comment\"># 输出系统环境变量</span></span></span><br><span class=\"line\">/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Wireshark.app/Contents/MacOS:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure><br>执行某个命令的时候，系统会依次从上面输出的6个目录中，查找可执行命令的程序。如果找不到就会报错。</p>\n<p>用户添加自己的命令到系统环境变量中只需要使用如下命令，将可执行文件目录添加到原有的系统环境变量PATH后面。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> PATH=<span class=\"variable\">$PATH</span>:/home/xxx/scripts/bin</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"可持续使用的自定义系统环境变量\"><a href=\"#可持续使用的自定义系统环境变量\" class=\"headerlink\" title=\"可持续使用的自定义系统环境变量\"></a>可持续使用的自定义系统环境变量</h4><p>自定义变量的方法可以按照前面说的定义用户局部系统变量、或者用export导出为全局系统变量。<br>但是，这种方式创建的变量是临时的，当前shell进程结束之后就会失效。</p>\n<p>要想永久的保存自定义变量，可以根据shell的启动过程，修改其启动时需要读取命令的文件。<br>如下面几个文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/profile # 系统默认的bash shell主启动文件，系统上每个用户登录都会执行此文件</span><br><span class=\"line\">~/.bash_profile</span><br><span class=\"line\">~/.bashrc</span><br><span class=\"line\">~/.bash_login</span><br><span class=\"line\">~/.profile</span><br></pre></td></tr></table></figure>\n<p>shell会按照下列顺序，运行第一个被找到的问题件，找到之后则忽略后面的</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.bash_profile</span><br><span class=\"line\">~/.bash_login</span><br><span class=\"line\">~/.profile</span><br></pre></td></tr></table></figure>\n<p>注意：这个列表中没有~/.bashrc文件，这是因为该文件往往是在其它文件(如：.profile，也可能是.bash_profile)中被执行的。</p>\n<h4 id=\"交互式shell进程\"><a href=\"#交互式shell进程\" class=\"headerlink\" title=\"交互式shell进程\"></a>交互式shell进程</h4><p>如果你的bash shell不是登录系统时启动的，那么你启动的shell叫做交互式shell。<br>交互式shell不会像登录shell一样运行，但它依然提供了命令行提示符来输入命令。<br>通俗来说，就是在终端，shell等待用户输入，然后执行用户输入的命令。</p>\n<h4 id=\"非交互式shell\"><a href=\"#非交互式shell\" class=\"headerlink\" title=\"非交互式shell\"></a>非交互式shell</h4><p>系统执行shell脚本时用的就是非交互式shell。不同于交互式shell的地方在于它没有命令行提示符。<br>这种模式下，shell不会与用户进行交互，执行完shell script脚本 shell也就终止了。</p>\n<p><strong>交互式shell和非交互式shell的区别在于：</strong><br>如果bash是作为交互式shell启动的，它就不会访问/etc/profile文件，只会检查用户HOME目录中的.bashrc文件。<br>非交互式shell，当启动进程时，它会检查这个BASH_SHELL环境变量，读取的是环境变量所指定的配置文件。<br>（BASH_SHELL这个环境变量默认情况下并未设置）</p>\n<h4 id=\"login-bash\"><a href=\"#login-bash\" class=\"headerlink\" title=\"login bash\"></a>login bash</h4><p>登录shell可以让用户与计算机交流</p>\n<h4 id=\"no-login-bash\"><a href=\"#no-login-bash\" class=\"headerlink\" title=\"no login bash\"></a>no login bash</h4><p>非登录shell不可用让用户与计算机交流。<br>比如用linux服务器搭建一个ftl服务器，并且创建了很多用户，那么可以将这些用户设置为nologin shell。<br>这样，这些用户仅仅可以使用ftl服务，不能用来登录Linux主机，保证了安全性。</p>\n<p>关于用户的默认登录shell是在 /etc/passwd 文件中记录的。此文件中每一行就是一个用户，每行以冒号分割字段，其中最后一个字段表示的是用户默认登录使用的shell。</p>\n<h4 id=\"环境变量持久保存两个方法。\"><a href=\"#环境变量持久保存两个方法。\" class=\"headerlink\" title=\"环境变量持久保存两个方法。\"></a>环境变量持久保存两个方法。</h4><p>1.将个人环境变量设置放在/etc/profile.d目录中，创建一个.sh结尾的文件，将所有新的或者修改过的全局环境变量设置放在这个文件中。<br>2.放在~/.bashrc文件中。</p>\n<h4 id=\"数组变量\"><a href=\"#数组变量\" class=\"headerlink\" title=\"数组变量\"></a>数组变量</h4><p>环境变量可作为数组使用。<br>数组是能够存储多个值的变量。<br>这些值可以单独引用，也可以作为整个数组来引用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> somekey=(one two three four five)</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$somekey</span></span></span><br><span class=\"line\">one two three four five</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;somekey[2]&#125;</span></span></span><br><span class=\"line\">three # 这里有问题，mac上输出的是‘two’ ！！！，linux虚拟机上输出是‘three’！！！</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;somekey[*]&#125;</span> <span class=\"comment\"># 输出全部，mac上可以不用&#123;&#125;，用此属性需谨慎。</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"附录-默认环境变量\"><a href=\"#附录-默认环境变量\" class=\"headerlink\" title=\"附录 - 默认环境变量\"></a>附录 - 默认环境变量</h3><h5 id=\"bash-shell-支持的Bourne变量\"><a href=\"#bash-shell-支持的Bourne变量\" class=\"headerlink\" title=\"bash shell 支持的Bourne变量\"></a>bash shell 支持的Bourne变量</h5><table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CDPATH</td>\n<td>冒号分隔的目录列表，作为cd命令的搜索</td>\n</tr>\n<tr>\n<td>HOME</td>\n<td>当前用户的主目录</td>\n</tr>\n<tr>\n<td>IFS</td>\n<td>sell用来将文本字符串分割成字段的一系列字符</td>\n</tr>\n<tr>\n<td>MAIL</td>\n<td>当前用户收件箱的文件名(bash shell会检查这个文件，看看有没有新的邮件）</td>\n</tr>\n<tr>\n<td>MAILPATH</td>\n<td>冒号分隔的当前用户收件箱的文件名列表(bash shell会检查列表中的每个文件，看看有没有新邮件）</td>\n</tr>\n<tr>\n<td>OPTARG</td>\n<td>getopts命令处理的最后一个选项参数值</td>\n</tr>\n<tr>\n<td>OPTIND</td>\n<td>getopts命令处理的最后一个选项参数的索引号</td>\n</tr>\n<tr>\n<td>PATH</td>\n<td>shell查找命令的目录列表，由冒号分隔</td>\n</tr>\n<tr>\n<td>PS1</td>\n<td>shell命令行界面的主提示符</td>\n</tr>\n<tr>\n<td>PS2</td>\n<td>sell命令行界面的次提示符</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"bash-shell环境变量\"><a href=\"#bash-shell环境变量\" class=\"headerlink\" title=\"bash shell环境变量\"></a>bash shell环境变量</h5><p>除了默认的Bourme的环境变量，bash shell还提供一此 自有的变量</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BASH</td>\n<td>当前shel实例的全路径名</td>\n</tr>\n<tr>\n<td>BASH_ALIASES</td>\n<td>含有当前已设置别名的关联数组</td>\n</tr>\n<tr>\n<td>BASH_ARGC</td>\n<td>含有传入子函数或shel脚本的参数总数的数组变量 </td>\n</tr>\n<tr>\n<td>BASH_ARCV</td>\n<td>含有传入子函数或shell脚本的参数的数组变量 </td>\n</tr>\n<tr>\n<td>BASH_CMDS</td>\n<td>关联数组，包含shell执行过的命令的所在位置 </td>\n</tr>\n<tr>\n<td>BASH_COMMAND</td>\n<td>shell正在执行的命令或马上就执行的命令 </td>\n</tr>\n<tr>\n<td>BASH_ENV</td>\n<td>设置了的话，每个bash脚本会在运行前先尝试运行该变量定义的启动文件 </td>\n</tr>\n<tr>\n<td>BASH_EXECUTION_STRING</td>\n<td>使用bash -c选项传递过来的命令 </td>\n</tr>\n<tr>\n<td>BASH_LINENO</td>\n<td>含有当前执行的shell函数的源代码行号的数组变量 </td>\n</tr>\n<tr>\n<td>BASH_REMATCH</td>\n<td>只读数组，在使用正则表达式的比较运算符=~进行肯定匹配(positive match)时， 包含了匹配到的模式和子模式 </td>\n</tr>\n<tr>\n<td>BASH_SOURCE</td>\n<td>含有当前正在执行的hel函数所在源文件名的数组变量 </td>\n</tr>\n<tr>\n<td>BASH_SUBSHELL</td>\n<td>当前子shell环境的嵌套级别(初始值是0) </td>\n</tr>\n<tr>\n<td>BASH_VERSINFO</td>\n<td>含有当前运行的bash shell的主版本号和次版本号的数组变量 </td>\n</tr>\n<tr>\n<td>BASH_VERSION</td>\n<td>当前运行的bash shell的版本号 </td>\n</tr>\n<tr>\n<td>BASH_XTRACEFD</td>\n<td>若设置成了有效的文件描述符(0,1,2)则’set -x’ 调试选项生成的跟踪输出可被重定向。通常用来将跟踪输出到一个文件中 </td>\n</tr>\n<tr>\n<td>BASHOPTS</td>\n<td>当前启用的bash shell选项的列表 </td>\n</tr>\n<tr>\n<td>BASHPID</td>\n<td>当前bash进程的PID </td>\n</tr>\n<tr>\n<td>COLUMNS</td>\n<td>当前bash shell实例所用终端的宽度 </td>\n</tr>\n<tr>\n<td>COMP_CWORD</td>\n<td>COMP_WORDS变量的索引值，后者含有当前光标的位置 </td>\n</tr>\n<tr>\n<td>COMP_LINE</td>\n<td>当前命令行 </td>\n</tr>\n<tr>\n<td>COMP_POINT</td>\n<td>当前光标位置相对于当前命令起始的索引 </td>\n</tr>\n<tr>\n<td>COMP_KEY</td>\n<td>用来调用shell函数补全功能的最后一个键 </td>\n</tr>\n<tr>\n<td>COMP_TYPE</td>\n<td>一个整数值，表示所尝试的补全类型，用以完成shell函数补全 </td>\n</tr>\n<tr>\n<td>COMP_WORDBREAKS</td>\n<td>Readline库中用于单词补全的词分隔字符 </td>\n</tr>\n<tr>\n<td>COMP_WORDS</td>\n<td>含有当前命令行所有单词的数组变量 </td>\n</tr>\n<tr>\n<td>COMPREPLY</td>\n<td>含有由shell函数生成的可能填充代码的数组变量 </td>\n</tr>\n<tr>\n<td>COPROC</td>\n<td>占用未命名的协进程的I/O文件描述符的数组变量 </td>\n</tr>\n<tr>\n<td>DIRSTACK</td>\n<td>含有目录栈当前内容的数组变量 </td>\n</tr>\n<tr>\n<td>EMACS</td>\n<td>设置为’t’ 时，表明emacs shell缓冲区正在工作，而行编辑功能被禁止 </td>\n</tr>\n<tr>\n<td>ENV</td>\n<td>如果设置了该环境变量，在bash shell脚本运行之前会先执行已定义的启动文件(仅用于当bash shell以IPOSIX模式被调用时) </td>\n</tr>\n<tr>\n<td>EUID</td>\n<td>当前用户的有效用户ID (数字形式) </td>\n</tr>\n<tr>\n<td>FCEDIT</td>\n<td>供fc命令使用的默认编辑器 </td>\n</tr>\n<tr>\n<td>FIGNORE</td>\n<td>在进行文件名补全时可以忽略后缀名列表，由冒号分隔 </td>\n</tr>\n<tr>\n<td>FUNCNAME</td>\n<td>当前执行的shell函数的名称</td>\n</tr>\n</tbody>\n</table>\n<p><strong>续</strong></p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FUNCNEST</td>\n<td>当设置成非零值时，表示所允许的最大函数嵌套级数(一旦超出，当前命令即被终止）</td>\n</tr>\n<tr>\n<td>GLOBIGNORE</td>\n<td>冒号分隔的模式列表，定义了在进行文件名扩展时可以忽略的一组文件名</td>\n</tr>\n<tr>\n<td>GROUPS</td>\n<td>含有当前用户属组列表的数组变量</td>\n</tr>\n<tr>\n<td>histchars</td>\n<td>控制历史记录扩展，最多可有3个字符</td>\n</tr>\n<tr>\n<td>HISTCMD</td>\n<td>当前命令在历史记录中的编号</td>\n</tr>\n<tr>\n<td>HISICONTROL</td>\n<td>控制哪些命令留在历史记录列表中</td>\n</tr>\n<tr>\n<td>HISTFILE</td>\n<td>保存shell历史记录列表的文件名(默认是bash history)</td>\n</tr>\n<tr>\n<td>hISTFILESIZe</td>\n<td>最多在历史文件中存多少行</td>\n</tr>\n<tr>\n<td>HISTTIMEFORMAT</td>\n<td>如果设置了且非空，就用作格式化字符串，以显示bash历史中每条命令的时间戳</td>\n</tr>\n<tr>\n<td>HISTIGNORE</td>\n<td>由冒号分隔的模式列表，用来决定历史文件中哪些命令会被忽略</td>\n</tr>\n<tr>\n<td>HISTSIZE</td>\n<td>最多在历史文件中存多少条命令</td>\n</tr>\n<tr>\n<td>HOSTFILE</td>\n<td>shell在补全主机名时读取的文件名称</td>\n</tr>\n<tr>\n<td>HOSTNAME</td>\n<td>当前主机的名称</td>\n</tr>\n<tr>\n<td>HOSTTYPE</td>\n<td>当前运行bash shell的机器</td>\n</tr>\n<tr>\n<td>IGNOREEOF</td>\n<td>sell在退出前必须收到连续的BOF字符的数量(如果这个值不存在，默认是1)</td>\n</tr>\n<tr>\n<td>INPUTRC</td>\n<td>Readline 初始化文件名(默认是.inputrc)</td>\n</tr>\n<tr>\n<td>LANG</td>\n<td>shell的语言环境类别</td>\n</tr>\n<tr>\n<td>LC_ALL</td>\n<td>定义了一个语言环境类别，能够覆盖LANG变量</td>\n</tr>\n<tr>\n<td>LC_COLLATE</td>\n<td>设置对字符串排序时用的排序规则</td>\n</tr>\n<tr>\n<td>LC_CTYPE</td>\n<td>决定如何解释出现在文件名扩展和模式匹配中的字符</td>\n</tr>\n<tr>\n<td>LC_MESSAGES</td>\n<td>在解释前面带有S的双引号字符串时，该环境变量决定了所采用的语言环境设置</td>\n</tr>\n<tr>\n<td>LC_NUMERIC</td>\n<td>决定着格式化数字时采用的语言环境设置</td>\n</tr>\n<tr>\n<td>LINENO</td>\n<td>当前执行的脚本的行号</td>\n</tr>\n<tr>\n<td>LINES</td>\n<td>定义了终端上可见的行数</td>\n</tr>\n<tr>\n<td>MACHTYPE</td>\n<td>用“CPU-公司-系统”(CPU-company-system) 格式定义的系统类利</td>\n</tr>\n<tr>\n<td>MAPFILE</td>\n<td>一个数组变量， 当mapfile命令未指定数组变量作为参数时，它存储了了mapfile所读入的文本</td>\n</tr>\n<tr>\n<td>MAILCHECK</td>\n<td>shell查看新邮件的频率(以秒为单位，默认值是60)</td>\n</tr>\n<tr>\n<td>OLDPWD</td>\n<td>shell之前的工作目录</td>\n</tr>\n<tr>\n<td>OPTERR</td>\n<td>设置为1时，bash sell会显示getopts命令产生的错误</td>\n</tr>\n<tr>\n<td>OSTYPE</td>\n<td>定义shell所在的操作系统</td>\n</tr>\n<tr>\n<td>PIPESTATUS</td>\n<td>含有前台进程的退出状态列表的数组变量</td>\n</tr>\n<tr>\n<td>POSIXLY_CORRECT</td>\n<td>设置了的话，bas会以POSsx模式启动</td>\n</tr>\n<tr>\n<td>PPID</td>\n<td>bash sell父进程的PID</td>\n</tr>\n<tr>\n<td>PROMPT_COMMAND</td>\n<td>设置了的话，在命令行主提示符显示之前会执行这条命令</td>\n</tr>\n<tr>\n<td>PROMPT_DIRTRIM</td>\n<td>用来定义当启用了\\w或\\W提示符字符串转义时显示的尾部目录名的数量。被删除的目录名会用一组英文句点替换</td>\n</tr>\n<tr>\n<td>PS3</td>\n<td>select命令的提示符</td>\n</tr>\n<tr>\n<td>PS4</td>\n<td>如果使用了bash的一x选项，在命令行之前显示的提示信息</td>\n</tr>\n<tr>\n<td>PWD</td>\n<td>当前工作目录</td>\n</tr>\n<tr>\n<td>RANDOM</td>\n<td>返回一个0~ 32767的随机数(对其的赋值可作为随机数生成器的种子)</td>\n</tr>\n<tr>\n<td>READLINE_LINE</td>\n<td>当使用bind -x命令时，存储Readline缓冲区的内容</td>\n</tr>\n<tr>\n<td>READLINE_POINT</td>\n<td>当使用bind -x命 令时，表示Readine缓冲区内容插人点的当前位置</td>\n</tr>\n<tr>\n<td>REPLY</td>\n<td>read命令的默认变量</td>\n</tr>\n<tr>\n<td>SECONDS</td>\n<td>自从shell启动到现在的秒数(对其赋值将会重置计数器)</td>\n</tr>\n<tr>\n<td>SHELL</td>\n<td>bash shell的全路径名</td>\n</tr>\n<tr>\n<td>SHELLOPTS</td>\n<td>已启用bash shell选项列表，列表项之间以冒号分隔</td>\n</tr>\n<tr>\n<td>SHLVL</td>\n<td>shell的层级;每次启动一个新bash shell,该值增加1</td>\n</tr>\n<tr>\n<td>TIMEFORMAT</td>\n<td>指定了shell的时间显示格式</td>\n</tr>\n<tr>\n<td>TMOUT</td>\n<td>select和read命令在没输人的情况下等待多久(以秒为单位)。默认值为0，表示无限长</td>\n</tr>\n<tr>\n<td>TMPDIR</td>\n<td>目录名，保存bash shell创建的临时文件</td>\n</tr>\n<tr>\n<td>UID</td>\n<td>当前用户的真实用户ID (数字形式)</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"实时通信与socket","date":"2021-01-05T16:00:00.000Z","_content":"\n在很久之前浏览器要实现一个与服务端的实时双端通信（比如聊天系统）只能通过http轮询来做\n当然，除此之外也有利用了flash实现一个socket来作为中转的方式。\n\n后来随着web应用的越发成熟，html5推出了webSocket协议，webSocket协议的出现大大的提高了浏览器与服务端实时通信的效率与性能。\n随着浏览器设备的不断更新升级，webSocket的逐渐成为了实时通信的主流方式\n\n#### 那么webSocket的优势在哪里呢？\n首先，跟flash相比，不需要再加载一个flash，少了一个中间中转环节；其次，flash本身在浏览器端就存在很多比如安全、性能等问题，当下flash已经退出了浏览器客户端的舞台了。\n至于对比http轮询方式，简单来说就是少去了三次握手和四次挥手的过程，也省掉了相对冗余的http头信息，极大的减少了通讯时间和节省了带宽资源。\n\n#### 基础知识\nTCP协议对应于传输层，而HTTP协议对应于应用层，Http协议是建立在TCP协议基础之上的，是一个超文本传输协议。\n当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。 Http会通过TCP建立起一个到服务器的连接通道，当本次请求的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。要想通过http建立实时通信，必须每隔一段时间发起一个请求询问服务器一次。\n当然http也可以开启长链接，增长tcp断开的时间，一定程度上减少http建立连接的耗时。但是http冗余的请求头数据还是无法得到解决。\n\nSocket 就像一个电话插座，负责连通两端的电话，进行点对点通信，让电话可以进行通信，端口就像插座上的孔，端口不能同时被其他进程占用。 \n而我们建立连接就像把插头插在这个插座上，创建一个Socket 实例开始监听后，这个电话插座就时刻监听着消息的传入，谁拨通我这个“IP 地址和端口”，我就接通谁。\nSocket 起源于 UNIX，在 UNIX 一切皆文件的思想下，进程间通信就被冠名为文件描述符（file descriptor），Socket 是一种“打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个“文件”，在建立连接打开后，可以向文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。\n\n服务端代码只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力很弱，而实际中服务器都需要有并发处理能力，为了达到并发处理，服务器就需要 fork 一个新的进程或者线程去处理请求。\n#### http2.0通讯方式\n好在，前面说的http都是说的http2.0以前的http，随着http2.0标准的普及，越来越多的浏览器都支持了此标准。\nhttp2.0的特点是支持多路复用、压缩请求头、采用二进制传输数据。\n因此理论上来说使用http2.0协议来建立长连接，也是一种替代websocket的手段。\n\n#### http2.0轮询与webSocket的比较\n```html\n安全与解密：\n1）WebSocket 支持明文通信 ws:// 和加密 wss://\n2）而 HTTP/2 协议虽然没有规定必须加密，但是主流浏览器都只支持 HTTP/2 over TLS.\n\n消息推送：\n1）WebSocket是全双工通道，可以双向通信。消息直接推送给 Web App。\n2）HTTP/2 虽然也支持 Server Push，但是服务器只能主动将资源推送到客户端缓存,并不允许将数据推送到客户端里跑的 Web App 本身\n服务器推送只能由浏览器处理，不会在应用程序代码中弹出服务器数据，这意味着应用程序没有 API 来获取这些事件的通知。为了接近实时地将数据推送给 Web App， HTTP/2 可以结合 SSE（Server-Sent Event）使用。这是一种新提出的 API，用于从服务端单向将数据推送给 Web App.\n3）WebSocket 在需要接近实时双向通信的领域，很有用武之地。而 HTTP/2 + SSE 适合用于展示实时数据，另外在客户端非浏览器的情况下，使用不加密的 HTTP/2 也是可能的。\n```\n\n#### websocket与Socket\ntcp/ip协议是一个协议栈，必须要具体实现以及对外提供操作接口，tcp/ip对外提供的操作接口就是 socket\nsocket跟tcp/ip并没有必然的联系，socket被设计的时候就希望能够适应其它网络协议，所以socket编程接口的出现只是可以更方便的的使用tcp/ip协议栈。\n其对tcp/ip进行抽象，形成了几个基本的函数接口：create、listen、accept、connect、read、write等\n不同语言都对应的建立了socket服务和客服端服务库。\nnodejs可以通过net模块。\n```javascript\nconst net = require(‘net’)\nconst server = net.createServer()\nserver.on('connection', client => {\n  client.write(‘Hi \\n’)\n  client.end(‘Bye\\n’)\n})\nserver.listen(9000)\n```\n```html\ncurl http://127.0.0.1:9000\nHi\nBye!\n```\n与socket连接的不一定只有浏览器，也可能是其它服务器或者其他客户端，比如可以用另一个Nodejs应用来做client端来进行连接。\n```javascript\n// client\nconst net = require('net')\nconst server = net.createServer()\nserver.on('connection', client => {\n  client.write(‘Hi \\n’)\n  client.end(‘Bye\\n’)\n})\n// Hi\n// Bye\n```\n\n当然，实际使用过程并不会如此简单，至少得在服务端维护一个连接池，专门用来管理连接\n而客户端也需要有相应的容错机制，比如重连和心跳等。\n```html\n长连接：连接 -> 数据传输 -> 心跳 -> 数据传输 -> 心跳 -> … -> 关闭连接\n```\n\n与socket名称相似的webSocket，其实两个并不是同一个东西。\nsocket本身并不是一个协议，它工作在OSI模型会话层，是一个套接字，是tcp/ip网络的api，是为了方便大家直接使用底层协议而存在的一个抽象层，是传输控制层协议。\n而WebSocket 却是应用层协议，是一个html5的协议（当然并不是说只能用在html5，其它客户端也可以按照此标准实现自己的），是一个典型的应用层协议。websocket和http一样都是建立在tcp之上的，通过tcp传输数据\n```html\nwebsocket属性：Socket.readyState、Socket.bufferedAmount\n0 - 表示连接尚未建立\n1 - 表示连接已建立，可以进行通信\n2 - 表示连接正在进行关闭\n3 - 表示连接已经关闭或者连接不能打开\nwebsocket事件：open、message、error、close、\nwebsocket方法：send、close\n```\n\n### 传送门\nhttps://zhuanlan.zhihu.com/p/51279572\nhttps://baibingqianlan.github.io/2019/07/04/websocket%E4%B8%8Ehttp%E8%BD%AE%E8%AF%A2.html\nSSE\nhttps://www.ruanyifeng.com/blog/2017/05/server-sent_events.html\n[socket通信原理](https://segmentfault.com/a/1190000013712747)\n","source":"_posts/long-connect.md","raw":"---\ntitle: 实时通信与socket\ndate: 2021/01/06\ntag: [长连接]\ncategory: 技术\n---\n\n在很久之前浏览器要实现一个与服务端的实时双端通信（比如聊天系统）只能通过http轮询来做\n当然，除此之外也有利用了flash实现一个socket来作为中转的方式。\n\n后来随着web应用的越发成熟，html5推出了webSocket协议，webSocket协议的出现大大的提高了浏览器与服务端实时通信的效率与性能。\n随着浏览器设备的不断更新升级，webSocket的逐渐成为了实时通信的主流方式\n\n#### 那么webSocket的优势在哪里呢？\n首先，跟flash相比，不需要再加载一个flash，少了一个中间中转环节；其次，flash本身在浏览器端就存在很多比如安全、性能等问题，当下flash已经退出了浏览器客户端的舞台了。\n至于对比http轮询方式，简单来说就是少去了三次握手和四次挥手的过程，也省掉了相对冗余的http头信息，极大的减少了通讯时间和节省了带宽资源。\n\n#### 基础知识\nTCP协议对应于传输层，而HTTP协议对应于应用层，Http协议是建立在TCP协议基础之上的，是一个超文本传输协议。\n当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。 Http会通过TCP建立起一个到服务器的连接通道，当本次请求的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。要想通过http建立实时通信，必须每隔一段时间发起一个请求询问服务器一次。\n当然http也可以开启长链接，增长tcp断开的时间，一定程度上减少http建立连接的耗时。但是http冗余的请求头数据还是无法得到解决。\n\nSocket 就像一个电话插座，负责连通两端的电话，进行点对点通信，让电话可以进行通信，端口就像插座上的孔，端口不能同时被其他进程占用。 \n而我们建立连接就像把插头插在这个插座上，创建一个Socket 实例开始监听后，这个电话插座就时刻监听着消息的传入，谁拨通我这个“IP 地址和端口”，我就接通谁。\nSocket 起源于 UNIX，在 UNIX 一切皆文件的思想下，进程间通信就被冠名为文件描述符（file descriptor），Socket 是一种“打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个“文件”，在建立连接打开后，可以向文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。\n\n服务端代码只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力很弱，而实际中服务器都需要有并发处理能力，为了达到并发处理，服务器就需要 fork 一个新的进程或者线程去处理请求。\n#### http2.0通讯方式\n好在，前面说的http都是说的http2.0以前的http，随着http2.0标准的普及，越来越多的浏览器都支持了此标准。\nhttp2.0的特点是支持多路复用、压缩请求头、采用二进制传输数据。\n因此理论上来说使用http2.0协议来建立长连接，也是一种替代websocket的手段。\n\n#### http2.0轮询与webSocket的比较\n```html\n安全与解密：\n1）WebSocket 支持明文通信 ws:// 和加密 wss://\n2）而 HTTP/2 协议虽然没有规定必须加密，但是主流浏览器都只支持 HTTP/2 over TLS.\n\n消息推送：\n1）WebSocket是全双工通道，可以双向通信。消息直接推送给 Web App。\n2）HTTP/2 虽然也支持 Server Push，但是服务器只能主动将资源推送到客户端缓存,并不允许将数据推送到客户端里跑的 Web App 本身\n服务器推送只能由浏览器处理，不会在应用程序代码中弹出服务器数据，这意味着应用程序没有 API 来获取这些事件的通知。为了接近实时地将数据推送给 Web App， HTTP/2 可以结合 SSE（Server-Sent Event）使用。这是一种新提出的 API，用于从服务端单向将数据推送给 Web App.\n3）WebSocket 在需要接近实时双向通信的领域，很有用武之地。而 HTTP/2 + SSE 适合用于展示实时数据，另外在客户端非浏览器的情况下，使用不加密的 HTTP/2 也是可能的。\n```\n\n#### websocket与Socket\ntcp/ip协议是一个协议栈，必须要具体实现以及对外提供操作接口，tcp/ip对外提供的操作接口就是 socket\nsocket跟tcp/ip并没有必然的联系，socket被设计的时候就希望能够适应其它网络协议，所以socket编程接口的出现只是可以更方便的的使用tcp/ip协议栈。\n其对tcp/ip进行抽象，形成了几个基本的函数接口：create、listen、accept、connect、read、write等\n不同语言都对应的建立了socket服务和客服端服务库。\nnodejs可以通过net模块。\n```javascript\nconst net = require(‘net’)\nconst server = net.createServer()\nserver.on('connection', client => {\n  client.write(‘Hi \\n’)\n  client.end(‘Bye\\n’)\n})\nserver.listen(9000)\n```\n```html\ncurl http://127.0.0.1:9000\nHi\nBye!\n```\n与socket连接的不一定只有浏览器，也可能是其它服务器或者其他客户端，比如可以用另一个Nodejs应用来做client端来进行连接。\n```javascript\n// client\nconst net = require('net')\nconst server = net.createServer()\nserver.on('connection', client => {\n  client.write(‘Hi \\n’)\n  client.end(‘Bye\\n’)\n})\n// Hi\n// Bye\n```\n\n当然，实际使用过程并不会如此简单，至少得在服务端维护一个连接池，专门用来管理连接\n而客户端也需要有相应的容错机制，比如重连和心跳等。\n```html\n长连接：连接 -> 数据传输 -> 心跳 -> 数据传输 -> 心跳 -> … -> 关闭连接\n```\n\n与socket名称相似的webSocket，其实两个并不是同一个东西。\nsocket本身并不是一个协议，它工作在OSI模型会话层，是一个套接字，是tcp/ip网络的api，是为了方便大家直接使用底层协议而存在的一个抽象层，是传输控制层协议。\n而WebSocket 却是应用层协议，是一个html5的协议（当然并不是说只能用在html5，其它客户端也可以按照此标准实现自己的），是一个典型的应用层协议。websocket和http一样都是建立在tcp之上的，通过tcp传输数据\n```html\nwebsocket属性：Socket.readyState、Socket.bufferedAmount\n0 - 表示连接尚未建立\n1 - 表示连接已建立，可以进行通信\n2 - 表示连接正在进行关闭\n3 - 表示连接已经关闭或者连接不能打开\nwebsocket事件：open、message、error、close、\nwebsocket方法：send、close\n```\n\n### 传送门\nhttps://zhuanlan.zhihu.com/p/51279572\nhttps://baibingqianlan.github.io/2019/07/04/websocket%E4%B8%8Ehttp%E8%BD%AE%E8%AF%A2.html\nSSE\nhttps://www.ruanyifeng.com/blog/2017/05/server-sent_events.html\n[socket通信原理](https://segmentfault.com/a/1190000013712747)\n","slug":"long-connect","published":1,"updated":"2021-03-30T01:32:00.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufq000wa0vz0e06bebp","content":"<p>在很久之前浏览器要实现一个与服务端的实时双端通信（比如聊天系统）只能通过http轮询来做<br>当然，除此之外也有利用了flash实现一个socket来作为中转的方式。</p>\n<p>后来随着web应用的越发成熟，html5推出了webSocket协议，webSocket协议的出现大大的提高了浏览器与服务端实时通信的效率与性能。<br>随着浏览器设备的不断更新升级，webSocket的逐渐成为了实时通信的主流方式</p>\n<h4 id=\"那么webSocket的优势在哪里呢？\"><a href=\"#那么webSocket的优势在哪里呢？\" class=\"headerlink\" title=\"那么webSocket的优势在哪里呢？\"></a>那么webSocket的优势在哪里呢？</h4><p>首先，跟flash相比，不需要再加载一个flash，少了一个中间中转环节；其次，flash本身在浏览器端就存在很多比如安全、性能等问题，当下flash已经退出了浏览器客户端的舞台了。<br>至于对比http轮询方式，简单来说就是少去了三次握手和四次挥手的过程，也省掉了相对冗余的http头信息，极大的减少了通讯时间和节省了带宽资源。</p>\n<h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><p>TCP协议对应于传输层，而HTTP协议对应于应用层，Http协议是建立在TCP协议基础之上的，是一个超文本传输协议。<br>当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。 Http会通过TCP建立起一个到服务器的连接通道，当本次请求的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。要想通过http建立实时通信，必须每隔一段时间发起一个请求询问服务器一次。<br>当然http也可以开启长链接，增长tcp断开的时间，一定程度上减少http建立连接的耗时。但是http冗余的请求头数据还是无法得到解决。</p>\n<p>Socket 就像一个电话插座，负责连通两端的电话，进行点对点通信，让电话可以进行通信，端口就像插座上的孔，端口不能同时被其他进程占用。<br>而我们建立连接就像把插头插在这个插座上，创建一个Socket 实例开始监听后，这个电话插座就时刻监听着消息的传入，谁拨通我这个“IP 地址和端口”，我就接通谁。<br>Socket 起源于 UNIX，在 UNIX 一切皆文件的思想下，进程间通信就被冠名为文件描述符（file descriptor），Socket 是一种“打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个“文件”，在建立连接打开后，可以向文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p>\n<p>服务端代码只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力很弱，而实际中服务器都需要有并发处理能力，为了达到并发处理，服务器就需要 fork 一个新的进程或者线程去处理请求。</p>\n<h4 id=\"http2-0通讯方式\"><a href=\"#http2-0通讯方式\" class=\"headerlink\" title=\"http2.0通讯方式\"></a>http2.0通讯方式</h4><p>好在，前面说的http都是说的http2.0以前的http，随着http2.0标准的普及，越来越多的浏览器都支持了此标准。<br>http2.0的特点是支持多路复用、压缩请求头、采用二进制传输数据。<br>因此理论上来说使用http2.0协议来建立长连接，也是一种替代websocket的手段。</p>\n<h4 id=\"http2-0轮询与webSocket的比较\"><a href=\"#http2-0轮询与webSocket的比较\" class=\"headerlink\" title=\"http2.0轮询与webSocket的比较\"></a>http2.0轮询与webSocket的比较</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安全与解密：</span><br><span class=\"line\">1）WebSocket 支持明文通信 ws:// 和加密 wss://</span><br><span class=\"line\">2）而 HTTP/2 协议虽然没有规定必须加密，但是主流浏览器都只支持 HTTP/2 over TLS.</span><br><span class=\"line\"></span><br><span class=\"line\">消息推送：</span><br><span class=\"line\">1）WebSocket是全双工通道，可以双向通信。消息直接推送给 Web App。</span><br><span class=\"line\">2）HTTP/2 虽然也支持 Server Push，但是服务器只能主动将资源推送到客户端缓存,并不允许将数据推送到客户端里跑的 Web App 本身</span><br><span class=\"line\">服务器推送只能由浏览器处理，不会在应用程序代码中弹出服务器数据，这意味着应用程序没有 API 来获取这些事件的通知。为了接近实时地将数据推送给 Web App， HTTP/2 可以结合 SSE（Server-Sent Event）使用。这是一种新提出的 API，用于从服务端单向将数据推送给 Web App.</span><br><span class=\"line\">3）WebSocket 在需要接近实时双向通信的领域，很有用武之地。而 HTTP/2 + SSE 适合用于展示实时数据，另外在客户端非浏览器的情况下，使用不加密的 HTTP/2 也是可能的。</span><br></pre></td></tr></table></figure>\n<h4 id=\"websocket与Socket\"><a href=\"#websocket与Socket\" class=\"headerlink\" title=\"websocket与Socket\"></a>websocket与Socket</h4><p>tcp/ip协议是一个协议栈，必须要具体实现以及对外提供操作接口，tcp/ip对外提供的操作接口就是 socket<br>socket跟tcp/ip并没有必然的联系，socket被设计的时候就希望能够适应其它网络协议，所以socket编程接口的出现只是可以更方便的的使用tcp/ip协议栈。<br>其对tcp/ip进行抽象，形成了几个基本的函数接口：create、listen、accept、connect、read、write等<br>不同语言都对应的建立了socket服务和客服端服务库。<br>nodejs可以通过net模块。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(‘net’)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer()</span><br><span class=\"line\">server.on(<span class=\"string\">&#x27;connection&#x27;</span>, <span class=\"function\"><span class=\"params\">client</span> =&gt;</span> &#123;</span><br><span class=\"line\">  client.write(‘Hi \\n’)</span><br><span class=\"line\">  client.end(‘Bye\\n’)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">server.listen(<span class=\"number\">9000</span>)</span><br></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://127.0.0.1:9000</span><br><span class=\"line\">Hi</span><br><span class=\"line\">Bye!</span><br></pre></td></tr></table></figure><br>与socket连接的不一定只有浏览器，也可能是其它服务器或者其他客户端，比如可以用另一个Nodejs应用来做client端来进行连接。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// client</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer()</span><br><span class=\"line\">server.on(<span class=\"string\">&#x27;connection&#x27;</span>, <span class=\"function\"><span class=\"params\">client</span> =&gt;</span> &#123;</span><br><span class=\"line\">  client.write(‘Hi \\n’)</span><br><span class=\"line\">  client.end(‘Bye\\n’)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// Hi</span></span><br><span class=\"line\"><span class=\"comment\">// Bye</span></span><br></pre></td></tr></table></figure></p>\n<p>当然，实际使用过程并不会如此简单，至少得在服务端维护一个连接池，专门用来管理连接<br>而客户端也需要有相应的容错机制，比如重连和心跳等。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">长连接：连接 -&gt; 数据传输 -&gt; 心跳 -&gt; 数据传输 -&gt; 心跳 -&gt; … -&gt; 关闭连接</span><br></pre></td></tr></table></figure></p>\n<p>与socket名称相似的webSocket，其实两个并不是同一个东西。<br>socket本身并不是一个协议，它工作在OSI模型会话层，是一个套接字，是tcp/ip网络的api，是为了方便大家直接使用底层协议而存在的一个抽象层，是传输控制层协议。<br>而WebSocket 却是应用层协议，是一个html5的协议（当然并不是说只能用在html5，其它客户端也可以按照此标准实现自己的），是一个典型的应用层协议。websocket和http一样都是建立在tcp之上的，通过tcp传输数据<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">websocket属性：Socket.readyState、Socket.bufferedAmount</span><br><span class=\"line\">0 - 表示连接尚未建立</span><br><span class=\"line\">1 - 表示连接已建立，可以进行通信</span><br><span class=\"line\">2 - 表示连接正在进行关闭</span><br><span class=\"line\">3 - 表示连接已经关闭或者连接不能打开</span><br><span class=\"line\">websocket事件：open、message、error、close、</span><br><span class=\"line\">websocket方法：send、close</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://zhuanlan.zhihu.com/p/51279572\">https://zhuanlan.zhihu.com/p/51279572</a><br><a href=\"https://baibingqianlan.github.io/2019/07/04/websocket%E4%B8%8Ehttp%E8%BD%AE%E8%AF%A2.html\">https://baibingqianlan.github.io/2019/07/04/websocket%E4%B8%8Ehttp%E8%BD%AE%E8%AF%A2.html</a><br>SSE<br><a href=\"https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html\">https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html</a><br><a href=\"https://segmentfault.com/a/1190000013712747\">socket通信原理</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在很久之前浏览器要实现一个与服务端的实时双端通信（比如聊天系统）只能通过http轮询来做<br>当然，除此之外也有利用了flash实现一个socket来作为中转的方式。</p>\n<p>后来随着web应用的越发成熟，html5推出了webSocket协议，webSocket协议的出现大大的提高了浏览器与服务端实时通信的效率与性能。<br>随着浏览器设备的不断更新升级，webSocket的逐渐成为了实时通信的主流方式</p>\n<h4 id=\"那么webSocket的优势在哪里呢？\"><a href=\"#那么webSocket的优势在哪里呢？\" class=\"headerlink\" title=\"那么webSocket的优势在哪里呢？\"></a>那么webSocket的优势在哪里呢？</h4><p>首先，跟flash相比，不需要再加载一个flash，少了一个中间中转环节；其次，flash本身在浏览器端就存在很多比如安全、性能等问题，当下flash已经退出了浏览器客户端的舞台了。<br>至于对比http轮询方式，简单来说就是少去了三次握手和四次挥手的过程，也省掉了相对冗余的http头信息，极大的减少了通讯时间和节省了带宽资源。</p>\n<h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><p>TCP协议对应于传输层，而HTTP协议对应于应用层，Http协议是建立在TCP协议基础之上的，是一个超文本传输协议。<br>当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。 Http会通过TCP建立起一个到服务器的连接通道，当本次请求的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。要想通过http建立实时通信，必须每隔一段时间发起一个请求询问服务器一次。<br>当然http也可以开启长链接，增长tcp断开的时间，一定程度上减少http建立连接的耗时。但是http冗余的请求头数据还是无法得到解决。</p>\n<p>Socket 就像一个电话插座，负责连通两端的电话，进行点对点通信，让电话可以进行通信，端口就像插座上的孔，端口不能同时被其他进程占用。<br>而我们建立连接就像把插头插在这个插座上，创建一个Socket 实例开始监听后，这个电话插座就时刻监听着消息的传入，谁拨通我这个“IP 地址和端口”，我就接通谁。<br>Socket 起源于 UNIX，在 UNIX 一切皆文件的思想下，进程间通信就被冠名为文件描述符（file descriptor），Socket 是一种“打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个“文件”，在建立连接打开后，可以向文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p>\n<p>服务端代码只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力很弱，而实际中服务器都需要有并发处理能力，为了达到并发处理，服务器就需要 fork 一个新的进程或者线程去处理请求。</p>\n<h4 id=\"http2-0通讯方式\"><a href=\"#http2-0通讯方式\" class=\"headerlink\" title=\"http2.0通讯方式\"></a>http2.0通讯方式</h4><p>好在，前面说的http都是说的http2.0以前的http，随着http2.0标准的普及，越来越多的浏览器都支持了此标准。<br>http2.0的特点是支持多路复用、压缩请求头、采用二进制传输数据。<br>因此理论上来说使用http2.0协议来建立长连接，也是一种替代websocket的手段。</p>\n<h4 id=\"http2-0轮询与webSocket的比较\"><a href=\"#http2-0轮询与webSocket的比较\" class=\"headerlink\" title=\"http2.0轮询与webSocket的比较\"></a>http2.0轮询与webSocket的比较</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安全与解密：</span><br><span class=\"line\">1）WebSocket 支持明文通信 ws:// 和加密 wss://</span><br><span class=\"line\">2）而 HTTP/2 协议虽然没有规定必须加密，但是主流浏览器都只支持 HTTP/2 over TLS.</span><br><span class=\"line\"></span><br><span class=\"line\">消息推送：</span><br><span class=\"line\">1）WebSocket是全双工通道，可以双向通信。消息直接推送给 Web App。</span><br><span class=\"line\">2）HTTP/2 虽然也支持 Server Push，但是服务器只能主动将资源推送到客户端缓存,并不允许将数据推送到客户端里跑的 Web App 本身</span><br><span class=\"line\">服务器推送只能由浏览器处理，不会在应用程序代码中弹出服务器数据，这意味着应用程序没有 API 来获取这些事件的通知。为了接近实时地将数据推送给 Web App， HTTP/2 可以结合 SSE（Server-Sent Event）使用。这是一种新提出的 API，用于从服务端单向将数据推送给 Web App.</span><br><span class=\"line\">3）WebSocket 在需要接近实时双向通信的领域，很有用武之地。而 HTTP/2 + SSE 适合用于展示实时数据，另外在客户端非浏览器的情况下，使用不加密的 HTTP/2 也是可能的。</span><br></pre></td></tr></table></figure>\n<h4 id=\"websocket与Socket\"><a href=\"#websocket与Socket\" class=\"headerlink\" title=\"websocket与Socket\"></a>websocket与Socket</h4><p>tcp/ip协议是一个协议栈，必须要具体实现以及对外提供操作接口，tcp/ip对外提供的操作接口就是 socket<br>socket跟tcp/ip并没有必然的联系，socket被设计的时候就希望能够适应其它网络协议，所以socket编程接口的出现只是可以更方便的的使用tcp/ip协议栈。<br>其对tcp/ip进行抽象，形成了几个基本的函数接口：create、listen、accept、connect、read、write等<br>不同语言都对应的建立了socket服务和客服端服务库。<br>nodejs可以通过net模块。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(‘net’)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer()</span><br><span class=\"line\">server.on(<span class=\"string\">&#x27;connection&#x27;</span>, <span class=\"function\"><span class=\"params\">client</span> =&gt;</span> &#123;</span><br><span class=\"line\">  client.write(‘Hi \\n’)</span><br><span class=\"line\">  client.end(‘Bye\\n’)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">server.listen(<span class=\"number\">9000</span>)</span><br></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://127.0.0.1:9000</span><br><span class=\"line\">Hi</span><br><span class=\"line\">Bye!</span><br></pre></td></tr></table></figure><br>与socket连接的不一定只有浏览器，也可能是其它服务器或者其他客户端，比如可以用另一个Nodejs应用来做client端来进行连接。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// client</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = net.createServer()</span><br><span class=\"line\">server.on(<span class=\"string\">&#x27;connection&#x27;</span>, <span class=\"function\"><span class=\"params\">client</span> =&gt;</span> &#123;</span><br><span class=\"line\">  client.write(‘Hi \\n’)</span><br><span class=\"line\">  client.end(‘Bye\\n’)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// Hi</span></span><br><span class=\"line\"><span class=\"comment\">// Bye</span></span><br></pre></td></tr></table></figure></p>\n<p>当然，实际使用过程并不会如此简单，至少得在服务端维护一个连接池，专门用来管理连接<br>而客户端也需要有相应的容错机制，比如重连和心跳等。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">长连接：连接 -&gt; 数据传输 -&gt; 心跳 -&gt; 数据传输 -&gt; 心跳 -&gt; … -&gt; 关闭连接</span><br></pre></td></tr></table></figure></p>\n<p>与socket名称相似的webSocket，其实两个并不是同一个东西。<br>socket本身并不是一个协议，它工作在OSI模型会话层，是一个套接字，是tcp/ip网络的api，是为了方便大家直接使用底层协议而存在的一个抽象层，是传输控制层协议。<br>而WebSocket 却是应用层协议，是一个html5的协议（当然并不是说只能用在html5，其它客户端也可以按照此标准实现自己的），是一个典型的应用层协议。websocket和http一样都是建立在tcp之上的，通过tcp传输数据<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">websocket属性：Socket.readyState、Socket.bufferedAmount</span><br><span class=\"line\">0 - 表示连接尚未建立</span><br><span class=\"line\">1 - 表示连接已建立，可以进行通信</span><br><span class=\"line\">2 - 表示连接正在进行关闭</span><br><span class=\"line\">3 - 表示连接已经关闭或者连接不能打开</span><br><span class=\"line\">websocket事件：open、message、error、close、</span><br><span class=\"line\">websocket方法：send、close</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://zhuanlan.zhihu.com/p/51279572\">https://zhuanlan.zhihu.com/p/51279572</a><br><a href=\"https://baibingqianlan.github.io/2019/07/04/websocket%E4%B8%8Ehttp%E8%BD%AE%E8%AF%A2.html\">https://baibingqianlan.github.io/2019/07/04/websocket%E4%B8%8Ehttp%E8%BD%AE%E8%AF%A2.html</a><br>SSE<br><a href=\"https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html\">https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html</a><br><a href=\"https://segmentfault.com/a/1190000013712747\">socket通信原理</a></p>\n"},{"title":"Mac终端入门","date":"2016-12-04T16:00:00.000Z","_content":"\nMac搭配的系统是基于Linux内核开发的，因此大部分Linux的命令都适用于Mac上\n对于我个人来说，作为一名Mac用户，一名特意买一本MacBook来开发（满足好奇心）来说，使用命令行操作是非常帅气的。\n同时，熟悉了使用命令操作一些功能能够极大的提高工作效率。\n因此为了提高开发效率，特意学习一下Mac的命令操作。\n下面是一些常用的Terminal操作。\n\n\n```\ncd —— 进入目录\n\nsudo —— 获取临时root权限\n\nfind ~iname xxx  —— 查找文件夹\n\nsudo shutdown -h now | sudo halt —— 关机\n\nsudo reboot | sudo shutdown -r now —— 重启\n\npasswd  —— 修改用户密码\n\nhistory —— 最近执行的命令以及编号\n\nenv —— 显示当前所有设置过的环境变量\n\nwho —— 当前登陆的所有用户\n\nwhoami —— 当前正在操作的用户名\n\n```\n\n### 登录远程机器：\n\n```\n\nssh xxx@ip -p 端口\n\n```\n\n### 操作文件\n\n```\n\nmkdir 文件名 —— 建立新目录\n\nrm -rf —— 删除文件夹\n\nrm —— 删除文件\n\npwd —— 显示当前文件夹路径\n\n```\n\n### Homebrew\n\n安装Homebrew\n\n```shell\nruby -e \"$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)\"\n```\n\n查找软件包\n```shell\nbrew search wget \n```\n\n安装软件包\n```shell\nbrew install wget\n```\n\n列出已安装的软件包\n```shell\nbrew list\n```\n\n删除软件包\n```shell\nbrew remove wget\n```\n\n查看软件包信息\n```shell\nbrew info wget\n```\n\n列出软件包依赖关系\n```shell\nbrew deps wget\n```\n\n更新软件包\n```shell\nbrew update\n```\n\n列出过时的软件包\n```shell\nbrew outdated\n```\n\n更新过时的软件包（全部或单个）\n```shell\nbrew upgrade \nbrew upgrade wget\n```\n\n### vim命令：\n\n```\n\ni —— 插入模式\n\nesc —— 退出\n\n:wq —— 保存并退出\n\n:q! —— 不保存退出\n\nu —— 撤销上一次操作\n\nctl+r 和u相反\n\n```\n\n### 一些快捷键\n\n```\n\ncommand + t —— 在终端新打开一个终端\n\ncommand + c —— 复制\n\ncommand + v —— 粘贴\n\ncommand + z —— 撤销\n\ncommand + 左（右） —— 移到行头（尾）\n\ncommand + shift + 左（右） —— 移到行头（尾）并选中\n\ncommand + r —— 刷新网页\n\nfn + 上（下） —— pageup(pagedown)\n\nfn + delete —— 向后删除\n\n```\n\n### 解压.gz文件\n\n```\ngunzip filename.gz\n\ngunzip -g filename.gz\n\n```\n\nor\n\n### 将 /tmp/etc.tar.gz 文件解压缩在 /usr/local/src 底下\n\n```\n\n[root@linux ~]# cd /usr/local/src\n\n[root@linux src]# tar -zxvf /tmp/etc.tar.gz\n\n```\n\n### mac查看物理cpu和逻辑cpu个数：\n\n```shell\nsysctl hw.physicalcpu: 2\nsysctl hw.logicalcpu: 4\n```\n\n\n### 安装redis教程传送门\n<a href=\"http://www.mamicode.com/info-detail-526405.html\" target=\"_blank\">http://www.mamicode.com/info-detail-526405.html</a>\n\n\n\n\n\n","source":"_posts/mac-terminal.md","raw":"---\ntitle: Mac终端入门\ntag: [mac,terminal]\ndate: 2016/12/05\ncategory: 技术\n---\n\nMac搭配的系统是基于Linux内核开发的，因此大部分Linux的命令都适用于Mac上\n对于我个人来说，作为一名Mac用户，一名特意买一本MacBook来开发（满足好奇心）来说，使用命令行操作是非常帅气的。\n同时，熟悉了使用命令操作一些功能能够极大的提高工作效率。\n因此为了提高开发效率，特意学习一下Mac的命令操作。\n下面是一些常用的Terminal操作。\n\n\n```\ncd —— 进入目录\n\nsudo —— 获取临时root权限\n\nfind ~iname xxx  —— 查找文件夹\n\nsudo shutdown -h now | sudo halt —— 关机\n\nsudo reboot | sudo shutdown -r now —— 重启\n\npasswd  —— 修改用户密码\n\nhistory —— 最近执行的命令以及编号\n\nenv —— 显示当前所有设置过的环境变量\n\nwho —— 当前登陆的所有用户\n\nwhoami —— 当前正在操作的用户名\n\n```\n\n### 登录远程机器：\n\n```\n\nssh xxx@ip -p 端口\n\n```\n\n### 操作文件\n\n```\n\nmkdir 文件名 —— 建立新目录\n\nrm -rf —— 删除文件夹\n\nrm —— 删除文件\n\npwd —— 显示当前文件夹路径\n\n```\n\n### Homebrew\n\n安装Homebrew\n\n```shell\nruby -e \"$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)\"\n```\n\n查找软件包\n```shell\nbrew search wget \n```\n\n安装软件包\n```shell\nbrew install wget\n```\n\n列出已安装的软件包\n```shell\nbrew list\n```\n\n删除软件包\n```shell\nbrew remove wget\n```\n\n查看软件包信息\n```shell\nbrew info wget\n```\n\n列出软件包依赖关系\n```shell\nbrew deps wget\n```\n\n更新软件包\n```shell\nbrew update\n```\n\n列出过时的软件包\n```shell\nbrew outdated\n```\n\n更新过时的软件包（全部或单个）\n```shell\nbrew upgrade \nbrew upgrade wget\n```\n\n### vim命令：\n\n```\n\ni —— 插入模式\n\nesc —— 退出\n\n:wq —— 保存并退出\n\n:q! —— 不保存退出\n\nu —— 撤销上一次操作\n\nctl+r 和u相反\n\n```\n\n### 一些快捷键\n\n```\n\ncommand + t —— 在终端新打开一个终端\n\ncommand + c —— 复制\n\ncommand + v —— 粘贴\n\ncommand + z —— 撤销\n\ncommand + 左（右） —— 移到行头（尾）\n\ncommand + shift + 左（右） —— 移到行头（尾）并选中\n\ncommand + r —— 刷新网页\n\nfn + 上（下） —— pageup(pagedown)\n\nfn + delete —— 向后删除\n\n```\n\n### 解压.gz文件\n\n```\ngunzip filename.gz\n\ngunzip -g filename.gz\n\n```\n\nor\n\n### 将 /tmp/etc.tar.gz 文件解压缩在 /usr/local/src 底下\n\n```\n\n[root@linux ~]# cd /usr/local/src\n\n[root@linux src]# tar -zxvf /tmp/etc.tar.gz\n\n```\n\n### mac查看物理cpu和逻辑cpu个数：\n\n```shell\nsysctl hw.physicalcpu: 2\nsysctl hw.logicalcpu: 4\n```\n\n\n### 安装redis教程传送门\n<a href=\"http://www.mamicode.com/info-detail-526405.html\" target=\"_blank\">http://www.mamicode.com/info-detail-526405.html</a>\n\n\n\n\n\n","slug":"mac-terminal","published":1,"updated":"2021-03-30T01:32:00.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufr000xa0vz58e983wf","content":"<p>Mac搭配的系统是基于Linux内核开发的，因此大部分Linux的命令都适用于Mac上<br>对于我个人来说，作为一名Mac用户，一名特意买一本MacBook来开发（满足好奇心）来说，使用命令行操作是非常帅气的。<br>同时，熟悉了使用命令操作一些功能能够极大的提高工作效率。<br>因此为了提高开发效率，特意学习一下Mac的命令操作。<br>下面是一些常用的Terminal操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd —— 进入目录</span><br><span class=\"line\"></span><br><span class=\"line\">sudo —— 获取临时root权限</span><br><span class=\"line\"></span><br><span class=\"line\">find ~iname xxx  —— 查找文件夹</span><br><span class=\"line\"></span><br><span class=\"line\">sudo shutdown -h now | sudo halt —— 关机</span><br><span class=\"line\"></span><br><span class=\"line\">sudo reboot | sudo shutdown -r now —— 重启</span><br><span class=\"line\"></span><br><span class=\"line\">passwd  —— 修改用户密码</span><br><span class=\"line\"></span><br><span class=\"line\">history —— 最近执行的命令以及编号</span><br><span class=\"line\"></span><br><span class=\"line\">env —— 显示当前所有设置过的环境变量</span><br><span class=\"line\"></span><br><span class=\"line\">who —— 当前登陆的所有用户</span><br><span class=\"line\"></span><br><span class=\"line\">whoami —— 当前正在操作的用户名</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"登录远程机器：\"><a href=\"#登录远程机器：\" class=\"headerlink\" title=\"登录远程机器：\"></a>登录远程机器：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ssh xxx@ip -p 端口</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"操作文件\"><a href=\"#操作文件\" class=\"headerlink\" title=\"操作文件\"></a>操作文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mkdir 文件名 —— 建立新目录</span><br><span class=\"line\"></span><br><span class=\"line\">rm -rf —— 删除文件夹</span><br><span class=\"line\"></span><br><span class=\"line\">rm —— 删除文件</span><br><span class=\"line\"></span><br><span class=\"line\">pwd —— 显示当前文件夹路径</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"Homebrew\"><a href=\"#Homebrew\" class=\"headerlink\" title=\"Homebrew\"></a>Homebrew</h3><p>安装Homebrew</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;</span><br></pre></td></tr></table></figure>\n<p>查找软件包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew search wget </span><br></pre></td></tr></table></figure></p>\n<p>安装软件包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install wget</span><br></pre></td></tr></table></figure></p>\n<p>列出已安装的软件包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew list</span><br></pre></td></tr></table></figure></p>\n<p>删除软件包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew remove wget</span><br></pre></td></tr></table></figure></p>\n<p>查看软件包信息<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew info wget</span><br></pre></td></tr></table></figure></p>\n<p>列出软件包依赖关系<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew deps wget</span><br></pre></td></tr></table></figure></p>\n<p>更新软件包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew update</span><br></pre></td></tr></table></figure></p>\n<p>列出过时的软件包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew outdated</span><br></pre></td></tr></table></figure></p>\n<p>更新过时的软件包（全部或单个）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew upgrade </span><br><span class=\"line\">brew upgrade wget</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"vim命令：\"><a href=\"#vim命令：\" class=\"headerlink\" title=\"vim命令：\"></a>vim命令：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">i —— 插入模式</span><br><span class=\"line\"></span><br><span class=\"line\">esc —— 退出</span><br><span class=\"line\"></span><br><span class=\"line\">:wq —— 保存并退出</span><br><span class=\"line\"></span><br><span class=\"line\">:q! —— 不保存退出</span><br><span class=\"line\"></span><br><span class=\"line\">u —— 撤销上一次操作</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+r 和u相反</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"一些快捷键\"><a href=\"#一些快捷键\" class=\"headerlink\" title=\"一些快捷键\"></a>一些快捷键</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">command + t —— 在终端新打开一个终端</span><br><span class=\"line\"></span><br><span class=\"line\">command + c —— 复制</span><br><span class=\"line\"></span><br><span class=\"line\">command + v —— 粘贴</span><br><span class=\"line\"></span><br><span class=\"line\">command + z —— 撤销</span><br><span class=\"line\"></span><br><span class=\"line\">command + 左（右） —— 移到行头（尾）</span><br><span class=\"line\"></span><br><span class=\"line\">command + shift + 左（右） —— 移到行头（尾）并选中</span><br><span class=\"line\"></span><br><span class=\"line\">command + r —— 刷新网页</span><br><span class=\"line\"></span><br><span class=\"line\">fn + 上（下） —— pageup(pagedown)</span><br><span class=\"line\"></span><br><span class=\"line\">fn + delete —— 向后删除</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"解压-gz文件\"><a href=\"#解压-gz文件\" class=\"headerlink\" title=\"解压.gz文件\"></a>解压.gz文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gunzip filename.gz</span><br><span class=\"line\"></span><br><span class=\"line\">gunzip -g filename.gz</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>or</p>\n<h3 id=\"将-tmp-etc-tar-gz-文件解压缩在-usr-local-src-底下\"><a href=\"#将-tmp-etc-tar-gz-文件解压缩在-usr-local-src-底下\" class=\"headerlink\" title=\"将 /tmp/etc.tar.gz 文件解压缩在 /usr/local/src 底下\"></a>将 /tmp/etc.tar.gz 文件解压缩在 /usr/local/src 底下</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[root@linux ~]# cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class=\"line\"></span><br><span class=\"line\">[root@linux src]# tar -zxvf &#x2F;tmp&#x2F;etc.tar.gz</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"mac查看物理cpu和逻辑cpu个数：\"><a href=\"#mac查看物理cpu和逻辑cpu个数：\" class=\"headerlink\" title=\"mac查看物理cpu和逻辑cpu个数：\"></a>mac查看物理cpu和逻辑cpu个数：</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl hw.physicalcpu: 2</span><br><span class=\"line\">sysctl hw.logicalcpu: 4</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装redis教程传送门\"><a href=\"#安装redis教程传送门\" class=\"headerlink\" title=\"安装redis教程传送门\"></a>安装redis教程传送门</h3><p><a href=\"http://www.mamicode.com/info-detail-526405.html\" target=\"_blank\">http://www.mamicode.com/info-detail-526405.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Mac搭配的系统是基于Linux内核开发的，因此大部分Linux的命令都适用于Mac上<br>对于我个人来说，作为一名Mac用户，一名特意买一本MacBook来开发（满足好奇心）来说，使用命令行操作是非常帅气的。<br>同时，熟悉了使用命令操作一些功能能够极大的提高工作效率。<br>因此为了提高开发效率，特意学习一下Mac的命令操作。<br>下面是一些常用的Terminal操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd —— 进入目录</span><br><span class=\"line\"></span><br><span class=\"line\">sudo —— 获取临时root权限</span><br><span class=\"line\"></span><br><span class=\"line\">find ~iname xxx  —— 查找文件夹</span><br><span class=\"line\"></span><br><span class=\"line\">sudo shutdown -h now | sudo halt —— 关机</span><br><span class=\"line\"></span><br><span class=\"line\">sudo reboot | sudo shutdown -r now —— 重启</span><br><span class=\"line\"></span><br><span class=\"line\">passwd  —— 修改用户密码</span><br><span class=\"line\"></span><br><span class=\"line\">history —— 最近执行的命令以及编号</span><br><span class=\"line\"></span><br><span class=\"line\">env —— 显示当前所有设置过的环境变量</span><br><span class=\"line\"></span><br><span class=\"line\">who —— 当前登陆的所有用户</span><br><span class=\"line\"></span><br><span class=\"line\">whoami —— 当前正在操作的用户名</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"登录远程机器：\"><a href=\"#登录远程机器：\" class=\"headerlink\" title=\"登录远程机器：\"></a>登录远程机器：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ssh xxx@ip -p 端口</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"操作文件\"><a href=\"#操作文件\" class=\"headerlink\" title=\"操作文件\"></a>操作文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mkdir 文件名 —— 建立新目录</span><br><span class=\"line\"></span><br><span class=\"line\">rm -rf —— 删除文件夹</span><br><span class=\"line\"></span><br><span class=\"line\">rm —— 删除文件</span><br><span class=\"line\"></span><br><span class=\"line\">pwd —— 显示当前文件夹路径</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"Homebrew\"><a href=\"#Homebrew\" class=\"headerlink\" title=\"Homebrew\"></a>Homebrew</h3><p>安装Homebrew</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;</span><br></pre></td></tr></table></figure>\n<p>查找软件包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew search wget </span><br></pre></td></tr></table></figure></p>\n<p>安装软件包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install wget</span><br></pre></td></tr></table></figure></p>\n<p>列出已安装的软件包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew list</span><br></pre></td></tr></table></figure></p>\n<p>删除软件包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew remove wget</span><br></pre></td></tr></table></figure></p>\n<p>查看软件包信息<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew info wget</span><br></pre></td></tr></table></figure></p>\n<p>列出软件包依赖关系<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew deps wget</span><br></pre></td></tr></table></figure></p>\n<p>更新软件包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew update</span><br></pre></td></tr></table></figure></p>\n<p>列出过时的软件包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew outdated</span><br></pre></td></tr></table></figure></p>\n<p>更新过时的软件包（全部或单个）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew upgrade </span><br><span class=\"line\">brew upgrade wget</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"vim命令：\"><a href=\"#vim命令：\" class=\"headerlink\" title=\"vim命令：\"></a>vim命令：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">i —— 插入模式</span><br><span class=\"line\"></span><br><span class=\"line\">esc —— 退出</span><br><span class=\"line\"></span><br><span class=\"line\">:wq —— 保存并退出</span><br><span class=\"line\"></span><br><span class=\"line\">:q! —— 不保存退出</span><br><span class=\"line\"></span><br><span class=\"line\">u —— 撤销上一次操作</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+r 和u相反</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"一些快捷键\"><a href=\"#一些快捷键\" class=\"headerlink\" title=\"一些快捷键\"></a>一些快捷键</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">command + t —— 在终端新打开一个终端</span><br><span class=\"line\"></span><br><span class=\"line\">command + c —— 复制</span><br><span class=\"line\"></span><br><span class=\"line\">command + v —— 粘贴</span><br><span class=\"line\"></span><br><span class=\"line\">command + z —— 撤销</span><br><span class=\"line\"></span><br><span class=\"line\">command + 左（右） —— 移到行头（尾）</span><br><span class=\"line\"></span><br><span class=\"line\">command + shift + 左（右） —— 移到行头（尾）并选中</span><br><span class=\"line\"></span><br><span class=\"line\">command + r —— 刷新网页</span><br><span class=\"line\"></span><br><span class=\"line\">fn + 上（下） —— pageup(pagedown)</span><br><span class=\"line\"></span><br><span class=\"line\">fn + delete —— 向后删除</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"解压-gz文件\"><a href=\"#解压-gz文件\" class=\"headerlink\" title=\"解压.gz文件\"></a>解压.gz文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gunzip filename.gz</span><br><span class=\"line\"></span><br><span class=\"line\">gunzip -g filename.gz</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>or</p>\n<h3 id=\"将-tmp-etc-tar-gz-文件解压缩在-usr-local-src-底下\"><a href=\"#将-tmp-etc-tar-gz-文件解压缩在-usr-local-src-底下\" class=\"headerlink\" title=\"将 /tmp/etc.tar.gz 文件解压缩在 /usr/local/src 底下\"></a>将 /tmp/etc.tar.gz 文件解压缩在 /usr/local/src 底下</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[root@linux ~]# cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class=\"line\"></span><br><span class=\"line\">[root@linux src]# tar -zxvf &#x2F;tmp&#x2F;etc.tar.gz</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"mac查看物理cpu和逻辑cpu个数：\"><a href=\"#mac查看物理cpu和逻辑cpu个数：\" class=\"headerlink\" title=\"mac查看物理cpu和逻辑cpu个数：\"></a>mac查看物理cpu和逻辑cpu个数：</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl hw.physicalcpu: 2</span><br><span class=\"line\">sysctl hw.logicalcpu: 4</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装redis教程传送门\"><a href=\"#安装redis教程传送门\" class=\"headerlink\" title=\"安装redis教程传送门\"></a>安装redis教程传送门</h3><p><a href=\"http://www.mamicode.com/info-detail-526405.html\" target=\"_blank\">http://www.mamicode.com/info-detail-526405.html</a></p>\n"},{"title":"我所理解的微前端","date":"2021-01-08T16:00:00.000Z","_content":"\n当下业内的微前端字眼出现的频率比较高，于是大致了解了一下微前端\n主要内容包括：什么是微前端？微前端的好处和意义是什么？做微前端应该如何做？\n\n#### 什么是微前端\n说微前端之前首先得跟微服务区分开来\n***微服务***是一种以业务功能为主的服务设计概念，每一个服务都具有自主运行的业务功能，对外开放不受语言限制的API (最常用的是HTTP)，应用程序则是由一个或多个微服务组成。\n微服务是由以单一应用程序构成的小服务，自己拥有自己的行程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用HTTP API通信。同时服务会使用最小的规模的集中管理 (例如 Docker) 能力，服务可以用不同的编程语言与数据库等组件实现。 —— 维基百科\n\n而微前端，是针对前台的单页系统而定义的概念，每一个微前端的功能模块都具有自主运行的业务功能，对外提供url访问路径（可以是完整的URL，也可以是前端history/hash等路由），应用有一个或多个单页系统组成，可以独立部署，方便的插拔，又能够方便的实现独立模块间的通信。类似与微服务的不同语言的兼容性，微前端各个子应用也可以使用各自自己的语言，比如react、vue、angular等。\n现如今前端多框架齐头并进，而且谁也不能保证会不会过几个月就新增一个新的框架，因此，在不重写原有系统的基础上使用新技术开发新功能是十分必要的需求，而微前端的思想就能够很方便的让这一需求成为可能，这也是微服务的一个很重要的卖点。\n\n#### 微前端的好处和意义\n1.独立开发部署，聚合使用。\n有过一定前端开发经验的人都知道，一个健康发展，长期迭代更新维护的系统，一定是越做越大，功能越来越多的。\n而随着功能的增多，代码量增多，打包构建更耗时，模块依赖更复杂，模块崩溃连锁反应风险更大。因此，当到达某个临界点的时候，就会促使开发人员对应用进行拆分了。\n然而系统拆分确实能够解决问题，但是对于用户来说就变成了使用一个系统变成了使用多个系统了，即使我们做了授权登录或者跨子域登录，对于不同系统之前的切换也是很麻烦的，如果有的选择，用户肯定是希望一个系统就能把自己的事情做完。\n\n2.跨团队、跨技术开发\n一个复杂的系统往往需要很多人、甚至不同的团队一起来开发的，而这也就意味着需要跨越多个时间线、多个技术栈和多个团队的编码风格。\n这些差异点集成在一起往往就是风险的不断叠加和维护成本的不断上升。微前端的思想可以很好的处理这一类问题。\n\n\n3.微前端最佳的使用场景是一些B端的管理系统，既能兼容集成历史系统，也可以将新的系统集成进来，并且不影响原先的交互体验。\n整体的微前端不仅仅是只将系统集成进来，而是整个微前端体系的完善。\n```html\n基座应用和微应用的自动部署能力。\n微应用的配置管理能力。\n本地开发调试能力。\n线上监控和统计能力等。\n```\n只有将整个能力体系搭建完善，才能说是整个微前端体系流程的完善。\n当发现使用微前端反而使效率变低，简单的变更复杂那就说明微前端并不适用。\n\n#### 如何做微前端\n微前端的思想其实有点类似于 iframe，起一个框架，做一个导航，然后嵌入不同的页面。\n单纯根据对概念的理解，实现微前端的就是将应用进行拆解和整合，通常是一个父应用加上一些子应用，主应用管理各个子应用。\n采用iframe来将多个应用整合到一起等等这些其实都属于微前端的实现方案\n\n当然，如果仅仅是套一个iframe那也太low了。\n一个好的微前端方案主要需要解决三个问题：\n```html\n路由切换、路由分发问题。\n子应用之间、子应用与主微应用的隔离问题。\n子应用直接的通信问题。\n```\n\n1.路由分发\n作为一个SPA的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用iframe之外，要能先拉取到微应用的页面内容， 这就需要远程拉取机制。\n远程拉取机制通常会采用fetch API来首先获取到微应用的HTML内容，然后通过解析将微应用的 JavaScript 和 CSS 进行抽离，采用 eval 方法来运行JavaScript，并将CSS和HTML 内容 append 到基座应用中留给微应用的展示区域，当微应用切换走时，同步卸载这些内容，这就构成的当前应用的展示流程。\n当然这个流程里会涉及到 CSS 样式的污染以及 JavaScript 对全局对象的污染。\n\n2.微应用隔离\n当前处理微应用隔离， 应对 CSS 全局对象污染的方法\n```html\n可结合 Webpack等打包工具，使用 css Module或者命名空间的方式给每个子应用添加特定的前缀，每次应用加载时，<br>将该应用所有的 link 和 style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可\n\n使用Web Components（shadowDom）技术，Web Components能够填入隔离 CSS 作用域。\n```\n每当微应用的JavaScript被加载并运行时，它的核心实际上是对全局对象 Window 的修改以及一些全局事件的改变，例如jQuery这个js运行后，会在Window上挂载一个window.$对象，对于其他库React，Vue也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响\n当前处理 Javascript 全局对象污染的方法\n```html\n最普遍的做法是采用沙箱机制（SandBox）。\n沙箱机制的核心是让局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。\n通常在Node.js端可以采用vm模块，而对于浏览器，则需要结合 with 关键字和 window.Proxy 对象来实现浏览器端的沙箱。\n```\n\n3.微前端的消息通信\n消息订阅（pub/sub）模式的通信机制\n在基座应用中会定义事件中心Event，每个微应用分别来注册事件，当被触发事件时再有事件中心统一分发，这就构成了基本的通信机制\n如果使用的是 React或者 Vue等框架，可以结合Redux和Vuex来一起使用，实现应用之间的通信。\n\n### 传送门\n[微前端探索](https://github.com/fengshi123/blog/issues/21)，介绍了了什么是微前端，以及乾坤框架的一些简介。\n\n[qiankun框架](https://qiankun.umijs.org/zh/guide) 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。\n\n[微前端在美团外卖的实践](https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html)，美团在微前端的实践经验\n\n[微前端那些事](https://github.com/phodal/microfrontends)，微前端框架 Mooa \n\n[Web Components](http://www.ruanyifeng.com/blog/2019/08/web_components.html) 入门实例教程\n\n[with关键字](https://cloud.tencent.com/developer/article/1408030)\n\n[CSS Module简介](http://www.ruanyifeng.com/blog/2016/06/css_modules.html)（CSSmodule就是一个css模块化的一个方案）\n\n[微应用简介](https://juejin.cn/post/6844904162509979662)\n\n","source":"_posts/micro-front.md","raw":"---\ntitle: 我所理解的微前端\ndate: 2021/01/09\ntag: [微前端]\ncategory: 技术\n---\n\n当下业内的微前端字眼出现的频率比较高，于是大致了解了一下微前端\n主要内容包括：什么是微前端？微前端的好处和意义是什么？做微前端应该如何做？\n\n#### 什么是微前端\n说微前端之前首先得跟微服务区分开来\n***微服务***是一种以业务功能为主的服务设计概念，每一个服务都具有自主运行的业务功能，对外开放不受语言限制的API (最常用的是HTTP)，应用程序则是由一个或多个微服务组成。\n微服务是由以单一应用程序构成的小服务，自己拥有自己的行程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用HTTP API通信。同时服务会使用最小的规模的集中管理 (例如 Docker) 能力，服务可以用不同的编程语言与数据库等组件实现。 —— 维基百科\n\n而微前端，是针对前台的单页系统而定义的概念，每一个微前端的功能模块都具有自主运行的业务功能，对外提供url访问路径（可以是完整的URL，也可以是前端history/hash等路由），应用有一个或多个单页系统组成，可以独立部署，方便的插拔，又能够方便的实现独立模块间的通信。类似与微服务的不同语言的兼容性，微前端各个子应用也可以使用各自自己的语言，比如react、vue、angular等。\n现如今前端多框架齐头并进，而且谁也不能保证会不会过几个月就新增一个新的框架，因此，在不重写原有系统的基础上使用新技术开发新功能是十分必要的需求，而微前端的思想就能够很方便的让这一需求成为可能，这也是微服务的一个很重要的卖点。\n\n#### 微前端的好处和意义\n1.独立开发部署，聚合使用。\n有过一定前端开发经验的人都知道，一个健康发展，长期迭代更新维护的系统，一定是越做越大，功能越来越多的。\n而随着功能的增多，代码量增多，打包构建更耗时，模块依赖更复杂，模块崩溃连锁反应风险更大。因此，当到达某个临界点的时候，就会促使开发人员对应用进行拆分了。\n然而系统拆分确实能够解决问题，但是对于用户来说就变成了使用一个系统变成了使用多个系统了，即使我们做了授权登录或者跨子域登录，对于不同系统之前的切换也是很麻烦的，如果有的选择，用户肯定是希望一个系统就能把自己的事情做完。\n\n2.跨团队、跨技术开发\n一个复杂的系统往往需要很多人、甚至不同的团队一起来开发的，而这也就意味着需要跨越多个时间线、多个技术栈和多个团队的编码风格。\n这些差异点集成在一起往往就是风险的不断叠加和维护成本的不断上升。微前端的思想可以很好的处理这一类问题。\n\n\n3.微前端最佳的使用场景是一些B端的管理系统，既能兼容集成历史系统，也可以将新的系统集成进来，并且不影响原先的交互体验。\n整体的微前端不仅仅是只将系统集成进来，而是整个微前端体系的完善。\n```html\n基座应用和微应用的自动部署能力。\n微应用的配置管理能力。\n本地开发调试能力。\n线上监控和统计能力等。\n```\n只有将整个能力体系搭建完善，才能说是整个微前端体系流程的完善。\n当发现使用微前端反而使效率变低，简单的变更复杂那就说明微前端并不适用。\n\n#### 如何做微前端\n微前端的思想其实有点类似于 iframe，起一个框架，做一个导航，然后嵌入不同的页面。\n单纯根据对概念的理解，实现微前端的就是将应用进行拆解和整合，通常是一个父应用加上一些子应用，主应用管理各个子应用。\n采用iframe来将多个应用整合到一起等等这些其实都属于微前端的实现方案\n\n当然，如果仅仅是套一个iframe那也太low了。\n一个好的微前端方案主要需要解决三个问题：\n```html\n路由切换、路由分发问题。\n子应用之间、子应用与主微应用的隔离问题。\n子应用直接的通信问题。\n```\n\n1.路由分发\n作为一个SPA的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用iframe之外，要能先拉取到微应用的页面内容， 这就需要远程拉取机制。\n远程拉取机制通常会采用fetch API来首先获取到微应用的HTML内容，然后通过解析将微应用的 JavaScript 和 CSS 进行抽离，采用 eval 方法来运行JavaScript，并将CSS和HTML 内容 append 到基座应用中留给微应用的展示区域，当微应用切换走时，同步卸载这些内容，这就构成的当前应用的展示流程。\n当然这个流程里会涉及到 CSS 样式的污染以及 JavaScript 对全局对象的污染。\n\n2.微应用隔离\n当前处理微应用隔离， 应对 CSS 全局对象污染的方法\n```html\n可结合 Webpack等打包工具，使用 css Module或者命名空间的方式给每个子应用添加特定的前缀，每次应用加载时，<br>将该应用所有的 link 和 style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可\n\n使用Web Components（shadowDom）技术，Web Components能够填入隔离 CSS 作用域。\n```\n每当微应用的JavaScript被加载并运行时，它的核心实际上是对全局对象 Window 的修改以及一些全局事件的改变，例如jQuery这个js运行后，会在Window上挂载一个window.$对象，对于其他库React，Vue也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响\n当前处理 Javascript 全局对象污染的方法\n```html\n最普遍的做法是采用沙箱机制（SandBox）。\n沙箱机制的核心是让局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。\n通常在Node.js端可以采用vm模块，而对于浏览器，则需要结合 with 关键字和 window.Proxy 对象来实现浏览器端的沙箱。\n```\n\n3.微前端的消息通信\n消息订阅（pub/sub）模式的通信机制\n在基座应用中会定义事件中心Event，每个微应用分别来注册事件，当被触发事件时再有事件中心统一分发，这就构成了基本的通信机制\n如果使用的是 React或者 Vue等框架，可以结合Redux和Vuex来一起使用，实现应用之间的通信。\n\n### 传送门\n[微前端探索](https://github.com/fengshi123/blog/issues/21)，介绍了了什么是微前端，以及乾坤框架的一些简介。\n\n[qiankun框架](https://qiankun.umijs.org/zh/guide) 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。\n\n[微前端在美团外卖的实践](https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html)，美团在微前端的实践经验\n\n[微前端那些事](https://github.com/phodal/microfrontends)，微前端框架 Mooa \n\n[Web Components](http://www.ruanyifeng.com/blog/2019/08/web_components.html) 入门实例教程\n\n[with关键字](https://cloud.tencent.com/developer/article/1408030)\n\n[CSS Module简介](http://www.ruanyifeng.com/blog/2016/06/css_modules.html)（CSSmodule就是一个css模块化的一个方案）\n\n[微应用简介](https://juejin.cn/post/6844904162509979662)\n\n","slug":"micro-front","published":1,"updated":"2021-03-30T01:32:00.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufu000ya0vzfjq8d22p","content":"<p>当下业内的微前端字眼出现的频率比较高，于是大致了解了一下微前端<br>主要内容包括：什么是微前端？微前端的好处和意义是什么？做微前端应该如何做？</p>\n<h4 id=\"什么是微前端\"><a href=\"#什么是微前端\" class=\"headerlink\" title=\"什么是微前端\"></a>什么是微前端</h4><p>说微前端之前首先得跟微服务区分开来<br><strong><em>微服务</em></strong>是一种以业务功能为主的服务设计概念，每一个服务都具有自主运行的业务功能，对外开放不受语言限制的API (最常用的是HTTP)，应用程序则是由一个或多个微服务组成。<br>微服务是由以单一应用程序构成的小服务，自己拥有自己的行程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用HTTP API通信。同时服务会使用最小的规模的集中管理 (例如 Docker) 能力，服务可以用不同的编程语言与数据库等组件实现。 —— 维基百科</p>\n<p>而微前端，是针对前台的单页系统而定义的概念，每一个微前端的功能模块都具有自主运行的业务功能，对外提供url访问路径（可以是完整的URL，也可以是前端history/hash等路由），应用有一个或多个单页系统组成，可以独立部署，方便的插拔，又能够方便的实现独立模块间的通信。类似与微服务的不同语言的兼容性，微前端各个子应用也可以使用各自自己的语言，比如react、vue、angular等。<br>现如今前端多框架齐头并进，而且谁也不能保证会不会过几个月就新增一个新的框架，因此，在不重写原有系统的基础上使用新技术开发新功能是十分必要的需求，而微前端的思想就能够很方便的让这一需求成为可能，这也是微服务的一个很重要的卖点。</p>\n<h4 id=\"微前端的好处和意义\"><a href=\"#微前端的好处和意义\" class=\"headerlink\" title=\"微前端的好处和意义\"></a>微前端的好处和意义</h4><p>1.独立开发部署，聚合使用。<br>有过一定前端开发经验的人都知道，一个健康发展，长期迭代更新维护的系统，一定是越做越大，功能越来越多的。<br>而随着功能的增多，代码量增多，打包构建更耗时，模块依赖更复杂，模块崩溃连锁反应风险更大。因此，当到达某个临界点的时候，就会促使开发人员对应用进行拆分了。<br>然而系统拆分确实能够解决问题，但是对于用户来说就变成了使用一个系统变成了使用多个系统了，即使我们做了授权登录或者跨子域登录，对于不同系统之前的切换也是很麻烦的，如果有的选择，用户肯定是希望一个系统就能把自己的事情做完。</p>\n<p>2.跨团队、跨技术开发<br>一个复杂的系统往往需要很多人、甚至不同的团队一起来开发的，而这也就意味着需要跨越多个时间线、多个技术栈和多个团队的编码风格。<br>这些差异点集成在一起往往就是风险的不断叠加和维护成本的不断上升。微前端的思想可以很好的处理这一类问题。</p>\n<p>3.微前端最佳的使用场景是一些B端的管理系统，既能兼容集成历史系统，也可以将新的系统集成进来，并且不影响原先的交互体验。<br>整体的微前端不仅仅是只将系统集成进来，而是整个微前端体系的完善。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基座应用和微应用的自动部署能力。</span><br><span class=\"line\">微应用的配置管理能力。</span><br><span class=\"line\">本地开发调试能力。</span><br><span class=\"line\">线上监控和统计能力等。</span><br></pre></td></tr></table></figure><br>只有将整个能力体系搭建完善，才能说是整个微前端体系流程的完善。<br>当发现使用微前端反而使效率变低，简单的变更复杂那就说明微前端并不适用。</p>\n<h4 id=\"如何做微前端\"><a href=\"#如何做微前端\" class=\"headerlink\" title=\"如何做微前端\"></a>如何做微前端</h4><p>微前端的思想其实有点类似于 iframe，起一个框架，做一个导航，然后嵌入不同的页面。<br>单纯根据对概念的理解，实现微前端的就是将应用进行拆解和整合，通常是一个父应用加上一些子应用，主应用管理各个子应用。<br>采用iframe来将多个应用整合到一起等等这些其实都属于微前端的实现方案</p>\n<p>当然，如果仅仅是套一个iframe那也太low了。<br>一个好的微前端方案主要需要解决三个问题：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">路由切换、路由分发问题。</span><br><span class=\"line\">子应用之间、子应用与主微应用的隔离问题。</span><br><span class=\"line\">子应用直接的通信问题。</span><br></pre></td></tr></table></figure></p>\n<p>1.路由分发<br>作为一个SPA的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用iframe之外，要能先拉取到微应用的页面内容， 这就需要远程拉取机制。<br>远程拉取机制通常会采用fetch API来首先获取到微应用的HTML内容，然后通过解析将微应用的 JavaScript 和 CSS 进行抽离，采用 eval 方法来运行JavaScript，并将CSS和HTML 内容 append 到基座应用中留给微应用的展示区域，当微应用切换走时，同步卸载这些内容，这就构成的当前应用的展示流程。<br>当然这个流程里会涉及到 CSS 样式的污染以及 JavaScript 对全局对象的污染。</p>\n<p>2.微应用隔离<br>当前处理微应用隔离， 应对 CSS 全局对象污染的方法<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可结合 Webpack等打包工具，使用 css Module或者命名空间的方式给每个子应用添加特定的前缀，每次应用加载时，<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>将该应用所有的 link 和 style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可</span><br><span class=\"line\"></span><br><span class=\"line\">使用Web Components（shadowDom）技术，Web Components能够填入隔离 CSS 作用域。</span><br></pre></td></tr></table></figure><br>每当微应用的JavaScript被加载并运行时，它的核心实际上是对全局对象 Window 的修改以及一些全局事件的改变，例如jQuery这个js运行后，会在Window上挂载一个window.$对象，对于其他库React，Vue也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响<br>当前处理 Javascript 全局对象污染的方法<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最普遍的做法是采用沙箱机制（SandBox）。</span><br><span class=\"line\">沙箱机制的核心是让局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。</span><br><span class=\"line\">通常在Node.js端可以采用vm模块，而对于浏览器，则需要结合 with 关键字和 window.Proxy 对象来实现浏览器端的沙箱。</span><br></pre></td></tr></table></figure></p>\n<p>3.微前端的消息通信<br>消息订阅（pub/sub）模式的通信机制<br>在基座应用中会定义事件中心Event，每个微应用分别来注册事件，当被触发事件时再有事件中心统一分发，这就构成了基本的通信机制<br>如果使用的是 React或者 Vue等框架，可以结合Redux和Vuex来一起使用，实现应用之间的通信。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://github.com/fengshi123/blog/issues/21\">微前端探索</a>，介绍了了什么是微前端，以及乾坤框架的一些简介。</p>\n<p><a href=\"https://qiankun.umijs.org/zh/guide\">qiankun框架</a> 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。</p>\n<p><a href=\"https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html\">微前端在美团外卖的实践</a>，美团在微前端的实践经验</p>\n<p><a href=\"https://github.com/phodal/microfrontends\">微前端那些事</a>，微前端框架 Mooa </p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2019/08/web_components.html\">Web Components</a> 入门实例教程</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1408030\">with关键字</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2016/06/css_modules.html\">CSS Module简介</a>（CSSmodule就是一个css模块化的一个方案）</p>\n<p><a href=\"https://juejin.cn/post/6844904162509979662\">微应用简介</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>当下业内的微前端字眼出现的频率比较高，于是大致了解了一下微前端<br>主要内容包括：什么是微前端？微前端的好处和意义是什么？做微前端应该如何做？</p>\n<h4 id=\"什么是微前端\"><a href=\"#什么是微前端\" class=\"headerlink\" title=\"什么是微前端\"></a>什么是微前端</h4><p>说微前端之前首先得跟微服务区分开来<br><strong><em>微服务</em></strong>是一种以业务功能为主的服务设计概念，每一个服务都具有自主运行的业务功能，对外开放不受语言限制的API (最常用的是HTTP)，应用程序则是由一个或多个微服务组成。<br>微服务是由以单一应用程序构成的小服务，自己拥有自己的行程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用HTTP API通信。同时服务会使用最小的规模的集中管理 (例如 Docker) 能力，服务可以用不同的编程语言与数据库等组件实现。 —— 维基百科</p>\n<p>而微前端，是针对前台的单页系统而定义的概念，每一个微前端的功能模块都具有自主运行的业务功能，对外提供url访问路径（可以是完整的URL，也可以是前端history/hash等路由），应用有一个或多个单页系统组成，可以独立部署，方便的插拔，又能够方便的实现独立模块间的通信。类似与微服务的不同语言的兼容性，微前端各个子应用也可以使用各自自己的语言，比如react、vue、angular等。<br>现如今前端多框架齐头并进，而且谁也不能保证会不会过几个月就新增一个新的框架，因此，在不重写原有系统的基础上使用新技术开发新功能是十分必要的需求，而微前端的思想就能够很方便的让这一需求成为可能，这也是微服务的一个很重要的卖点。</p>\n<h4 id=\"微前端的好处和意义\"><a href=\"#微前端的好处和意义\" class=\"headerlink\" title=\"微前端的好处和意义\"></a>微前端的好处和意义</h4><p>1.独立开发部署，聚合使用。<br>有过一定前端开发经验的人都知道，一个健康发展，长期迭代更新维护的系统，一定是越做越大，功能越来越多的。<br>而随着功能的增多，代码量增多，打包构建更耗时，模块依赖更复杂，模块崩溃连锁反应风险更大。因此，当到达某个临界点的时候，就会促使开发人员对应用进行拆分了。<br>然而系统拆分确实能够解决问题，但是对于用户来说就变成了使用一个系统变成了使用多个系统了，即使我们做了授权登录或者跨子域登录，对于不同系统之前的切换也是很麻烦的，如果有的选择，用户肯定是希望一个系统就能把自己的事情做完。</p>\n<p>2.跨团队、跨技术开发<br>一个复杂的系统往往需要很多人、甚至不同的团队一起来开发的，而这也就意味着需要跨越多个时间线、多个技术栈和多个团队的编码风格。<br>这些差异点集成在一起往往就是风险的不断叠加和维护成本的不断上升。微前端的思想可以很好的处理这一类问题。</p>\n<p>3.微前端最佳的使用场景是一些B端的管理系统，既能兼容集成历史系统，也可以将新的系统集成进来，并且不影响原先的交互体验。<br>整体的微前端不仅仅是只将系统集成进来，而是整个微前端体系的完善。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基座应用和微应用的自动部署能力。</span><br><span class=\"line\">微应用的配置管理能力。</span><br><span class=\"line\">本地开发调试能力。</span><br><span class=\"line\">线上监控和统计能力等。</span><br></pre></td></tr></table></figure><br>只有将整个能力体系搭建完善，才能说是整个微前端体系流程的完善。<br>当发现使用微前端反而使效率变低，简单的变更复杂那就说明微前端并不适用。</p>\n<h4 id=\"如何做微前端\"><a href=\"#如何做微前端\" class=\"headerlink\" title=\"如何做微前端\"></a>如何做微前端</h4><p>微前端的思想其实有点类似于 iframe，起一个框架，做一个导航，然后嵌入不同的页面。<br>单纯根据对概念的理解，实现微前端的就是将应用进行拆解和整合，通常是一个父应用加上一些子应用，主应用管理各个子应用。<br>采用iframe来将多个应用整合到一起等等这些其实都属于微前端的实现方案</p>\n<p>当然，如果仅仅是套一个iframe那也太low了。<br>一个好的微前端方案主要需要解决三个问题：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">路由切换、路由分发问题。</span><br><span class=\"line\">子应用之间、子应用与主微应用的隔离问题。</span><br><span class=\"line\">子应用直接的通信问题。</span><br></pre></td></tr></table></figure></p>\n<p>1.路由分发<br>作为一个SPA的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用iframe之外，要能先拉取到微应用的页面内容， 这就需要远程拉取机制。<br>远程拉取机制通常会采用fetch API来首先获取到微应用的HTML内容，然后通过解析将微应用的 JavaScript 和 CSS 进行抽离，采用 eval 方法来运行JavaScript，并将CSS和HTML 内容 append 到基座应用中留给微应用的展示区域，当微应用切换走时，同步卸载这些内容，这就构成的当前应用的展示流程。<br>当然这个流程里会涉及到 CSS 样式的污染以及 JavaScript 对全局对象的污染。</p>\n<p>2.微应用隔离<br>当前处理微应用隔离， 应对 CSS 全局对象污染的方法<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可结合 Webpack等打包工具，使用 css Module或者命名空间的方式给每个子应用添加特定的前缀，每次应用加载时，<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>将该应用所有的 link 和 style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可</span><br><span class=\"line\"></span><br><span class=\"line\">使用Web Components（shadowDom）技术，Web Components能够填入隔离 CSS 作用域。</span><br></pre></td></tr></table></figure><br>每当微应用的JavaScript被加载并运行时，它的核心实际上是对全局对象 Window 的修改以及一些全局事件的改变，例如jQuery这个js运行后，会在Window上挂载一个window.$对象，对于其他库React，Vue也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响<br>当前处理 Javascript 全局对象污染的方法<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最普遍的做法是采用沙箱机制（SandBox）。</span><br><span class=\"line\">沙箱机制的核心是让局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。</span><br><span class=\"line\">通常在Node.js端可以采用vm模块，而对于浏览器，则需要结合 with 关键字和 window.Proxy 对象来实现浏览器端的沙箱。</span><br></pre></td></tr></table></figure></p>\n<p>3.微前端的消息通信<br>消息订阅（pub/sub）模式的通信机制<br>在基座应用中会定义事件中心Event，每个微应用分别来注册事件，当被触发事件时再有事件中心统一分发，这就构成了基本的通信机制<br>如果使用的是 React或者 Vue等框架，可以结合Redux和Vuex来一起使用，实现应用之间的通信。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://github.com/fengshi123/blog/issues/21\">微前端探索</a>，介绍了了什么是微前端，以及乾坤框架的一些简介。</p>\n<p><a href=\"https://qiankun.umijs.org/zh/guide\">qiankun框架</a> 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。</p>\n<p><a href=\"https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html\">微前端在美团外卖的实践</a>，美团在微前端的实践经验</p>\n<p><a href=\"https://github.com/phodal/microfrontends\">微前端那些事</a>，微前端框架 Mooa </p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2019/08/web_components.html\">Web Components</a> 入门实例教程</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1408030\">with关键字</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2016/06/css_modules.html\">CSS Module简介</a>（CSSmodule就是一个css模块化的一个方案）</p>\n<p><a href=\"https://juejin.cn/post/6844904162509979662\">微应用简介</a></p>\n"},{"title":"Mysql入门","date":"2016-12-24T16:00:00.000Z","_content":"\nMysql 是最流行的关系型数据库管理系统，尤其是在Web应用方面。\nMysql,由瑞典MySQL AB公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\nMysql是开源的、免费的、支持大型的数据库\nMysql使用标准的SQL数据语言形式。\n```html\nps: ${ xxx } 表示 xxx 是变量\n```\n\n### mysql安装\n\nMac 系统用 brew 安装mysql\n\n安装mysql\n``` html\nbrew update # 更新下brew\nbrew install mysql # brew安装 mysql\n```\n\n设置 MySQL 用户以及数据存放地址\n``` html\n$ unset TMPDIR\n\n$ mysql_install_db --verbose --user=`whoami` --basedir=\"$(brew --prefix mysql)\" --datadir=/usr/local/var/mysql --tmpdir=/tmp\n```\n\n忘记mysql数据库密码\n``` sql\nupdate user set authentication_string=password('my_password') where user='root';\n```\n\n修改密码\n``` sql\nSET PASSWORD FOR 'root'@'localhost' = PASSWORD('newpass');\n```\n\n可能遇到的问题\n\n错误码：ERROR 1045 (28000)\n``` html\ncd /etc\n\nsudo vim my.cnf\n\n编辑如下代码到 my.cnf 文件,保存成功应该就可以了\n[mysqld]\nskip-grant-tables\nlower_case_table_names=1\n```\n\n权限不足的时候可以创建一个账号\n``` sql\nCREATE USER 'golden'@'localhost' IDENTIFIED BY 'password';\nGRANT ALL PRIVILEGES ON * . * TO 'golden'@'localhost';\nFLUSH PRIVILEGES;\n```\n\n---\n\n启动mysql\n```shell\nmysql.server start\nsudo /etc/init.d/mysql start \n\nor\n\nsudo /usr/local/mysql/support-files/mysql.server start;\n```\n\n开机启动mysql\n``` html\n/etc/init.d/mysqld start\n```\n\n通过sql文件执行脚本\n``` sql\nsource  /Users/zsr/learn/crawler/sql/createtable.sql; \n\nor \n\nmysql -D samp_db -u root -p < createtable.sql\n```\n\n登录 mysql\n``` shell\nmysql -u ${ databasename } -p # 然后输入mysql密码\n```\n\n---\n\n创建一个数据库，设置character是为了兼容汉字\n``` sql\ncreate database ${newdatabasename} character set gbk;\n```\n\n查看所有的数据库\n``` sql\nshow databases;\n```\n\n删除数据库\n``` sql\ndrop database ${databasename};\n```\n\n选中 testdb 数据库\n``` sql\nuse ${databasename};\n```\n\n---\n\n创建一张表\n``` sql\nuse ${databasename}\n\ncreate table students\n（\n\tid int unsigned not null auto_increment primary key,\n\tname char(8) not null,\n\tsex char(4) not null,\n\tage tinyint unsigned not null,\n\ttel char(13) null default \"-\"\n);\n```\n\n修改表名\n``` sql\nalter table ${oldtablename} rename to ${newtablename};\n```\n\n查看所有表\n``` sql\nshow tables;\n```\n\n删除表\n``` sql\ndrop table ${tabename};\n```\n\n显示数据表的属性，属性类型，主键信息\n``` sql\nshow columns from students\n```\n\n---\n\n查看列\n``` sql\ndesc ${tablename};\n```\n\n添加列\n``` sql\nalter table ${tablename} add column ${newcolumnname} varchar(30);\n```\n\n删除列\n``` sql\nalter table ${tablename} drop column ${columnname};\n```\n\n修改列名\n``` sql\nalter table ${tablename} change ${ondcolumnname} ${newcolumnname} int; \n```\n\n修改列属性\n``` sql\nalter table ${tablename} modify ${oldattr} char(80);\n```\n\n---\n\n增加数据\n``` sql \ninsert into ${tablename} values (${column1}, ${column2}); /*如果自增id，则column1为0*/\n```\n\n修改数据\n``` sql\nupdate ${tablename} set ${attr}=${newAttr} where ${id=3}; /*id=3代表查询条件*/\n```\n\n查询数据\n``` sql\nselect * from ${tablename} where ${id=3};\n```\n\n删除数据\n``` sql\ndelete from ${tablename} where ${id=3};\n```\n\n---\n\n详细的常用查询操作\n1.查询从第n条开始的m条数据、asc 升序(desc 降序)\n``` sql\nselect * from ${tablename} limit n,m;\nselect ${column1},${column2} from ${tablename} order by ${column} asc limit n,m\nselect ${column1},${column2} from ${tablename} order by ${column} desc limit n,m\n```\n\n查看数据库编码\n``` sql\nshow variables like 'character%'; \n```\n\n查看数据库位置\n``` sql\nshow variables like 'datadir%'\n```\n\n数据库中文乱码\n```sql\nmysql> show variables like '%char%';\n+--------------------------------------+----------------------------+\n| Variable_name                        | Value                      |\n+--------------------------------------+----------------------------+\n| character_set_client                 | latin1                       |\n| character_set_connection             | utf8                       |\n| character_set_database               | utf8                       |\n| character_set_filesystem             | binary                     |\n| character_set_results                | utf8                       |\n| character_set_server                 | utf8                       |\n| character_set_system                 | utf8                       |\n| character_sets_dir                   | /usr/share/mysql/charsets/ |\n| validate_password_special_char_count | 1                          |\n+--------------------------------------+----------------------------+\nset character_set_client=utf8;\n```\nmysql 数据库中文乱码是因为数据库默认的编码方式是 latin1\n解决办法就是将其手动改为utf8即可\n*但是*这只是临时办法，变量只是session级别的存储，数据库重启之后就没了\n```shell\nsudo vim /etc/mysql/my.cnf\nor\nsudo vim /etc/my.cnf\n```\n在my.cnf 文件里面配置数据库的编码集\n```shell\n[mysqld]\ncharacter-set-server=utf8\n[client]\ndefault-character-set=utf8\n[mysql]\ndefault-character-set=utf8\n```\n\n\n备份数据\n``` html\nmysqldump -udbusername -pdbpwd dbname > ./epoos.sql\nscp -r root@xxx.193.173.xx:/xxx/xxx/xxx/epoos.sql /Users/zsr/epoos \n```\n\n还原数据\n``` sql\nmysql -h127.0.0.1 -uroot -p123456 epoos < epoos.sql\n```\n\n如果上面的还原功能不好使，可以\n``` html\n1.创建新数据库 newdb\n2.use newdb\n3.执行备份的sql文件\n```\n\n#### ubuntu安装mysql\n```shell\nsudo apt-get update \nsudo apt-get install mysql-server # 安装 mysql 服务端\nmysql_secure_installation # mysql 安装安全配置向导，设置密码\n```\n执行安全配置向导可能报如下错误：\n```shell\n# 报错信息\nError: Access denied for user 'root'@'localhost'\n```\n解决方案：\n```shell\nsudo -iu root # 用 root 用户执行此命令即可\nmysql_secure_installation\n\n# 中文解释\n1)为root用户设置密码；\n2)删除匿名账号；\n3)取消root用户远程登录；\n4)删除test库和对test库的访问权限；\n5)刷新授权表使修改生效。\n```\n\n\n#### 新建新用户\n```shell\n# 创建 dev 用户\nmysql> CREATE USER dev@% IDENTIFIED BY 'Abc123456!';\n# 给用户 dev 所有数据库的权限\nmysql> grant all PRIVILEGES on *.* to 'dev'@'%' IDENTIFIED BY \"Abc123456!\";\n# 刷新配置\nflush privileges; \n```\n\n#### 远程端口不通\n```shell\n# 测试端口是否通顺\ntelnet 10.216.8.142 3306\n```\nmysql 数据库经常会遇到本地能连通但是其它机器通过 ip 访问的时候就不通的情况。\n排查可以从下面三种情形入手（具体方式可以网上搜一搜，很多，这里就不列了）\n\n这种情形比较常见的原因有三个：\n1.机器防火墙 3306 端口没有开\n2.登录的数据库用户没有开 ip 访问的权限，找到user表，赋予其 % 权限。\n3.数据库初始的时候地址没有注释掉 bind-address\n\n```shell\n# 这个文件配置可能在/etc/my.cnf/;/etc/mysql/my.cnf;也可能在 /etc/mysql/mysql.conf.d\n# 具体情形根据系统有所不同，但是只需要找到 bind-address 将其注释掉即可\n#bind-address\t\t= 127.0.0.1\n```\n\n\n#### 卸载mysql\n\n把下面几个目录全部删掉应该就可以完全卸载mysql了\n值得注意的是，如果有数据库需要备份的，需提前做好备份。\n\n```shell\nrm -rf ~/Library/PreferencePanes/My*\nsudo rm -rf /Library/Receipts/mysql*\nsudo rm -rf /Library/Receipts/MySQL*\nsudo rm -rf /var/db/receipts/com.mysql.*\n\nsudo rm /usr/local/mysql\nsudo rm -rf /usr/local/mysql*\nsudo rm -rf /Library/StartupItems/MySQLCOM\nsudo rm -rf /Library/PreferencePanes/My* \n```\n\n\n### 传送门\nhttps://dev.mysql.com/doc/refman/5.6/en/linux-installation.html","source":"_posts/mysql.md","raw":"---\ntitle: Mysql入门\ntag: [mysql, 数据库]\ndate: 2016/12/25\ncategory: 技术\n---\n\nMysql 是最流行的关系型数据库管理系统，尤其是在Web应用方面。\nMysql,由瑞典MySQL AB公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\nMysql是开源的、免费的、支持大型的数据库\nMysql使用标准的SQL数据语言形式。\n```html\nps: ${ xxx } 表示 xxx 是变量\n```\n\n### mysql安装\n\nMac 系统用 brew 安装mysql\n\n安装mysql\n``` html\nbrew update # 更新下brew\nbrew install mysql # brew安装 mysql\n```\n\n设置 MySQL 用户以及数据存放地址\n``` html\n$ unset TMPDIR\n\n$ mysql_install_db --verbose --user=`whoami` --basedir=\"$(brew --prefix mysql)\" --datadir=/usr/local/var/mysql --tmpdir=/tmp\n```\n\n忘记mysql数据库密码\n``` sql\nupdate user set authentication_string=password('my_password') where user='root';\n```\n\n修改密码\n``` sql\nSET PASSWORD FOR 'root'@'localhost' = PASSWORD('newpass');\n```\n\n可能遇到的问题\n\n错误码：ERROR 1045 (28000)\n``` html\ncd /etc\n\nsudo vim my.cnf\n\n编辑如下代码到 my.cnf 文件,保存成功应该就可以了\n[mysqld]\nskip-grant-tables\nlower_case_table_names=1\n```\n\n权限不足的时候可以创建一个账号\n``` sql\nCREATE USER 'golden'@'localhost' IDENTIFIED BY 'password';\nGRANT ALL PRIVILEGES ON * . * TO 'golden'@'localhost';\nFLUSH PRIVILEGES;\n```\n\n---\n\n启动mysql\n```shell\nmysql.server start\nsudo /etc/init.d/mysql start \n\nor\n\nsudo /usr/local/mysql/support-files/mysql.server start;\n```\n\n开机启动mysql\n``` html\n/etc/init.d/mysqld start\n```\n\n通过sql文件执行脚本\n``` sql\nsource  /Users/zsr/learn/crawler/sql/createtable.sql; \n\nor \n\nmysql -D samp_db -u root -p < createtable.sql\n```\n\n登录 mysql\n``` shell\nmysql -u ${ databasename } -p # 然后输入mysql密码\n```\n\n---\n\n创建一个数据库，设置character是为了兼容汉字\n``` sql\ncreate database ${newdatabasename} character set gbk;\n```\n\n查看所有的数据库\n``` sql\nshow databases;\n```\n\n删除数据库\n``` sql\ndrop database ${databasename};\n```\n\n选中 testdb 数据库\n``` sql\nuse ${databasename};\n```\n\n---\n\n创建一张表\n``` sql\nuse ${databasename}\n\ncreate table students\n（\n\tid int unsigned not null auto_increment primary key,\n\tname char(8) not null,\n\tsex char(4) not null,\n\tage tinyint unsigned not null,\n\ttel char(13) null default \"-\"\n);\n```\n\n修改表名\n``` sql\nalter table ${oldtablename} rename to ${newtablename};\n```\n\n查看所有表\n``` sql\nshow tables;\n```\n\n删除表\n``` sql\ndrop table ${tabename};\n```\n\n显示数据表的属性，属性类型，主键信息\n``` sql\nshow columns from students\n```\n\n---\n\n查看列\n``` sql\ndesc ${tablename};\n```\n\n添加列\n``` sql\nalter table ${tablename} add column ${newcolumnname} varchar(30);\n```\n\n删除列\n``` sql\nalter table ${tablename} drop column ${columnname};\n```\n\n修改列名\n``` sql\nalter table ${tablename} change ${ondcolumnname} ${newcolumnname} int; \n```\n\n修改列属性\n``` sql\nalter table ${tablename} modify ${oldattr} char(80);\n```\n\n---\n\n增加数据\n``` sql \ninsert into ${tablename} values (${column1}, ${column2}); /*如果自增id，则column1为0*/\n```\n\n修改数据\n``` sql\nupdate ${tablename} set ${attr}=${newAttr} where ${id=3}; /*id=3代表查询条件*/\n```\n\n查询数据\n``` sql\nselect * from ${tablename} where ${id=3};\n```\n\n删除数据\n``` sql\ndelete from ${tablename} where ${id=3};\n```\n\n---\n\n详细的常用查询操作\n1.查询从第n条开始的m条数据、asc 升序(desc 降序)\n``` sql\nselect * from ${tablename} limit n,m;\nselect ${column1},${column2} from ${tablename} order by ${column} asc limit n,m\nselect ${column1},${column2} from ${tablename} order by ${column} desc limit n,m\n```\n\n查看数据库编码\n``` sql\nshow variables like 'character%'; \n```\n\n查看数据库位置\n``` sql\nshow variables like 'datadir%'\n```\n\n数据库中文乱码\n```sql\nmysql> show variables like '%char%';\n+--------------------------------------+----------------------------+\n| Variable_name                        | Value                      |\n+--------------------------------------+----------------------------+\n| character_set_client                 | latin1                       |\n| character_set_connection             | utf8                       |\n| character_set_database               | utf8                       |\n| character_set_filesystem             | binary                     |\n| character_set_results                | utf8                       |\n| character_set_server                 | utf8                       |\n| character_set_system                 | utf8                       |\n| character_sets_dir                   | /usr/share/mysql/charsets/ |\n| validate_password_special_char_count | 1                          |\n+--------------------------------------+----------------------------+\nset character_set_client=utf8;\n```\nmysql 数据库中文乱码是因为数据库默认的编码方式是 latin1\n解决办法就是将其手动改为utf8即可\n*但是*这只是临时办法，变量只是session级别的存储，数据库重启之后就没了\n```shell\nsudo vim /etc/mysql/my.cnf\nor\nsudo vim /etc/my.cnf\n```\n在my.cnf 文件里面配置数据库的编码集\n```shell\n[mysqld]\ncharacter-set-server=utf8\n[client]\ndefault-character-set=utf8\n[mysql]\ndefault-character-set=utf8\n```\n\n\n备份数据\n``` html\nmysqldump -udbusername -pdbpwd dbname > ./epoos.sql\nscp -r root@xxx.193.173.xx:/xxx/xxx/xxx/epoos.sql /Users/zsr/epoos \n```\n\n还原数据\n``` sql\nmysql -h127.0.0.1 -uroot -p123456 epoos < epoos.sql\n```\n\n如果上面的还原功能不好使，可以\n``` html\n1.创建新数据库 newdb\n2.use newdb\n3.执行备份的sql文件\n```\n\n#### ubuntu安装mysql\n```shell\nsudo apt-get update \nsudo apt-get install mysql-server # 安装 mysql 服务端\nmysql_secure_installation # mysql 安装安全配置向导，设置密码\n```\n执行安全配置向导可能报如下错误：\n```shell\n# 报错信息\nError: Access denied for user 'root'@'localhost'\n```\n解决方案：\n```shell\nsudo -iu root # 用 root 用户执行此命令即可\nmysql_secure_installation\n\n# 中文解释\n1)为root用户设置密码；\n2)删除匿名账号；\n3)取消root用户远程登录；\n4)删除test库和对test库的访问权限；\n5)刷新授权表使修改生效。\n```\n\n\n#### 新建新用户\n```shell\n# 创建 dev 用户\nmysql> CREATE USER dev@% IDENTIFIED BY 'Abc123456!';\n# 给用户 dev 所有数据库的权限\nmysql> grant all PRIVILEGES on *.* to 'dev'@'%' IDENTIFIED BY \"Abc123456!\";\n# 刷新配置\nflush privileges; \n```\n\n#### 远程端口不通\n```shell\n# 测试端口是否通顺\ntelnet 10.216.8.142 3306\n```\nmysql 数据库经常会遇到本地能连通但是其它机器通过 ip 访问的时候就不通的情况。\n排查可以从下面三种情形入手（具体方式可以网上搜一搜，很多，这里就不列了）\n\n这种情形比较常见的原因有三个：\n1.机器防火墙 3306 端口没有开\n2.登录的数据库用户没有开 ip 访问的权限，找到user表，赋予其 % 权限。\n3.数据库初始的时候地址没有注释掉 bind-address\n\n```shell\n# 这个文件配置可能在/etc/my.cnf/;/etc/mysql/my.cnf;也可能在 /etc/mysql/mysql.conf.d\n# 具体情形根据系统有所不同，但是只需要找到 bind-address 将其注释掉即可\n#bind-address\t\t= 127.0.0.1\n```\n\n\n#### 卸载mysql\n\n把下面几个目录全部删掉应该就可以完全卸载mysql了\n值得注意的是，如果有数据库需要备份的，需提前做好备份。\n\n```shell\nrm -rf ~/Library/PreferencePanes/My*\nsudo rm -rf /Library/Receipts/mysql*\nsudo rm -rf /Library/Receipts/MySQL*\nsudo rm -rf /var/db/receipts/com.mysql.*\n\nsudo rm /usr/local/mysql\nsudo rm -rf /usr/local/mysql*\nsudo rm -rf /Library/StartupItems/MySQLCOM\nsudo rm -rf /Library/PreferencePanes/My* \n```\n\n\n### 传送门\nhttps://dev.mysql.com/doc/refman/5.6/en/linux-installation.html","slug":"mysql","published":1,"updated":"2021-03-30T01:32:00.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufu000za0vz5apzc53q","content":"<p>Mysql 是最流行的关系型数据库管理系统，尤其是在Web应用方面。<br>Mysql,由瑞典MySQL AB公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。<br>Mysql是开源的、免费的、支持大型的数据库<br>Mysql使用标准的SQL数据语言形式。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps: $&#123; xxx &#125; 表示 xxx 是变量</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"mysql安装\"><a href=\"#mysql安装\" class=\"headerlink\" title=\"mysql安装\"></a>mysql安装</h3><p>Mac 系统用 brew 安装mysql</p>\n<p>安装mysql<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew update # 更新下brew</span><br><span class=\"line\">brew install mysql # brew安装 mysql</span><br></pre></td></tr></table></figure></p>\n<p>设置 MySQL 用户以及数据存放地址<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ unset TMPDIR</span><br><span class=\"line\"></span><br><span class=\"line\">$ mysql_install_db --verbose --user=`whoami` --basedir=&quot;$(brew --prefix mysql)&quot; --datadir=/usr/local/var/mysql --tmpdir=/tmp</span><br></pre></td></tr></table></figure></p>\n<p>忘记mysql数据库密码<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">user</span> <span class=\"keyword\">set</span> authentication_string=<span class=\"keyword\">password</span>(<span class=\"string\">&#x27;my_password&#x27;</span>) <span class=\"keyword\">where</span> <span class=\"keyword\">user</span>=<span class=\"string\">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure></p>\n<p>修改密码<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">PASSWORD</span> <span class=\"keyword\">FOR</span> <span class=\"string\">&#x27;root&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span> = <span class=\"keyword\">PASSWORD</span>(<span class=\"string\">&#x27;newpass&#x27;</span>);</span><br></pre></td></tr></table></figure></p>\n<p>可能遇到的问题</p>\n<p>错误码：ERROR 1045 (28000)<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /etc</span><br><span class=\"line\"></span><br><span class=\"line\">sudo vim my.cnf</span><br><span class=\"line\"></span><br><span class=\"line\">编辑如下代码到 my.cnf 文件,保存成功应该就可以了</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">skip-grant-tables</span><br><span class=\"line\">lower_case_table_names=1</span><br></pre></td></tr></table></figure></p>\n<p>权限不足的时候可以创建一个账号<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> <span class=\"string\">&#x27;golden&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span> <span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;password&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">ALL</span> <span class=\"keyword\">PRIVILEGES</span> <span class=\"keyword\">ON</span> * . * <span class=\"keyword\">TO</span> <span class=\"string\">&#x27;golden&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">FLUSH</span> <span class=\"keyword\">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>启动mysql<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql.server start</span><br><span class=\"line\">sudo /etc/init.d/mysql start </span><br><span class=\"line\"></span><br><span class=\"line\">or</span><br><span class=\"line\"></span><br><span class=\"line\">sudo /usr/local/mysql/support-files/mysql.server start;</span><br></pre></td></tr></table></figure></p>\n<p>开机启动mysql<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/mysqld start</span><br></pre></td></tr></table></figure></p>\n<p>通过sql文件执行脚本<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source  /Users/zsr/learn/crawler/sql/createtable.sql; </span><br><span class=\"line\"></span><br><span class=\"line\">or </span><br><span class=\"line\"></span><br><span class=\"line\">mysql -D samp_db -u root -p &lt; createtable.sql</span><br></pre></td></tr></table></figure></p>\n<p>登录 mysql<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u $&#123; databasename &#125; -p # 然后输入mysql密码</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>创建一个数据库，设置character是为了兼容汉字<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">database</span> $&#123;newdatabasename&#125; <span class=\"built_in\">character</span> <span class=\"keyword\">set</span> gbk;</span><br></pre></td></tr></table></figure></p>\n<p>查看所有的数据库<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">databases</span>;</span><br></pre></td></tr></table></figure></p>\n<p>删除数据库<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">database</span> $&#123;databasename&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>选中 testdb 数据库<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> $&#123;databasename&#125;;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>创建一张表<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> $&#123;databasename&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> students</span><br><span class=\"line\">（</span><br><span class=\"line\">\t<span class=\"keyword\">id</span> <span class=\"built_in\">int</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span> auto_increment primary <span class=\"keyword\">key</span>,</span><br><span class=\"line\">\t<span class=\"keyword\">name</span> <span class=\"built_in\">char</span>(<span class=\"number\">8</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\tsex <span class=\"built_in\">char</span>(<span class=\"number\">4</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\tage <span class=\"built_in\">tinyint</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\ttel <span class=\"built_in\">char</span>(<span class=\"number\">13</span>) <span class=\"literal\">null</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;-&quot;</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>修改表名<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> $&#123;oldtablename&#125; <span class=\"keyword\">rename</span> <span class=\"keyword\">to</span> $&#123;newtablename&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>查看所有表<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span>;</span><br></pre></td></tr></table></figure></p>\n<p>删除表<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> $&#123;tabename&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>显示数据表的属性，属性类型，主键信息<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">columns</span> <span class=\"keyword\">from</span> students</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>查看列<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">desc $&#123;tablename&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>添加列<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> $&#123;tablename&#125; <span class=\"keyword\">add</span> <span class=\"keyword\">column</span> $&#123;newcolumnname&#125; <span class=\"built_in\">varchar</span>(<span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure></p>\n<p>删除列<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> $&#123;tablename&#125; <span class=\"keyword\">drop</span> <span class=\"keyword\">column</span> $&#123;columnname&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>修改列名<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> $&#123;tablename&#125; <span class=\"keyword\">change</span> $&#123;ondcolumnname&#125; $&#123;newcolumnname&#125; <span class=\"built_in\">int</span>; </span><br></pre></td></tr></table></figure></p>\n<p>修改列属性<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> $&#123;tablename&#125; <span class=\"keyword\">modify</span> $&#123;oldattr&#125; <span class=\"built_in\">char</span>(<span class=\"number\">80</span>);</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>增加数据<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> $&#123;tablename&#125; <span class=\"keyword\">values</span> ($&#123;column1&#125;, $&#123;column2&#125;); <span class=\"comment\">/*如果自增id，则column1为0*/</span></span><br></pre></td></tr></table></figure></p>\n<p>修改数据<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> $&#123;tablename&#125; <span class=\"keyword\">set</span> $&#123;<span class=\"keyword\">attr</span>&#125;=$&#123;newAttr&#125; <span class=\"keyword\">where</span> $&#123;<span class=\"keyword\">id</span>=<span class=\"number\">3</span>&#125;; <span class=\"comment\">/*id=3代表查询条件*/</span></span><br></pre></td></tr></table></figure></p>\n<p>查询数据<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> $&#123;tablename&#125; <span class=\"keyword\">where</span> $&#123;<span class=\"keyword\">id</span>=<span class=\"number\">3</span>&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>删除数据<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> $&#123;tablename&#125; <span class=\"keyword\">where</span> $&#123;<span class=\"keyword\">id</span>=<span class=\"number\">3</span>&#125;;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>详细的常用查询操作<br>1.查询从第n条开始的m条数据、asc 升序(desc 降序)<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> $&#123;tablename&#125; <span class=\"keyword\">limit</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">select</span> $&#123;column1&#125;,$&#123;column2&#125; <span class=\"keyword\">from</span> $&#123;tablename&#125; <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> $&#123;<span class=\"keyword\">column</span>&#125; <span class=\"keyword\">asc</span> <span class=\"keyword\">limit</span> n,m</span><br><span class=\"line\"><span class=\"keyword\">select</span> $&#123;column1&#125;,$&#123;column2&#125; <span class=\"keyword\">from</span> $&#123;tablename&#125; <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> $&#123;<span class=\"keyword\">column</span>&#125; <span class=\"keyword\">desc</span> <span class=\"keyword\">limit</span> n,m</span><br></pre></td></tr></table></figure></p>\n<p>查看数据库编码<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;character%&#x27;</span>; </span><br></pre></td></tr></table></figure></p>\n<p>查看数据库位置<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;datadir%&#x27;</span></span><br></pre></td></tr></table></figure></p>\n<p>数据库中文乱码<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%char%&#x27;;</span><br><span class=\"line\">+<span class=\"comment\">--------------------------------------+----------------------------+</span></span><br><span class=\"line\">| Variable_name                        | Value                      |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------------------+----------------------------+</span></span><br><span class=\"line\">| character_set_client                 | latin1                       |</span><br><span class=\"line\">| character_set_connection             | utf8                       |</span><br><span class=\"line\">| character_set_database               | utf8                       |</span><br><span class=\"line\">| character_set_filesystem             | binary                     |</span><br><span class=\"line\">| character_set_results                | utf8                       |</span><br><span class=\"line\">| character_set_server                 | utf8                       |</span><br><span class=\"line\">| character_set_system                 | utf8                       |</span><br><span class=\"line\">| character_sets_dir                   | /usr/share/mysql/charsets/ |</span><br><span class=\"line\">| validate_password_special_char_count | 1                          |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------------------+----------------------------+</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> character_set_client=utf8;</span><br></pre></td></tr></table></figure><br>mysql 数据库中文乱码是因为数据库默认的编码方式是 latin1<br>解决办法就是将其手动改为utf8即可<br><em>但是</em>这只是临时办法，变量只是session级别的存储，数据库重启之后就没了<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/mysql/my.cnf</span><br><span class=\"line\">or</span><br><span class=\"line\">sudo vim /etc/my.cnf</span><br></pre></td></tr></table></figure><br>在my.cnf 文件里面配置数据库的编码集<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">default-character-set=utf8</span><br></pre></td></tr></table></figure></p>\n<p>备份数据<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldump -udbusername -pdbpwd dbname &gt; ./epoos.sql</span><br><span class=\"line\">scp -r root@xxx.193.173.xx:/xxx/xxx/xxx/epoos.sql /Users/zsr/epoos </span><br></pre></td></tr></table></figure></p>\n<p>还原数据<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -h127.0.0.1 -uroot -p123456 epoos &lt; epoos.sql</span><br></pre></td></tr></table></figure></p>\n<p>如果上面的还原功能不好使，可以<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.创建新数据库 newdb</span><br><span class=\"line\">2.use newdb</span><br><span class=\"line\">3.执行备份的sql文件</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ubuntu安装mysql\"><a href=\"#ubuntu安装mysql\" class=\"headerlink\" title=\"ubuntu安装mysql\"></a>ubuntu安装mysql</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update </span><br><span class=\"line\">sudo apt-get install mysql-server # 安装 mysql 服务端</span><br><span class=\"line\">mysql_secure_installation # mysql 安装安全配置向导，设置密码</span><br></pre></td></tr></table></figure>\n<p>执行安全配置向导可能报如下错误：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 报错信息</span></span><br><span class=\"line\">Error: Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27;</span><br></pre></td></tr></table></figure><br>解决方案：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -iu root # 用 root 用户执行此命令即可</span><br><span class=\"line\">mysql_secure_installation</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 中文解释</span></span><br><span class=\"line\">1)为root用户设置密码；</span><br><span class=\"line\">2)删除匿名账号；</span><br><span class=\"line\">3)取消root用户远程登录；</span><br><span class=\"line\">4)删除test库和对test库的访问权限；</span><br><span class=\"line\">5)刷新授权表使修改生效。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"新建新用户\"><a href=\"#新建新用户\" class=\"headerlink\" title=\"新建新用户\"></a>新建新用户</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 创建 dev 用户</span></span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span><span class=\"bash\"> CREATE USER dev@% IDENTIFIED BY <span class=\"string\">&#x27;Abc123456!&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 给用户 dev 所有数据库的权限</span></span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span><span class=\"bash\"> grant all PRIVILEGES on *.* to <span class=\"string\">&#x27;dev&#x27;</span>@<span class=\"string\">&#x27;%&#x27;</span> IDENTIFIED BY <span class=\"string\">&quot;Abc123456!&quot;</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 刷新配置</span></span><br><span class=\"line\">flush privileges; </span><br></pre></td></tr></table></figure>\n<h4 id=\"远程端口不通\"><a href=\"#远程端口不通\" class=\"headerlink\" title=\"远程端口不通\"></a>远程端口不通</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 测试端口是否通顺</span></span><br><span class=\"line\">telnet 10.216.8.142 3306</span><br></pre></td></tr></table></figure>\n<p>mysql 数据库经常会遇到本地能连通但是其它机器通过 ip 访问的时候就不通的情况。<br>排查可以从下面三种情形入手（具体方式可以网上搜一搜，很多，这里就不列了）</p>\n<p>这种情形比较常见的原因有三个：<br>1.机器防火墙 3306 端口没有开<br>2.登录的数据库用户没有开 ip 访问的权限，找到user表，赋予其 % 权限。<br>3.数据库初始的时候地址没有注释掉 bind-address</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这个文件配置可能在/etc/my.cnf/;/etc/mysql/my.cnf;也可能在 /etc/mysql/mysql.conf.d</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 具体情形根据系统有所不同，但是只需要找到 bind-address 将其注释掉即可</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">bind-address\t\t= 127.0.0.1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"卸载mysql\"><a href=\"#卸载mysql\" class=\"headerlink\" title=\"卸载mysql\"></a>卸载mysql</h4><p>把下面几个目录全部删掉应该就可以完全卸载mysql了<br>值得注意的是，如果有数据库需要备份的，需提前做好备份。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf ~/Library/PreferencePanes/My*</span><br><span class=\"line\">sudo rm -rf /Library/Receipts/mysql*</span><br><span class=\"line\">sudo rm -rf /Library/Receipts/MySQL*</span><br><span class=\"line\">sudo rm -rf /var/db/receipts/com.mysql.*</span><br><span class=\"line\"></span><br><span class=\"line\">sudo rm /usr/local/mysql</span><br><span class=\"line\">sudo rm -rf /usr/local/mysql*</span><br><span class=\"line\">sudo rm -rf /Library/StartupItems/MySQLCOM</span><br><span class=\"line\">sudo rm -rf /Library/PreferencePanes/My* </span><br></pre></td></tr></table></figure>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://dev.mysql.com/doc/refman/5.6/en/linux-installation.html\">https://dev.mysql.com/doc/refman/5.6/en/linux-installation.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Mysql 是最流行的关系型数据库管理系统，尤其是在Web应用方面。<br>Mysql,由瑞典MySQL AB公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。<br>Mysql是开源的、免费的、支持大型的数据库<br>Mysql使用标准的SQL数据语言形式。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps: $&#123; xxx &#125; 表示 xxx 是变量</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"mysql安装\"><a href=\"#mysql安装\" class=\"headerlink\" title=\"mysql安装\"></a>mysql安装</h3><p>Mac 系统用 brew 安装mysql</p>\n<p>安装mysql<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew update # 更新下brew</span><br><span class=\"line\">brew install mysql # brew安装 mysql</span><br></pre></td></tr></table></figure></p>\n<p>设置 MySQL 用户以及数据存放地址<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ unset TMPDIR</span><br><span class=\"line\"></span><br><span class=\"line\">$ mysql_install_db --verbose --user=`whoami` --basedir=&quot;$(brew --prefix mysql)&quot; --datadir=/usr/local/var/mysql --tmpdir=/tmp</span><br></pre></td></tr></table></figure></p>\n<p>忘记mysql数据库密码<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">user</span> <span class=\"keyword\">set</span> authentication_string=<span class=\"keyword\">password</span>(<span class=\"string\">&#x27;my_password&#x27;</span>) <span class=\"keyword\">where</span> <span class=\"keyword\">user</span>=<span class=\"string\">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure></p>\n<p>修改密码<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">PASSWORD</span> <span class=\"keyword\">FOR</span> <span class=\"string\">&#x27;root&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span> = <span class=\"keyword\">PASSWORD</span>(<span class=\"string\">&#x27;newpass&#x27;</span>);</span><br></pre></td></tr></table></figure></p>\n<p>可能遇到的问题</p>\n<p>错误码：ERROR 1045 (28000)<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /etc</span><br><span class=\"line\"></span><br><span class=\"line\">sudo vim my.cnf</span><br><span class=\"line\"></span><br><span class=\"line\">编辑如下代码到 my.cnf 文件,保存成功应该就可以了</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">skip-grant-tables</span><br><span class=\"line\">lower_case_table_names=1</span><br></pre></td></tr></table></figure></p>\n<p>权限不足的时候可以创建一个账号<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> <span class=\"string\">&#x27;golden&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span> <span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;password&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">ALL</span> <span class=\"keyword\">PRIVILEGES</span> <span class=\"keyword\">ON</span> * . * <span class=\"keyword\">TO</span> <span class=\"string\">&#x27;golden&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">FLUSH</span> <span class=\"keyword\">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>启动mysql<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql.server start</span><br><span class=\"line\">sudo /etc/init.d/mysql start </span><br><span class=\"line\"></span><br><span class=\"line\">or</span><br><span class=\"line\"></span><br><span class=\"line\">sudo /usr/local/mysql/support-files/mysql.server start;</span><br></pre></td></tr></table></figure></p>\n<p>开机启动mysql<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/mysqld start</span><br></pre></td></tr></table></figure></p>\n<p>通过sql文件执行脚本<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source  /Users/zsr/learn/crawler/sql/createtable.sql; </span><br><span class=\"line\"></span><br><span class=\"line\">or </span><br><span class=\"line\"></span><br><span class=\"line\">mysql -D samp_db -u root -p &lt; createtable.sql</span><br></pre></td></tr></table></figure></p>\n<p>登录 mysql<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u $&#123; databasename &#125; -p # 然后输入mysql密码</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>创建一个数据库，设置character是为了兼容汉字<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">database</span> $&#123;newdatabasename&#125; <span class=\"built_in\">character</span> <span class=\"keyword\">set</span> gbk;</span><br></pre></td></tr></table></figure></p>\n<p>查看所有的数据库<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">databases</span>;</span><br></pre></td></tr></table></figure></p>\n<p>删除数据库<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">database</span> $&#123;databasename&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>选中 testdb 数据库<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> $&#123;databasename&#125;;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>创建一张表<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> $&#123;databasename&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> students</span><br><span class=\"line\">（</span><br><span class=\"line\">\t<span class=\"keyword\">id</span> <span class=\"built_in\">int</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span> auto_increment primary <span class=\"keyword\">key</span>,</span><br><span class=\"line\">\t<span class=\"keyword\">name</span> <span class=\"built_in\">char</span>(<span class=\"number\">8</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\tsex <span class=\"built_in\">char</span>(<span class=\"number\">4</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\tage <span class=\"built_in\">tinyint</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\ttel <span class=\"built_in\">char</span>(<span class=\"number\">13</span>) <span class=\"literal\">null</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;-&quot;</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>修改表名<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> $&#123;oldtablename&#125; <span class=\"keyword\">rename</span> <span class=\"keyword\">to</span> $&#123;newtablename&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>查看所有表<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span>;</span><br></pre></td></tr></table></figure></p>\n<p>删除表<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> $&#123;tabename&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>显示数据表的属性，属性类型，主键信息<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">columns</span> <span class=\"keyword\">from</span> students</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>查看列<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">desc $&#123;tablename&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>添加列<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> $&#123;tablename&#125; <span class=\"keyword\">add</span> <span class=\"keyword\">column</span> $&#123;newcolumnname&#125; <span class=\"built_in\">varchar</span>(<span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure></p>\n<p>删除列<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> $&#123;tablename&#125; <span class=\"keyword\">drop</span> <span class=\"keyword\">column</span> $&#123;columnname&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>修改列名<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> $&#123;tablename&#125; <span class=\"keyword\">change</span> $&#123;ondcolumnname&#125; $&#123;newcolumnname&#125; <span class=\"built_in\">int</span>; </span><br></pre></td></tr></table></figure></p>\n<p>修改列属性<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> $&#123;tablename&#125; <span class=\"keyword\">modify</span> $&#123;oldattr&#125; <span class=\"built_in\">char</span>(<span class=\"number\">80</span>);</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>增加数据<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> $&#123;tablename&#125; <span class=\"keyword\">values</span> ($&#123;column1&#125;, $&#123;column2&#125;); <span class=\"comment\">/*如果自增id，则column1为0*/</span></span><br></pre></td></tr></table></figure></p>\n<p>修改数据<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> $&#123;tablename&#125; <span class=\"keyword\">set</span> $&#123;<span class=\"keyword\">attr</span>&#125;=$&#123;newAttr&#125; <span class=\"keyword\">where</span> $&#123;<span class=\"keyword\">id</span>=<span class=\"number\">3</span>&#125;; <span class=\"comment\">/*id=3代表查询条件*/</span></span><br></pre></td></tr></table></figure></p>\n<p>查询数据<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> $&#123;tablename&#125; <span class=\"keyword\">where</span> $&#123;<span class=\"keyword\">id</span>=<span class=\"number\">3</span>&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>删除数据<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> $&#123;tablename&#125; <span class=\"keyword\">where</span> $&#123;<span class=\"keyword\">id</span>=<span class=\"number\">3</span>&#125;;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>详细的常用查询操作<br>1.查询从第n条开始的m条数据、asc 升序(desc 降序)<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> $&#123;tablename&#125; <span class=\"keyword\">limit</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">select</span> $&#123;column1&#125;,$&#123;column2&#125; <span class=\"keyword\">from</span> $&#123;tablename&#125; <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> $&#123;<span class=\"keyword\">column</span>&#125; <span class=\"keyword\">asc</span> <span class=\"keyword\">limit</span> n,m</span><br><span class=\"line\"><span class=\"keyword\">select</span> $&#123;column1&#125;,$&#123;column2&#125; <span class=\"keyword\">from</span> $&#123;tablename&#125; <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> $&#123;<span class=\"keyword\">column</span>&#125; <span class=\"keyword\">desc</span> <span class=\"keyword\">limit</span> n,m</span><br></pre></td></tr></table></figure></p>\n<p>查看数据库编码<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;character%&#x27;</span>; </span><br></pre></td></tr></table></figure></p>\n<p>查看数据库位置<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">&#x27;datadir%&#x27;</span></span><br></pre></td></tr></table></figure></p>\n<p>数据库中文乱码<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%char%&#x27;;</span><br><span class=\"line\">+<span class=\"comment\">--------------------------------------+----------------------------+</span></span><br><span class=\"line\">| Variable_name                        | Value                      |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------------------+----------------------------+</span></span><br><span class=\"line\">| character_set_client                 | latin1                       |</span><br><span class=\"line\">| character_set_connection             | utf8                       |</span><br><span class=\"line\">| character_set_database               | utf8                       |</span><br><span class=\"line\">| character_set_filesystem             | binary                     |</span><br><span class=\"line\">| character_set_results                | utf8                       |</span><br><span class=\"line\">| character_set_server                 | utf8                       |</span><br><span class=\"line\">| character_set_system                 | utf8                       |</span><br><span class=\"line\">| character_sets_dir                   | /usr/share/mysql/charsets/ |</span><br><span class=\"line\">| validate_password_special_char_count | 1                          |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------------------+----------------------------+</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> character_set_client=utf8;</span><br></pre></td></tr></table></figure><br>mysql 数据库中文乱码是因为数据库默认的编码方式是 latin1<br>解决办法就是将其手动改为utf8即可<br><em>但是</em>这只是临时办法，变量只是session级别的存储，数据库重启之后就没了<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/mysql/my.cnf</span><br><span class=\"line\">or</span><br><span class=\"line\">sudo vim /etc/my.cnf</span><br></pre></td></tr></table></figure><br>在my.cnf 文件里面配置数据库的编码集<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">default-character-set=utf8</span><br></pre></td></tr></table></figure></p>\n<p>备份数据<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldump -udbusername -pdbpwd dbname &gt; ./epoos.sql</span><br><span class=\"line\">scp -r root@xxx.193.173.xx:/xxx/xxx/xxx/epoos.sql /Users/zsr/epoos </span><br></pre></td></tr></table></figure></p>\n<p>还原数据<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -h127.0.0.1 -uroot -p123456 epoos &lt; epoos.sql</span><br></pre></td></tr></table></figure></p>\n<p>如果上面的还原功能不好使，可以<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.创建新数据库 newdb</span><br><span class=\"line\">2.use newdb</span><br><span class=\"line\">3.执行备份的sql文件</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ubuntu安装mysql\"><a href=\"#ubuntu安装mysql\" class=\"headerlink\" title=\"ubuntu安装mysql\"></a>ubuntu安装mysql</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update </span><br><span class=\"line\">sudo apt-get install mysql-server # 安装 mysql 服务端</span><br><span class=\"line\">mysql_secure_installation # mysql 安装安全配置向导，设置密码</span><br></pre></td></tr></table></figure>\n<p>执行安全配置向导可能报如下错误：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 报错信息</span></span><br><span class=\"line\">Error: Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27;</span><br></pre></td></tr></table></figure><br>解决方案：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -iu root # 用 root 用户执行此命令即可</span><br><span class=\"line\">mysql_secure_installation</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 中文解释</span></span><br><span class=\"line\">1)为root用户设置密码；</span><br><span class=\"line\">2)删除匿名账号；</span><br><span class=\"line\">3)取消root用户远程登录；</span><br><span class=\"line\">4)删除test库和对test库的访问权限；</span><br><span class=\"line\">5)刷新授权表使修改生效。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"新建新用户\"><a href=\"#新建新用户\" class=\"headerlink\" title=\"新建新用户\"></a>新建新用户</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 创建 dev 用户</span></span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span><span class=\"bash\"> CREATE USER dev@% IDENTIFIED BY <span class=\"string\">&#x27;Abc123456!&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 给用户 dev 所有数据库的权限</span></span><br><span class=\"line\"><span class=\"meta\">mysql&gt;</span><span class=\"bash\"> grant all PRIVILEGES on *.* to <span class=\"string\">&#x27;dev&#x27;</span>@<span class=\"string\">&#x27;%&#x27;</span> IDENTIFIED BY <span class=\"string\">&quot;Abc123456!&quot;</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 刷新配置</span></span><br><span class=\"line\">flush privileges; </span><br></pre></td></tr></table></figure>\n<h4 id=\"远程端口不通\"><a href=\"#远程端口不通\" class=\"headerlink\" title=\"远程端口不通\"></a>远程端口不通</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 测试端口是否通顺</span></span><br><span class=\"line\">telnet 10.216.8.142 3306</span><br></pre></td></tr></table></figure>\n<p>mysql 数据库经常会遇到本地能连通但是其它机器通过 ip 访问的时候就不通的情况。<br>排查可以从下面三种情形入手（具体方式可以网上搜一搜，很多，这里就不列了）</p>\n<p>这种情形比较常见的原因有三个：<br>1.机器防火墙 3306 端口没有开<br>2.登录的数据库用户没有开 ip 访问的权限，找到user表，赋予其 % 权限。<br>3.数据库初始的时候地址没有注释掉 bind-address</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这个文件配置可能在/etc/my.cnf/;/etc/mysql/my.cnf;也可能在 /etc/mysql/mysql.conf.d</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 具体情形根据系统有所不同，但是只需要找到 bind-address 将其注释掉即可</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">bind-address\t\t= 127.0.0.1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"卸载mysql\"><a href=\"#卸载mysql\" class=\"headerlink\" title=\"卸载mysql\"></a>卸载mysql</h4><p>把下面几个目录全部删掉应该就可以完全卸载mysql了<br>值得注意的是，如果有数据库需要备份的，需提前做好备份。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf ~/Library/PreferencePanes/My*</span><br><span class=\"line\">sudo rm -rf /Library/Receipts/mysql*</span><br><span class=\"line\">sudo rm -rf /Library/Receipts/MySQL*</span><br><span class=\"line\">sudo rm -rf /var/db/receipts/com.mysql.*</span><br><span class=\"line\"></span><br><span class=\"line\">sudo rm /usr/local/mysql</span><br><span class=\"line\">sudo rm -rf /usr/local/mysql*</span><br><span class=\"line\">sudo rm -rf /Library/StartupItems/MySQLCOM</span><br><span class=\"line\">sudo rm -rf /Library/PreferencePanes/My* </span><br></pre></td></tr></table></figure>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://dev.mysql.com/doc/refman/5.6/en/linux-installation.html\">https://dev.mysql.com/doc/refman/5.6/en/linux-installation.html</a></p>\n"},{"title":"Mysql入门(二)","date":"2019-02-12T16:00:00.000Z","_content":"\n### 字段类型与合理的选择字段类型\n\n转载自：\nhttps://www.kancloud.cn/thinkphp/mysql-design-optimalize/39325\n\n### 字段类型\n\n#### 数值\nMySQL 的数值数据类型可以大致划分为两个类别，一个是整数，另一个是浮点数或小数。\n许多不同的子类型对这些类别中的每一个都是可用的，每个子类型支持不同大小的数据，并且 MySQL 允许我们指定数值字段中的值是否有正负之分(UNSIGNED)或者用零填补(ZEROFILL)。\n\n<img src=\"http://zhoushirong.github.io/img/mysql1.png\" alt=\"mysql\" width=\"867\" height=\"684\">\n\n\n- INT\n在 MySQL 中支持的 5 个主要整数类型是 TINYINT，SMALLINT，MEDIUMINT，INT 和 BIGINT。这些类型在很大程度上是相同的，只有它们存储的值的大小是不相同的。\n\nMySQL 以一个可选的显示宽度指示器的形式对 SQL 标准进行扩展(如 INT(6),6即是其宽度指示器,**该宽度指示器并不会影响int列存储字段的大小,也就是说,超过6位它不会自动截取,依然会存储,只有超过它本身的存储范围才会截取;此处宽度指示器的作用在于该字段是否有zerofill,如果有就未满足6位的部分就会用0来填充)**，这样当从数据库检索一个值时，可以把这个值加长到指定的长度。例如，指定一个字段的类型为 INT(6)，就可以保证所包含数字少于 6 个的值从数据库中检索出来时能够自动地用空格填充。需要注意的是，使用一个宽度指示器不会影响字段的大小和它可以存储的值的范围。\n\n万一我们需要对一个字段存储一个超出许可范围的数字，MySQL 会根据允许范围最接近它的一端截短后再进行存储。还有一个比较特别的地方是，MySQL 会在不合规定的值插入表前自动修改为 0。\n\n- unsigned 和 zerofill\nUNSIGNED 修饰符规定字段只保存正值,即无符号,而mysql字段默认是有符号的。因为不需要保存数字的正、负符号，可以在储时节约一个\"位\"的空间(即翻一倍)。从而增大这个字段可以存储的值的范围。注意这个修饰符要紧跟在数值类型后面;\nZEROFILL 修饰符规定 0（不是空格）可以用来真补输出的值。使用这个修饰符可以阻止 MySQL 数据库存储负值,如果某列设置为zerofill,那它自动就unsigned。这个值要配合int,tinyint,smallint,midiumint等字段的宽度指示器来用;XXint(M),如果没有zerofill,这个M的宽度指示器是没有意义的.(注意,测试前导0的时候,还是去黑窗口测试;)\n\n```html\n为什么mysql存储的值要分有符号和无符号呢?因为一个字节,占8bit;也就1个bit有0和1两种可能,8个bit就是2^8 = 256种可能,也就是0~255;但如果是有符号的话,就得拿一个1bit来存储这个负号,本来8bit只剩7bit,2^7 = 128,也就是-128~127(正数部分包含一个0);\n```\n- FLOAT、DOUBLE 和 DECIMAL 类型\nMySQL 支持的三个浮点类型是 FLOAT、DOUBLE 和 DECIMAL 类型。FLOAT 数值类型用于表示单精度浮点数值，而 DOUBLE 数值类型用于表示双精度浮点数值。\n与整数一样，这些类型也带有附加参数：一个显示宽度指示器和一个小数点指示器(必须要带有指示器,要不然会查不到结果,**并且宽度指示器和XXint类型的宽度指示器不同,这里是有实际限制宽度的)。**比如语句 FLOAT(7,3) 规定显示的值不会超过 7 位数字(包括小数位)，小数点后面带有 3 位数字。对于小数点后面的位数超过允许范围的值，MySQL 会自动将它四舍五入为最接近它的值，再插入它。\nDECIMAL 数据类型用于精度要求非常高的计算中，这种类型允许指定数值的精度和计数方法作为选择参数。精度在这里指为这个值保存的有效数字的总个数，而计数方法表示小数点后数字的位数。比如语句 DECIMAL(7,3) 规定了存储的值不会超过 7 位数字，并且小数点后不超过 3 位。\nFLOAT 类型在长度比较高比如 float(10,2)和 decimal(10,2)同时插入一个符合(10,2)宽度的数值,float 就会出现最后小数点出现一些出入;\nUNSIGNED 和 ZEROFILL 修饰符也可以被 FLOAT、DOUBLE 和 DECIMAL 数据类型使用。并且效果与 INT 数据类型相同。\n\n```html\n关于flaot和double\n在这里我建议,干脆忘记mysql有double这个数据类型。至于why？就不要管它了\n```\n\n#### 字符串类型\nMySQL 提供了 8 个基本的字符串类型，可以存储的范围从简单的一个字符到巨大的文本块或二进制字符串数据。\n\n<img src=\"http://zhoushirong.github.io/img/mysql1.png\" alt=\"mysql\" width=\"895\" height=\"523\">\n\n- BINARY\nBINARY不是函数，是类型转换运算符，它用来强制它后面的字符串为一个二进制字符串，可以理解为在字符串比较的时候区分大小写\n```sql\nSELECT BINARY 'ABCD' = 'abcd' as COM1,'ABCD' = 'abcd' as COM2; -- COM1输出为0,COM2输出为1;\n```\n- CHAR 和 VARCHAR 类型\nCHAR 类型用于定长字符串，并且必须在圆括号内用一个大小修饰符来定义。这个大小修饰符的范围从 0-255。比指定长度大的值将被截短，而比指定长度小的值将会用空格作填补。\n\nCHAR 类型可以使用 BINARY 修饰符。当用于比较运算时，这个修饰符使 CHAR 以二进制方式参于运算，而不是以传统的区分大小写的方式。\n\nCHAR 类型的一个变体是 VARCHAR 类型。它是一种可变长度的字符串类型，并且也必须带有一个范围在 0-255 之间的指示器。\n\nCHAR 和 VARCHGAR 不同之处在于 MYSQL 数据库处理这个指示器的方式：CHAR 把这个大小视为值的大小，不长度不足的情况下就用空格补足。而 VARCHAR 类型把它视为最大值并且只使用存储字符串实际需要的长度（增加一个额外字节来存储字符串本身的长度）来存储值。所以短于指示器长度的 VARCHAR 类型不会被空格填补，但长于指示器的值仍然会被截短。\n\n因为 VARCHAR 类型可以根据实际内容动态改变存储值的长度，所以在不能确定字段需要多少字符时使用 VARCHAR 类型可以大大地节约磁盘空间、提高存储效率。**但如果确切知道字符串长度,比如就在50~55之间,那就用 CHAR 因为 CHAR 类型由于本身定长的特性使其性能要高于 VARCHAR;**\n\nVARCHAR 类型在使用 BINARY 修饰符时与 CHAR 类型完全相同。\n\n- TEXT 和 BLOB 类型\n对于字段长度要求超过 255 个的情况下，MySQL 提供了 TEXT 和 BLOB 两种类型。根据存储数据的大小，它们都有不同的子类型。这些大型的数据用于存储文本块或图像、声音文件等二进制数据类型。\n\nTEXT 和 BLOB 类型在分类和比较上存在区别。BLOB 类型区分大小写，而 TEXT 不区分大小写。大小修饰符不用于各种 BLOB 和 TEXT 子类型。比指定类型支持的最大范围大的值将被自动截短。\n\n#### 时间类型\n在处理日期和时间类型的值时，MySQL 带有 5 个不同的数据类型可供选择。\n\n<img src=\"http://zhoushirong.github.io/img/mysql3.png\" alt=\"mysql\" width=\"868\" height=\"320\">\n\n- DATE、TIME 和 YEAR 类型\nMySQL 用 DATE 和 YEAR 类型存储简单的日期值，使用 TIME 类型存储时间值。这些类型可以描述为字符串或不带分隔符的整数序列。如果描述为字符串，DATE 类型的值应该使用连字号作为分隔符分开，而 TIME 类型的值应该使用冒号作为分隔符分开。\n\n**需要注意的是，没有冒号分隔符的 TIME 类型值，将会被 MySQL 理解为持续的时间，而不是时间戳。**\nMySQL 还对日期的年份中的两个数字的值，或是 SQL 语句中为 YEAR 类型输入的两个数字进行最大限度的通译。因为所有 YEAR 类型的值必须用 4 个数字存储。MySQL 试图将 2 个数字的年份转换为 4 个数字的值。把在 00-69 范围内的值转换到 2000-2069 范围内。把 70-99 范围内的值转换到 1970-1979 之内。如果 MySQL 自动转换后的值并不符合我们的需要，请输入 4 个数字表示的年份。\n\n- DATETIME 和 TIMESTAMP 类型\n除了日期和时间数据类型，MySQL 还支持 DATETIME 和 TIMESTAMP 这两种混合类型。它们可以把日期和时间作为单个的值进行存储。这两种类型通常用于自动存储包含当前日期和时间的时间戳，并可在需要执行大量数据库事务和需要建立一个调试和审查用途的审计跟踪的应用程序中发挥良好作用。\n\n```html\n如果我们对 TIMESTAMP 类型的字段没有明确赋值，或是被赋与了 null 值。MySQL 会自动使用系统当前的日期和时间来填充它。\n```\n\n#### 复合类型\nMySQL 还支持两种复合数据类型 ENUM 和 SET，它们扩展了 SQL 规范。虽然这些类型在技术上是字符串类型，但是可以被视为不同的数据类型。一个 ENUM 类型只允许从一个集合中取得一个值；而 SET 类型允许从一个集合中取得任意多个值。\n\n- ENUM 类型\nENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。ENUM 类型字段可以从集合中取得一个值或使用 null 值，除此之外的输入将会使 MySQL 在这个字段中插入一个空字符串。另外如果插入值的大小写与集合中值的大小写不匹配，MySQL 会自动使用插入值的大小写转换成与集合中大小写一致的值。\n\nENUM 类型在系统内部可以存储为数字，并且从 1 开始用数字做索引。一个 ENUM 类型最多可以包含 65536 个元素，其中一个元素被 MySQL 保留，用来存储错误信息，这个错误值用索引 0 或者一个空字符串表示。\n\nMySQL 认为 ENUM 类型集合中出现的值是合法输入，除此之外其它任何输入都将失败。这说明通过搜索包含空字符串或对应数字索引为 0 的行就可以很容易地找到错误记录的位置。\n\n- SET 类型\nSET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。并且与 ENUM 类型相同的是任何试图在 SET 类型字段中插入非预定义的值都会使 MySQL 插入一个空字符串。**如果插入一个即有合法的元素又有非法的元素的记录，MySQL 将会保留合法的元素，除去非法的元素。**\n一个 SET 类型最多可以包含 64 项元素。还去除了重复的元素，所以 SET 类型中不可能包含两个相同的元素。\n希望从 SET 类型字段中找出非法的记录只需查找包含空字符串或二进制值为 0 的行。\n\n\n### 字段类型总结\n1.虽然上面列出了很多字段类型,但最常用也就是 varchar(255),char(255),text,tinyint(4),smallint(6),mediumint,int(11)几种。\n2.复合类型我们一般用tinyint,更快的时间更省的空间以及更容易扩展\n3.关于手机号，推荐用char(11),char(11)在查询上更有效率，因为手机号是一个活跃字段参与逻辑会很多。\n4.一些常用字段举例\n姓名：char(20)\n价格：DECIMAL(7, 3)\n产品序列号：SMALLINT(5) unsigned\n文章内容: TEXT\nMD5: CHAR(32)\nip: char(15)\ntime: int(10)\nemail char(32)\n\n### 合理的选择数据类型\n- 选择合理范围内最小的\n我们应该选择最小的数据范围，因为这样可以大大减少磁盘空间及磁盘I/0读写开销，减少内存占用，减少CPU的占用率。\n\n- 选择相对简单的数据类型\n数字类型相对字符串类型要简单的多，尤其是在比较运算时，所以我们应该选择最简单的数据类型，比如说在保存时间时，因为PHP可以良好的处理LINUX时间戳所以我们可以将日期存为int(10)要方便、合适、快速的多。\n\n```html\n但是，工作中随着项目越做越多，业务逻辑的处理越来越难以后，我发现时间类型还是用时间类型本身的字段类型要好一些，因为mysql有着丰富的时间函数供我使用，方便我完成很多与时间相关的逻辑，比如月排行榜，周排行榜，当日热门，生日多少天等等逻辑\n```\n- 不要使用null\n为什么这么说呢，因为MYSQL对NULL字段索引优化不佳，增加更多的计算难度，同时在保存与处理NULL类形时，也会做更多的工作，所以从效率上来说，不建议用过多的NULL。有些值他确实有可能没有值，怎么办呢？解决方法是数值弄用整数0，字符串用空来定义默认值即可。\n\n- 字符串类型的使用\n字符串数据类型是一个万能数据类型，可以储存数值、字符串、日期等。\n保存数值类型最好不要用字符串数据类型，这样存储的空间显然是会更大，而且在排序时字符串的9是大于22的，其实如果进行运算时mysql会将字符串转换为数值类型，大大降低效果，而且这种转换是不会走原有的索引的。\n如果明确数据在一个完整的集合中如男，女，那么可以使用set或enum数据类型，这种数据类型在运算及储存时以数值方式操作，所以效率要比字符串更好，同时空间占用更少。\n\n- VARCHAR与CHAR\nVARCHAR是可变长度字符串类型，那么即然长度是可变的就会使用1，2个字节来保存字符的长度，如果长度在255内使用1个字节来保存字符长度，否则使用2个字符来保存长度。由于varchar是根据储存的值来保存数据，所以可以大大节约磁盘空间。\n如果数据经常被执行更新操作，由于VARCHAR是根据内容来进行储存的，所以mysql将做更多的工作来完成更新操作，如果新数据长度大于老数据长度一些存储引擎会进行拆分操作处理。同时varchar会完全保留内部所有数据，最典型的说明就是尾部的空格。\nCHAR固定长度的字符串保存类型，CHAR会去掉尾部的空格。在数据长度相近时使用char类型比较合适，比如md5加密的密码用户名等。\n如果数据经常进行更新修改操作，那么CHAR更好些，因为char长度固定，性能上要快。\n\n- 数值类型的选择\n数值数据类型要比字符串执行更快，区间小的数据类型占用空间更少，处理速度更快，如tinyint可比bigint要快的多\n选择数据类型时要考虑内容长度，比如是保存毫米单位还是米而选择不同的数值类型\n\n##### 整数\n整数类型很多比如tinyint、int、smallint、bigint等，那么我们要根据自己需要存储的数据长度决定使用的类型，同时tinyint(10)与tinyint(100)在储存与计算上并无任何差别，区别只是显示层面上，但是我们也要选择适合合适的数据类型长度。可以通过指定zerofill属性查看显示时区别。\n\n##### 浮点数与精度数值\n浮点数float在储存空间及运行效率上要优于精度数值类型decimal，但float与double会有舍入错误而decimal则可以提供更加准确的小数级精确运算不会有错误产生计算更精确，适用于金融类型数据的存储。\n\n\n","source":"_posts/mysql2.md","raw":"---\ntitle: Mysql入门(二)\ntag: [mysql, 数据库, sql]\ndate: 2019/02/13\ncategory: 技术\n---\n\n### 字段类型与合理的选择字段类型\n\n转载自：\nhttps://www.kancloud.cn/thinkphp/mysql-design-optimalize/39325\n\n### 字段类型\n\n#### 数值\nMySQL 的数值数据类型可以大致划分为两个类别，一个是整数，另一个是浮点数或小数。\n许多不同的子类型对这些类别中的每一个都是可用的，每个子类型支持不同大小的数据，并且 MySQL 允许我们指定数值字段中的值是否有正负之分(UNSIGNED)或者用零填补(ZEROFILL)。\n\n<img src=\"http://zhoushirong.github.io/img/mysql1.png\" alt=\"mysql\" width=\"867\" height=\"684\">\n\n\n- INT\n在 MySQL 中支持的 5 个主要整数类型是 TINYINT，SMALLINT，MEDIUMINT，INT 和 BIGINT。这些类型在很大程度上是相同的，只有它们存储的值的大小是不相同的。\n\nMySQL 以一个可选的显示宽度指示器的形式对 SQL 标准进行扩展(如 INT(6),6即是其宽度指示器,**该宽度指示器并不会影响int列存储字段的大小,也就是说,超过6位它不会自动截取,依然会存储,只有超过它本身的存储范围才会截取;此处宽度指示器的作用在于该字段是否有zerofill,如果有就未满足6位的部分就会用0来填充)**，这样当从数据库检索一个值时，可以把这个值加长到指定的长度。例如，指定一个字段的类型为 INT(6)，就可以保证所包含数字少于 6 个的值从数据库中检索出来时能够自动地用空格填充。需要注意的是，使用一个宽度指示器不会影响字段的大小和它可以存储的值的范围。\n\n万一我们需要对一个字段存储一个超出许可范围的数字，MySQL 会根据允许范围最接近它的一端截短后再进行存储。还有一个比较特别的地方是，MySQL 会在不合规定的值插入表前自动修改为 0。\n\n- unsigned 和 zerofill\nUNSIGNED 修饰符规定字段只保存正值,即无符号,而mysql字段默认是有符号的。因为不需要保存数字的正、负符号，可以在储时节约一个\"位\"的空间(即翻一倍)。从而增大这个字段可以存储的值的范围。注意这个修饰符要紧跟在数值类型后面;\nZEROFILL 修饰符规定 0（不是空格）可以用来真补输出的值。使用这个修饰符可以阻止 MySQL 数据库存储负值,如果某列设置为zerofill,那它自动就unsigned。这个值要配合int,tinyint,smallint,midiumint等字段的宽度指示器来用;XXint(M),如果没有zerofill,这个M的宽度指示器是没有意义的.(注意,测试前导0的时候,还是去黑窗口测试;)\n\n```html\n为什么mysql存储的值要分有符号和无符号呢?因为一个字节,占8bit;也就1个bit有0和1两种可能,8个bit就是2^8 = 256种可能,也就是0~255;但如果是有符号的话,就得拿一个1bit来存储这个负号,本来8bit只剩7bit,2^7 = 128,也就是-128~127(正数部分包含一个0);\n```\n- FLOAT、DOUBLE 和 DECIMAL 类型\nMySQL 支持的三个浮点类型是 FLOAT、DOUBLE 和 DECIMAL 类型。FLOAT 数值类型用于表示单精度浮点数值，而 DOUBLE 数值类型用于表示双精度浮点数值。\n与整数一样，这些类型也带有附加参数：一个显示宽度指示器和一个小数点指示器(必须要带有指示器,要不然会查不到结果,**并且宽度指示器和XXint类型的宽度指示器不同,这里是有实际限制宽度的)。**比如语句 FLOAT(7,3) 规定显示的值不会超过 7 位数字(包括小数位)，小数点后面带有 3 位数字。对于小数点后面的位数超过允许范围的值，MySQL 会自动将它四舍五入为最接近它的值，再插入它。\nDECIMAL 数据类型用于精度要求非常高的计算中，这种类型允许指定数值的精度和计数方法作为选择参数。精度在这里指为这个值保存的有效数字的总个数，而计数方法表示小数点后数字的位数。比如语句 DECIMAL(7,3) 规定了存储的值不会超过 7 位数字，并且小数点后不超过 3 位。\nFLOAT 类型在长度比较高比如 float(10,2)和 decimal(10,2)同时插入一个符合(10,2)宽度的数值,float 就会出现最后小数点出现一些出入;\nUNSIGNED 和 ZEROFILL 修饰符也可以被 FLOAT、DOUBLE 和 DECIMAL 数据类型使用。并且效果与 INT 数据类型相同。\n\n```html\n关于flaot和double\n在这里我建议,干脆忘记mysql有double这个数据类型。至于why？就不要管它了\n```\n\n#### 字符串类型\nMySQL 提供了 8 个基本的字符串类型，可以存储的范围从简单的一个字符到巨大的文本块或二进制字符串数据。\n\n<img src=\"http://zhoushirong.github.io/img/mysql1.png\" alt=\"mysql\" width=\"895\" height=\"523\">\n\n- BINARY\nBINARY不是函数，是类型转换运算符，它用来强制它后面的字符串为一个二进制字符串，可以理解为在字符串比较的时候区分大小写\n```sql\nSELECT BINARY 'ABCD' = 'abcd' as COM1,'ABCD' = 'abcd' as COM2; -- COM1输出为0,COM2输出为1;\n```\n- CHAR 和 VARCHAR 类型\nCHAR 类型用于定长字符串，并且必须在圆括号内用一个大小修饰符来定义。这个大小修饰符的范围从 0-255。比指定长度大的值将被截短，而比指定长度小的值将会用空格作填补。\n\nCHAR 类型可以使用 BINARY 修饰符。当用于比较运算时，这个修饰符使 CHAR 以二进制方式参于运算，而不是以传统的区分大小写的方式。\n\nCHAR 类型的一个变体是 VARCHAR 类型。它是一种可变长度的字符串类型，并且也必须带有一个范围在 0-255 之间的指示器。\n\nCHAR 和 VARCHGAR 不同之处在于 MYSQL 数据库处理这个指示器的方式：CHAR 把这个大小视为值的大小，不长度不足的情况下就用空格补足。而 VARCHAR 类型把它视为最大值并且只使用存储字符串实际需要的长度（增加一个额外字节来存储字符串本身的长度）来存储值。所以短于指示器长度的 VARCHAR 类型不会被空格填补，但长于指示器的值仍然会被截短。\n\n因为 VARCHAR 类型可以根据实际内容动态改变存储值的长度，所以在不能确定字段需要多少字符时使用 VARCHAR 类型可以大大地节约磁盘空间、提高存储效率。**但如果确切知道字符串长度,比如就在50~55之间,那就用 CHAR 因为 CHAR 类型由于本身定长的特性使其性能要高于 VARCHAR;**\n\nVARCHAR 类型在使用 BINARY 修饰符时与 CHAR 类型完全相同。\n\n- TEXT 和 BLOB 类型\n对于字段长度要求超过 255 个的情况下，MySQL 提供了 TEXT 和 BLOB 两种类型。根据存储数据的大小，它们都有不同的子类型。这些大型的数据用于存储文本块或图像、声音文件等二进制数据类型。\n\nTEXT 和 BLOB 类型在分类和比较上存在区别。BLOB 类型区分大小写，而 TEXT 不区分大小写。大小修饰符不用于各种 BLOB 和 TEXT 子类型。比指定类型支持的最大范围大的值将被自动截短。\n\n#### 时间类型\n在处理日期和时间类型的值时，MySQL 带有 5 个不同的数据类型可供选择。\n\n<img src=\"http://zhoushirong.github.io/img/mysql3.png\" alt=\"mysql\" width=\"868\" height=\"320\">\n\n- DATE、TIME 和 YEAR 类型\nMySQL 用 DATE 和 YEAR 类型存储简单的日期值，使用 TIME 类型存储时间值。这些类型可以描述为字符串或不带分隔符的整数序列。如果描述为字符串，DATE 类型的值应该使用连字号作为分隔符分开，而 TIME 类型的值应该使用冒号作为分隔符分开。\n\n**需要注意的是，没有冒号分隔符的 TIME 类型值，将会被 MySQL 理解为持续的时间，而不是时间戳。**\nMySQL 还对日期的年份中的两个数字的值，或是 SQL 语句中为 YEAR 类型输入的两个数字进行最大限度的通译。因为所有 YEAR 类型的值必须用 4 个数字存储。MySQL 试图将 2 个数字的年份转换为 4 个数字的值。把在 00-69 范围内的值转换到 2000-2069 范围内。把 70-99 范围内的值转换到 1970-1979 之内。如果 MySQL 自动转换后的值并不符合我们的需要，请输入 4 个数字表示的年份。\n\n- DATETIME 和 TIMESTAMP 类型\n除了日期和时间数据类型，MySQL 还支持 DATETIME 和 TIMESTAMP 这两种混合类型。它们可以把日期和时间作为单个的值进行存储。这两种类型通常用于自动存储包含当前日期和时间的时间戳，并可在需要执行大量数据库事务和需要建立一个调试和审查用途的审计跟踪的应用程序中发挥良好作用。\n\n```html\n如果我们对 TIMESTAMP 类型的字段没有明确赋值，或是被赋与了 null 值。MySQL 会自动使用系统当前的日期和时间来填充它。\n```\n\n#### 复合类型\nMySQL 还支持两种复合数据类型 ENUM 和 SET，它们扩展了 SQL 规范。虽然这些类型在技术上是字符串类型，但是可以被视为不同的数据类型。一个 ENUM 类型只允许从一个集合中取得一个值；而 SET 类型允许从一个集合中取得任意多个值。\n\n- ENUM 类型\nENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。ENUM 类型字段可以从集合中取得一个值或使用 null 值，除此之外的输入将会使 MySQL 在这个字段中插入一个空字符串。另外如果插入值的大小写与集合中值的大小写不匹配，MySQL 会自动使用插入值的大小写转换成与集合中大小写一致的值。\n\nENUM 类型在系统内部可以存储为数字，并且从 1 开始用数字做索引。一个 ENUM 类型最多可以包含 65536 个元素，其中一个元素被 MySQL 保留，用来存储错误信息，这个错误值用索引 0 或者一个空字符串表示。\n\nMySQL 认为 ENUM 类型集合中出现的值是合法输入，除此之外其它任何输入都将失败。这说明通过搜索包含空字符串或对应数字索引为 0 的行就可以很容易地找到错误记录的位置。\n\n- SET 类型\nSET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。并且与 ENUM 类型相同的是任何试图在 SET 类型字段中插入非预定义的值都会使 MySQL 插入一个空字符串。**如果插入一个即有合法的元素又有非法的元素的记录，MySQL 将会保留合法的元素，除去非法的元素。**\n一个 SET 类型最多可以包含 64 项元素。还去除了重复的元素，所以 SET 类型中不可能包含两个相同的元素。\n希望从 SET 类型字段中找出非法的记录只需查找包含空字符串或二进制值为 0 的行。\n\n\n### 字段类型总结\n1.虽然上面列出了很多字段类型,但最常用也就是 varchar(255),char(255),text,tinyint(4),smallint(6),mediumint,int(11)几种。\n2.复合类型我们一般用tinyint,更快的时间更省的空间以及更容易扩展\n3.关于手机号，推荐用char(11),char(11)在查询上更有效率，因为手机号是一个活跃字段参与逻辑会很多。\n4.一些常用字段举例\n姓名：char(20)\n价格：DECIMAL(7, 3)\n产品序列号：SMALLINT(5) unsigned\n文章内容: TEXT\nMD5: CHAR(32)\nip: char(15)\ntime: int(10)\nemail char(32)\n\n### 合理的选择数据类型\n- 选择合理范围内最小的\n我们应该选择最小的数据范围，因为这样可以大大减少磁盘空间及磁盘I/0读写开销，减少内存占用，减少CPU的占用率。\n\n- 选择相对简单的数据类型\n数字类型相对字符串类型要简单的多，尤其是在比较运算时，所以我们应该选择最简单的数据类型，比如说在保存时间时，因为PHP可以良好的处理LINUX时间戳所以我们可以将日期存为int(10)要方便、合适、快速的多。\n\n```html\n但是，工作中随着项目越做越多，业务逻辑的处理越来越难以后，我发现时间类型还是用时间类型本身的字段类型要好一些，因为mysql有着丰富的时间函数供我使用，方便我完成很多与时间相关的逻辑，比如月排行榜，周排行榜，当日热门，生日多少天等等逻辑\n```\n- 不要使用null\n为什么这么说呢，因为MYSQL对NULL字段索引优化不佳，增加更多的计算难度，同时在保存与处理NULL类形时，也会做更多的工作，所以从效率上来说，不建议用过多的NULL。有些值他确实有可能没有值，怎么办呢？解决方法是数值弄用整数0，字符串用空来定义默认值即可。\n\n- 字符串类型的使用\n字符串数据类型是一个万能数据类型，可以储存数值、字符串、日期等。\n保存数值类型最好不要用字符串数据类型，这样存储的空间显然是会更大，而且在排序时字符串的9是大于22的，其实如果进行运算时mysql会将字符串转换为数值类型，大大降低效果，而且这种转换是不会走原有的索引的。\n如果明确数据在一个完整的集合中如男，女，那么可以使用set或enum数据类型，这种数据类型在运算及储存时以数值方式操作，所以效率要比字符串更好，同时空间占用更少。\n\n- VARCHAR与CHAR\nVARCHAR是可变长度字符串类型，那么即然长度是可变的就会使用1，2个字节来保存字符的长度，如果长度在255内使用1个字节来保存字符长度，否则使用2个字符来保存长度。由于varchar是根据储存的值来保存数据，所以可以大大节约磁盘空间。\n如果数据经常被执行更新操作，由于VARCHAR是根据内容来进行储存的，所以mysql将做更多的工作来完成更新操作，如果新数据长度大于老数据长度一些存储引擎会进行拆分操作处理。同时varchar会完全保留内部所有数据，最典型的说明就是尾部的空格。\nCHAR固定长度的字符串保存类型，CHAR会去掉尾部的空格。在数据长度相近时使用char类型比较合适，比如md5加密的密码用户名等。\n如果数据经常进行更新修改操作，那么CHAR更好些，因为char长度固定，性能上要快。\n\n- 数值类型的选择\n数值数据类型要比字符串执行更快，区间小的数据类型占用空间更少，处理速度更快，如tinyint可比bigint要快的多\n选择数据类型时要考虑内容长度，比如是保存毫米单位还是米而选择不同的数值类型\n\n##### 整数\n整数类型很多比如tinyint、int、smallint、bigint等，那么我们要根据自己需要存储的数据长度决定使用的类型，同时tinyint(10)与tinyint(100)在储存与计算上并无任何差别，区别只是显示层面上，但是我们也要选择适合合适的数据类型长度。可以通过指定zerofill属性查看显示时区别。\n\n##### 浮点数与精度数值\n浮点数float在储存空间及运行效率上要优于精度数值类型decimal，但float与double会有舍入错误而decimal则可以提供更加准确的小数级精确运算不会有错误产生计算更精确，适用于金融类型数据的存储。\n\n\n","slug":"mysql2","published":1,"updated":"2021-03-30T01:32:00.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufv0010a0vz2f3g2q58","content":"<h3 id=\"字段类型与合理的选择字段类型\"><a href=\"#字段类型与合理的选择字段类型\" class=\"headerlink\" title=\"字段类型与合理的选择字段类型\"></a>字段类型与合理的选择字段类型</h3><p>转载自：<br><a href=\"https://www.kancloud.cn/thinkphp/mysql-design-optimalize/39325\">https://www.kancloud.cn/thinkphp/mysql-design-optimalize/39325</a></p>\n<h3 id=\"字段类型\"><a href=\"#字段类型\" class=\"headerlink\" title=\"字段类型\"></a>字段类型</h3><h4 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h4><p>MySQL 的数值数据类型可以大致划分为两个类别，一个是整数，另一个是浮点数或小数。<br>许多不同的子类型对这些类别中的每一个都是可用的，每个子类型支持不同大小的数据，并且 MySQL 允许我们指定数值字段中的值是否有正负之分(UNSIGNED)或者用零填补(ZEROFILL)。</p>\n<p><img src=\"http://zhoushirong.github.io/img/mysql1.png\" alt=\"mysql\" width=\"867\" height=\"684\"></p>\n<ul>\n<li>INT<br>在 MySQL 中支持的 5 个主要整数类型是 TINYINT，SMALLINT，MEDIUMINT，INT 和 BIGINT。这些类型在很大程度上是相同的，只有它们存储的值的大小是不相同的。</li>\n</ul>\n<p>MySQL 以一个可选的显示宽度指示器的形式对 SQL 标准进行扩展(如 INT(6),6即是其宽度指示器,<strong>该宽度指示器并不会影响int列存储字段的大小,也就是说,超过6位它不会自动截取,依然会存储,只有超过它本身的存储范围才会截取;此处宽度指示器的作用在于该字段是否有zerofill,如果有就未满足6位的部分就会用0来填充)</strong>，这样当从数据库检索一个值时，可以把这个值加长到指定的长度。例如，指定一个字段的类型为 INT(6)，就可以保证所包含数字少于 6 个的值从数据库中检索出来时能够自动地用空格填充。需要注意的是，使用一个宽度指示器不会影响字段的大小和它可以存储的值的范围。</p>\n<p>万一我们需要对一个字段存储一个超出许可范围的数字，MySQL 会根据允许范围最接近它的一端截短后再进行存储。还有一个比较特别的地方是，MySQL 会在不合规定的值插入表前自动修改为 0。</p>\n<ul>\n<li>unsigned 和 zerofill<br>UNSIGNED 修饰符规定字段只保存正值,即无符号,而mysql字段默认是有符号的。因为不需要保存数字的正、负符号，可以在储时节约一个”位”的空间(即翻一倍)。从而增大这个字段可以存储的值的范围。注意这个修饰符要紧跟在数值类型后面;<br>ZEROFILL 修饰符规定 0（不是空格）可以用来真补输出的值。使用这个修饰符可以阻止 MySQL 数据库存储负值,如果某列设置为zerofill,那它自动就unsigned。这个值要配合int,tinyint,smallint,midiumint等字段的宽度指示器来用;XXint(M),如果没有zerofill,这个M的宽度指示器是没有意义的.(注意,测试前导0的时候,还是去黑窗口测试;)</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为什么mysql存储的值要分有符号和无符号呢?因为一个字节,占8bit;也就1个bit有0和1两种可能,8个bit就是2^8 = 256种可能,也就是0~255;但如果是有符号的话,就得拿一个1bit来存储这个负号,本来8bit只剩7bit,2^7 = 128,也就是-128~127(正数部分包含一个0);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>FLOAT、DOUBLE 和 DECIMAL 类型<br>MySQL 支持的三个浮点类型是 FLOAT、DOUBLE 和 DECIMAL 类型。FLOAT 数值类型用于表示单精度浮点数值，而 DOUBLE 数值类型用于表示双精度浮点数值。<br>与整数一样，这些类型也带有附加参数：一个显示宽度指示器和一个小数点指示器(必须要带有指示器,要不然会查不到结果,<strong>并且宽度指示器和XXint类型的宽度指示器不同,这里是有实际限制宽度的)。</strong>比如语句 FLOAT(7,3) 规定显示的值不会超过 7 位数字(包括小数位)，小数点后面带有 3 位数字。对于小数点后面的位数超过允许范围的值，MySQL 会自动将它四舍五入为最接近它的值，再插入它。<br>DECIMAL 数据类型用于精度要求非常高的计算中，这种类型允许指定数值的精度和计数方法作为选择参数。精度在这里指为这个值保存的有效数字的总个数，而计数方法表示小数点后数字的位数。比如语句 DECIMAL(7,3) 规定了存储的值不会超过 7 位数字，并且小数点后不超过 3 位。<br>FLOAT 类型在长度比较高比如 float(10,2)和 decimal(10,2)同时插入一个符合(10,2)宽度的数值,float 就会出现最后小数点出现一些出入;<br>UNSIGNED 和 ZEROFILL 修饰符也可以被 FLOAT、DOUBLE 和 DECIMAL 数据类型使用。并且效果与 INT 数据类型相同。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">关于flaot和double</span><br><span class=\"line\">在这里我建议,干脆忘记mysql有double这个数据类型。至于why？就不要管它了</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h4><p>MySQL 提供了 8 个基本的字符串类型，可以存储的范围从简单的一个字符到巨大的文本块或二进制字符串数据。</p>\n<p><img src=\"http://zhoushirong.github.io/img/mysql1.png\" alt=\"mysql\" width=\"895\" height=\"523\"></p>\n<ul>\n<li>BINARY<br>BINARY不是函数，是类型转换运算符，它用来强制它后面的字符串为一个二进制字符串，可以理解为在字符串比较的时候区分大小写<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">BINARY</span> <span class=\"string\">&#x27;ABCD&#x27;</span> = <span class=\"string\">&#x27;abcd&#x27;</span> <span class=\"keyword\">as</span> COM1,<span class=\"string\">&#x27;ABCD&#x27;</span> = <span class=\"string\">&#x27;abcd&#x27;</span> <span class=\"keyword\">as</span> COM2; <span class=\"comment\">-- COM1输出为0,COM2输出为1;</span></span><br></pre></td></tr></table></figure></li>\n<li>CHAR 和 VARCHAR 类型<br>CHAR 类型用于定长字符串，并且必须在圆括号内用一个大小修饰符来定义。这个大小修饰符的范围从 0-255。比指定长度大的值将被截短，而比指定长度小的值将会用空格作填补。</li>\n</ul>\n<p>CHAR 类型可以使用 BINARY 修饰符。当用于比较运算时，这个修饰符使 CHAR 以二进制方式参于运算，而不是以传统的区分大小写的方式。</p>\n<p>CHAR 类型的一个变体是 VARCHAR 类型。它是一种可变长度的字符串类型，并且也必须带有一个范围在 0-255 之间的指示器。</p>\n<p>CHAR 和 VARCHGAR 不同之处在于 MYSQL 数据库处理这个指示器的方式：CHAR 把这个大小视为值的大小，不长度不足的情况下就用空格补足。而 VARCHAR 类型把它视为最大值并且只使用存储字符串实际需要的长度（增加一个额外字节来存储字符串本身的长度）来存储值。所以短于指示器长度的 VARCHAR 类型不会被空格填补，但长于指示器的值仍然会被截短。</p>\n<p>因为 VARCHAR 类型可以根据实际内容动态改变存储值的长度，所以在不能确定字段需要多少字符时使用 VARCHAR 类型可以大大地节约磁盘空间、提高存储效率。<strong>但如果确切知道字符串长度,比如就在50~55之间,那就用 CHAR 因为 CHAR 类型由于本身定长的特性使其性能要高于 VARCHAR;</strong></p>\n<p>VARCHAR 类型在使用 BINARY 修饰符时与 CHAR 类型完全相同。</p>\n<ul>\n<li>TEXT 和 BLOB 类型<br>对于字段长度要求超过 255 个的情况下，MySQL 提供了 TEXT 和 BLOB 两种类型。根据存储数据的大小，它们都有不同的子类型。这些大型的数据用于存储文本块或图像、声音文件等二进制数据类型。</li>\n</ul>\n<p>TEXT 和 BLOB 类型在分类和比较上存在区别。BLOB 类型区分大小写，而 TEXT 不区分大小写。大小修饰符不用于各种 BLOB 和 TEXT 子类型。比指定类型支持的最大范围大的值将被自动截短。</p>\n<h4 id=\"时间类型\"><a href=\"#时间类型\" class=\"headerlink\" title=\"时间类型\"></a>时间类型</h4><p>在处理日期和时间类型的值时，MySQL 带有 5 个不同的数据类型可供选择。</p>\n<p><img src=\"http://zhoushirong.github.io/img/mysql3.png\" alt=\"mysql\" width=\"868\" height=\"320\"></p>\n<ul>\n<li>DATE、TIME 和 YEAR 类型<br>MySQL 用 DATE 和 YEAR 类型存储简单的日期值，使用 TIME 类型存储时间值。这些类型可以描述为字符串或不带分隔符的整数序列。如果描述为字符串，DATE 类型的值应该使用连字号作为分隔符分开，而 TIME 类型的值应该使用冒号作为分隔符分开。</li>\n</ul>\n<p><strong>需要注意的是，没有冒号分隔符的 TIME 类型值，将会被 MySQL 理解为持续的时间，而不是时间戳。</strong><br>MySQL 还对日期的年份中的两个数字的值，或是 SQL 语句中为 YEAR 类型输入的两个数字进行最大限度的通译。因为所有 YEAR 类型的值必须用 4 个数字存储。MySQL 试图将 2 个数字的年份转换为 4 个数字的值。把在 00-69 范围内的值转换到 2000-2069 范围内。把 70-99 范围内的值转换到 1970-1979 之内。如果 MySQL 自动转换后的值并不符合我们的需要，请输入 4 个数字表示的年份。</p>\n<ul>\n<li>DATETIME 和 TIMESTAMP 类型<br>除了日期和时间数据类型，MySQL 还支持 DATETIME 和 TIMESTAMP 这两种混合类型。它们可以把日期和时间作为单个的值进行存储。这两种类型通常用于自动存储包含当前日期和时间的时间戳，并可在需要执行大量数据库事务和需要建立一个调试和审查用途的审计跟踪的应用程序中发挥良好作用。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果我们对 TIMESTAMP 类型的字段没有明确赋值，或是被赋与了 null 值。MySQL 会自动使用系统当前的日期和时间来填充它。</span><br></pre></td></tr></table></figure>\n<h4 id=\"复合类型\"><a href=\"#复合类型\" class=\"headerlink\" title=\"复合类型\"></a>复合类型</h4><p>MySQL 还支持两种复合数据类型 ENUM 和 SET，它们扩展了 SQL 规范。虽然这些类型在技术上是字符串类型，但是可以被视为不同的数据类型。一个 ENUM 类型只允许从一个集合中取得一个值；而 SET 类型允许从一个集合中取得任意多个值。</p>\n<ul>\n<li>ENUM 类型<br>ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。ENUM 类型字段可以从集合中取得一个值或使用 null 值，除此之外的输入将会使 MySQL 在这个字段中插入一个空字符串。另外如果插入值的大小写与集合中值的大小写不匹配，MySQL 会自动使用插入值的大小写转换成与集合中大小写一致的值。</li>\n</ul>\n<p>ENUM 类型在系统内部可以存储为数字，并且从 1 开始用数字做索引。一个 ENUM 类型最多可以包含 65536 个元素，其中一个元素被 MySQL 保留，用来存储错误信息，这个错误值用索引 0 或者一个空字符串表示。</p>\n<p>MySQL 认为 ENUM 类型集合中出现的值是合法输入，除此之外其它任何输入都将失败。这说明通过搜索包含空字符串或对应数字索引为 0 的行就可以很容易地找到错误记录的位置。</p>\n<ul>\n<li>SET 类型<br>SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。并且与 ENUM 类型相同的是任何试图在 SET 类型字段中插入非预定义的值都会使 MySQL 插入一个空字符串。<strong>如果插入一个即有合法的元素又有非法的元素的记录，MySQL 将会保留合法的元素，除去非法的元素。</strong><br>一个 SET 类型最多可以包含 64 项元素。还去除了重复的元素，所以 SET 类型中不可能包含两个相同的元素。<br>希望从 SET 类型字段中找出非法的记录只需查找包含空字符串或二进制值为 0 的行。</li>\n</ul>\n<h3 id=\"字段类型总结\"><a href=\"#字段类型总结\" class=\"headerlink\" title=\"字段类型总结\"></a>字段类型总结</h3><p>1.虽然上面列出了很多字段类型,但最常用也就是 varchar(255),char(255),text,tinyint(4),smallint(6),mediumint,int(11)几种。<br>2.复合类型我们一般用tinyint,更快的时间更省的空间以及更容易扩展<br>3.关于手机号，推荐用char(11),char(11)在查询上更有效率，因为手机号是一个活跃字段参与逻辑会很多。<br>4.一些常用字段举例<br>姓名：char(20)<br>价格：DECIMAL(7, 3)<br>产品序列号：SMALLINT(5) unsigned<br>文章内容: TEXT<br>MD5: CHAR(32)<br>ip: char(15)<br>time: int(10)<br>email char(32)</p>\n<h3 id=\"合理的选择数据类型\"><a href=\"#合理的选择数据类型\" class=\"headerlink\" title=\"合理的选择数据类型\"></a>合理的选择数据类型</h3><ul>\n<li><p>选择合理范围内最小的<br>我们应该选择最小的数据范围，因为这样可以大大减少磁盘空间及磁盘I/0读写开销，减少内存占用，减少CPU的占用率。</p>\n</li>\n<li><p>选择相对简单的数据类型<br>数字类型相对字符串类型要简单的多，尤其是在比较运算时，所以我们应该选择最简单的数据类型，比如说在保存时间时，因为PHP可以良好的处理LINUX时间戳所以我们可以将日期存为int(10)要方便、合适、快速的多。</p>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">但是，工作中随着项目越做越多，业务逻辑的处理越来越难以后，我发现时间类型还是用时间类型本身的字段类型要好一些，因为mysql有着丰富的时间函数供我使用，方便我完成很多与时间相关的逻辑，比如月排行榜，周排行榜，当日热门，生日多少天等等逻辑</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>不要使用null<br>为什么这么说呢，因为MYSQL对NULL字段索引优化不佳，增加更多的计算难度，同时在保存与处理NULL类形时，也会做更多的工作，所以从效率上来说，不建议用过多的NULL。有些值他确实有可能没有值，怎么办呢？解决方法是数值弄用整数0，字符串用空来定义默认值即可。</p>\n</li>\n<li><p>字符串类型的使用<br>字符串数据类型是一个万能数据类型，可以储存数值、字符串、日期等。<br>保存数值类型最好不要用字符串数据类型，这样存储的空间显然是会更大，而且在排序时字符串的9是大于22的，其实如果进行运算时mysql会将字符串转换为数值类型，大大降低效果，而且这种转换是不会走原有的索引的。<br>如果明确数据在一个完整的集合中如男，女，那么可以使用set或enum数据类型，这种数据类型在运算及储存时以数值方式操作，所以效率要比字符串更好，同时空间占用更少。</p>\n</li>\n<li><p>VARCHAR与CHAR<br>VARCHAR是可变长度字符串类型，那么即然长度是可变的就会使用1，2个字节来保存字符的长度，如果长度在255内使用1个字节来保存字符长度，否则使用2个字符来保存长度。由于varchar是根据储存的值来保存数据，所以可以大大节约磁盘空间。<br>如果数据经常被执行更新操作，由于VARCHAR是根据内容来进行储存的，所以mysql将做更多的工作来完成更新操作，如果新数据长度大于老数据长度一些存储引擎会进行拆分操作处理。同时varchar会完全保留内部所有数据，最典型的说明就是尾部的空格。<br>CHAR固定长度的字符串保存类型，CHAR会去掉尾部的空格。在数据长度相近时使用char类型比较合适，比如md5加密的密码用户名等。<br>如果数据经常进行更新修改操作，那么CHAR更好些，因为char长度固定，性能上要快。</p>\n</li>\n<li><p>数值类型的选择<br>数值数据类型要比字符串执行更快，区间小的数据类型占用空间更少，处理速度更快，如tinyint可比bigint要快的多<br>选择数据类型时要考虑内容长度，比如是保存毫米单位还是米而选择不同的数值类型</p>\n</li>\n</ul>\n<h5 id=\"整数\"><a href=\"#整数\" class=\"headerlink\" title=\"整数\"></a>整数</h5><p>整数类型很多比如tinyint、int、smallint、bigint等，那么我们要根据自己需要存储的数据长度决定使用的类型，同时tinyint(10)与tinyint(100)在储存与计算上并无任何差别，区别只是显示层面上，但是我们也要选择适合合适的数据类型长度。可以通过指定zerofill属性查看显示时区别。</p>\n<h5 id=\"浮点数与精度数值\"><a href=\"#浮点数与精度数值\" class=\"headerlink\" title=\"浮点数与精度数值\"></a>浮点数与精度数值</h5><p>浮点数float在储存空间及运行效率上要优于精度数值类型decimal，但float与double会有舍入错误而decimal则可以提供更加准确的小数级精确运算不会有错误产生计算更精确，适用于金融类型数据的存储。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"字段类型与合理的选择字段类型\"><a href=\"#字段类型与合理的选择字段类型\" class=\"headerlink\" title=\"字段类型与合理的选择字段类型\"></a>字段类型与合理的选择字段类型</h3><p>转载自：<br><a href=\"https://www.kancloud.cn/thinkphp/mysql-design-optimalize/39325\">https://www.kancloud.cn/thinkphp/mysql-design-optimalize/39325</a></p>\n<h3 id=\"字段类型\"><a href=\"#字段类型\" class=\"headerlink\" title=\"字段类型\"></a>字段类型</h3><h4 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h4><p>MySQL 的数值数据类型可以大致划分为两个类别，一个是整数，另一个是浮点数或小数。<br>许多不同的子类型对这些类别中的每一个都是可用的，每个子类型支持不同大小的数据，并且 MySQL 允许我们指定数值字段中的值是否有正负之分(UNSIGNED)或者用零填补(ZEROFILL)。</p>\n<p><img src=\"http://zhoushirong.github.io/img/mysql1.png\" alt=\"mysql\" width=\"867\" height=\"684\"></p>\n<ul>\n<li>INT<br>在 MySQL 中支持的 5 个主要整数类型是 TINYINT，SMALLINT，MEDIUMINT，INT 和 BIGINT。这些类型在很大程度上是相同的，只有它们存储的值的大小是不相同的。</li>\n</ul>\n<p>MySQL 以一个可选的显示宽度指示器的形式对 SQL 标准进行扩展(如 INT(6),6即是其宽度指示器,<strong>该宽度指示器并不会影响int列存储字段的大小,也就是说,超过6位它不会自动截取,依然会存储,只有超过它本身的存储范围才会截取;此处宽度指示器的作用在于该字段是否有zerofill,如果有就未满足6位的部分就会用0来填充)</strong>，这样当从数据库检索一个值时，可以把这个值加长到指定的长度。例如，指定一个字段的类型为 INT(6)，就可以保证所包含数字少于 6 个的值从数据库中检索出来时能够自动地用空格填充。需要注意的是，使用一个宽度指示器不会影响字段的大小和它可以存储的值的范围。</p>\n<p>万一我们需要对一个字段存储一个超出许可范围的数字，MySQL 会根据允许范围最接近它的一端截短后再进行存储。还有一个比较特别的地方是，MySQL 会在不合规定的值插入表前自动修改为 0。</p>\n<ul>\n<li>unsigned 和 zerofill<br>UNSIGNED 修饰符规定字段只保存正值,即无符号,而mysql字段默认是有符号的。因为不需要保存数字的正、负符号，可以在储时节约一个”位”的空间(即翻一倍)。从而增大这个字段可以存储的值的范围。注意这个修饰符要紧跟在数值类型后面;<br>ZEROFILL 修饰符规定 0（不是空格）可以用来真补输出的值。使用这个修饰符可以阻止 MySQL 数据库存储负值,如果某列设置为zerofill,那它自动就unsigned。这个值要配合int,tinyint,smallint,midiumint等字段的宽度指示器来用;XXint(M),如果没有zerofill,这个M的宽度指示器是没有意义的.(注意,测试前导0的时候,还是去黑窗口测试;)</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为什么mysql存储的值要分有符号和无符号呢?因为一个字节,占8bit;也就1个bit有0和1两种可能,8个bit就是2^8 = 256种可能,也就是0~255;但如果是有符号的话,就得拿一个1bit来存储这个负号,本来8bit只剩7bit,2^7 = 128,也就是-128~127(正数部分包含一个0);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>FLOAT、DOUBLE 和 DECIMAL 类型<br>MySQL 支持的三个浮点类型是 FLOAT、DOUBLE 和 DECIMAL 类型。FLOAT 数值类型用于表示单精度浮点数值，而 DOUBLE 数值类型用于表示双精度浮点数值。<br>与整数一样，这些类型也带有附加参数：一个显示宽度指示器和一个小数点指示器(必须要带有指示器,要不然会查不到结果,<strong>并且宽度指示器和XXint类型的宽度指示器不同,这里是有实际限制宽度的)。</strong>比如语句 FLOAT(7,3) 规定显示的值不会超过 7 位数字(包括小数位)，小数点后面带有 3 位数字。对于小数点后面的位数超过允许范围的值，MySQL 会自动将它四舍五入为最接近它的值，再插入它。<br>DECIMAL 数据类型用于精度要求非常高的计算中，这种类型允许指定数值的精度和计数方法作为选择参数。精度在这里指为这个值保存的有效数字的总个数，而计数方法表示小数点后数字的位数。比如语句 DECIMAL(7,3) 规定了存储的值不会超过 7 位数字，并且小数点后不超过 3 位。<br>FLOAT 类型在长度比较高比如 float(10,2)和 decimal(10,2)同时插入一个符合(10,2)宽度的数值,float 就会出现最后小数点出现一些出入;<br>UNSIGNED 和 ZEROFILL 修饰符也可以被 FLOAT、DOUBLE 和 DECIMAL 数据类型使用。并且效果与 INT 数据类型相同。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">关于flaot和double</span><br><span class=\"line\">在这里我建议,干脆忘记mysql有double这个数据类型。至于why？就不要管它了</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h4><p>MySQL 提供了 8 个基本的字符串类型，可以存储的范围从简单的一个字符到巨大的文本块或二进制字符串数据。</p>\n<p><img src=\"http://zhoushirong.github.io/img/mysql1.png\" alt=\"mysql\" width=\"895\" height=\"523\"></p>\n<ul>\n<li>BINARY<br>BINARY不是函数，是类型转换运算符，它用来强制它后面的字符串为一个二进制字符串，可以理解为在字符串比较的时候区分大小写<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">BINARY</span> <span class=\"string\">&#x27;ABCD&#x27;</span> = <span class=\"string\">&#x27;abcd&#x27;</span> <span class=\"keyword\">as</span> COM1,<span class=\"string\">&#x27;ABCD&#x27;</span> = <span class=\"string\">&#x27;abcd&#x27;</span> <span class=\"keyword\">as</span> COM2; <span class=\"comment\">-- COM1输出为0,COM2输出为1;</span></span><br></pre></td></tr></table></figure></li>\n<li>CHAR 和 VARCHAR 类型<br>CHAR 类型用于定长字符串，并且必须在圆括号内用一个大小修饰符来定义。这个大小修饰符的范围从 0-255。比指定长度大的值将被截短，而比指定长度小的值将会用空格作填补。</li>\n</ul>\n<p>CHAR 类型可以使用 BINARY 修饰符。当用于比较运算时，这个修饰符使 CHAR 以二进制方式参于运算，而不是以传统的区分大小写的方式。</p>\n<p>CHAR 类型的一个变体是 VARCHAR 类型。它是一种可变长度的字符串类型，并且也必须带有一个范围在 0-255 之间的指示器。</p>\n<p>CHAR 和 VARCHGAR 不同之处在于 MYSQL 数据库处理这个指示器的方式：CHAR 把这个大小视为值的大小，不长度不足的情况下就用空格补足。而 VARCHAR 类型把它视为最大值并且只使用存储字符串实际需要的长度（增加一个额外字节来存储字符串本身的长度）来存储值。所以短于指示器长度的 VARCHAR 类型不会被空格填补，但长于指示器的值仍然会被截短。</p>\n<p>因为 VARCHAR 类型可以根据实际内容动态改变存储值的长度，所以在不能确定字段需要多少字符时使用 VARCHAR 类型可以大大地节约磁盘空间、提高存储效率。<strong>但如果确切知道字符串长度,比如就在50~55之间,那就用 CHAR 因为 CHAR 类型由于本身定长的特性使其性能要高于 VARCHAR;</strong></p>\n<p>VARCHAR 类型在使用 BINARY 修饰符时与 CHAR 类型完全相同。</p>\n<ul>\n<li>TEXT 和 BLOB 类型<br>对于字段长度要求超过 255 个的情况下，MySQL 提供了 TEXT 和 BLOB 两种类型。根据存储数据的大小，它们都有不同的子类型。这些大型的数据用于存储文本块或图像、声音文件等二进制数据类型。</li>\n</ul>\n<p>TEXT 和 BLOB 类型在分类和比较上存在区别。BLOB 类型区分大小写，而 TEXT 不区分大小写。大小修饰符不用于各种 BLOB 和 TEXT 子类型。比指定类型支持的最大范围大的值将被自动截短。</p>\n<h4 id=\"时间类型\"><a href=\"#时间类型\" class=\"headerlink\" title=\"时间类型\"></a>时间类型</h4><p>在处理日期和时间类型的值时，MySQL 带有 5 个不同的数据类型可供选择。</p>\n<p><img src=\"http://zhoushirong.github.io/img/mysql3.png\" alt=\"mysql\" width=\"868\" height=\"320\"></p>\n<ul>\n<li>DATE、TIME 和 YEAR 类型<br>MySQL 用 DATE 和 YEAR 类型存储简单的日期值，使用 TIME 类型存储时间值。这些类型可以描述为字符串或不带分隔符的整数序列。如果描述为字符串，DATE 类型的值应该使用连字号作为分隔符分开，而 TIME 类型的值应该使用冒号作为分隔符分开。</li>\n</ul>\n<p><strong>需要注意的是，没有冒号分隔符的 TIME 类型值，将会被 MySQL 理解为持续的时间，而不是时间戳。</strong><br>MySQL 还对日期的年份中的两个数字的值，或是 SQL 语句中为 YEAR 类型输入的两个数字进行最大限度的通译。因为所有 YEAR 类型的值必须用 4 个数字存储。MySQL 试图将 2 个数字的年份转换为 4 个数字的值。把在 00-69 范围内的值转换到 2000-2069 范围内。把 70-99 范围内的值转换到 1970-1979 之内。如果 MySQL 自动转换后的值并不符合我们的需要，请输入 4 个数字表示的年份。</p>\n<ul>\n<li>DATETIME 和 TIMESTAMP 类型<br>除了日期和时间数据类型，MySQL 还支持 DATETIME 和 TIMESTAMP 这两种混合类型。它们可以把日期和时间作为单个的值进行存储。这两种类型通常用于自动存储包含当前日期和时间的时间戳，并可在需要执行大量数据库事务和需要建立一个调试和审查用途的审计跟踪的应用程序中发挥良好作用。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果我们对 TIMESTAMP 类型的字段没有明确赋值，或是被赋与了 null 值。MySQL 会自动使用系统当前的日期和时间来填充它。</span><br></pre></td></tr></table></figure>\n<h4 id=\"复合类型\"><a href=\"#复合类型\" class=\"headerlink\" title=\"复合类型\"></a>复合类型</h4><p>MySQL 还支持两种复合数据类型 ENUM 和 SET，它们扩展了 SQL 规范。虽然这些类型在技术上是字符串类型，但是可以被视为不同的数据类型。一个 ENUM 类型只允许从一个集合中取得一个值；而 SET 类型允许从一个集合中取得任意多个值。</p>\n<ul>\n<li>ENUM 类型<br>ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。ENUM 类型字段可以从集合中取得一个值或使用 null 值，除此之外的输入将会使 MySQL 在这个字段中插入一个空字符串。另外如果插入值的大小写与集合中值的大小写不匹配，MySQL 会自动使用插入值的大小写转换成与集合中大小写一致的值。</li>\n</ul>\n<p>ENUM 类型在系统内部可以存储为数字，并且从 1 开始用数字做索引。一个 ENUM 类型最多可以包含 65536 个元素，其中一个元素被 MySQL 保留，用来存储错误信息，这个错误值用索引 0 或者一个空字符串表示。</p>\n<p>MySQL 认为 ENUM 类型集合中出现的值是合法输入，除此之外其它任何输入都将失败。这说明通过搜索包含空字符串或对应数字索引为 0 的行就可以很容易地找到错误记录的位置。</p>\n<ul>\n<li>SET 类型<br>SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。并且与 ENUM 类型相同的是任何试图在 SET 类型字段中插入非预定义的值都会使 MySQL 插入一个空字符串。<strong>如果插入一个即有合法的元素又有非法的元素的记录，MySQL 将会保留合法的元素，除去非法的元素。</strong><br>一个 SET 类型最多可以包含 64 项元素。还去除了重复的元素，所以 SET 类型中不可能包含两个相同的元素。<br>希望从 SET 类型字段中找出非法的记录只需查找包含空字符串或二进制值为 0 的行。</li>\n</ul>\n<h3 id=\"字段类型总结\"><a href=\"#字段类型总结\" class=\"headerlink\" title=\"字段类型总结\"></a>字段类型总结</h3><p>1.虽然上面列出了很多字段类型,但最常用也就是 varchar(255),char(255),text,tinyint(4),smallint(6),mediumint,int(11)几种。<br>2.复合类型我们一般用tinyint,更快的时间更省的空间以及更容易扩展<br>3.关于手机号，推荐用char(11),char(11)在查询上更有效率，因为手机号是一个活跃字段参与逻辑会很多。<br>4.一些常用字段举例<br>姓名：char(20)<br>价格：DECIMAL(7, 3)<br>产品序列号：SMALLINT(5) unsigned<br>文章内容: TEXT<br>MD5: CHAR(32)<br>ip: char(15)<br>time: int(10)<br>email char(32)</p>\n<h3 id=\"合理的选择数据类型\"><a href=\"#合理的选择数据类型\" class=\"headerlink\" title=\"合理的选择数据类型\"></a>合理的选择数据类型</h3><ul>\n<li><p>选择合理范围内最小的<br>我们应该选择最小的数据范围，因为这样可以大大减少磁盘空间及磁盘I/0读写开销，减少内存占用，减少CPU的占用率。</p>\n</li>\n<li><p>选择相对简单的数据类型<br>数字类型相对字符串类型要简单的多，尤其是在比较运算时，所以我们应该选择最简单的数据类型，比如说在保存时间时，因为PHP可以良好的处理LINUX时间戳所以我们可以将日期存为int(10)要方便、合适、快速的多。</p>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">但是，工作中随着项目越做越多，业务逻辑的处理越来越难以后，我发现时间类型还是用时间类型本身的字段类型要好一些，因为mysql有着丰富的时间函数供我使用，方便我完成很多与时间相关的逻辑，比如月排行榜，周排行榜，当日热门，生日多少天等等逻辑</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>不要使用null<br>为什么这么说呢，因为MYSQL对NULL字段索引优化不佳，增加更多的计算难度，同时在保存与处理NULL类形时，也会做更多的工作，所以从效率上来说，不建议用过多的NULL。有些值他确实有可能没有值，怎么办呢？解决方法是数值弄用整数0，字符串用空来定义默认值即可。</p>\n</li>\n<li><p>字符串类型的使用<br>字符串数据类型是一个万能数据类型，可以储存数值、字符串、日期等。<br>保存数值类型最好不要用字符串数据类型，这样存储的空间显然是会更大，而且在排序时字符串的9是大于22的，其实如果进行运算时mysql会将字符串转换为数值类型，大大降低效果，而且这种转换是不会走原有的索引的。<br>如果明确数据在一个完整的集合中如男，女，那么可以使用set或enum数据类型，这种数据类型在运算及储存时以数值方式操作，所以效率要比字符串更好，同时空间占用更少。</p>\n</li>\n<li><p>VARCHAR与CHAR<br>VARCHAR是可变长度字符串类型，那么即然长度是可变的就会使用1，2个字节来保存字符的长度，如果长度在255内使用1个字节来保存字符长度，否则使用2个字符来保存长度。由于varchar是根据储存的值来保存数据，所以可以大大节约磁盘空间。<br>如果数据经常被执行更新操作，由于VARCHAR是根据内容来进行储存的，所以mysql将做更多的工作来完成更新操作，如果新数据长度大于老数据长度一些存储引擎会进行拆分操作处理。同时varchar会完全保留内部所有数据，最典型的说明就是尾部的空格。<br>CHAR固定长度的字符串保存类型，CHAR会去掉尾部的空格。在数据长度相近时使用char类型比较合适，比如md5加密的密码用户名等。<br>如果数据经常进行更新修改操作，那么CHAR更好些，因为char长度固定，性能上要快。</p>\n</li>\n<li><p>数值类型的选择<br>数值数据类型要比字符串执行更快，区间小的数据类型占用空间更少，处理速度更快，如tinyint可比bigint要快的多<br>选择数据类型时要考虑内容长度，比如是保存毫米单位还是米而选择不同的数值类型</p>\n</li>\n</ul>\n<h5 id=\"整数\"><a href=\"#整数\" class=\"headerlink\" title=\"整数\"></a>整数</h5><p>整数类型很多比如tinyint、int、smallint、bigint等，那么我们要根据自己需要存储的数据长度决定使用的类型，同时tinyint(10)与tinyint(100)在储存与计算上并无任何差别，区别只是显示层面上，但是我们也要选择适合合适的数据类型长度。可以通过指定zerofill属性查看显示时区别。</p>\n<h5 id=\"浮点数与精度数值\"><a href=\"#浮点数与精度数值\" class=\"headerlink\" title=\"浮点数与精度数值\"></a>浮点数与精度数值</h5><p>浮点数float在储存空间及运行效率上要优于精度数值类型decimal，但float与double会有舍入错误而decimal则可以提供更加准确的小数级精确运算不会有错误产生计算更精确，适用于金融类型数据的存储。</p>\n"},{"title":"Nginx简单介绍","date":"2016-12-24T16:00:00.000Z","_content":"\nNginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。\nNginx在官方测试的结果中，能够支持五万个平行连接，而在实际的运作中可以支持二万至四万个平行链接。\n整体采用模块化设计是nginx的一个重大特点，甚至http服务器核心功能也是一个模块。\n旧版本的Nginx的模块是静态的，添加和删除模块都要对Nginx进行重新编译，1.9.11以及更新的版本已经支持动态模块加载。 —— 来自维基百科\n\nNginx最初是作为一个web服务器创建的。但是Nginx除了作为web服务器，还有个功能就是提供反向代理服务\n利用Nginx你可以适当地分配流量（负载均衡器）、流媒体、动态调整图像大小、缓存内容等等。\n\n#### 正向代理\n\n作为客户端的中介接受请求，隐藏真实的用户，向服务端获取资源，如果代理在墙外，则可以实现翻墙\n\n#### 反向代理\n\n作为服务端的中介，隐藏真实的服务器，目的是为了实现安全和负载均衡等一系列的功能\n\n安全：用户的请求不会直接到内网的服务器上，而是通过代理做了一层转发，在这一层可以实现安全过滤、流控、防DDOS等一系列策略\n\n负载均衡：我们可以水平扩展后端真正提供服务的服务器数量，代理按照规则转发请求到各个服务端，使得各个服务器负载接近均衡\n\n\n### 在mac osx\n\n1.brew\n\n```shell\nbrew list 查看brew安装的软件列表\nbrew search xx // 搜索\nbrew install xx // 安装\nbrew info xx //查看xx信息\nbrew uninstall xx //卸载\n```\n\n1.用brew安装nginx\n\n```shell\nbrew install nginx\n```\n\n2.启动nginx\n\n```shell\n[sudo] nginx\n```\n\n3.查看nginx的进程\n\n```shell\n[sudo] ps aux | grep nginx\n```\n\n访问此地址查看是否启动nginx成功：http://localhost:8080/\n\n4.查看nginx版本\n\n```shell\nnginx -v\n```\n\n5.停止nginx\n\n```shell\n[sudo] nginx -s stop\n```\n\n6.重新加载nginx\n\n```shell\n[sudo] nginx -s reload\n```\n\n7.重启nginx\n\n```shell\n[sudo] nginx -s stop && [sudo] nginx\n```\n\n\nps:如果启动或重启的时候遇到pid报错则按如下方法杀掉nginx主进程\n\n在进程列表里面找到master进程，他的编号就是主进程号了。\n\n步骤一：询nginx主进程\n\n```shell\nps -ef | grep nginx\n```\n\n步骤2：发送信号\n\n```html\n从容停止：sudo kill -QUIT 主进程号\n\n快速停止：sudo kill -TERM 主进程号\n\n强制停止nginx：sudo pkill -9 nginx\n```\n\n8.nginx默认配置位置\n\n```shell\n/etc/nginx/nginx.conf\n/usr/local/etc/nginx/nginx.conf\n# 或者\n/usr/local/nginx/conf/nginx.conf\n```\n\n\n### ubuntu系统\n\n安装\n\n```html\n[sudo] apt-get install nginx\n\n```\n\n### 查看nginx是否启动\n\n```html\nps -ef|grep nginx\n```\n\n### 关于nginx配置之后获取不到用户真实IP的问题\n是因为nginx代理之后未能将ip转发过去。\n解决办法：在nginx location匹配项后面加入如下配置即可\n```shell\nproxy_set_header        Host            $host; \nproxy_set_header        X-Real-IP       $remote_addr; \nproxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for; \n```\n\n但是如果有多个规则，就需要在每个规则下面重复配置；\n解决办法就是在公共的nginx.conf 里面include proxy.conf公共文件\n然后在proxy.conf公共文件中加入上面的配置即可将ip转发了。\nproxy.conf 文件\n```shell\nproxy_set_header        Host            $host; \nproxy_set_header        X-Real-IP       $remote_addr; \nproxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for; \n```\nnginx.conf 文件\n```shell\nhttp {\n  ####\n  #...略...#\n  include /etc/nginx/proxy.conf; # 此文件路径为proxy.conf存放地址\n  #...略...#\n}\n```\n之后在nodejs端就可以通过下面的代码获取到真实的ip地址了\n```html\nreq.get(\"X-Real-IP\") || req.get(\"X-Forwarded-For\") || req.ip,\n```\n\n\n\n\n-------------------------------\n\n### 参考&&相关链接\n\n##### 官方配置文档\n\n<a href=\"http://nginx.org/en/docs/\" target=\"_blank\">http://nginx.org/en/docs/</a>\n\n##### nginx配置从0开始：\n\n<a href=\"http://www.open-open.com/lib/view/open1419826381531.html\" target=\"_blank\">http://www.open-open.com/lib/view/open1419826381531.html</a>\n\n##### nginx 配置 location 总结及 rewrite 规则写法：\n\n<a href=\"https://linux.cn/article-5714-1.html\" target=\"_blank\">https://linux.cn/article-5714-1.html</a>\n\n##### 配置nginx\n<a href=\"http://arccode.net/2015/02/27/Nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E8%AE%B0/\" target=\"_blank\">http://arccode.net/2015/02/27/Nginx配置小记/</a>\n","source":"_posts/nginx.md","raw":"---\ntitle: Nginx简单介绍\ntag: [nginx]\ndate: 2016/12/25\ncategory: 技术\n---\n\nNginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。\nNginx在官方测试的结果中，能够支持五万个平行连接，而在实际的运作中可以支持二万至四万个平行链接。\n整体采用模块化设计是nginx的一个重大特点，甚至http服务器核心功能也是一个模块。\n旧版本的Nginx的模块是静态的，添加和删除模块都要对Nginx进行重新编译，1.9.11以及更新的版本已经支持动态模块加载。 —— 来自维基百科\n\nNginx最初是作为一个web服务器创建的。但是Nginx除了作为web服务器，还有个功能就是提供反向代理服务\n利用Nginx你可以适当地分配流量（负载均衡器）、流媒体、动态调整图像大小、缓存内容等等。\n\n#### 正向代理\n\n作为客户端的中介接受请求，隐藏真实的用户，向服务端获取资源，如果代理在墙外，则可以实现翻墙\n\n#### 反向代理\n\n作为服务端的中介，隐藏真实的服务器，目的是为了实现安全和负载均衡等一系列的功能\n\n安全：用户的请求不会直接到内网的服务器上，而是通过代理做了一层转发，在这一层可以实现安全过滤、流控、防DDOS等一系列策略\n\n负载均衡：我们可以水平扩展后端真正提供服务的服务器数量，代理按照规则转发请求到各个服务端，使得各个服务器负载接近均衡\n\n\n### 在mac osx\n\n1.brew\n\n```shell\nbrew list 查看brew安装的软件列表\nbrew search xx // 搜索\nbrew install xx // 安装\nbrew info xx //查看xx信息\nbrew uninstall xx //卸载\n```\n\n1.用brew安装nginx\n\n```shell\nbrew install nginx\n```\n\n2.启动nginx\n\n```shell\n[sudo] nginx\n```\n\n3.查看nginx的进程\n\n```shell\n[sudo] ps aux | grep nginx\n```\n\n访问此地址查看是否启动nginx成功：http://localhost:8080/\n\n4.查看nginx版本\n\n```shell\nnginx -v\n```\n\n5.停止nginx\n\n```shell\n[sudo] nginx -s stop\n```\n\n6.重新加载nginx\n\n```shell\n[sudo] nginx -s reload\n```\n\n7.重启nginx\n\n```shell\n[sudo] nginx -s stop && [sudo] nginx\n```\n\n\nps:如果启动或重启的时候遇到pid报错则按如下方法杀掉nginx主进程\n\n在进程列表里面找到master进程，他的编号就是主进程号了。\n\n步骤一：询nginx主进程\n\n```shell\nps -ef | grep nginx\n```\n\n步骤2：发送信号\n\n```html\n从容停止：sudo kill -QUIT 主进程号\n\n快速停止：sudo kill -TERM 主进程号\n\n强制停止nginx：sudo pkill -9 nginx\n```\n\n8.nginx默认配置位置\n\n```shell\n/etc/nginx/nginx.conf\n/usr/local/etc/nginx/nginx.conf\n# 或者\n/usr/local/nginx/conf/nginx.conf\n```\n\n\n### ubuntu系统\n\n安装\n\n```html\n[sudo] apt-get install nginx\n\n```\n\n### 查看nginx是否启动\n\n```html\nps -ef|grep nginx\n```\n\n### 关于nginx配置之后获取不到用户真实IP的问题\n是因为nginx代理之后未能将ip转发过去。\n解决办法：在nginx location匹配项后面加入如下配置即可\n```shell\nproxy_set_header        Host            $host; \nproxy_set_header        X-Real-IP       $remote_addr; \nproxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for; \n```\n\n但是如果有多个规则，就需要在每个规则下面重复配置；\n解决办法就是在公共的nginx.conf 里面include proxy.conf公共文件\n然后在proxy.conf公共文件中加入上面的配置即可将ip转发了。\nproxy.conf 文件\n```shell\nproxy_set_header        Host            $host; \nproxy_set_header        X-Real-IP       $remote_addr; \nproxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for; \n```\nnginx.conf 文件\n```shell\nhttp {\n  ####\n  #...略...#\n  include /etc/nginx/proxy.conf; # 此文件路径为proxy.conf存放地址\n  #...略...#\n}\n```\n之后在nodejs端就可以通过下面的代码获取到真实的ip地址了\n```html\nreq.get(\"X-Real-IP\") || req.get(\"X-Forwarded-For\") || req.ip,\n```\n\n\n\n\n-------------------------------\n\n### 参考&&相关链接\n\n##### 官方配置文档\n\n<a href=\"http://nginx.org/en/docs/\" target=\"_blank\">http://nginx.org/en/docs/</a>\n\n##### nginx配置从0开始：\n\n<a href=\"http://www.open-open.com/lib/view/open1419826381531.html\" target=\"_blank\">http://www.open-open.com/lib/view/open1419826381531.html</a>\n\n##### nginx 配置 location 总结及 rewrite 规则写法：\n\n<a href=\"https://linux.cn/article-5714-1.html\" target=\"_blank\">https://linux.cn/article-5714-1.html</a>\n\n##### 配置nginx\n<a href=\"http://arccode.net/2015/02/27/Nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E8%AE%B0/\" target=\"_blank\">http://arccode.net/2015/02/27/Nginx配置小记/</a>\n","slug":"nginx","published":1,"updated":"2021-03-30T01:32:00.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufw0011a0vzf9hz65qa","content":"<p>Nginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。<br>Nginx在官方测试的结果中，能够支持五万个平行连接，而在实际的运作中可以支持二万至四万个平行链接。<br>整体采用模块化设计是nginx的一个重大特点，甚至http服务器核心功能也是一个模块。<br>旧版本的Nginx的模块是静态的，添加和删除模块都要对Nginx进行重新编译，1.9.11以及更新的版本已经支持动态模块加载。 —— 来自维基百科</p>\n<p>Nginx最初是作为一个web服务器创建的。但是Nginx除了作为web服务器，还有个功能就是提供反向代理服务<br>利用Nginx你可以适当地分配流量（负载均衡器）、流媒体、动态调整图像大小、缓存内容等等。</p>\n<h4 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h4><p>作为客户端的中介接受请求，隐藏真实的用户，向服务端获取资源，如果代理在墙外，则可以实现翻墙</p>\n<h4 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h4><p>作为服务端的中介，隐藏真实的服务器，目的是为了实现安全和负载均衡等一系列的功能</p>\n<p>安全：用户的请求不会直接到内网的服务器上，而是通过代理做了一层转发，在这一层可以实现安全过滤、流控、防DDOS等一系列策略</p>\n<p>负载均衡：我们可以水平扩展后端真正提供服务的服务器数量，代理按照规则转发请求到各个服务端，使得各个服务器负载接近均衡</p>\n<h3 id=\"在mac-osx\"><a href=\"#在mac-osx\" class=\"headerlink\" title=\"在mac osx\"></a>在mac osx</h3><p>1.brew</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew list 查看brew安装的软件列表</span><br><span class=\"line\">brew search xx // 搜索</span><br><span class=\"line\">brew install xx // 安装</span><br><span class=\"line\">brew info xx //查看xx信息</span><br><span class=\"line\">brew uninstall xx //卸载</span><br></pre></td></tr></table></figure>\n<p>1.用brew安装nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install nginx</span><br></pre></td></tr></table></figure>\n<p>2.启动nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] nginx</span><br></pre></td></tr></table></figure>\n<p>3.查看nginx的进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] ps aux | grep nginx</span><br></pre></td></tr></table></figure>\n<p>访问此地址查看是否启动nginx成功：<a href=\"http://localhost:8080/\">http://localhost:8080/</a></p>\n<p>4.查看nginx版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -v</span><br></pre></td></tr></table></figure>\n<p>5.停止nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] nginx -s stop</span><br></pre></td></tr></table></figure>\n<p>6.重新加载nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] nginx -s reload</span><br></pre></td></tr></table></figure>\n<p>7.重启nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] nginx -s stop &amp;&amp; [sudo] nginx</span><br></pre></td></tr></table></figure>\n<p>ps:如果启动或重启的时候遇到pid报错则按如下方法杀掉nginx主进程</p>\n<p>在进程列表里面找到master进程，他的编号就是主进程号了。</p>\n<p>步骤一：询nginx主进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef | grep nginx</span><br></pre></td></tr></table></figure>\n<p>步骤2：发送信号</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从容停止：sudo kill -QUIT 主进程号</span><br><span class=\"line\"></span><br><span class=\"line\">快速停止：sudo kill -TERM 主进程号</span><br><span class=\"line\"></span><br><span class=\"line\">强制停止nginx：sudo pkill -9 nginx</span><br></pre></td></tr></table></figure>\n<p>8.nginx默认配置位置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/nginx/nginx.conf</span><br><span class=\"line\">/usr/local/etc/nginx/nginx.conf</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 或者</span></span><br><span class=\"line\">/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>\n<h3 id=\"ubuntu系统\"><a href=\"#ubuntu系统\" class=\"headerlink\" title=\"ubuntu系统\"></a>ubuntu系统</h3><p>安装</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] apt-get install nginx</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看nginx是否启动\"><a href=\"#查看nginx是否启动\" class=\"headerlink\" title=\"查看nginx是否启动\"></a>查看nginx是否启动</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef|grep nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"关于nginx配置之后获取不到用户真实IP的问题\"><a href=\"#关于nginx配置之后获取不到用户真实IP的问题\" class=\"headerlink\" title=\"关于nginx配置之后获取不到用户真实IP的问题\"></a>关于nginx配置之后获取不到用户真实IP的问题</h3><p>是因为nginx代理之后未能将ip转发过去。<br>解决办法：在nginx location匹配项后面加入如下配置即可<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header        Host            $host; </span><br><span class=\"line\">proxy_set_header        X-Real-IP       $remote_addr; </span><br><span class=\"line\">proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for; </span><br></pre></td></tr></table></figure></p>\n<p>但是如果有多个规则，就需要在每个规则下面重复配置；<br>解决办法就是在公共的nginx.conf 里面include proxy.conf公共文件<br>然后在proxy.conf公共文件中加入上面的配置即可将ip转发了。<br>proxy.conf 文件<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header        Host            $host; </span><br><span class=\"line\">proxy_set_header        X-Real-IP       $remote_addr; </span><br><span class=\"line\">proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for; </span><br></pre></td></tr></table></figure><br>nginx.conf 文件<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"><span class=\"comment\">###</span></span></span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">...略...<span class=\"comment\">#</span></span></span><br><span class=\"line\">  include /etc/nginx/proxy.conf; # 此文件路径为proxy.conf存放地址</span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">...略...<span class=\"comment\">#</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>之后在nodejs端就可以通过下面的代码获取到真实的ip地址了<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">req.get(&quot;X-Real-IP&quot;) || req.get(&quot;X-Forwarded-For&quot;) || req.ip,</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"参考-amp-amp-相关链接\"><a href=\"#参考-amp-amp-相关链接\" class=\"headerlink\" title=\"参考&amp;&amp;相关链接\"></a>参考&amp;&amp;相关链接</h3><h5 id=\"官方配置文档\"><a href=\"#官方配置文档\" class=\"headerlink\" title=\"官方配置文档\"></a>官方配置文档</h5><p><a href=\"http://nginx.org/en/docs/\" target=\"_blank\">http://nginx.org/en/docs/</a></p>\n<h5 id=\"nginx配置从0开始：\"><a href=\"#nginx配置从0开始：\" class=\"headerlink\" title=\"nginx配置从0开始：\"></a>nginx配置从0开始：</h5><p><a href=\"http://www.open-open.com/lib/view/open1419826381531.html\" target=\"_blank\">http://www.open-open.com/lib/view/open1419826381531.html</a></p>\n<h5 id=\"nginx-配置-location-总结及-rewrite-规则写法：\"><a href=\"#nginx-配置-location-总结及-rewrite-规则写法：\" class=\"headerlink\" title=\"nginx 配置 location 总结及 rewrite 规则写法：\"></a>nginx 配置 location 总结及 rewrite 规则写法：</h5><p><a href=\"https://linux.cn/article-5714-1.html\" target=\"_blank\">https://linux.cn/article-5714-1.html</a></p>\n<h5 id=\"配置nginx\"><a href=\"#配置nginx\" class=\"headerlink\" title=\"配置nginx\"></a>配置nginx</h5><p><a href=\"http://arccode.net/2015/02/27/Nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E8%AE%B0/\" target=\"_blank\">http://arccode.net/2015/02/27/Nginx配置小记/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Nginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。<br>Nginx在官方测试的结果中，能够支持五万个平行连接，而在实际的运作中可以支持二万至四万个平行链接。<br>整体采用模块化设计是nginx的一个重大特点，甚至http服务器核心功能也是一个模块。<br>旧版本的Nginx的模块是静态的，添加和删除模块都要对Nginx进行重新编译，1.9.11以及更新的版本已经支持动态模块加载。 —— 来自维基百科</p>\n<p>Nginx最初是作为一个web服务器创建的。但是Nginx除了作为web服务器，还有个功能就是提供反向代理服务<br>利用Nginx你可以适当地分配流量（负载均衡器）、流媒体、动态调整图像大小、缓存内容等等。</p>\n<h4 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h4><p>作为客户端的中介接受请求，隐藏真实的用户，向服务端获取资源，如果代理在墙外，则可以实现翻墙</p>\n<h4 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h4><p>作为服务端的中介，隐藏真实的服务器，目的是为了实现安全和负载均衡等一系列的功能</p>\n<p>安全：用户的请求不会直接到内网的服务器上，而是通过代理做了一层转发，在这一层可以实现安全过滤、流控、防DDOS等一系列策略</p>\n<p>负载均衡：我们可以水平扩展后端真正提供服务的服务器数量，代理按照规则转发请求到各个服务端，使得各个服务器负载接近均衡</p>\n<h3 id=\"在mac-osx\"><a href=\"#在mac-osx\" class=\"headerlink\" title=\"在mac osx\"></a>在mac osx</h3><p>1.brew</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew list 查看brew安装的软件列表</span><br><span class=\"line\">brew search xx // 搜索</span><br><span class=\"line\">brew install xx // 安装</span><br><span class=\"line\">brew info xx //查看xx信息</span><br><span class=\"line\">brew uninstall xx //卸载</span><br></pre></td></tr></table></figure>\n<p>1.用brew安装nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install nginx</span><br></pre></td></tr></table></figure>\n<p>2.启动nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] nginx</span><br></pre></td></tr></table></figure>\n<p>3.查看nginx的进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] ps aux | grep nginx</span><br></pre></td></tr></table></figure>\n<p>访问此地址查看是否启动nginx成功：<a href=\"http://localhost:8080/\">http://localhost:8080/</a></p>\n<p>4.查看nginx版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -v</span><br></pre></td></tr></table></figure>\n<p>5.停止nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] nginx -s stop</span><br></pre></td></tr></table></figure>\n<p>6.重新加载nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] nginx -s reload</span><br></pre></td></tr></table></figure>\n<p>7.重启nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] nginx -s stop &amp;&amp; [sudo] nginx</span><br></pre></td></tr></table></figure>\n<p>ps:如果启动或重启的时候遇到pid报错则按如下方法杀掉nginx主进程</p>\n<p>在进程列表里面找到master进程，他的编号就是主进程号了。</p>\n<p>步骤一：询nginx主进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef | grep nginx</span><br></pre></td></tr></table></figure>\n<p>步骤2：发送信号</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从容停止：sudo kill -QUIT 主进程号</span><br><span class=\"line\"></span><br><span class=\"line\">快速停止：sudo kill -TERM 主进程号</span><br><span class=\"line\"></span><br><span class=\"line\">强制停止nginx：sudo pkill -9 nginx</span><br></pre></td></tr></table></figure>\n<p>8.nginx默认配置位置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/nginx/nginx.conf</span><br><span class=\"line\">/usr/local/etc/nginx/nginx.conf</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 或者</span></span><br><span class=\"line\">/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>\n<h3 id=\"ubuntu系统\"><a href=\"#ubuntu系统\" class=\"headerlink\" title=\"ubuntu系统\"></a>ubuntu系统</h3><p>安装</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sudo] apt-get install nginx</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看nginx是否启动\"><a href=\"#查看nginx是否启动\" class=\"headerlink\" title=\"查看nginx是否启动\"></a>查看nginx是否启动</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef|grep nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"关于nginx配置之后获取不到用户真实IP的问题\"><a href=\"#关于nginx配置之后获取不到用户真实IP的问题\" class=\"headerlink\" title=\"关于nginx配置之后获取不到用户真实IP的问题\"></a>关于nginx配置之后获取不到用户真实IP的问题</h3><p>是因为nginx代理之后未能将ip转发过去。<br>解决办法：在nginx location匹配项后面加入如下配置即可<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header        Host            $host; </span><br><span class=\"line\">proxy_set_header        X-Real-IP       $remote_addr; </span><br><span class=\"line\">proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for; </span><br></pre></td></tr></table></figure></p>\n<p>但是如果有多个规则，就需要在每个规则下面重复配置；<br>解决办法就是在公共的nginx.conf 里面include proxy.conf公共文件<br>然后在proxy.conf公共文件中加入上面的配置即可将ip转发了。<br>proxy.conf 文件<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header        Host            $host; </span><br><span class=\"line\">proxy_set_header        X-Real-IP       $remote_addr; </span><br><span class=\"line\">proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for; </span><br></pre></td></tr></table></figure><br>nginx.conf 文件<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"><span class=\"comment\">###</span></span></span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">...略...<span class=\"comment\">#</span></span></span><br><span class=\"line\">  include /etc/nginx/proxy.conf; # 此文件路径为proxy.conf存放地址</span><br><span class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">...略...<span class=\"comment\">#</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>之后在nodejs端就可以通过下面的代码获取到真实的ip地址了<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">req.get(&quot;X-Real-IP&quot;) || req.get(&quot;X-Forwarded-For&quot;) || req.ip,</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"参考-amp-amp-相关链接\"><a href=\"#参考-amp-amp-相关链接\" class=\"headerlink\" title=\"参考&amp;&amp;相关链接\"></a>参考&amp;&amp;相关链接</h3><h5 id=\"官方配置文档\"><a href=\"#官方配置文档\" class=\"headerlink\" title=\"官方配置文档\"></a>官方配置文档</h5><p><a href=\"http://nginx.org/en/docs/\" target=\"_blank\">http://nginx.org/en/docs/</a></p>\n<h5 id=\"nginx配置从0开始：\"><a href=\"#nginx配置从0开始：\" class=\"headerlink\" title=\"nginx配置从0开始：\"></a>nginx配置从0开始：</h5><p><a href=\"http://www.open-open.com/lib/view/open1419826381531.html\" target=\"_blank\">http://www.open-open.com/lib/view/open1419826381531.html</a></p>\n<h5 id=\"nginx-配置-location-总结及-rewrite-规则写法：\"><a href=\"#nginx-配置-location-总结及-rewrite-规则写法：\" class=\"headerlink\" title=\"nginx 配置 location 总结及 rewrite 规则写法：\"></a>nginx 配置 location 总结及 rewrite 规则写法：</h5><p><a href=\"https://linux.cn/article-5714-1.html\" target=\"_blank\">https://linux.cn/article-5714-1.html</a></p>\n<h5 id=\"配置nginx\"><a href=\"#配置nginx\" class=\"headerlink\" title=\"配置nginx\"></a>配置nginx</h5><p><a href=\"http://arccode.net/2015/02/27/Nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E8%AE%B0/\" target=\"_blank\">http://arccode.net/2015/02/27/Nginx配置小记/</a></p>\n"},{"title":"Nodejs子进程","date":"2020-12-29T16:00:00.000Z","_content":"\n进程是CPU分配资源的最小单位，分配独立内存，进程之间可通信，但是必须通过内核，使用IPC接口来做，代价比较大\n线程是CPU调度的最小单位\n\njavascript 语言本身被发明出来就是为浏览器服务的，所以为了在浏览器端渲染的界面的时候不会被来自不同金IC的数据干扰，js执行环境被设计成了单进程执行。\n但是在作为Nodejs使用的时候，为了最大发挥服务器的多核优势，Nodejs也被安排了多进程的能力。而为其提供多进程能力的核心模块就是 child_process\nchild_process提供了衍生子进程的能力，主要由child_process.spawn()函数提供。\n默认情况下， stdin、 stdout 和 stderr 的管道会在父 Node.js 进程和衍生的子进程之间建立，这些管道的容量是有限的。\n\n#### child_process.spawn\nnodejs还提供了一些基于child_process.spawn的一些替代方法，都是基于 child_process.spawn() 或 child_process.spawnSync() 实现的。\n```html\nchild_process.exec(): 衍生 shell 并且在 shell 中运行命令，当完成时则将 stdout 和 stderr 传给回调函数。\nchild_process.execFile(): 类似于 child_process.exec()，但是默认情况下它会直接衍生命令而不先衍生 shell。\nchild_process.fork(): 衍生新的 Node.js 进程，并调用指定的模块，该模块已建立了 IPC 通信通道，可以在父进程与子进程之间发送消息。\nchild_process.execSync(): child_process.exec() 的同步版本，会阻塞 Node.js 事件循环。\nchild_process.execFileSync(): child_process.execFile() 的同步版本，会阻塞 Node.js 事件循环。\n```\n来自[官方文档](http://nodejs.cn/api/child_process.html)\n\n#### cluster\ncluster模块是基于child_process.fork方法创建的，它可以使用IPC和父进程进行通信。\n![图片](http://zhoushirong.github.io/img/child_process.png)\n\ncluster 模块可以创建共享服务器端口的子进程，因此常常被用作nodejs的多进程部署，pm2的cluster模式就是利用了此方法。\n1.利用cluster创建子进程的方法\n```javascript\nconst cluster = require('cluster')\nconst http = require('http')\nconst numsCPUS = require('os').cpus().length\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`)\n  for( let i = 0; i < numsCPUS.length; i++) {\n    cluster.fork() // fork出来的子进程拥有和父进程一致的、独立的资源(数据空间、堆、栈)等。\n  }\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`)\n    cluster.fork() // 重新fork子进程\n  })\n} else { // 业务逻辑代码\n  http.createServer((req, res) => {\n    res.writeHead(200)\n    res.end('hello world\\n')\n  }).listen(8000)\n  console.log(`worker ${process.pid} started`)\n}\n```\n\n2.cluster实现原理\ncluster其实就是对于child_process模块的封装，通过child_procress.fork()出子进程，同时基于IPC实现了与master进程之间的通信。\nmaster进程创建一个socket，并绑定监听到该目标端口，通过与子进程之间建立IPC通道，调用子进程的send方法，将socket（链接句柄）传递给子进程，大致实现如下。\n```javascript\n// master.js\nconst { fork } = require('child_process')\nconst cpus = require('os').cpus()\nconst net = require('net')\nconst workers = []\nfor (let i = 0; i < cpus.length; i++) {\n  workers.push(fork('./worker.js'))\n}\n\nconst handle = net._createServerHandle('0.0.0.0', 8000) // 其实这个handle就是我们的业务逻辑(app.js)\nhandle.listen()\n\nhandle.on('connection', (err, handle) => {\n  const worker = workers.pop()\n  worker.send({}, handle)\n  workers.unshift(worker)\n})\n```\n子进程的接收到来自主进程的消息以及句柄之后\n```javascript\n// worker.js\nconst net = require('net')\nprocess.on('message', (message, handle) => {\n  const socket = new net.socket({ handle })\n  socket.readable = true\n  socket.writable = true\n  socket.end(['data', message])\n})\n```\n\n\n\n### 传送门\nNodejs cluster模块深入探究：\nhttps://cloud.tencent.com/developer/article/1061912\nNodejs 进阶：解答 Cluster 模块的几个疑问：\nhttps://cloud.tencent.com/developer/article/1600191\n\n\npm2的cluster模式与fork模式的区别\nhttps://github.com/mopduan/team/issues/19\n\n浏览器进程与线程梳理\nhttps://segmentfault.com/a/1190000012925872\n\ncluster子进程重启方案\nhttps://javascript.ruanyifeng.com/nodejs/cluster.html\n\ncluster 模块的实现原理\nhttps://cloud.tencent.com/developer/article/1600191","source":"_posts/node-progress.md","raw":"---\ntitle: Nodejs子进程\ndate: 2020/12/30\ntag: [nodejs,child_process,cluster]\ncategory: 技术\n---\n\n进程是CPU分配资源的最小单位，分配独立内存，进程之间可通信，但是必须通过内核，使用IPC接口来做，代价比较大\n线程是CPU调度的最小单位\n\njavascript 语言本身被发明出来就是为浏览器服务的，所以为了在浏览器端渲染的界面的时候不会被来自不同金IC的数据干扰，js执行环境被设计成了单进程执行。\n但是在作为Nodejs使用的时候，为了最大发挥服务器的多核优势，Nodejs也被安排了多进程的能力。而为其提供多进程能力的核心模块就是 child_process\nchild_process提供了衍生子进程的能力，主要由child_process.spawn()函数提供。\n默认情况下， stdin、 stdout 和 stderr 的管道会在父 Node.js 进程和衍生的子进程之间建立，这些管道的容量是有限的。\n\n#### child_process.spawn\nnodejs还提供了一些基于child_process.spawn的一些替代方法，都是基于 child_process.spawn() 或 child_process.spawnSync() 实现的。\n```html\nchild_process.exec(): 衍生 shell 并且在 shell 中运行命令，当完成时则将 stdout 和 stderr 传给回调函数。\nchild_process.execFile(): 类似于 child_process.exec()，但是默认情况下它会直接衍生命令而不先衍生 shell。\nchild_process.fork(): 衍生新的 Node.js 进程，并调用指定的模块，该模块已建立了 IPC 通信通道，可以在父进程与子进程之间发送消息。\nchild_process.execSync(): child_process.exec() 的同步版本，会阻塞 Node.js 事件循环。\nchild_process.execFileSync(): child_process.execFile() 的同步版本，会阻塞 Node.js 事件循环。\n```\n来自[官方文档](http://nodejs.cn/api/child_process.html)\n\n#### cluster\ncluster模块是基于child_process.fork方法创建的，它可以使用IPC和父进程进行通信。\n![图片](http://zhoushirong.github.io/img/child_process.png)\n\ncluster 模块可以创建共享服务器端口的子进程，因此常常被用作nodejs的多进程部署，pm2的cluster模式就是利用了此方法。\n1.利用cluster创建子进程的方法\n```javascript\nconst cluster = require('cluster')\nconst http = require('http')\nconst numsCPUS = require('os').cpus().length\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`)\n  for( let i = 0; i < numsCPUS.length; i++) {\n    cluster.fork() // fork出来的子进程拥有和父进程一致的、独立的资源(数据空间、堆、栈)等。\n  }\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`)\n    cluster.fork() // 重新fork子进程\n  })\n} else { // 业务逻辑代码\n  http.createServer((req, res) => {\n    res.writeHead(200)\n    res.end('hello world\\n')\n  }).listen(8000)\n  console.log(`worker ${process.pid} started`)\n}\n```\n\n2.cluster实现原理\ncluster其实就是对于child_process模块的封装，通过child_procress.fork()出子进程，同时基于IPC实现了与master进程之间的通信。\nmaster进程创建一个socket，并绑定监听到该目标端口，通过与子进程之间建立IPC通道，调用子进程的send方法，将socket（链接句柄）传递给子进程，大致实现如下。\n```javascript\n// master.js\nconst { fork } = require('child_process')\nconst cpus = require('os').cpus()\nconst net = require('net')\nconst workers = []\nfor (let i = 0; i < cpus.length; i++) {\n  workers.push(fork('./worker.js'))\n}\n\nconst handle = net._createServerHandle('0.0.0.0', 8000) // 其实这个handle就是我们的业务逻辑(app.js)\nhandle.listen()\n\nhandle.on('connection', (err, handle) => {\n  const worker = workers.pop()\n  worker.send({}, handle)\n  workers.unshift(worker)\n})\n```\n子进程的接收到来自主进程的消息以及句柄之后\n```javascript\n// worker.js\nconst net = require('net')\nprocess.on('message', (message, handle) => {\n  const socket = new net.socket({ handle })\n  socket.readable = true\n  socket.writable = true\n  socket.end(['data', message])\n})\n```\n\n\n\n### 传送门\nNodejs cluster模块深入探究：\nhttps://cloud.tencent.com/developer/article/1061912\nNodejs 进阶：解答 Cluster 模块的几个疑问：\nhttps://cloud.tencent.com/developer/article/1600191\n\n\npm2的cluster模式与fork模式的区别\nhttps://github.com/mopduan/team/issues/19\n\n浏览器进程与线程梳理\nhttps://segmentfault.com/a/1190000012925872\n\ncluster子进程重启方案\nhttps://javascript.ruanyifeng.com/nodejs/cluster.html\n\ncluster 模块的实现原理\nhttps://cloud.tencent.com/developer/article/1600191","slug":"node-progress","published":1,"updated":"2021-03-30T01:32:00.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufw0012a0vzgr3ua6kp","content":"<p>进程是CPU分配资源的最小单位，分配独立内存，进程之间可通信，但是必须通过内核，使用IPC接口来做，代价比较大<br>线程是CPU调度的最小单位</p>\n<p>javascript 语言本身被发明出来就是为浏览器服务的，所以为了在浏览器端渲染的界面的时候不会被来自不同金IC的数据干扰，js执行环境被设计成了单进程执行。<br>但是在作为Nodejs使用的时候，为了最大发挥服务器的多核优势，Nodejs也被安排了多进程的能力。而为其提供多进程能力的核心模块就是 child_process<br>child_process提供了衍生子进程的能力，主要由child_process.spawn()函数提供。<br>默认情况下， stdin、 stdout 和 stderr 的管道会在父 Node.js 进程和衍生的子进程之间建立，这些管道的容量是有限的。</p>\n<h4 id=\"child-process-spawn\"><a href=\"#child-process-spawn\" class=\"headerlink\" title=\"child_process.spawn\"></a>child_process.spawn</h4><p>nodejs还提供了一些基于child_process.spawn的一些替代方法，都是基于 child_process.spawn() 或 child_process.spawnSync() 实现的。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child_process.exec(): 衍生 shell 并且在 shell 中运行命令，当完成时则将 stdout 和 stderr 传给回调函数。</span><br><span class=\"line\">child_process.execFile(): 类似于 child_process.exec()，但是默认情况下它会直接衍生命令而不先衍生 shell。</span><br><span class=\"line\">child_process.fork(): 衍生新的 Node.js 进程，并调用指定的模块，该模块已建立了 IPC 通信通道，可以在父进程与子进程之间发送消息。</span><br><span class=\"line\">child_process.execSync(): child_process.exec() 的同步版本，会阻塞 Node.js 事件循环。</span><br><span class=\"line\">child_process.execFileSync(): child_process.execFile() 的同步版本，会阻塞 Node.js 事件循环。</span><br></pre></td></tr></table></figure><br>来自<a href=\"http://nodejs.cn/api/child_process.html\">官方文档</a></p>\n<h4 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h4><p>cluster模块是基于child_process.fork方法创建的，它可以使用IPC和父进程进行通信。<br><img src=\"http://zhoushirong.github.io/img/child_process.png\" alt=\"图片\"></p>\n<p>cluster 模块可以创建共享服务器端口的子进程，因此常常被用作nodejs的多进程部署，pm2的cluster模式就是利用了此方法。<br>1.利用cluster创建子进程的方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cluster = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cluster&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> numsCPUS = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;os&#x27;</span>).cpus().length</span><br><span class=\"line\"><span class=\"keyword\">if</span> (cluster.isMaster) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Master <span class=\"subst\">$&#123;process.pid&#125;</span> is running`</span>)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">for</span>(<span class=\"params\"> <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; numsCPUS.length; i++</span>)</span> &#123;</span><br><span class=\"line\">    cluster.fork() <span class=\"comment\">// fork出来的子进程拥有和父进程一致的、独立的资源(数据空间、堆、栈)等。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  cluster.on(<span class=\"string\">&#x27;exit&#x27;</span>, <span class=\"function\">(<span class=\"params\">worker, code, signal</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`worker <span class=\"subst\">$&#123;worker.process.pid&#125;</span> died`</span>)</span><br><span class=\"line\">    cluster.fork() <span class=\"comment\">// 重新fork子进程</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 业务逻辑代码</span></span><br><span class=\"line\">  http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.writeHead(<span class=\"number\">200</span>)</span><br><span class=\"line\">    res.end(<span class=\"string\">&#x27;hello world\\n&#x27;</span>)</span><br><span class=\"line\">  &#125;).listen(<span class=\"number\">8000</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`worker <span class=\"subst\">$&#123;process.pid&#125;</span> started`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.cluster实现原理<br>cluster其实就是对于child_process模块的封装，通过child_procress.fork()出子进程，同时基于IPC实现了与master进程之间的通信。<br>master进程创建一个socket，并绑定监听到该目标端口，通过与子进程之间建立IPC通道，调用子进程的send方法，将socket（链接句柄）传递给子进程，大致实现如下。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// master.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; fork &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> cpus = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;os&#x27;</span>).cpus()</span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> workers = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; cpus.length; i++) &#123;</span><br><span class=\"line\">  workers.push(fork(<span class=\"string\">&#x27;./worker.js&#x27;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> handle = net._createServerHandle(<span class=\"string\">&#x27;0.0.0.0&#x27;</span>, <span class=\"number\">8000</span>) <span class=\"comment\">// 其实这个handle就是我们的业务逻辑(app.js)</span></span><br><span class=\"line\">handle.listen()</span><br><span class=\"line\"></span><br><span class=\"line\">handle.on(<span class=\"string\">&#x27;connection&#x27;</span>, <span class=\"function\">(<span class=\"params\">err, handle</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> worker = workers.pop()</span><br><span class=\"line\">  worker.send(&#123;&#125;, handle)</span><br><span class=\"line\">  workers.unshift(worker)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>子进程的接收到来自主进程的消息以及句柄之后<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// worker.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>)</span><br><span class=\"line\">process.on(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\">(<span class=\"params\">message, handle</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> socket = <span class=\"keyword\">new</span> net.socket(&#123; handle &#125;)</span><br><span class=\"line\">  socket.readable = <span class=\"literal\">true</span></span><br><span class=\"line\">  socket.writable = <span class=\"literal\">true</span></span><br><span class=\"line\">  socket.end([<span class=\"string\">&#x27;data&#x27;</span>, message])</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>Nodejs cluster模块深入探究：<br><a href=\"https://cloud.tencent.com/developer/article/1061912\">https://cloud.tencent.com/developer/article/1061912</a><br>Nodejs 进阶：解答 Cluster 模块的几个疑问：<br><a href=\"https://cloud.tencent.com/developer/article/1600191\">https://cloud.tencent.com/developer/article/1600191</a></p>\n<p>pm2的cluster模式与fork模式的区别<br><a href=\"https://github.com/mopduan/team/issues/19\">https://github.com/mopduan/team/issues/19</a></p>\n<p>浏览器进程与线程梳理<br><a href=\"https://segmentfault.com/a/1190000012925872\">https://segmentfault.com/a/1190000012925872</a></p>\n<p>cluster子进程重启方案<br><a href=\"https://javascript.ruanyifeng.com/nodejs/cluster.html\">https://javascript.ruanyifeng.com/nodejs/cluster.html</a></p>\n<p>cluster 模块的实现原理<br><a href=\"https://cloud.tencent.com/developer/article/1600191\">https://cloud.tencent.com/developer/article/1600191</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>进程是CPU分配资源的最小单位，分配独立内存，进程之间可通信，但是必须通过内核，使用IPC接口来做，代价比较大<br>线程是CPU调度的最小单位</p>\n<p>javascript 语言本身被发明出来就是为浏览器服务的，所以为了在浏览器端渲染的界面的时候不会被来自不同金IC的数据干扰，js执行环境被设计成了单进程执行。<br>但是在作为Nodejs使用的时候，为了最大发挥服务器的多核优势，Nodejs也被安排了多进程的能力。而为其提供多进程能力的核心模块就是 child_process<br>child_process提供了衍生子进程的能力，主要由child_process.spawn()函数提供。<br>默认情况下， stdin、 stdout 和 stderr 的管道会在父 Node.js 进程和衍生的子进程之间建立，这些管道的容量是有限的。</p>\n<h4 id=\"child-process-spawn\"><a href=\"#child-process-spawn\" class=\"headerlink\" title=\"child_process.spawn\"></a>child_process.spawn</h4><p>nodejs还提供了一些基于child_process.spawn的一些替代方法，都是基于 child_process.spawn() 或 child_process.spawnSync() 实现的。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child_process.exec(): 衍生 shell 并且在 shell 中运行命令，当完成时则将 stdout 和 stderr 传给回调函数。</span><br><span class=\"line\">child_process.execFile(): 类似于 child_process.exec()，但是默认情况下它会直接衍生命令而不先衍生 shell。</span><br><span class=\"line\">child_process.fork(): 衍生新的 Node.js 进程，并调用指定的模块，该模块已建立了 IPC 通信通道，可以在父进程与子进程之间发送消息。</span><br><span class=\"line\">child_process.execSync(): child_process.exec() 的同步版本，会阻塞 Node.js 事件循环。</span><br><span class=\"line\">child_process.execFileSync(): child_process.execFile() 的同步版本，会阻塞 Node.js 事件循环。</span><br></pre></td></tr></table></figure><br>来自<a href=\"http://nodejs.cn/api/child_process.html\">官方文档</a></p>\n<h4 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h4><p>cluster模块是基于child_process.fork方法创建的，它可以使用IPC和父进程进行通信。<br><img src=\"http://zhoushirong.github.io/img/child_process.png\" alt=\"图片\"></p>\n<p>cluster 模块可以创建共享服务器端口的子进程，因此常常被用作nodejs的多进程部署，pm2的cluster模式就是利用了此方法。<br>1.利用cluster创建子进程的方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cluster = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cluster&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> numsCPUS = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;os&#x27;</span>).cpus().length</span><br><span class=\"line\"><span class=\"keyword\">if</span> (cluster.isMaster) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Master <span class=\"subst\">$&#123;process.pid&#125;</span> is running`</span>)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">for</span>(<span class=\"params\"> <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; numsCPUS.length; i++</span>)</span> &#123;</span><br><span class=\"line\">    cluster.fork() <span class=\"comment\">// fork出来的子进程拥有和父进程一致的、独立的资源(数据空间、堆、栈)等。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  cluster.on(<span class=\"string\">&#x27;exit&#x27;</span>, <span class=\"function\">(<span class=\"params\">worker, code, signal</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`worker <span class=\"subst\">$&#123;worker.process.pid&#125;</span> died`</span>)</span><br><span class=\"line\">    cluster.fork() <span class=\"comment\">// 重新fork子进程</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 业务逻辑代码</span></span><br><span class=\"line\">  http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.writeHead(<span class=\"number\">200</span>)</span><br><span class=\"line\">    res.end(<span class=\"string\">&#x27;hello world\\n&#x27;</span>)</span><br><span class=\"line\">  &#125;).listen(<span class=\"number\">8000</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`worker <span class=\"subst\">$&#123;process.pid&#125;</span> started`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.cluster实现原理<br>cluster其实就是对于child_process模块的封装，通过child_procress.fork()出子进程，同时基于IPC实现了与master进程之间的通信。<br>master进程创建一个socket，并绑定监听到该目标端口，通过与子进程之间建立IPC通道，调用子进程的send方法，将socket（链接句柄）传递给子进程，大致实现如下。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// master.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; fork &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> cpus = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;os&#x27;</span>).cpus()</span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> workers = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; cpus.length; i++) &#123;</span><br><span class=\"line\">  workers.push(fork(<span class=\"string\">&#x27;./worker.js&#x27;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> handle = net._createServerHandle(<span class=\"string\">&#x27;0.0.0.0&#x27;</span>, <span class=\"number\">8000</span>) <span class=\"comment\">// 其实这个handle就是我们的业务逻辑(app.js)</span></span><br><span class=\"line\">handle.listen()</span><br><span class=\"line\"></span><br><span class=\"line\">handle.on(<span class=\"string\">&#x27;connection&#x27;</span>, <span class=\"function\">(<span class=\"params\">err, handle</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> worker = workers.pop()</span><br><span class=\"line\">  worker.send(&#123;&#125;, handle)</span><br><span class=\"line\">  workers.unshift(worker)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>子进程的接收到来自主进程的消息以及句柄之后<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// worker.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> net = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;net&#x27;</span>)</span><br><span class=\"line\">process.on(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\">(<span class=\"params\">message, handle</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> socket = <span class=\"keyword\">new</span> net.socket(&#123; handle &#125;)</span><br><span class=\"line\">  socket.readable = <span class=\"literal\">true</span></span><br><span class=\"line\">  socket.writable = <span class=\"literal\">true</span></span><br><span class=\"line\">  socket.end([<span class=\"string\">&#x27;data&#x27;</span>, message])</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>Nodejs cluster模块深入探究：<br><a href=\"https://cloud.tencent.com/developer/article/1061912\">https://cloud.tencent.com/developer/article/1061912</a><br>Nodejs 进阶：解答 Cluster 模块的几个疑问：<br><a href=\"https://cloud.tencent.com/developer/article/1600191\">https://cloud.tencent.com/developer/article/1600191</a></p>\n<p>pm2的cluster模式与fork模式的区别<br><a href=\"https://github.com/mopduan/team/issues/19\">https://github.com/mopduan/team/issues/19</a></p>\n<p>浏览器进程与线程梳理<br><a href=\"https://segmentfault.com/a/1190000012925872\">https://segmentfault.com/a/1190000012925872</a></p>\n<p>cluster子进程重启方案<br><a href=\"https://javascript.ruanyifeng.com/nodejs/cluster.html\">https://javascript.ruanyifeng.com/nodejs/cluster.html</a></p>\n<p>cluster 模块的实现原理<br><a href=\"https://cloud.tencent.com/developer/article/1600191\">https://cloud.tencent.com/developer/article/1600191</a></p>\n"},{"title":"Nodejs服务器部署","date":"2018-01-07T16:00:00.000Z","_content":"\n虽然PHP是“世界上最好的语言。”\n但是我还是喜欢JS。\n凡是可以用Javascript来写的应用，最终都会用Javascript来写。\n近些年Nodejs异常的火爆，因此有一些服务端也开始使用js来写了。作为前端开发工程师，nodejs也是必须要掌握的一项技能了。\n最近在网上买了个云服务器，于是想搭个Node服务出来。\n\n### 第一步：Nodejs的安装\n\n现在，在Window上和Mac上安装nodejs还是很方便的，去官网下载下来，下一步下一步下一步...就可以了。\n可是在服务器上安装就稍微有些麻烦了，在服务端（ubuntu）安装的时候一般都是下载源码，手动编译的，这就显得有些麻烦了。\n刚开始的时候还是有些坑。\n\n#### 方法一、通过源码编译安装\n\n首先将nodejs的源码安装包下载下来，然后解压编译\n\n``` shell\napt-get update # 更新已安装的包 若提示权限不足，在前面加上sudo\nwget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz # 获取nodejs最新包，版本号可选最新的\ntar xvf node-v8.9.4.tar.gz # 解压nodejs源码包\ncd node-v8.9.4 \n./configure \nmake # make编译需要花较长的时间\nmake install # 如果发现权限异常，需要在命令前面加上sudo\ncp /usr/local/bin/node /usr/sbin/ \nnode -v  #v8.9.4 查看当前安装的Node的版本 \n```\n\nmake的时候可能会报这个错误：\n``` html\nWARNING: failed to autodetect C++ compiler version (CXX=g++)\n```\n\n解决办法，手动编译； 编译结束，执行make install\n``` shell\napt-get install build-essential\nmake install\n```\n\n如果没有报错或者已解决错误，完成上述步骤，nodejs在服务端的安装以及结束了。\n接下来通过查看版本，检测是否安装成功\n\nnode安装完成\n``` html\nnode -v # 查看nodejs版本 v8.9.4\nnpm -v # 查看npm版本\n```\n\nnodejs安装目录\n```shell\nwhich node # 利用which命令查看当前使用的nodejs可执行文件位置\nwhere node # 利用where is 命令查看当前所有的nodejs可执行文件位置\n```\n\n#### 方法二、通过二进制文件安装\n\n``` shell\nwget https://nodejs.org/dist/v8.11.2/node-v8.11.2-linux-x64.tar.xz # 获取nodejs最新包，版本号可选最新的\nxz -d node-v8.11.2-linux-x64tar.xz # 两次解压\ntar -xvf  node-v8.11.2-linux-x64tar\n\nexport PATH=/home/xxx/nodejs/node-v8.11.2-linux-x64/bin:$PATH # 在.bashrc 文件中追加此句，设置环境变量\n```\n\n\n### 第二步：将本地的小网站上传到服务器上去\n\n首先确定服务器上的网站存放目录。\n\n这里我将它放到/website/\n\n``` shell\nscp -r /Users/zsr/test ubuntu/@123.xxx.xxx.xxx:/website\n```\n\n或者用rsync\n\n``` html\nrsync -a /Users/zsr/* root@118.193.173.25:~/website/\n```\n上传过长中出了一个错误,如果是直接上传到tmp就可以，其它的目录就会报错：\n\n``` html\nscp permission denied\n```\n\n网上查了下是因为权限不足，于是试了下上传到tmp目录，发现可行，确定是权限的问题之后就将自己的目录权限设置一下，就能正常上传了。\n*权限问题需谨慎，这里给了最高权限，实际生产环境自己调整适当的权限。*\n\n``` html\n# chmod 777 ./data1\n```\n\n### 第三步：安装mongodb\n\n``` html\napt-get update\napt-get install mongo\n```\n\n如果不update会报如下错误：\n``` html\nUnable to locate package mongo\n```\n\n### 第四步：安装pm2\n\n``` html\nnpm install -g pm2\n```\n\n### 第五步：安装并配置Nginx解析\n\n安装\n``` shell\nsudo apt-get install nginx\n```\n\n查看nginx是否安装成功\n\n``` shell\nnginx -v\n```\n\n配置文件路径\n``` shell\n/etc/nginx\n```\n\n配置过程中遇到个坑，老是返回hello nginx页面\n\n解决办法\n``` html\n注释掉\n\n/etc/nginx/nginx.conf \n\n里面的 \n\ninclude /etc/nginx/sites-enabled/* \n\n这一行\n```\n\n然后增加如下nginx配置，将80端口反代理到项目端口\n比如我在服务端写了个简单的node程序，端口为3000\n\n配置代理如下：\n\n``` html\nserver {\n    listen 80;\n    server_name xxx.xxx.xxx.xxx;\n    location / {\n        proxy_pass http://xxx.xxx.xxx.xxx:3000;\n    }\n}\n```\n\n配置完毕，检测Nginx配置是否正确\n\n``` html\nsudo nginx -t\n```\n\n检测错误，则对应具体信息做修改\n检测正确，重启Nginx 服务生效\n\n``` shell\nsudo service nginx reload\n```\n\n然后访问xxx.xxx.xxx.xxx:80即可访问到Node程序了\n\n至此服务端Node搭建网站告一段落\n下一步就是申请域名了。\n\n\n\n\n\n\n\n","source":"_posts/nodejs.md","raw":"---\ntitle: Nodejs服务器部署\ndate: 2018/01/08\ntag: nodejs\ncategory: 技术\n---\n\n虽然PHP是“世界上最好的语言。”\n但是我还是喜欢JS。\n凡是可以用Javascript来写的应用，最终都会用Javascript来写。\n近些年Nodejs异常的火爆，因此有一些服务端也开始使用js来写了。作为前端开发工程师，nodejs也是必须要掌握的一项技能了。\n最近在网上买了个云服务器，于是想搭个Node服务出来。\n\n### 第一步：Nodejs的安装\n\n现在，在Window上和Mac上安装nodejs还是很方便的，去官网下载下来，下一步下一步下一步...就可以了。\n可是在服务器上安装就稍微有些麻烦了，在服务端（ubuntu）安装的时候一般都是下载源码，手动编译的，这就显得有些麻烦了。\n刚开始的时候还是有些坑。\n\n#### 方法一、通过源码编译安装\n\n首先将nodejs的源码安装包下载下来，然后解压编译\n\n``` shell\napt-get update # 更新已安装的包 若提示权限不足，在前面加上sudo\nwget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz # 获取nodejs最新包，版本号可选最新的\ntar xvf node-v8.9.4.tar.gz # 解压nodejs源码包\ncd node-v8.9.4 \n./configure \nmake # make编译需要花较长的时间\nmake install # 如果发现权限异常，需要在命令前面加上sudo\ncp /usr/local/bin/node /usr/sbin/ \nnode -v  #v8.9.4 查看当前安装的Node的版本 \n```\n\nmake的时候可能会报这个错误：\n``` html\nWARNING: failed to autodetect C++ compiler version (CXX=g++)\n```\n\n解决办法，手动编译； 编译结束，执行make install\n``` shell\napt-get install build-essential\nmake install\n```\n\n如果没有报错或者已解决错误，完成上述步骤，nodejs在服务端的安装以及结束了。\n接下来通过查看版本，检测是否安装成功\n\nnode安装完成\n``` html\nnode -v # 查看nodejs版本 v8.9.4\nnpm -v # 查看npm版本\n```\n\nnodejs安装目录\n```shell\nwhich node # 利用which命令查看当前使用的nodejs可执行文件位置\nwhere node # 利用where is 命令查看当前所有的nodejs可执行文件位置\n```\n\n#### 方法二、通过二进制文件安装\n\n``` shell\nwget https://nodejs.org/dist/v8.11.2/node-v8.11.2-linux-x64.tar.xz # 获取nodejs最新包，版本号可选最新的\nxz -d node-v8.11.2-linux-x64tar.xz # 两次解压\ntar -xvf  node-v8.11.2-linux-x64tar\n\nexport PATH=/home/xxx/nodejs/node-v8.11.2-linux-x64/bin:$PATH # 在.bashrc 文件中追加此句，设置环境变量\n```\n\n\n### 第二步：将本地的小网站上传到服务器上去\n\n首先确定服务器上的网站存放目录。\n\n这里我将它放到/website/\n\n``` shell\nscp -r /Users/zsr/test ubuntu/@123.xxx.xxx.xxx:/website\n```\n\n或者用rsync\n\n``` html\nrsync -a /Users/zsr/* root@118.193.173.25:~/website/\n```\n上传过长中出了一个错误,如果是直接上传到tmp就可以，其它的目录就会报错：\n\n``` html\nscp permission denied\n```\n\n网上查了下是因为权限不足，于是试了下上传到tmp目录，发现可行，确定是权限的问题之后就将自己的目录权限设置一下，就能正常上传了。\n*权限问题需谨慎，这里给了最高权限，实际生产环境自己调整适当的权限。*\n\n``` html\n# chmod 777 ./data1\n```\n\n### 第三步：安装mongodb\n\n``` html\napt-get update\napt-get install mongo\n```\n\n如果不update会报如下错误：\n``` html\nUnable to locate package mongo\n```\n\n### 第四步：安装pm2\n\n``` html\nnpm install -g pm2\n```\n\n### 第五步：安装并配置Nginx解析\n\n安装\n``` shell\nsudo apt-get install nginx\n```\n\n查看nginx是否安装成功\n\n``` shell\nnginx -v\n```\n\n配置文件路径\n``` shell\n/etc/nginx\n```\n\n配置过程中遇到个坑，老是返回hello nginx页面\n\n解决办法\n``` html\n注释掉\n\n/etc/nginx/nginx.conf \n\n里面的 \n\ninclude /etc/nginx/sites-enabled/* \n\n这一行\n```\n\n然后增加如下nginx配置，将80端口反代理到项目端口\n比如我在服务端写了个简单的node程序，端口为3000\n\n配置代理如下：\n\n``` html\nserver {\n    listen 80;\n    server_name xxx.xxx.xxx.xxx;\n    location / {\n        proxy_pass http://xxx.xxx.xxx.xxx:3000;\n    }\n}\n```\n\n配置完毕，检测Nginx配置是否正确\n\n``` html\nsudo nginx -t\n```\n\n检测错误，则对应具体信息做修改\n检测正确，重启Nginx 服务生效\n\n``` shell\nsudo service nginx reload\n```\n\n然后访问xxx.xxx.xxx.xxx:80即可访问到Node程序了\n\n至此服务端Node搭建网站告一段落\n下一步就是申请域名了。\n\n\n\n\n\n\n\n","slug":"nodejs","published":1,"updated":"2021-03-30T01:32:00.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufx0013a0vz18ct1f4w","content":"<p>虽然PHP是“世界上最好的语言。”<br>但是我还是喜欢JS。<br>凡是可以用Javascript来写的应用，最终都会用Javascript来写。<br>近些年Nodejs异常的火爆，因此有一些服务端也开始使用js来写了。作为前端开发工程师，nodejs也是必须要掌握的一项技能了。<br>最近在网上买了个云服务器，于是想搭个Node服务出来。</p>\n<h3 id=\"第一步：Nodejs的安装\"><a href=\"#第一步：Nodejs的安装\" class=\"headerlink\" title=\"第一步：Nodejs的安装\"></a>第一步：Nodejs的安装</h3><p>现在，在Window上和Mac上安装nodejs还是很方便的，去官网下载下来，下一步下一步下一步…就可以了。<br>可是在服务器上安装就稍微有些麻烦了，在服务端（ubuntu）安装的时候一般都是下载源码，手动编译的，这就显得有些麻烦了。<br>刚开始的时候还是有些坑。</p>\n<h4 id=\"方法一、通过源码编译安装\"><a href=\"#方法一、通过源码编译安装\" class=\"headerlink\" title=\"方法一、通过源码编译安装\"></a>方法一、通过源码编译安装</h4><p>首先将nodejs的源码安装包下载下来，然后解压编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get update # 更新已安装的包 若提示权限不足，在前面加上sudo</span><br><span class=\"line\">wget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz # 获取nodejs最新包，版本号可选最新的</span><br><span class=\"line\">tar xvf node-v8.9.4.tar.gz # 解压nodejs源码包</span><br><span class=\"line\">cd node-v8.9.4 </span><br><span class=\"line\">./configure </span><br><span class=\"line\">make # make编译需要花较长的时间</span><br><span class=\"line\">make install # 如果发现权限异常，需要在命令前面加上sudo</span><br><span class=\"line\">cp /usr/local/bin/node /usr/sbin/ </span><br><span class=\"line\">node -v  #v8.9.4 查看当前安装的Node的版本 </span><br></pre></td></tr></table></figure>\n<p>make的时候可能会报这个错误：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WARNING: failed to autodetect C++ compiler version (CXX=g++)</span><br></pre></td></tr></table></figure></p>\n<p>解决办法，手动编译； 编译结束，执行make install<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install build-essential</span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure></p>\n<p>如果没有报错或者已解决错误，完成上述步骤，nodejs在服务端的安装以及结束了。<br>接下来通过查看版本，检测是否安装成功</p>\n<p>node安装完成<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v # 查看nodejs版本 v8.9.4</span><br><span class=\"line\">npm -v # 查看npm版本</span><br></pre></td></tr></table></figure></p>\n<p>nodejs安装目录<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which node # 利用which命令查看当前使用的nodejs可执行文件位置</span><br><span class=\"line\">where node # 利用where is 命令查看当前所有的nodejs可执行文件位置</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"方法二、通过二进制文件安装\"><a href=\"#方法二、通过二进制文件安装\" class=\"headerlink\" title=\"方法二、通过二进制文件安装\"></a>方法二、通过二进制文件安装</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://nodejs.org/dist/v8.11.2/node-v8.11.2-linux-x64.tar.xz # 获取nodejs最新包，版本号可选最新的</span><br><span class=\"line\">xz -d node-v8.11.2-linux-x64tar.xz # 两次解压</span><br><span class=\"line\">tar -xvf  node-v8.11.2-linux-x64tar</span><br><span class=\"line\"></span><br><span class=\"line\">export PATH=/home/xxx/nodejs/node-v8.11.2-linux-x64/bin:$PATH # 在.bashrc 文件中追加此句，设置环境变量</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步：将本地的小网站上传到服务器上去\"><a href=\"#第二步：将本地的小网站上传到服务器上去\" class=\"headerlink\" title=\"第二步：将本地的小网站上传到服务器上去\"></a>第二步：将本地的小网站上传到服务器上去</h3><p>首先确定服务器上的网站存放目录。</p>\n<p>这里我将它放到/website/</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r /Users/zsr/test ubuntu/@123.xxx.xxx.xxx:/website</span><br></pre></td></tr></table></figure>\n<p>或者用rsync</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync -a /Users/zsr/* root@118.193.173.25:~/website/</span><br></pre></td></tr></table></figure>\n<p>上传过长中出了一个错误,如果是直接上传到tmp就可以，其它的目录就会报错：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp permission denied</span><br></pre></td></tr></table></figure>\n<p>网上查了下是因为权限不足，于是试了下上传到tmp目录，发现可行，确定是权限的问题之后就将自己的目录权限设置一下，就能正常上传了。<br><em>权限问题需谨慎，这里给了最高权限，实际生产环境自己调整适当的权限。</em></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># chmod 777 ./data1</span><br></pre></td></tr></table></figure>\n<h3 id=\"第三步：安装mongodb\"><a href=\"#第三步：安装mongodb\" class=\"headerlink\" title=\"第三步：安装mongodb\"></a>第三步：安装mongodb</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get update</span><br><span class=\"line\">apt-get install mongo</span><br></pre></td></tr></table></figure>\n<p>如果不update会报如下错误：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unable to locate package mongo</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第四步：安装pm2\"><a href=\"#第四步：安装pm2\" class=\"headerlink\" title=\"第四步：安装pm2\"></a>第四步：安装pm2</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g pm2</span><br></pre></td></tr></table></figure>\n<h3 id=\"第五步：安装并配置Nginx解析\"><a href=\"#第五步：安装并配置Nginx解析\" class=\"headerlink\" title=\"第五步：安装并配置Nginx解析\"></a>第五步：安装并配置Nginx解析</h3><p>安装<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install nginx</span><br></pre></td></tr></table></figure></p>\n<p>查看nginx是否安装成功</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -v</span><br></pre></td></tr></table></figure>\n<p>配置文件路径<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/nginx</span><br></pre></td></tr></table></figure></p>\n<p>配置过程中遇到个坑，老是返回hello nginx页面</p>\n<p>解决办法<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注释掉</span><br><span class=\"line\"></span><br><span class=\"line\">/etc/nginx/nginx.conf </span><br><span class=\"line\"></span><br><span class=\"line\">里面的 </span><br><span class=\"line\"></span><br><span class=\"line\">include /etc/nginx/sites-enabled/* </span><br><span class=\"line\"></span><br><span class=\"line\">这一行</span><br></pre></td></tr></table></figure></p>\n<p>然后增加如下nginx配置，将80端口反代理到项目端口<br>比如我在服务端写了个简单的node程序，端口为3000</p>\n<p>配置代理如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name xxx.xxx.xxx.xxx;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://xxx.xxx.xxx.xxx:3000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置完毕，检测Nginx配置是否正确</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nginx -t</span><br></pre></td></tr></table></figure>\n<p>检测错误，则对应具体信息做修改<br>检测正确，重启Nginx 服务生效</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service nginx reload</span><br></pre></td></tr></table></figure>\n<p>然后访问xxx.xxx.xxx.xxx:80即可访问到Node程序了</p>\n<p>至此服务端Node搭建网站告一段落<br>下一步就是申请域名了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>虽然PHP是“世界上最好的语言。”<br>但是我还是喜欢JS。<br>凡是可以用Javascript来写的应用，最终都会用Javascript来写。<br>近些年Nodejs异常的火爆，因此有一些服务端也开始使用js来写了。作为前端开发工程师，nodejs也是必须要掌握的一项技能了。<br>最近在网上买了个云服务器，于是想搭个Node服务出来。</p>\n<h3 id=\"第一步：Nodejs的安装\"><a href=\"#第一步：Nodejs的安装\" class=\"headerlink\" title=\"第一步：Nodejs的安装\"></a>第一步：Nodejs的安装</h3><p>现在，在Window上和Mac上安装nodejs还是很方便的，去官网下载下来，下一步下一步下一步…就可以了。<br>可是在服务器上安装就稍微有些麻烦了，在服务端（ubuntu）安装的时候一般都是下载源码，手动编译的，这就显得有些麻烦了。<br>刚开始的时候还是有些坑。</p>\n<h4 id=\"方法一、通过源码编译安装\"><a href=\"#方法一、通过源码编译安装\" class=\"headerlink\" title=\"方法一、通过源码编译安装\"></a>方法一、通过源码编译安装</h4><p>首先将nodejs的源码安装包下载下来，然后解压编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get update # 更新已安装的包 若提示权限不足，在前面加上sudo</span><br><span class=\"line\">wget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz # 获取nodejs最新包，版本号可选最新的</span><br><span class=\"line\">tar xvf node-v8.9.4.tar.gz # 解压nodejs源码包</span><br><span class=\"line\">cd node-v8.9.4 </span><br><span class=\"line\">./configure </span><br><span class=\"line\">make # make编译需要花较长的时间</span><br><span class=\"line\">make install # 如果发现权限异常，需要在命令前面加上sudo</span><br><span class=\"line\">cp /usr/local/bin/node /usr/sbin/ </span><br><span class=\"line\">node -v  #v8.9.4 查看当前安装的Node的版本 </span><br></pre></td></tr></table></figure>\n<p>make的时候可能会报这个错误：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WARNING: failed to autodetect C++ compiler version (CXX=g++)</span><br></pre></td></tr></table></figure></p>\n<p>解决办法，手动编译； 编译结束，执行make install<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install build-essential</span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure></p>\n<p>如果没有报错或者已解决错误，完成上述步骤，nodejs在服务端的安装以及结束了。<br>接下来通过查看版本，检测是否安装成功</p>\n<p>node安装完成<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v # 查看nodejs版本 v8.9.4</span><br><span class=\"line\">npm -v # 查看npm版本</span><br></pre></td></tr></table></figure></p>\n<p>nodejs安装目录<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which node # 利用which命令查看当前使用的nodejs可执行文件位置</span><br><span class=\"line\">where node # 利用where is 命令查看当前所有的nodejs可执行文件位置</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"方法二、通过二进制文件安装\"><a href=\"#方法二、通过二进制文件安装\" class=\"headerlink\" title=\"方法二、通过二进制文件安装\"></a>方法二、通过二进制文件安装</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://nodejs.org/dist/v8.11.2/node-v8.11.2-linux-x64.tar.xz # 获取nodejs最新包，版本号可选最新的</span><br><span class=\"line\">xz -d node-v8.11.2-linux-x64tar.xz # 两次解压</span><br><span class=\"line\">tar -xvf  node-v8.11.2-linux-x64tar</span><br><span class=\"line\"></span><br><span class=\"line\">export PATH=/home/xxx/nodejs/node-v8.11.2-linux-x64/bin:$PATH # 在.bashrc 文件中追加此句，设置环境变量</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二步：将本地的小网站上传到服务器上去\"><a href=\"#第二步：将本地的小网站上传到服务器上去\" class=\"headerlink\" title=\"第二步：将本地的小网站上传到服务器上去\"></a>第二步：将本地的小网站上传到服务器上去</h3><p>首先确定服务器上的网站存放目录。</p>\n<p>这里我将它放到/website/</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r /Users/zsr/test ubuntu/@123.xxx.xxx.xxx:/website</span><br></pre></td></tr></table></figure>\n<p>或者用rsync</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync -a /Users/zsr/* root@118.193.173.25:~/website/</span><br></pre></td></tr></table></figure>\n<p>上传过长中出了一个错误,如果是直接上传到tmp就可以，其它的目录就会报错：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp permission denied</span><br></pre></td></tr></table></figure>\n<p>网上查了下是因为权限不足，于是试了下上传到tmp目录，发现可行，确定是权限的问题之后就将自己的目录权限设置一下，就能正常上传了。<br><em>权限问题需谨慎，这里给了最高权限，实际生产环境自己调整适当的权限。</em></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># chmod 777 ./data1</span><br></pre></td></tr></table></figure>\n<h3 id=\"第三步：安装mongodb\"><a href=\"#第三步：安装mongodb\" class=\"headerlink\" title=\"第三步：安装mongodb\"></a>第三步：安装mongodb</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get update</span><br><span class=\"line\">apt-get install mongo</span><br></pre></td></tr></table></figure>\n<p>如果不update会报如下错误：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unable to locate package mongo</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第四步：安装pm2\"><a href=\"#第四步：安装pm2\" class=\"headerlink\" title=\"第四步：安装pm2\"></a>第四步：安装pm2</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g pm2</span><br></pre></td></tr></table></figure>\n<h3 id=\"第五步：安装并配置Nginx解析\"><a href=\"#第五步：安装并配置Nginx解析\" class=\"headerlink\" title=\"第五步：安装并配置Nginx解析\"></a>第五步：安装并配置Nginx解析</h3><p>安装<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install nginx</span><br></pre></td></tr></table></figure></p>\n<p>查看nginx是否安装成功</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -v</span><br></pre></td></tr></table></figure>\n<p>配置文件路径<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/nginx</span><br></pre></td></tr></table></figure></p>\n<p>配置过程中遇到个坑，老是返回hello nginx页面</p>\n<p>解决办法<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注释掉</span><br><span class=\"line\"></span><br><span class=\"line\">/etc/nginx/nginx.conf </span><br><span class=\"line\"></span><br><span class=\"line\">里面的 </span><br><span class=\"line\"></span><br><span class=\"line\">include /etc/nginx/sites-enabled/* </span><br><span class=\"line\"></span><br><span class=\"line\">这一行</span><br></pre></td></tr></table></figure></p>\n<p>然后增加如下nginx配置，将80端口反代理到项目端口<br>比如我在服务端写了个简单的node程序，端口为3000</p>\n<p>配置代理如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name xxx.xxx.xxx.xxx;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://xxx.xxx.xxx.xxx:3000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置完毕，检测Nginx配置是否正确</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nginx -t</span><br></pre></td></tr></table></figure>\n<p>检测错误，则对应具体信息做修改<br>检测正确，重启Nginx 服务生效</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service nginx reload</span><br></pre></td></tr></table></figure>\n<p>然后访问xxx.xxx.xxx.xxx:80即可访问到Node程序了</p>\n<p>至此服务端Node搭建网站告一段落<br>下一步就是申请域名了。</p>\n"},{"layout":"default","title":"NODEJS开发经验","date":"2019-01-14T16:00:00.000Z","_content":"\n前段时间做了一个 nodejs 应用，项目架构是 前端 vue 单页应用，后端 nodejs\n其实有考虑 ssr，但是因开发时间比较紧张，就没能使用。\n下面是开发过程中的一些经验以及遇到的一些问题。\n\n### 一、技术架构\n<img src=\"http://zhoushirong.github.io/img/nodejs.png\" alt=\"koa洋葱模型\" width=\"860px\" />\n\n具体项目技术栈如下：\nclient端: vue 全家桶、history-router\nserver端: koa、koa-router、redis+sentinel、msyql、java (java后端组同学开发)\n\n### 二、项目目录\n```html\nclient/ # 所有的前端文件\n- node_module/ # 前端文件依赖包\n- src/ # 前端代码源码\n- webpack/ # 构建工具\n- package.json # 前端依赖包文件\nmock/ # mock数据，\n- api/ #对后端的mock（接口数据）\n- index.js #mock入口文件\nnode_modules/ # 项目启动开发工具依赖包\nserver/ # 服务端代码\n- channel/ # 数据渠道、来源（java http、java dubbo、数据库、redis）\n- config/ # 网站配置文件（环境配置、数据库、redis 配置等）\n- middleware/ # 中间件\n- model # 数据库数据模型层\n- node_modules/ # 服务端依赖包\n- router/ # 路由（controler层）\n- tools/ # 一些常用工具函数\n- app.js # 服务入口\n- autoRouter.js #路由入口\n- package.json # 后端依赖包文件\npackage.json # 公共项目依赖包文件\n```\n\n### 三、技术要点\n##### promise、async await \npromise、async、await都属于javascript基础，这里略过。\n\n##### client 端的请求\n请求类型大概分为如下几类，以及各个类别对应的 koa 处理中间件模块\n\n1.页面请求 —— history-router\n\n2.静态资源请求 —— koa-static\n\n3.favicon请求 —— koa-favicon\n\n4.接口请求 —— koa-router\n\n##### NODEJS 请求过程\n\n<img src=\"http://zhoushirong.github.io/img/request1.png\" alt=\"请求流程\" width=\"560px\" />\n\n<img src=\"http://zhoushirong.github.io/img/request2.png\" alt=\"请求接口模型\" width=\"560px\" />\n\n##### koa 中间件、node端路由\n\n中间件：中间件在请求和响应的过程中给我们一个修改数据的机会\n\n中间件的功能包括：\n1.执行任何代码。\n2.修改请求和响应对象。\n3.终结请求 - 响应循环。\n4.调用堆栈中的下一个中间件\n\n\n中间件是koa的核心，中间件return一个中间件函数，最好是用一个函数给封装起来，以便于传参和可扩展性。\n本项目几乎所有路由处理都是通过中间件完成的。\n\n中间件操作分为同步操作和异步操作。\n同步操作很简单，处理完事务之后直接 await next() 到下一个中间件即可。\n```javascript\nfunction middleFunction(param1, param2) {\n  return async function middle1(ctx, next) {\n    if ('/middle1' == ctx.path) {\n      ctx.body = { data: param1 + param2 }\n    } else {\n      await next();\n    }\n  }\n}\n```\n\n异步中间件，也很好理解，就是在中间件内部进行处理的是一个异步流程。\n我们可以借助 async 和 await 来处理异步事务。\n\n```javascript\nfunction middleFunction(param1, param2) {\n  return async function middle3(ctx, next) {\n    if ('/middle3' == ctx.path) {\n      // 对于异步操作，await 必须等待一个promise对象\n\t  ctx.body = await new Promise((resolve, reject) => {\n        setTimeout(() => {\n          resolve(param1 + param2)\n        }, 3000)\n      })\n    } else {\n      await next()\n    }\n  }\n}\n```\n\nkoa 中中间件是最核心的操作，因此往往会有很多中间件，中间件多意味着管理上需要花费更多的精力。\n因此，koa 也提供了一些很方便的管理工具，如：用 koa-compose 组合中间件\n\n```javascript\nconst compose = require('koa-compose')\nasync function middle1(ctx, next) {\n  if ('/middle1' == ctx.path) {\n    ctx.body = { data: 'middle1' }\n  } else {\n    await next();\n  }\n}\nasync function middle2(ctx, next) {\n  if ('/middle2' == ctx.path) {\n    ctx.body = { data: 'middle2' }\n  } else {\n    await next()\n  }\n}\n// ...\nconst middles = compose([middle1, middle2, /*...*/])\napp.use(middles)\n```\n\n多个中间件如何执行？执行顺序如何？\nkoa 中间件执行过程是一层一层的执行的，由外而内，再由内向外。\n网上流传着很广泛的“洋葱模型”很好的诠释了这顺序，如下图所示：\n\n<img src=\"http://zhoushirong.github.io/img/onion.png\" alt=\"koa洋葱模型\" width=\"360px\" />\n\n等同于下面的这张图。\n<img src=\"http://zhoushirong.github.io/img/routerpath.png\" alt=\"koa洋葱模型2\" width=\"600px\" />\n\n\n```javascript\nconst Koa = require('koa')\nconst app = new Koa()\napp.use(async (ctx, next) => {\n  console.log(1)\n  await next()\n  console.log(2)\n})\n\napp.use(async (ctx, next) => {\n  console.log(3)\n  await next()\n  console.log(4)\n})\n\napp.use(async (ctx, next) => {\n  console.log(5)\n  ctx.body = 'Hello World'\n  console.log(6)\n})\napp.listen(3000)\n\n// curl localhost:3000 输出：\n// 1\n// 3\n// 5\n// 6\n// 4\n// 2\n```\n\n其执行顺序等同于下面的：\n\n```javascript\nfunction func1() {\n  return new Promise((resolve, reject) => {\n    console.log(1)\n    func2()\n    console.log(2)\n  })\n}\n\nfunction func2() {\n  return new Promise((resolve, reject) => {\n    console.log(3)\n    func3()\n    console.log(4)\n  })\n}\n\nfunction func3() {\n  console.log(5)\n  return new Promise((resolve, reject) => {\n    console.log(6)\n  })\n}\n\nfunc1()\n\n// node index.js 执行结果如下：\n// 1\n// 3\n// 5\n// 6\n// 4\n// 2\n```\n理解了上面两段代码也就大概理解了 koa 的中间件的执行了。\n\n\n##### 整个系统执行中间件过程如下\nkoa-compress > koa-bodyparser > koa2-connect-history-api-fallback > koa-favicon > koa-static > commonRouter -> koa-router\n\n其中 commonRouter 为自定义的中间件，内部路由过程如下：\n记录开始时间 > 判断登录态 > 执行后续路由 > 回来执行记录结束时间 > 打日志(日志需要有请求时间)\n\n\n##### 容错、错误码\n容错是程序的必要操作，尤其是后端项目，尤其重要，因为一旦报错很可能导致整个系统崩溃。\n影响范围极大，为了更好的管理错误，我们最好能做到统一出口、入口，以便能够对错误进行更好的监控，以及异常处理。\n可以借助于中间件来完成。\n\n##### 日志(引入log4 -> 日志埋点上报 -> logsearch|kibana查看)\n日志也是后端项目必不可少的，nodejs 项目目前比较流行的日志框架有很多\nlog4js 是目前用的比较多的，其格式也跟其它语言的日志类似。（如 java 的log4j）\nlog4js：可以做日志收集、写入文件，在服务器直接指定固定目录/data/nodejs/log\n\n```shell\ndata/nodejs/access.log\ndata/nodejs/other.log\ndata/nodejs/server.log\n```\n\n##### 本地调试\n断点调试是一个很好的习惯，nodejs 最简单快捷的方式就是 console.log 直接控制台查看。\n但是，对于复杂的情形，我们也会有需要用到断点调试的时候。\n使用 vscode开发，并启动nodejs服务，可以很方便的进行断点 debug。\n\n##### 数据 mock\n对于 nodejs 数据 mock 可以有很多方式：\n方式一：是用第三方 mock 服务，启动一个mock数据端口<a href=\"https://github.com/zhoushirong/static-mock\">static-mock</a>\n方式二：利用 webpack 的插件<a href=\"https://www.npmjs.com/package/webpack-api-mocker\">webpack-api-mocker</a>\n\n开发此项目的时候用的是方法二，好处是可以少启动一个端口，mock 可以和 client 的 webpack-dev-server 共享端口。\n\n\n##### 用到的主要第三方中间件\n***koa-static***：将静态目录映射为路由可访问的路径\n***koa-favicon***：将favicon.ico路径映射为可访问路径并设置max-age缓存头\n***koa-compress***：对请求进行开启gzip压缩，效果很明显（nginx也可以做压缩），压缩之后 \nresponse-headers会有这个属性  Content-Encoding:gzip\n***koa-bodyparser***：对于POST请求的处理，koa-bodyparser中间件可以把 koa2 上下文的 formData 数据解析到\t      ctx.request.body中\n***koa2-connect-history-api-fallback***：对vue history路由做处理，默认将非.xxx后缀请求跳到默认index.html页面\n\n\n##### 安全 xss、csrf、sql注入\nkoa-helmet：9个安全中间件的集合、帮助app抵御常见的一些web安全隐患\nkoa-limit：防止DOS攻击\nkoa-csrf：防止CSRF攻击\nsql注入：对参数进行过滤（见后面附录1）\n\n除此之外，还用到了如下工具：\n##### 启动工具 pm2、nodemon、配置、部署、健康检查\n##### redis、sentinels、Medis图形化工具\n##### mysql、mysql连接池、navicat图形化工具\n\n#### 四、踩过的坑\n\n1.favicon.ico 不出来：\n\n```javascript\napp.use(favicon(path.join(__dirname, 'favicon.ico')))\n```\n\n```html\n<link rel=\"shortcut icon\" href=\"/favicon.ico\" type=\"image/x-icon\">\n```\n\n\n2.直接用浏览器打开接口失败\n\n原因：koa2-connect-history-api-fallback 中间件做了强制跳转\n\n```javascript\n// /server/node_modules/koa2-connect-history-api-fallback/lib/connect-history-api-fallback.js\n// koa2-connect-history-api-fallback 中间件在此处做了强制跳转\nif (parsedUrl.pathname.indexOf('.') !== -1 && options.disableDotRule !== true) {\n  logger('Not rewriting', ctx.method, ctx.url, 'because the path includes a dot (.) character.');\n  return next();\n}\n```\n\n解决办法：设置白名单\n\n```javascript\napp.use(historyApiFallback({ whiteList: ['/api/'] }))\n```\n\n3.ndp环境变量首次设置之后生效，后面修改不生效，不生效\n\n```html\nndp -> 配置 -> 发布配置 -> NODE_ENV \n```\n\n原因：怀疑是ndp本身的bug，未确定。\n\n解决办法：手动杀掉服务器上pm2进程，重新启动。\n\n\n4.发布之后进程没有杀死，有一个错误的进程将服务器cpu跑满了。\n\n原因：可能是早期服务代码不完善，报错导致pm2管理失败，后续未重现\n\n解决办法：手动杀掉服务器进程\n\n\n\n5.日志打印报错，log4js 本地能写日志文件，服务器上写不了。\n\n原因：\n\n本地开发启动NODE服务的时候只启动一个进程。(需理解进程的概念)\n\n而通过ndp发布之后，自动通过pm2启动，用的是cluster模式，启动了多个进程。\n\nlog4js，对于单进程和多进程需要做不同的配置。\n\n解决办法：\n\n```javascript\n// 文档地址： https://log4js-node.github.io/log4js-node/api.html\nlog4js.configure({\n  disableClustering: true, // 不启动日志的集群模式\n  // pm2: true, // 或者使用pm2，此模式需要服务端安装 pm2 install pm2-intercom\n  // ...\n})\n```\n\n6.测试、后端登录我们的项目的时候登录偶尔登录不上，切接口数据更新不及时\n\n原因：配置nginx的时候配置了缓存6min\n\n```shell\n location / {\n  proxy_pass http://node_server;\n  expires 10m; # 这个不需要\n}\n```\n\n解决办法：\n\n去掉nginx缓存配置 expires选项。\n\n\n\n7.每次到一个新的环境，第一次构建都会报模块找不到的错误，重试N次之后正常。\n\n可能原因：\n\n执行build.sh的时候执行的是npm install client && npm install server 安装的总命令\n\n总命令下的子命令 npm install client 等才是真正的安装npm依赖模块\n\n而执行build.sh的时候脚本是同步的，但是只针对脚本内的总命令，不包括子命令\n\n导致npm安装变成异步执行了，在npm未安装完成的情况下执行npm run build导致报错\n\n解决办法：将总命令拆开分别执行安装\n\n```shell\nregistry=https://registry.npm.taobao.org\nnpm install --prefix  ./client --registry=$registry\nnpm install --prefix ./server --registry=$registry\nnpm run build\n```\n\n\n\n8.经过 Nginx 的静态资源和接口返回的数据被截掉了一部分，返回的数据不完整。\n\n问题原因：\n\n新的预发环境nginx配置了缓冲，缓冲过小的时候nginx会将数据写入硬盘，而此时如果没有硬盘文件夹的读取权限，就会出现请求数据被截断的情况。\n\n 解决办法：增大缓冲\n\n```shell\n# 在预发环境 和 线上环境的location / 下面配置 proxy_buffers 缓存大小\nlocation / {\n  proxy_buffer_size 64k; # 请求头缓冲大小\n  proxy_buffers 4 512k; # 请求内容缓冲大小 4 * 512kb\n}\n```\n\n\n### 传送门：\n\n1.mac 靠谱的安装mysql教程地址：\n\nhttps://gist.github.com/nrollr/3f57fc15ded7dddddcc4e82fe137b58e\n\n2.redis命令教程地址\n\nhttp://redisdoc.com/\n\n3.redis sentinels学习配置教程\n\nhttps://blog.csdn.net/men_wen/article/details/72724406\n\n4.上次分享的nodejs架构基础参考\n\nhttp://doc.hz.netease.com/pages/viewpage.action?pageId=117468038\n\n5.koa安全中间件简介\n\nhttps://cnodejs.org/topic/5a502debafa0a121784a89c3\n\n\n### 附录1：\n\nnode-mysql中防止SQL注入四种常用方法：\n\n方法一：\n\n使用 escape 方法对参数进行编码，如：\n\n```sql\nmysql.escape(param); \nconnection.escape(param);\npoll.escape(param)\n```\n\nescape()方法编码规则：\n\n```html\nNumbers不进行转换；\n\nBooleans转换为true/false；\n\nDate对象转换为’YYYY-mm-dd HH:ii:ss’字符串；\n\nBuffers转换为hex字符串，如X’0fa5’；\n\nStrings进行安全转义；\n\nArrays转换为列表，如[‘a’, ‘b’]会转换为’a’, ‘b’；\n\n多维数组转换为组列表，如[[‘a’, ‘b’], [‘c’, ‘d’]]会转换为’a’, ‘b’), (‘c’, ‘d’)；\n\nObjects会转换为key=value键值对的形式。嵌套的对象转换为字符串；\n\nundefined/null会转换为NULL；\n\nMySQL不支持NaN/Infinity，并且会触发MySQL错误。\n```\n\n\n\n方法二：\n\n使用connection.query()的查询参数占位符\n\n使用？作为查询参数占位符。\n\n在使用查询参数占位符的时候，在其内部自动调用 connection.escape() 方法对其传入的参数进行编码，如：\n\n```javascript\nlet post  = { name: 'namestring' }\nlet query = connection.query('SELECT * FROM users WHERE ?', post, (err, results) => {\n});\nconsole.log(query.sql); // SELECT * FROM users WHERE name = 'namestring'\n```\n\n\n\n方法三：\n\n使用escapedId()编码SQL查询标识符。\n\n```javascript\nmysql.escapedId(identifier)\nconnection.escapeId(identifier)\npool.escapeId(identifier)\n\n// 多用于排序，如：\nlet sorter = 'date'\nlet sql = 'SELECT * FROM posts ORDER BY ' + connection.escapeId(sorter)\n```\n\n\n\n方法四：\n\n使用mysql.format()转义参数。\n\n准备查询，此方法用于准备查询语句，该函数会自动选择合适的转义参数。\n\n\n","source":"_posts/nodejs2.md","raw":"---\nlayout: default\ntitle: NODEJS开发经验\ndate: 2019-01-15\ntag: [nodejs, 服务端]\ncategory: 笔记\n---\n\n前段时间做了一个 nodejs 应用，项目架构是 前端 vue 单页应用，后端 nodejs\n其实有考虑 ssr，但是因开发时间比较紧张，就没能使用。\n下面是开发过程中的一些经验以及遇到的一些问题。\n\n### 一、技术架构\n<img src=\"http://zhoushirong.github.io/img/nodejs.png\" alt=\"koa洋葱模型\" width=\"860px\" />\n\n具体项目技术栈如下：\nclient端: vue 全家桶、history-router\nserver端: koa、koa-router、redis+sentinel、msyql、java (java后端组同学开发)\n\n### 二、项目目录\n```html\nclient/ # 所有的前端文件\n- node_module/ # 前端文件依赖包\n- src/ # 前端代码源码\n- webpack/ # 构建工具\n- package.json # 前端依赖包文件\nmock/ # mock数据，\n- api/ #对后端的mock（接口数据）\n- index.js #mock入口文件\nnode_modules/ # 项目启动开发工具依赖包\nserver/ # 服务端代码\n- channel/ # 数据渠道、来源（java http、java dubbo、数据库、redis）\n- config/ # 网站配置文件（环境配置、数据库、redis 配置等）\n- middleware/ # 中间件\n- model # 数据库数据模型层\n- node_modules/ # 服务端依赖包\n- router/ # 路由（controler层）\n- tools/ # 一些常用工具函数\n- app.js # 服务入口\n- autoRouter.js #路由入口\n- package.json # 后端依赖包文件\npackage.json # 公共项目依赖包文件\n```\n\n### 三、技术要点\n##### promise、async await \npromise、async、await都属于javascript基础，这里略过。\n\n##### client 端的请求\n请求类型大概分为如下几类，以及各个类别对应的 koa 处理中间件模块\n\n1.页面请求 —— history-router\n\n2.静态资源请求 —— koa-static\n\n3.favicon请求 —— koa-favicon\n\n4.接口请求 —— koa-router\n\n##### NODEJS 请求过程\n\n<img src=\"http://zhoushirong.github.io/img/request1.png\" alt=\"请求流程\" width=\"560px\" />\n\n<img src=\"http://zhoushirong.github.io/img/request2.png\" alt=\"请求接口模型\" width=\"560px\" />\n\n##### koa 中间件、node端路由\n\n中间件：中间件在请求和响应的过程中给我们一个修改数据的机会\n\n中间件的功能包括：\n1.执行任何代码。\n2.修改请求和响应对象。\n3.终结请求 - 响应循环。\n4.调用堆栈中的下一个中间件\n\n\n中间件是koa的核心，中间件return一个中间件函数，最好是用一个函数给封装起来，以便于传参和可扩展性。\n本项目几乎所有路由处理都是通过中间件完成的。\n\n中间件操作分为同步操作和异步操作。\n同步操作很简单，处理完事务之后直接 await next() 到下一个中间件即可。\n```javascript\nfunction middleFunction(param1, param2) {\n  return async function middle1(ctx, next) {\n    if ('/middle1' == ctx.path) {\n      ctx.body = { data: param1 + param2 }\n    } else {\n      await next();\n    }\n  }\n}\n```\n\n异步中间件，也很好理解，就是在中间件内部进行处理的是一个异步流程。\n我们可以借助 async 和 await 来处理异步事务。\n\n```javascript\nfunction middleFunction(param1, param2) {\n  return async function middle3(ctx, next) {\n    if ('/middle3' == ctx.path) {\n      // 对于异步操作，await 必须等待一个promise对象\n\t  ctx.body = await new Promise((resolve, reject) => {\n        setTimeout(() => {\n          resolve(param1 + param2)\n        }, 3000)\n      })\n    } else {\n      await next()\n    }\n  }\n}\n```\n\nkoa 中中间件是最核心的操作，因此往往会有很多中间件，中间件多意味着管理上需要花费更多的精力。\n因此，koa 也提供了一些很方便的管理工具，如：用 koa-compose 组合中间件\n\n```javascript\nconst compose = require('koa-compose')\nasync function middle1(ctx, next) {\n  if ('/middle1' == ctx.path) {\n    ctx.body = { data: 'middle1' }\n  } else {\n    await next();\n  }\n}\nasync function middle2(ctx, next) {\n  if ('/middle2' == ctx.path) {\n    ctx.body = { data: 'middle2' }\n  } else {\n    await next()\n  }\n}\n// ...\nconst middles = compose([middle1, middle2, /*...*/])\napp.use(middles)\n```\n\n多个中间件如何执行？执行顺序如何？\nkoa 中间件执行过程是一层一层的执行的，由外而内，再由内向外。\n网上流传着很广泛的“洋葱模型”很好的诠释了这顺序，如下图所示：\n\n<img src=\"http://zhoushirong.github.io/img/onion.png\" alt=\"koa洋葱模型\" width=\"360px\" />\n\n等同于下面的这张图。\n<img src=\"http://zhoushirong.github.io/img/routerpath.png\" alt=\"koa洋葱模型2\" width=\"600px\" />\n\n\n```javascript\nconst Koa = require('koa')\nconst app = new Koa()\napp.use(async (ctx, next) => {\n  console.log(1)\n  await next()\n  console.log(2)\n})\n\napp.use(async (ctx, next) => {\n  console.log(3)\n  await next()\n  console.log(4)\n})\n\napp.use(async (ctx, next) => {\n  console.log(5)\n  ctx.body = 'Hello World'\n  console.log(6)\n})\napp.listen(3000)\n\n// curl localhost:3000 输出：\n// 1\n// 3\n// 5\n// 6\n// 4\n// 2\n```\n\n其执行顺序等同于下面的：\n\n```javascript\nfunction func1() {\n  return new Promise((resolve, reject) => {\n    console.log(1)\n    func2()\n    console.log(2)\n  })\n}\n\nfunction func2() {\n  return new Promise((resolve, reject) => {\n    console.log(3)\n    func3()\n    console.log(4)\n  })\n}\n\nfunction func3() {\n  console.log(5)\n  return new Promise((resolve, reject) => {\n    console.log(6)\n  })\n}\n\nfunc1()\n\n// node index.js 执行结果如下：\n// 1\n// 3\n// 5\n// 6\n// 4\n// 2\n```\n理解了上面两段代码也就大概理解了 koa 的中间件的执行了。\n\n\n##### 整个系统执行中间件过程如下\nkoa-compress > koa-bodyparser > koa2-connect-history-api-fallback > koa-favicon > koa-static > commonRouter -> koa-router\n\n其中 commonRouter 为自定义的中间件，内部路由过程如下：\n记录开始时间 > 判断登录态 > 执行后续路由 > 回来执行记录结束时间 > 打日志(日志需要有请求时间)\n\n\n##### 容错、错误码\n容错是程序的必要操作，尤其是后端项目，尤其重要，因为一旦报错很可能导致整个系统崩溃。\n影响范围极大，为了更好的管理错误，我们最好能做到统一出口、入口，以便能够对错误进行更好的监控，以及异常处理。\n可以借助于中间件来完成。\n\n##### 日志(引入log4 -> 日志埋点上报 -> logsearch|kibana查看)\n日志也是后端项目必不可少的，nodejs 项目目前比较流行的日志框架有很多\nlog4js 是目前用的比较多的，其格式也跟其它语言的日志类似。（如 java 的log4j）\nlog4js：可以做日志收集、写入文件，在服务器直接指定固定目录/data/nodejs/log\n\n```shell\ndata/nodejs/access.log\ndata/nodejs/other.log\ndata/nodejs/server.log\n```\n\n##### 本地调试\n断点调试是一个很好的习惯，nodejs 最简单快捷的方式就是 console.log 直接控制台查看。\n但是，对于复杂的情形，我们也会有需要用到断点调试的时候。\n使用 vscode开发，并启动nodejs服务，可以很方便的进行断点 debug。\n\n##### 数据 mock\n对于 nodejs 数据 mock 可以有很多方式：\n方式一：是用第三方 mock 服务，启动一个mock数据端口<a href=\"https://github.com/zhoushirong/static-mock\">static-mock</a>\n方式二：利用 webpack 的插件<a href=\"https://www.npmjs.com/package/webpack-api-mocker\">webpack-api-mocker</a>\n\n开发此项目的时候用的是方法二，好处是可以少启动一个端口，mock 可以和 client 的 webpack-dev-server 共享端口。\n\n\n##### 用到的主要第三方中间件\n***koa-static***：将静态目录映射为路由可访问的路径\n***koa-favicon***：将favicon.ico路径映射为可访问路径并设置max-age缓存头\n***koa-compress***：对请求进行开启gzip压缩，效果很明显（nginx也可以做压缩），压缩之后 \nresponse-headers会有这个属性  Content-Encoding:gzip\n***koa-bodyparser***：对于POST请求的处理，koa-bodyparser中间件可以把 koa2 上下文的 formData 数据解析到\t      ctx.request.body中\n***koa2-connect-history-api-fallback***：对vue history路由做处理，默认将非.xxx后缀请求跳到默认index.html页面\n\n\n##### 安全 xss、csrf、sql注入\nkoa-helmet：9个安全中间件的集合、帮助app抵御常见的一些web安全隐患\nkoa-limit：防止DOS攻击\nkoa-csrf：防止CSRF攻击\nsql注入：对参数进行过滤（见后面附录1）\n\n除此之外，还用到了如下工具：\n##### 启动工具 pm2、nodemon、配置、部署、健康检查\n##### redis、sentinels、Medis图形化工具\n##### mysql、mysql连接池、navicat图形化工具\n\n#### 四、踩过的坑\n\n1.favicon.ico 不出来：\n\n```javascript\napp.use(favicon(path.join(__dirname, 'favicon.ico')))\n```\n\n```html\n<link rel=\"shortcut icon\" href=\"/favicon.ico\" type=\"image/x-icon\">\n```\n\n\n2.直接用浏览器打开接口失败\n\n原因：koa2-connect-history-api-fallback 中间件做了强制跳转\n\n```javascript\n// /server/node_modules/koa2-connect-history-api-fallback/lib/connect-history-api-fallback.js\n// koa2-connect-history-api-fallback 中间件在此处做了强制跳转\nif (parsedUrl.pathname.indexOf('.') !== -1 && options.disableDotRule !== true) {\n  logger('Not rewriting', ctx.method, ctx.url, 'because the path includes a dot (.) character.');\n  return next();\n}\n```\n\n解决办法：设置白名单\n\n```javascript\napp.use(historyApiFallback({ whiteList: ['/api/'] }))\n```\n\n3.ndp环境变量首次设置之后生效，后面修改不生效，不生效\n\n```html\nndp -> 配置 -> 发布配置 -> NODE_ENV \n```\n\n原因：怀疑是ndp本身的bug，未确定。\n\n解决办法：手动杀掉服务器上pm2进程，重新启动。\n\n\n4.发布之后进程没有杀死，有一个错误的进程将服务器cpu跑满了。\n\n原因：可能是早期服务代码不完善，报错导致pm2管理失败，后续未重现\n\n解决办法：手动杀掉服务器进程\n\n\n\n5.日志打印报错，log4js 本地能写日志文件，服务器上写不了。\n\n原因：\n\n本地开发启动NODE服务的时候只启动一个进程。(需理解进程的概念)\n\n而通过ndp发布之后，自动通过pm2启动，用的是cluster模式，启动了多个进程。\n\nlog4js，对于单进程和多进程需要做不同的配置。\n\n解决办法：\n\n```javascript\n// 文档地址： https://log4js-node.github.io/log4js-node/api.html\nlog4js.configure({\n  disableClustering: true, // 不启动日志的集群模式\n  // pm2: true, // 或者使用pm2，此模式需要服务端安装 pm2 install pm2-intercom\n  // ...\n})\n```\n\n6.测试、后端登录我们的项目的时候登录偶尔登录不上，切接口数据更新不及时\n\n原因：配置nginx的时候配置了缓存6min\n\n```shell\n location / {\n  proxy_pass http://node_server;\n  expires 10m; # 这个不需要\n}\n```\n\n解决办法：\n\n去掉nginx缓存配置 expires选项。\n\n\n\n7.每次到一个新的环境，第一次构建都会报模块找不到的错误，重试N次之后正常。\n\n可能原因：\n\n执行build.sh的时候执行的是npm install client && npm install server 安装的总命令\n\n总命令下的子命令 npm install client 等才是真正的安装npm依赖模块\n\n而执行build.sh的时候脚本是同步的，但是只针对脚本内的总命令，不包括子命令\n\n导致npm安装变成异步执行了，在npm未安装完成的情况下执行npm run build导致报错\n\n解决办法：将总命令拆开分别执行安装\n\n```shell\nregistry=https://registry.npm.taobao.org\nnpm install --prefix  ./client --registry=$registry\nnpm install --prefix ./server --registry=$registry\nnpm run build\n```\n\n\n\n8.经过 Nginx 的静态资源和接口返回的数据被截掉了一部分，返回的数据不完整。\n\n问题原因：\n\n新的预发环境nginx配置了缓冲，缓冲过小的时候nginx会将数据写入硬盘，而此时如果没有硬盘文件夹的读取权限，就会出现请求数据被截断的情况。\n\n 解决办法：增大缓冲\n\n```shell\n# 在预发环境 和 线上环境的location / 下面配置 proxy_buffers 缓存大小\nlocation / {\n  proxy_buffer_size 64k; # 请求头缓冲大小\n  proxy_buffers 4 512k; # 请求内容缓冲大小 4 * 512kb\n}\n```\n\n\n### 传送门：\n\n1.mac 靠谱的安装mysql教程地址：\n\nhttps://gist.github.com/nrollr/3f57fc15ded7dddddcc4e82fe137b58e\n\n2.redis命令教程地址\n\nhttp://redisdoc.com/\n\n3.redis sentinels学习配置教程\n\nhttps://blog.csdn.net/men_wen/article/details/72724406\n\n4.上次分享的nodejs架构基础参考\n\nhttp://doc.hz.netease.com/pages/viewpage.action?pageId=117468038\n\n5.koa安全中间件简介\n\nhttps://cnodejs.org/topic/5a502debafa0a121784a89c3\n\n\n### 附录1：\n\nnode-mysql中防止SQL注入四种常用方法：\n\n方法一：\n\n使用 escape 方法对参数进行编码，如：\n\n```sql\nmysql.escape(param); \nconnection.escape(param);\npoll.escape(param)\n```\n\nescape()方法编码规则：\n\n```html\nNumbers不进行转换；\n\nBooleans转换为true/false；\n\nDate对象转换为’YYYY-mm-dd HH:ii:ss’字符串；\n\nBuffers转换为hex字符串，如X’0fa5’；\n\nStrings进行安全转义；\n\nArrays转换为列表，如[‘a’, ‘b’]会转换为’a’, ‘b’；\n\n多维数组转换为组列表，如[[‘a’, ‘b’], [‘c’, ‘d’]]会转换为’a’, ‘b’), (‘c’, ‘d’)；\n\nObjects会转换为key=value键值对的形式。嵌套的对象转换为字符串；\n\nundefined/null会转换为NULL；\n\nMySQL不支持NaN/Infinity，并且会触发MySQL错误。\n```\n\n\n\n方法二：\n\n使用connection.query()的查询参数占位符\n\n使用？作为查询参数占位符。\n\n在使用查询参数占位符的时候，在其内部自动调用 connection.escape() 方法对其传入的参数进行编码，如：\n\n```javascript\nlet post  = { name: 'namestring' }\nlet query = connection.query('SELECT * FROM users WHERE ?', post, (err, results) => {\n});\nconsole.log(query.sql); // SELECT * FROM users WHERE name = 'namestring'\n```\n\n\n\n方法三：\n\n使用escapedId()编码SQL查询标识符。\n\n```javascript\nmysql.escapedId(identifier)\nconnection.escapeId(identifier)\npool.escapeId(identifier)\n\n// 多用于排序，如：\nlet sorter = 'date'\nlet sql = 'SELECT * FROM posts ORDER BY ' + connection.escapeId(sorter)\n```\n\n\n\n方法四：\n\n使用mysql.format()转义参数。\n\n准备查询，此方法用于准备查询语句，该函数会自动选择合适的转义参数。\n\n\n","slug":"nodejs2","published":1,"updated":"2021-03-30T01:32:00.322Z","comments":1,"photos":[],"link":"","_id":"ckn2g7ufx0014a0vz9c0affxs","content":"<p>前段时间做了一个 nodejs 应用，项目架构是 前端 vue 单页应用，后端 nodejs<br>其实有考虑 ssr，但是因开发时间比较紧张，就没能使用。<br>下面是开发过程中的一些经验以及遇到的一些问题。</p>\n<h3 id=\"一、技术架构\"><a href=\"#一、技术架构\" class=\"headerlink\" title=\"一、技术架构\"></a>一、技术架构</h3><p><img src=\"http://zhoushirong.github.io/img/nodejs.png\" alt=\"koa洋葱模型\" width=\"860px\" /></p>\n<p>具体项目技术栈如下：<br>client端: vue 全家桶、history-router<br>server端: koa、koa-router、redis+sentinel、msyql、java (java后端组同学开发)</p>\n<h3 id=\"二、项目目录\"><a href=\"#二、项目目录\" class=\"headerlink\" title=\"二、项目目录\"></a>二、项目目录</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">client/ # 所有的前端文件</span><br><span class=\"line\">- node_module/ # 前端文件依赖包</span><br><span class=\"line\">- src/ # 前端代码源码</span><br><span class=\"line\">- webpack/ # 构建工具</span><br><span class=\"line\">- package.json # 前端依赖包文件</span><br><span class=\"line\">mock/ # mock数据，</span><br><span class=\"line\">- api/ #对后端的mock（接口数据）</span><br><span class=\"line\">- index.js #mock入口文件</span><br><span class=\"line\">node_modules/ # 项目启动开发工具依赖包</span><br><span class=\"line\">server/ # 服务端代码</span><br><span class=\"line\">- channel/ # 数据渠道、来源（java http、java dubbo、数据库、redis）</span><br><span class=\"line\">- config/ # 网站配置文件（环境配置、数据库、redis 配置等）</span><br><span class=\"line\">- middleware/ # 中间件</span><br><span class=\"line\">- model # 数据库数据模型层</span><br><span class=\"line\">- node_modules/ # 服务端依赖包</span><br><span class=\"line\">- router/ # 路由（controler层）</span><br><span class=\"line\">- tools/ # 一些常用工具函数</span><br><span class=\"line\">- app.js # 服务入口</span><br><span class=\"line\">- autoRouter.js #路由入口</span><br><span class=\"line\">- package.json # 后端依赖包文件</span><br><span class=\"line\">package.json # 公共项目依赖包文件</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、技术要点\"><a href=\"#三、技术要点\" class=\"headerlink\" title=\"三、技术要点\"></a>三、技术要点</h3><h5 id=\"promise、async-await\"><a href=\"#promise、async-await\" class=\"headerlink\" title=\"promise、async await\"></a>promise、async await</h5><p>promise、async、await都属于javascript基础，这里略过。</p>\n<h5 id=\"client-端的请求\"><a href=\"#client-端的请求\" class=\"headerlink\" title=\"client 端的请求\"></a>client 端的请求</h5><p>请求类型大概分为如下几类，以及各个类别对应的 koa 处理中间件模块</p>\n<p>1.页面请求 —— history-router</p>\n<p>2.静态资源请求 —— koa-static</p>\n<p>3.favicon请求 —— koa-favicon</p>\n<p>4.接口请求 —— koa-router</p>\n<h5 id=\"NODEJS-请求过程\"><a href=\"#NODEJS-请求过程\" class=\"headerlink\" title=\"NODEJS 请求过程\"></a>NODEJS 请求过程</h5><p><img src=\"http://zhoushirong.github.io/img/request1.png\" alt=\"请求流程\" width=\"560px\" /></p>\n<p><img src=\"http://zhoushirong.github.io/img/request2.png\" alt=\"请求接口模型\" width=\"560px\" /></p>\n<h5 id=\"koa-中间件、node端路由\"><a href=\"#koa-中间件、node端路由\" class=\"headerlink\" title=\"koa 中间件、node端路由\"></a>koa 中间件、node端路由</h5><p>中间件：中间件在请求和响应的过程中给我们一个修改数据的机会</p>\n<p>中间件的功能包括：<br>1.执行任何代码。<br>2.修改请求和响应对象。<br>3.终结请求 - 响应循环。<br>4.调用堆栈中的下一个中间件</p>\n<p>中间件是koa的核心，中间件return一个中间件函数，最好是用一个函数给封装起来，以便于传参和可扩展性。<br>本项目几乎所有路由处理都是通过中间件完成的。</p>\n<p>中间件操作分为同步操作和异步操作。<br>同步操作很简单，处理完事务之后直接 await next() 到下一个中间件即可。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleFunction</span>(<span class=\"params\">param1, param2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middle1</span>(<span class=\"params\">ctx, next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;/middle1&#x27;</span> == ctx.path) &#123;</span><br><span class=\"line\">      ctx.body = &#123; <span class=\"attr\">data</span>: param1 + param2 &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>异步中间件，也很好理解，就是在中间件内部进行处理的是一个异步流程。<br>我们可以借助 async 和 await 来处理异步事务。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleFunction</span>(<span class=\"params\">param1, param2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middle3</span>(<span class=\"params\">ctx, next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;/middle3&#x27;</span> == ctx.path) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 对于异步操作，await 必须等待一个promise对象</span></span><br><span class=\"line\">\t  ctx.body = <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          resolve(param1 + param2)</span><br><span class=\"line\">        &#125;, <span class=\"number\">3000</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>koa 中中间件是最核心的操作，因此往往会有很多中间件，中间件多意味着管理上需要花费更多的精力。<br>因此，koa 也提供了一些很方便的管理工具，如：用 koa-compose 组合中间件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-compose&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middle1</span>(<span class=\"params\">ctx, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;/middle1&#x27;</span> == ctx.path) &#123;</span><br><span class=\"line\">    ctx.body = &#123; <span class=\"attr\">data</span>: <span class=\"string\">&#x27;middle1&#x27;</span> &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middle2</span>(<span class=\"params\">ctx, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;/middle2&#x27;</span> == ctx.path) &#123;</span><br><span class=\"line\">    ctx.body = &#123; <span class=\"attr\">data</span>: <span class=\"string\">&#x27;middle2&#x27;</span> &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> middles = compose([middle1, middle2, <span class=\"comment\">/*...*/</span>])</span><br><span class=\"line\">app.use(middles)</span><br></pre></td></tr></table></figure>\n<p>多个中间件如何执行？执行顺序如何？<br>koa 中间件执行过程是一层一层的执行的，由外而内，再由内向外。<br>网上流传着很广泛的“洋葱模型”很好的诠释了这顺序，如下图所示：</p>\n<p><img src=\"http://zhoushirong.github.io/img/onion.png\" alt=\"koa洋葱模型\" width=\"360px\" /></p>\n<p>等同于下面的这张图。<br><img src=\"http://zhoushirong.github.io/img/routerpath.png\" alt=\"koa洋葱模型2\" width=\"600px\" /></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>)</span><br><span class=\"line\">  ctx.body = <span class=\"string\">&#x27;Hello World&#x27;</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">6</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// curl localhost:3000 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>其执行顺序等同于下面的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    func2()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\">    func3()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">6</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func1()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// node index.js 执行结果如下：</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>理解了上面两段代码也就大概理解了 koa 的中间件的执行了。</p>\n<h5 id=\"整个系统执行中间件过程如下\"><a href=\"#整个系统执行中间件过程如下\" class=\"headerlink\" title=\"整个系统执行中间件过程如下\"></a>整个系统执行中间件过程如下</h5><p>koa-compress &gt; koa-bodyparser &gt; koa2-connect-history-api-fallback &gt; koa-favicon &gt; koa-static &gt; commonRouter -&gt; koa-router</p>\n<p>其中 commonRouter 为自定义的中间件，内部路由过程如下：<br>记录开始时间 &gt; 判断登录态 &gt; 执行后续路由 &gt; 回来执行记录结束时间 &gt; 打日志(日志需要有请求时间)</p>\n<h5 id=\"容错、错误码\"><a href=\"#容错、错误码\" class=\"headerlink\" title=\"容错、错误码\"></a>容错、错误码</h5><p>容错是程序的必要操作，尤其是后端项目，尤其重要，因为一旦报错很可能导致整个系统崩溃。<br>影响范围极大，为了更好的管理错误，我们最好能做到统一出口、入口，以便能够对错误进行更好的监控，以及异常处理。<br>可以借助于中间件来完成。</p>\n<h5 id=\"日志-引入log4-gt-日志埋点上报-gt-logsearch-kibana查看\"><a href=\"#日志-引入log4-gt-日志埋点上报-gt-logsearch-kibana查看\" class=\"headerlink\" title=\"日志(引入log4 -&gt; 日志埋点上报 -&gt; logsearch|kibana查看)\"></a>日志(引入log4 -&gt; 日志埋点上报 -&gt; logsearch|kibana查看)</h5><p>日志也是后端项目必不可少的，nodejs 项目目前比较流行的日志框架有很多<br>log4js 是目前用的比较多的，其格式也跟其它语言的日志类似。（如 java 的log4j）<br>log4js：可以做日志收集、写入文件，在服务器直接指定固定目录/data/nodejs/log</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data/nodejs/access.log</span><br><span class=\"line\">data/nodejs/other.log</span><br><span class=\"line\">data/nodejs/server.log</span><br></pre></td></tr></table></figure>\n<h5 id=\"本地调试\"><a href=\"#本地调试\" class=\"headerlink\" title=\"本地调试\"></a>本地调试</h5><p>断点调试是一个很好的习惯，nodejs 最简单快捷的方式就是 console.log 直接控制台查看。<br>但是，对于复杂的情形，我们也会有需要用到断点调试的时候。<br>使用 vscode开发，并启动nodejs服务，可以很方便的进行断点 debug。</p>\n<h5 id=\"数据-mock\"><a href=\"#数据-mock\" class=\"headerlink\" title=\"数据 mock\"></a>数据 mock</h5><p>对于 nodejs 数据 mock 可以有很多方式：<br>方式一：是用第三方 mock 服务，启动一个mock数据端口<a href=\"https://github.com/zhoushirong/static-mock\">static-mock</a><br>方式二：利用 webpack 的插件<a href=\"https://www.npmjs.com/package/webpack-api-mocker\">webpack-api-mocker</a></p>\n<p>开发此项目的时候用的是方法二，好处是可以少启动一个端口，mock 可以和 client 的 webpack-dev-server 共享端口。</p>\n<h5 id=\"用到的主要第三方中间件\"><a href=\"#用到的主要第三方中间件\" class=\"headerlink\" title=\"用到的主要第三方中间件\"></a>用到的主要第三方中间件</h5><p><strong><em>koa-static</em></strong>：将静态目录映射为路由可访问的路径<br><strong><em>koa-favicon</em></strong>：将favicon.ico路径映射为可访问路径并设置max-age缓存头<br><strong><em>koa-compress</em></strong>：对请求进行开启gzip压缩，效果很明显（nginx也可以做压缩），压缩之后<br>response-headers会有这个属性  Content-Encoding:gzip<br><strong><em>koa-bodyparser</em></strong>：对于POST请求的处理，koa-bodyparser中间件可以把 koa2 上下文的 formData 数据解析到          ctx.request.body中<br><strong><em>koa2-connect-history-api-fallback</em></strong>：对vue history路由做处理，默认将非.xxx后缀请求跳到默认index.html页面</p>\n<h5 id=\"安全-xss、csrf、sql注入\"><a href=\"#安全-xss、csrf、sql注入\" class=\"headerlink\" title=\"安全 xss、csrf、sql注入\"></a>安全 xss、csrf、sql注入</h5><p>koa-helmet：9个安全中间件的集合、帮助app抵御常见的一些web安全隐患<br>koa-limit：防止DOS攻击<br>koa-csrf：防止CSRF攻击<br>sql注入：对参数进行过滤（见后面附录1）</p>\n<p>除此之外，还用到了如下工具：</p>\n<h5 id=\"启动工具-pm2、nodemon、配置、部署、健康检查\"><a href=\"#启动工具-pm2、nodemon、配置、部署、健康检查\" class=\"headerlink\" title=\"启动工具 pm2、nodemon、配置、部署、健康检查\"></a>启动工具 pm2、nodemon、配置、部署、健康检查</h5><h5 id=\"redis、sentinels、Medis图形化工具\"><a href=\"#redis、sentinels、Medis图形化工具\" class=\"headerlink\" title=\"redis、sentinels、Medis图形化工具\"></a>redis、sentinels、Medis图形化工具</h5><h5 id=\"mysql、mysql连接池、navicat图形化工具\"><a href=\"#mysql、mysql连接池、navicat图形化工具\" class=\"headerlink\" title=\"mysql、mysql连接池、navicat图形化工具\"></a>mysql、mysql连接池、navicat图形化工具</h5><h4 id=\"四、踩过的坑\"><a href=\"#四、踩过的坑\" class=\"headerlink\" title=\"四、踩过的坑\"></a>四、踩过的坑</h4><p>1.favicon.ico 不出来：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(favicon(path.join(__dirname, <span class=\"string\">&#x27;favicon.ico&#x27;</span>)))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;shortcut icon&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/favicon.ico&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;image/x-icon&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>2.直接用浏览器打开接口失败</p>\n<p>原因：koa2-connect-history-api-fallback 中间件做了强制跳转</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /server/node_modules/koa2-connect-history-api-fallback/lib/connect-history-api-fallback.js</span></span><br><span class=\"line\"><span class=\"comment\">// koa2-connect-history-api-fallback 中间件在此处做了强制跳转</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (parsedUrl.pathname.indexOf(<span class=\"string\">&#x27;.&#x27;</span>) !== -<span class=\"number\">1</span> &amp;&amp; options.disableDotRule !== <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  logger(<span class=\"string\">&#x27;Not rewriting&#x27;</span>, ctx.method, ctx.url, <span class=\"string\">&#x27;because the path includes a dot (.) character.&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解决办法：设置白名单</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(historyApiFallback(&#123; <span class=\"attr\">whiteList</span>: [<span class=\"string\">&#x27;/api/&#x27;</span>] &#125;))</span><br></pre></td></tr></table></figure>\n<p>3.ndp环境变量首次设置之后生效，后面修改不生效，不生效</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ndp -&gt; 配置 -&gt; 发布配置 -&gt; NODE_ENV </span><br></pre></td></tr></table></figure>\n<p>原因：怀疑是ndp本身的bug，未确定。</p>\n<p>解决办法：手动杀掉服务器上pm2进程，重新启动。</p>\n<p>4.发布之后进程没有杀死，有一个错误的进程将服务器cpu跑满了。</p>\n<p>原因：可能是早期服务代码不完善，报错导致pm2管理失败，后续未重现</p>\n<p>解决办法：手动杀掉服务器进程</p>\n<p>5.日志打印报错，log4js 本地能写日志文件，服务器上写不了。</p>\n<p>原因：</p>\n<p>本地开发启动NODE服务的时候只启动一个进程。(需理解进程的概念)</p>\n<p>而通过ndp发布之后，自动通过pm2启动，用的是cluster模式，启动了多个进程。</p>\n<p>log4js，对于单进程和多进程需要做不同的配置。</p>\n<p>解决办法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 文档地址： https://log4js-node.github.io/log4js-node/api.html</span></span><br><span class=\"line\">log4js.configure(&#123;</span><br><span class=\"line\">  disableClustering: <span class=\"literal\">true</span>, <span class=\"comment\">// 不启动日志的集群模式</span></span><br><span class=\"line\">  <span class=\"comment\">// pm2: true, // 或者使用pm2，此模式需要服务端安装 pm2 install pm2-intercom</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>6.测试、后端登录我们的项目的时候登录偶尔登录不上，切接口数据更新不及时</p>\n<p>原因：配置nginx的时候配置了缓存6min</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> location / &#123;</span><br><span class=\"line\">  proxy_pass http://node_server;</span><br><span class=\"line\">  expires 10m; # 这个不需要</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解决办法：</p>\n<p>去掉nginx缓存配置 expires选项。</p>\n<p>7.每次到一个新的环境，第一次构建都会报模块找不到的错误，重试N次之后正常。</p>\n<p>可能原因：</p>\n<p>执行build.sh的时候执行的是npm install client &amp;&amp; npm install server 安装的总命令</p>\n<p>总命令下的子命令 npm install client 等才是真正的安装npm依赖模块</p>\n<p>而执行build.sh的时候脚本是同步的，但是只针对脚本内的总命令，不包括子命令</p>\n<p>导致npm安装变成异步执行了，在npm未安装完成的情况下执行npm run build导致报错</p>\n<p>解决办法：将总命令拆开分别执行安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registry=https://registry.npm.taobao.org</span><br><span class=\"line\">npm install --prefix  ./client --registry=$registry</span><br><span class=\"line\">npm install --prefix ./server --registry=$registry</span><br><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n<p>8.经过 Nginx 的静态资源和接口返回的数据被截掉了一部分，返回的数据不完整。</p>\n<p>问题原因：</p>\n<p>新的预发环境nginx配置了缓冲，缓冲过小的时候nginx会将数据写入硬盘，而此时如果没有硬盘文件夹的读取权限，就会出现请求数据被截断的情况。</p>\n<p> 解决办法：增大缓冲</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在预发环境 和 线上环境的location / 下面配置 proxy_buffers 缓存大小</span></span><br><span class=\"line\">location / &#123;</span><br><span class=\"line\">  proxy_buffer_size 64k; # 请求头缓冲大小</span><br><span class=\"line\">  proxy_buffers 4 512k; # 请求内容缓冲大小 4 * 512kb</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"传送门：\"><a href=\"#传送门：\" class=\"headerlink\" title=\"传送门：\"></a>传送门：</h3><p>1.mac 靠谱的安装mysql教程地址：</p>\n<p><a href=\"https://gist.github.com/nrollr/3f57fc15ded7dddddcc4e82fe137b58e\">https://gist.github.com/nrollr/3f57fc15ded7dddddcc4e82fe137b58e</a></p>\n<p>2.redis命令教程地址</p>\n<p><a href=\"http://redisdoc.com/\">http://redisdoc.com/</a></p>\n<p>3.redis sentinels学习配置教程</p>\n<p><a href=\"https://blog.csdn.net/men_wen/article/details/72724406\">https://blog.csdn.net/men_wen/article/details/72724406</a></p>\n<p>4.上次分享的nodejs架构基础参考</p>\n<p><a href=\"http://doc.hz.netease.com/pages/viewpage.action?pageId=117468038\">http://doc.hz.netease.com/pages/viewpage.action?pageId=117468038</a></p>\n<p>5.koa安全中间件简介</p>\n<p><a href=\"https://cnodejs.org/topic/5a502debafa0a121784a89c3\">https://cnodejs.org/topic/5a502debafa0a121784a89c3</a></p>\n<h3 id=\"附录1：\"><a href=\"#附录1：\" class=\"headerlink\" title=\"附录1：\"></a>附录1：</h3><p>node-mysql中防止SQL注入四种常用方法：</p>\n<p>方法一：</p>\n<p>使用 escape 方法对参数进行编码，如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql.escape(param); </span><br><span class=\"line\">connection.escape(param);</span><br><span class=\"line\">poll.escape(param)</span><br></pre></td></tr></table></figure>\n<p>escape()方法编码规则：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Numbers不进行转换；</span><br><span class=\"line\"></span><br><span class=\"line\">Booleans转换为true/false；</span><br><span class=\"line\"></span><br><span class=\"line\">Date对象转换为’YYYY-mm-dd HH:ii:ss’字符串；</span><br><span class=\"line\"></span><br><span class=\"line\">Buffers转换为hex字符串，如X’0fa5’；</span><br><span class=\"line\"></span><br><span class=\"line\">Strings进行安全转义；</span><br><span class=\"line\"></span><br><span class=\"line\">Arrays转换为列表，如[‘a’, ‘b’]会转换为’a’, ‘b’；</span><br><span class=\"line\"></span><br><span class=\"line\">多维数组转换为组列表，如[[‘a’, ‘b’], [‘c’, ‘d’]]会转换为’a’, ‘b’), (‘c’, ‘d’)；</span><br><span class=\"line\"></span><br><span class=\"line\">Objects会转换为key=value键值对的形式。嵌套的对象转换为字符串；</span><br><span class=\"line\"></span><br><span class=\"line\">undefined/null会转换为NULL；</span><br><span class=\"line\"></span><br><span class=\"line\">MySQL不支持NaN/Infinity，并且会触发MySQL错误。</span><br></pre></td></tr></table></figure>\n<p>方法二：</p>\n<p>使用connection.query()的查询参数占位符</p>\n<p>使用？作为查询参数占位符。</p>\n<p>在使用查询参数占位符的时候，在其内部自动调用 connection.escape() 方法对其传入的参数进行编码，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> post  = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;namestring&#x27;</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> query = connection.query(<span class=\"string\">&#x27;SELECT * FROM users WHERE ?&#x27;</span>, post, <span class=\"function\">(<span class=\"params\">err, results</span>) =&gt;</span> &#123;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(query.sql); <span class=\"comment\">// SELECT * FROM users WHERE name = &#x27;namestring&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>方法三：</p>\n<p>使用escapedId()编码SQL查询标识符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql.escapedId(identifier)</span><br><span class=\"line\">connection.escapeId(identifier)</span><br><span class=\"line\">pool.escapeId(identifier)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 多用于排序，如：</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sorter = <span class=\"string\">&#x27;date&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sql = <span class=\"string\">&#x27;SELECT * FROM posts ORDER BY &#x27;</span> + connection.escapeId(sorter)</span><br></pre></td></tr></table></figure>\n<p>方法四：</p>\n<p>使用mysql.format()转义参数。</p>\n<p>准备查询，此方法用于准备查询语句，该函数会自动选择合适的转义参数。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前段时间做了一个 nodejs 应用，项目架构是 前端 vue 单页应用，后端 nodejs<br>其实有考虑 ssr，但是因开发时间比较紧张，就没能使用。<br>下面是开发过程中的一些经验以及遇到的一些问题。</p>\n<h3 id=\"一、技术架构\"><a href=\"#一、技术架构\" class=\"headerlink\" title=\"一、技术架构\"></a>一、技术架构</h3><p><img src=\"http://zhoushirong.github.io/img/nodejs.png\" alt=\"koa洋葱模型\" width=\"860px\" /></p>\n<p>具体项目技术栈如下：<br>client端: vue 全家桶、history-router<br>server端: koa、koa-router、redis+sentinel、msyql、java (java后端组同学开发)</p>\n<h3 id=\"二、项目目录\"><a href=\"#二、项目目录\" class=\"headerlink\" title=\"二、项目目录\"></a>二、项目目录</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">client/ # 所有的前端文件</span><br><span class=\"line\">- node_module/ # 前端文件依赖包</span><br><span class=\"line\">- src/ # 前端代码源码</span><br><span class=\"line\">- webpack/ # 构建工具</span><br><span class=\"line\">- package.json # 前端依赖包文件</span><br><span class=\"line\">mock/ # mock数据，</span><br><span class=\"line\">- api/ #对后端的mock（接口数据）</span><br><span class=\"line\">- index.js #mock入口文件</span><br><span class=\"line\">node_modules/ # 项目启动开发工具依赖包</span><br><span class=\"line\">server/ # 服务端代码</span><br><span class=\"line\">- channel/ # 数据渠道、来源（java http、java dubbo、数据库、redis）</span><br><span class=\"line\">- config/ # 网站配置文件（环境配置、数据库、redis 配置等）</span><br><span class=\"line\">- middleware/ # 中间件</span><br><span class=\"line\">- model # 数据库数据模型层</span><br><span class=\"line\">- node_modules/ # 服务端依赖包</span><br><span class=\"line\">- router/ # 路由（controler层）</span><br><span class=\"line\">- tools/ # 一些常用工具函数</span><br><span class=\"line\">- app.js # 服务入口</span><br><span class=\"line\">- autoRouter.js #路由入口</span><br><span class=\"line\">- package.json # 后端依赖包文件</span><br><span class=\"line\">package.json # 公共项目依赖包文件</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、技术要点\"><a href=\"#三、技术要点\" class=\"headerlink\" title=\"三、技术要点\"></a>三、技术要点</h3><h5 id=\"promise、async-await\"><a href=\"#promise、async-await\" class=\"headerlink\" title=\"promise、async await\"></a>promise、async await</h5><p>promise、async、await都属于javascript基础，这里略过。</p>\n<h5 id=\"client-端的请求\"><a href=\"#client-端的请求\" class=\"headerlink\" title=\"client 端的请求\"></a>client 端的请求</h5><p>请求类型大概分为如下几类，以及各个类别对应的 koa 处理中间件模块</p>\n<p>1.页面请求 —— history-router</p>\n<p>2.静态资源请求 —— koa-static</p>\n<p>3.favicon请求 —— koa-favicon</p>\n<p>4.接口请求 —— koa-router</p>\n<h5 id=\"NODEJS-请求过程\"><a href=\"#NODEJS-请求过程\" class=\"headerlink\" title=\"NODEJS 请求过程\"></a>NODEJS 请求过程</h5><p><img src=\"http://zhoushirong.github.io/img/request1.png\" alt=\"请求流程\" width=\"560px\" /></p>\n<p><img src=\"http://zhoushirong.github.io/img/request2.png\" alt=\"请求接口模型\" width=\"560px\" /></p>\n<h5 id=\"koa-中间件、node端路由\"><a href=\"#koa-中间件、node端路由\" class=\"headerlink\" title=\"koa 中间件、node端路由\"></a>koa 中间件、node端路由</h5><p>中间件：中间件在请求和响应的过程中给我们一个修改数据的机会</p>\n<p>中间件的功能包括：<br>1.执行任何代码。<br>2.修改请求和响应对象。<br>3.终结请求 - 响应循环。<br>4.调用堆栈中的下一个中间件</p>\n<p>中间件是koa的核心，中间件return一个中间件函数，最好是用一个函数给封装起来，以便于传参和可扩展性。<br>本项目几乎所有路由处理都是通过中间件完成的。</p>\n<p>中间件操作分为同步操作和异步操作。<br>同步操作很简单，处理完事务之后直接 await next() 到下一个中间件即可。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleFunction</span>(<span class=\"params\">param1, param2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middle1</span>(<span class=\"params\">ctx, next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;/middle1&#x27;</span> == ctx.path) &#123;</span><br><span class=\"line\">      ctx.body = &#123; <span class=\"attr\">data</span>: param1 + param2 &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>异步中间件，也很好理解，就是在中间件内部进行处理的是一个异步流程。<br>我们可以借助 async 和 await 来处理异步事务。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleFunction</span>(<span class=\"params\">param1, param2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middle3</span>(<span class=\"params\">ctx, next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;/middle3&#x27;</span> == ctx.path) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 对于异步操作，await 必须等待一个promise对象</span></span><br><span class=\"line\">\t  ctx.body = <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          resolve(param1 + param2)</span><br><span class=\"line\">        &#125;, <span class=\"number\">3000</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>koa 中中间件是最核心的操作，因此往往会有很多中间件，中间件多意味着管理上需要花费更多的精力。<br>因此，koa 也提供了一些很方便的管理工具，如：用 koa-compose 组合中间件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-compose&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middle1</span>(<span class=\"params\">ctx, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;/middle1&#x27;</span> == ctx.path) &#123;</span><br><span class=\"line\">    ctx.body = &#123; <span class=\"attr\">data</span>: <span class=\"string\">&#x27;middle1&#x27;</span> &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middle2</span>(<span class=\"params\">ctx, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;/middle2&#x27;</span> == ctx.path) &#123;</span><br><span class=\"line\">    ctx.body = &#123; <span class=\"attr\">data</span>: <span class=\"string\">&#x27;middle2&#x27;</span> &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> middles = compose([middle1, middle2, <span class=\"comment\">/*...*/</span>])</span><br><span class=\"line\">app.use(middles)</span><br></pre></td></tr></table></figure>\n<p>多个中间件如何执行？执行顺序如何？<br>koa 中间件执行过程是一层一层的执行的，由外而内，再由内向外。<br>网上流传着很广泛的“洋葱模型”很好的诠释了这顺序，如下图所示：</p>\n<p><img src=\"http://zhoushirong.github.io/img/onion.png\" alt=\"koa洋葱模型\" width=\"360px\" /></p>\n<p>等同于下面的这张图。<br><img src=\"http://zhoushirong.github.io/img/routerpath.png\" alt=\"koa洋葱模型2\" width=\"600px\" /></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>)</span><br><span class=\"line\">  ctx.body = <span class=\"string\">&#x27;Hello World&#x27;</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">6</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// curl localhost:3000 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>其执行顺序等同于下面的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    func2()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\">    func3()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">6</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func1()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// node index.js 执行结果如下：</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>理解了上面两段代码也就大概理解了 koa 的中间件的执行了。</p>\n<h5 id=\"整个系统执行中间件过程如下\"><a href=\"#整个系统执行中间件过程如下\" class=\"headerlink\" title=\"整个系统执行中间件过程如下\"></a>整个系统执行中间件过程如下</h5><p>koa-compress &gt; koa-bodyparser &gt; koa2-connect-history-api-fallback &gt; koa-favicon &gt; koa-static &gt; commonRouter -&gt; koa-router</p>\n<p>其中 commonRouter 为自定义的中间件，内部路由过程如下：<br>记录开始时间 &gt; 判断登录态 &gt; 执行后续路由 &gt; 回来执行记录结束时间 &gt; 打日志(日志需要有请求时间)</p>\n<h5 id=\"容错、错误码\"><a href=\"#容错、错误码\" class=\"headerlink\" title=\"容错、错误码\"></a>容错、错误码</h5><p>容错是程序的必要操作，尤其是后端项目，尤其重要，因为一旦报错很可能导致整个系统崩溃。<br>影响范围极大，为了更好的管理错误，我们最好能做到统一出口、入口，以便能够对错误进行更好的监控，以及异常处理。<br>可以借助于中间件来完成。</p>\n<h5 id=\"日志-引入log4-gt-日志埋点上报-gt-logsearch-kibana查看\"><a href=\"#日志-引入log4-gt-日志埋点上报-gt-logsearch-kibana查看\" class=\"headerlink\" title=\"日志(引入log4 -&gt; 日志埋点上报 -&gt; logsearch|kibana查看)\"></a>日志(引入log4 -&gt; 日志埋点上报 -&gt; logsearch|kibana查看)</h5><p>日志也是后端项目必不可少的，nodejs 项目目前比较流行的日志框架有很多<br>log4js 是目前用的比较多的，其格式也跟其它语言的日志类似。（如 java 的log4j）<br>log4js：可以做日志收集、写入文件，在服务器直接指定固定目录/data/nodejs/log</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data/nodejs/access.log</span><br><span class=\"line\">data/nodejs/other.log</span><br><span class=\"line\">data/nodejs/server.log</span><br></pre></td></tr></table></figure>\n<h5 id=\"本地调试\"><a href=\"#本地调试\" class=\"headerlink\" title=\"本地调试\"></a>本地调试</h5><p>断点调试是一个很好的习惯，nodejs 最简单快捷的方式就是 console.log 直接控制台查看。<br>但是，对于复杂的情形，我们也会有需要用到断点调试的时候。<br>使用 vscode开发，并启动nodejs服务，可以很方便的进行断点 debug。</p>\n<h5 id=\"数据-mock\"><a href=\"#数据-mock\" class=\"headerlink\" title=\"数据 mock\"></a>数据 mock</h5><p>对于 nodejs 数据 mock 可以有很多方式：<br>方式一：是用第三方 mock 服务，启动一个mock数据端口<a href=\"https://github.com/zhoushirong/static-mock\">static-mock</a><br>方式二：利用 webpack 的插件<a href=\"https://www.npmjs.com/package/webpack-api-mocker\">webpack-api-mocker</a></p>\n<p>开发此项目的时候用的是方法二，好处是可以少启动一个端口，mock 可以和 client 的 webpack-dev-server 共享端口。</p>\n<h5 id=\"用到的主要第三方中间件\"><a href=\"#用到的主要第三方中间件\" class=\"headerlink\" title=\"用到的主要第三方中间件\"></a>用到的主要第三方中间件</h5><p><strong><em>koa-static</em></strong>：将静态目录映射为路由可访问的路径<br><strong><em>koa-favicon</em></strong>：将favicon.ico路径映射为可访问路径并设置max-age缓存头<br><strong><em>koa-compress</em></strong>：对请求进行开启gzip压缩，效果很明显（nginx也可以做压缩），压缩之后<br>response-headers会有这个属性  Content-Encoding:gzip<br><strong><em>koa-bodyparser</em></strong>：对于POST请求的处理，koa-bodyparser中间件可以把 koa2 上下文的 formData 数据解析到          ctx.request.body中<br><strong><em>koa2-connect-history-api-fallback</em></strong>：对vue history路由做处理，默认将非.xxx后缀请求跳到默认index.html页面</p>\n<h5 id=\"安全-xss、csrf、sql注入\"><a href=\"#安全-xss、csrf、sql注入\" class=\"headerlink\" title=\"安全 xss、csrf、sql注入\"></a>安全 xss、csrf、sql注入</h5><p>koa-helmet：9个安全中间件的集合、帮助app抵御常见的一些web安全隐患<br>koa-limit：防止DOS攻击<br>koa-csrf：防止CSRF攻击<br>sql注入：对参数进行过滤（见后面附录1）</p>\n<p>除此之外，还用到了如下工具：</p>\n<h5 id=\"启动工具-pm2、nodemon、配置、部署、健康检查\"><a href=\"#启动工具-pm2、nodemon、配置、部署、健康检查\" class=\"headerlink\" title=\"启动工具 pm2、nodemon、配置、部署、健康检查\"></a>启动工具 pm2、nodemon、配置、部署、健康检查</h5><h5 id=\"redis、sentinels、Medis图形化工具\"><a href=\"#redis、sentinels、Medis图形化工具\" class=\"headerlink\" title=\"redis、sentinels、Medis图形化工具\"></a>redis、sentinels、Medis图形化工具</h5><h5 id=\"mysql、mysql连接池、navicat图形化工具\"><a href=\"#mysql、mysql连接池、navicat图形化工具\" class=\"headerlink\" title=\"mysql、mysql连接池、navicat图形化工具\"></a>mysql、mysql连接池、navicat图形化工具</h5><h4 id=\"四、踩过的坑\"><a href=\"#四、踩过的坑\" class=\"headerlink\" title=\"四、踩过的坑\"></a>四、踩过的坑</h4><p>1.favicon.ico 不出来：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(favicon(path.join(__dirname, <span class=\"string\">&#x27;favicon.ico&#x27;</span>)))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;shortcut icon&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/favicon.ico&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;image/x-icon&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>2.直接用浏览器打开接口失败</p>\n<p>原因：koa2-connect-history-api-fallback 中间件做了强制跳转</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /server/node_modules/koa2-connect-history-api-fallback/lib/connect-history-api-fallback.js</span></span><br><span class=\"line\"><span class=\"comment\">// koa2-connect-history-api-fallback 中间件在此处做了强制跳转</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (parsedUrl.pathname.indexOf(<span class=\"string\">&#x27;.&#x27;</span>) !== -<span class=\"number\">1</span> &amp;&amp; options.disableDotRule !== <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  logger(<span class=\"string\">&#x27;Not rewriting&#x27;</span>, ctx.method, ctx.url, <span class=\"string\">&#x27;because the path includes a dot (.) character.&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解决办法：设置白名单</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(historyApiFallback(&#123; <span class=\"attr\">whiteList</span>: [<span class=\"string\">&#x27;/api/&#x27;</span>] &#125;))</span><br></pre></td></tr></table></figure>\n<p>3.ndp环境变量首次设置之后生效，后面修改不生效，不生效</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ndp -&gt; 配置 -&gt; 发布配置 -&gt; NODE_ENV </span><br></pre></td></tr></table></figure>\n<p>原因：怀疑是ndp本身的bug，未确定。</p>\n<p>解决办法：手动杀掉服务器上pm2进程，重新启动。</p>\n<p>4.发布之后进程没有杀死，有一个错误的进程将服务器cpu跑满了。</p>\n<p>原因：可能是早期服务代码不完善，报错导致pm2管理失败，后续未重现</p>\n<p>解决办法：手动杀掉服务器进程</p>\n<p>5.日志打印报错，log4js 本地能写日志文件，服务器上写不了。</p>\n<p>原因：</p>\n<p>本地开发启动NODE服务的时候只启动一个进程。(需理解进程的概念)</p>\n<p>而通过ndp发布之后，自动通过pm2启动，用的是cluster模式，启动了多个进程。</p>\n<p>log4js，对于单进程和多进程需要做不同的配置。</p>\n<p>解决办法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 文档地址： https://log4js-node.github.io/log4js-node/api.html</span></span><br><span class=\"line\">log4js.configure(&#123;</span><br><span class=\"line\">  disableClustering: <span class=\"literal\">true</span>, <span class=\"comment\">// 不启动日志的集群模式</span></span><br><span class=\"line\">  <span class=\"comment\">// pm2: true, // 或者使用pm2，此模式需要服务端安装 pm2 install pm2-intercom</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>6.测试、后端登录我们的项目的时候登录偶尔登录不上，切接口数据更新不及时</p>\n<p>原因：配置nginx的时候配置了缓存6min</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> location / &#123;</span><br><span class=\"line\">  proxy_pass http://node_server;</span><br><span class=\"line\">  expires 10m; # 这个不需要</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解决办法：</p>\n<p>去掉nginx缓存配置 expires选项。</p>\n<p>7.每次到一个新的环境，第一次构建都会报模块找不到的错误，重试N次之后正常。</p>\n<p>可能原因：</p>\n<p>执行build.sh的时候执行的是npm install client &amp;&amp; npm install server 安装的总命令</p>\n<p>总命令下的子命令 npm install client 等才是真正的安装npm依赖模块</p>\n<p>而执行build.sh的时候脚本是同步的，但是只针对脚本内的总命令，不包括子命令</p>\n<p>导致npm安装变成异步执行了，在npm未安装完成的情况下执行npm run build导致报错</p>\n<p>解决办法：将总命令拆开分别执行安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registry=https://registry.npm.taobao.org</span><br><span class=\"line\">npm install --prefix  ./client --registry=$registry</span><br><span class=\"line\">npm install --prefix ./server --registry=$registry</span><br><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n<p>8.经过 Nginx 的静态资源和接口返回的数据被截掉了一部分，返回的数据不完整。</p>\n<p>问题原因：</p>\n<p>新的预发环境nginx配置了缓冲，缓冲过小的时候nginx会将数据写入硬盘，而此时如果没有硬盘文件夹的读取权限，就会出现请求数据被截断的情况。</p>\n<p> 解决办法：增大缓冲</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在预发环境 和 线上环境的location / 下面配置 proxy_buffers 缓存大小</span></span><br><span class=\"line\">location / &#123;</span><br><span class=\"line\">  proxy_buffer_size 64k; # 请求头缓冲大小</span><br><span class=\"line\">  proxy_buffers 4 512k; # 请求内容缓冲大小 4 * 512kb</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"传送门：\"><a href=\"#传送门：\" class=\"headerlink\" title=\"传送门：\"></a>传送门：</h3><p>1.mac 靠谱的安装mysql教程地址：</p>\n<p><a href=\"https://gist.github.com/nrollr/3f57fc15ded7dddddcc4e82fe137b58e\">https://gist.github.com/nrollr/3f57fc15ded7dddddcc4e82fe137b58e</a></p>\n<p>2.redis命令教程地址</p>\n<p><a href=\"http://redisdoc.com/\">http://redisdoc.com/</a></p>\n<p>3.redis sentinels学习配置教程</p>\n<p><a href=\"https://blog.csdn.net/men_wen/article/details/72724406\">https://blog.csdn.net/men_wen/article/details/72724406</a></p>\n<p>4.上次分享的nodejs架构基础参考</p>\n<p><a href=\"http://doc.hz.netease.com/pages/viewpage.action?pageId=117468038\">http://doc.hz.netease.com/pages/viewpage.action?pageId=117468038</a></p>\n<p>5.koa安全中间件简介</p>\n<p><a href=\"https://cnodejs.org/topic/5a502debafa0a121784a89c3\">https://cnodejs.org/topic/5a502debafa0a121784a89c3</a></p>\n<h3 id=\"附录1：\"><a href=\"#附录1：\" class=\"headerlink\" title=\"附录1：\"></a>附录1：</h3><p>node-mysql中防止SQL注入四种常用方法：</p>\n<p>方法一：</p>\n<p>使用 escape 方法对参数进行编码，如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql.escape(param); </span><br><span class=\"line\">connection.escape(param);</span><br><span class=\"line\">poll.escape(param)</span><br></pre></td></tr></table></figure>\n<p>escape()方法编码规则：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Numbers不进行转换；</span><br><span class=\"line\"></span><br><span class=\"line\">Booleans转换为true/false；</span><br><span class=\"line\"></span><br><span class=\"line\">Date对象转换为’YYYY-mm-dd HH:ii:ss’字符串；</span><br><span class=\"line\"></span><br><span class=\"line\">Buffers转换为hex字符串，如X’0fa5’；</span><br><span class=\"line\"></span><br><span class=\"line\">Strings进行安全转义；</span><br><span class=\"line\"></span><br><span class=\"line\">Arrays转换为列表，如[‘a’, ‘b’]会转换为’a’, ‘b’；</span><br><span class=\"line\"></span><br><span class=\"line\">多维数组转换为组列表，如[[‘a’, ‘b’], [‘c’, ‘d’]]会转换为’a’, ‘b’), (‘c’, ‘d’)；</span><br><span class=\"line\"></span><br><span class=\"line\">Objects会转换为key=value键值对的形式。嵌套的对象转换为字符串；</span><br><span class=\"line\"></span><br><span class=\"line\">undefined/null会转换为NULL；</span><br><span class=\"line\"></span><br><span class=\"line\">MySQL不支持NaN/Infinity，并且会触发MySQL错误。</span><br></pre></td></tr></table></figure>\n<p>方法二：</p>\n<p>使用connection.query()的查询参数占位符</p>\n<p>使用？作为查询参数占位符。</p>\n<p>在使用查询参数占位符的时候，在其内部自动调用 connection.escape() 方法对其传入的参数进行编码，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> post  = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;namestring&#x27;</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> query = connection.query(<span class=\"string\">&#x27;SELECT * FROM users WHERE ?&#x27;</span>, post, <span class=\"function\">(<span class=\"params\">err, results</span>) =&gt;</span> &#123;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(query.sql); <span class=\"comment\">// SELECT * FROM users WHERE name = &#x27;namestring&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>方法三：</p>\n<p>使用escapedId()编码SQL查询标识符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql.escapedId(identifier)</span><br><span class=\"line\">connection.escapeId(identifier)</span><br><span class=\"line\">pool.escapeId(identifier)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 多用于排序，如：</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sorter = <span class=\"string\">&#x27;date&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sql = <span class=\"string\">&#x27;SELECT * FROM posts ORDER BY &#x27;</span> + connection.escapeId(sorter)</span><br></pre></td></tr></table></figure>\n<p>方法四：</p>\n<p>使用mysql.format()转义参数。</p>\n<p>准备查询，此方法用于准备查询语句，该函数会自动选择合适的转义参数。</p>\n"},{"title":"node与dubbo接口","date":"2019-01-15T16:00:00.000Z","_content":"\n对于一个很少写后端服务的前端开发者来说，开发一个 nodejs 应用，并通过 nodejs 服务代理调用其它服务（如java）提供的 http 接口还是很容易理解的。\n无非就是将原本在 client 端的调用转到 nodejs 端来做。\n\n但是，随着业务的扩大（nodejs服务技术的积累），渐渐的 jser 们开始不再满足于单单作为一个 http 请求中转站了。\n开始为 nodejs 争取更大的适用范围，包括调用缓存服务（如:redis）、调用数据库（如:mysql)。\n当然，对于一些大厂，一些后端业务比较复杂的情形，更为常见的是通过“RPC”来进行数据调用。\n\n#### 什么是 RPC 调用？\n官方解释：RPC（Remote Proceduce Call）远程过程调用，是一种通过网络从远程计算机程序上请求服务的操作。\n我的理解是：\n1.可以在同一台机器上的不同进程之间进行数据交换。\n2.可以在同一机房不同机器之间进行数据交换。\n3.可以在不同机房、不同地域之间进行数据交换。\n\n从上面的解释可以看出，在 nodejs 端进行 http 请求转发其实也可以算是一种 RPC 调用。\n但是，此处，我想要介绍的却不是 http，而是另外的‘RPC’调用方式。\n\n#### 为什么 Nodejs 要接入 ‘另外的 RPC ’调用方式呢？\n其实，之前我们使用 nodejs 开发的后端服务使用http已经足够满足当前的业务需求了。\n那么，为什么还需要接入另外的 RPC 框架呢？\n\n下面是个人总结的原因：\n```html\n1.性能，对于内网调用，在 http 未经过特别优化的情况下，Http 调用性能并不好，三次握手就占据了大部分时间。\n2.通用性，我们公司我所在的部门后端服务之间的互相调用都是用的非 Http 协议，如果我们接入 Nodejs 需要后端同学专门为我们提供 http 接口。\n3.技术积累，虽然目前 http 服务能够满足业务，但是难保以后不会切这种模式。\n```\n\n#### 如何选择另外的‘RPC’框架？\nRPC 调用有很多种方式，互联网发展这么多年，目前市面上已经发展出了很多框架。\n其中比较常用的有：\n```html\nDubbo：阿里巴巴开源的一个分布式服务框架\nMotan：新浪微博开源的 Java 框架\ngRPC：Google 开发的开源 RPC 框架\nThrift：Facebook 开发的一个 RPC 框架，采用 thrift 作为 IDL\njsonrpc：一个无状态轻量级的 RPC 框架\n```\n\n没有最好的框架，只有最适合自己的才是最好的。\n经过一番了解与实践，我们的 Nodejs 服务最终的选择是 Dubbo。\n\n#### 为什么选择 Dubbo\n既然市面上有那么多 RPC 框架，为什么我们要选择 Dubbo 呢？\n原因如下：\n```html\n1.框架统一性，我厂 java 后端目前使用的 RPC 框架是 Dubbo，因此 Nodejs 同样使用 Dubbo 能减少一些麻烦。\n2.目前国内 nodejs 社区相对比较活跃，用的比较成熟的 rpc 框架也是 dubbo。\n3.Dubbo 框架是阿里开源的，文档是中文，而且很详细。\n```\n\n#### Dubbo 简介\n既然框架已经确定了，那么接下来就是如何接入 Dubbo 了，在此之前，我们需要明白 Dubbo 是什么？\n官方说法：\n```html\nDubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以 SOA 服务治理方案。\n```\nDubbo 是阿里开源的一个 java 的分布式服务框架，原来是专门为 java 服务的，之前一段时间停止维护了，但是后面又宣布开始维护了。于是，在 Nodejs 兴起之后，就有一些个人或者企业做起了 Nodejs 端对 Dubbo 的接入。\n\n其中相对用的比较多的有<a href=\"https://github.com/omnip620/node-zookeeper-dubbo\" target=\"_blank\">node-zookeeper-dubbo</a> 以及 <a href=\"https://github.com/dubbo/dubbo2.js\">dubbo2.js</a>（官方推荐）。\n\n如果仅仅只需要接入 Dubbo，通过上面两个框架就已经足够了，只要能够调通就能够正常的使用 java 方提供的 Dubbo 接口了。\n但是，显然这样是不够的（亲身经历），如果不搞明白 Dubbo 的大概原理，遇到问题就直接懵逼了。\n不说别的，至少 Dubbo 的大概框架得弄清楚一下，不然接口配置都不一定能配对。\n\n因此，下面再简单介绍一下 Dubbo 这个框架（可以直接看<a href=\"http://dubbo.apache.org/zh-cn/docs/user/quick-start.html\" target=\"_blank\">官方文档</a>然后再回来）。\n官方文档以及很详细了，就不过多介绍了。\n\n下面补充一下官方文档上我觉得“不够直观”或者我觉得比较重要的东西。\n\n#### Dubbo 组成。\n其实，主要就是这一张图。\n<img src=\"http://zhoushirong.github.io/img/dubbo-arc.png\" alt=\"Dubbo 架构\"/>\nDubbo 的核心就是上面这张图了，能看懂基本上也就明白了什么是 Dubbo 了。\n\nDubbo 分为几大块：\n1.服务提供者（Provider）\n2.服务消费者（Consumer）\n3.服务调度者（Registry）\n4.服务统计、管理者（Monitor）\n\n这里提供者就是服务的提供方了，可以是 java、也可以是 nodejs。\n当然，Nodejs 用作“服务提供方”的情形，阿里内部有这个操作，对于其它团队来说可能有些麻烦。\n因此，这里我们所说的 nodejs 不用作提供方，仅仅用作消费方。\n\n大致过程为：\n```html\n1.java 后端开发启动Dubbo服务，作为“服务提供者”，注册到“服务调度者（zookeeper）”\n2.nodejs 作为消费者，启动服务，作为“服务消费者”，“服务调度者（zookeeper）在订阅服务”\n3.服务调度者通知消费者服务状态。\n4.经过调度，nodejs 消费方与 java 服务提供方建立直连，并将调用情况以统计的方式发送到“服务的统计管理者”\n5.服务调度者与消费者和提供者建立长连接，实时监控服务状态，并及时通知提供者和消费者。\n```\n\n#### Dubbo 协议报文消息格式\nDubbo 默认使用 Dubbo 协议，Hessian2 序列化方式。适合传入参数数据包较小，消费者比提供者个数多的场景。\n\n下面是其中一帧数据的数据格式：\nheader：存放一些协议信息\n\n位数 | 0-7 | 8-15 | 16-23 | 24-31 | 32-95 | 96-127\n--|--\n含义 | magic heihgt | magic low | request and serializtion flag | response status | request id | body length\n\ndubbo 采用固定长度的消息头：16个字节（128bit），不固定长度的消息体来进行数据传输\n\n2byte（0-15）:类似java字节码文件里的魔数，用来判断是不是dubbo协议的数据包，类似 class 类文件里面的作用，用来标识一帧的开始，魔数是常量0xdabb。\n1byte（16-23）：消息标志位，16-20 序列 id, 21 event, 22 two way, 23 请求或响应标识。\n1byte（24-31） 状态，当消息类型为响应时，设置响应状态。24-31位。状态位, 设置请求响应状态，dubbo定义了一些响应的类型。\n8byte（32-95）： 消息ID, long类型，每一个请求的唯一识别id（由于采用异步通讯的方式，用来把请求request和返回的response对应上）\n4byte （96-127）：消息长度，96-127位。消息体 body 长度, int 类型，即记录Body Content有多少个字节。\n\n\n### 附录\nDubbo 协议：消息状态码\n```java\n/**\n* ok.\n*/\npublic static final byte OK = 20;\n\n/**\n* clien side timeout.\n*/\npublic static final byte CLIENT_TIMEOUT = 30;\n\n/**\n* server side timeout.\n*/\npublic static final byte SERVER_TIMEOUT = 31;\n\n/**\n* request format error.\n*/\npublic static final byte BAD_REQUEST = 40;\n\n/**\n* response format error.\n*/\npublic static final byte BAD_RESPONSE = 50;\n\n/**\n* service not found.\n*/\npublic static final byte SERVICE_NOT_FOUND = 60;\n\n/**\n* service error.\n*/\npublic static final byte SERVICE_ERROR = 70;\n\n/**\n* internal server error.\n*/\npublic static final byte SERVER_ERROR = 80;\n\n/**\n* internal server error.\n*/\npublic static final byte CLIENT_ERROR = 90;\n\n/**\n* server side threadpool exhausted and quick return.\n*/\npublic static final byte SERVER_THREADPOOL_EXHAUSTED_ERROR = 100;\n```\n\n\n### 传送门\n\nDubbo 官方文档：\nhttp://dubbo.apache.org/zh-cn/docs/user/quick-start.html\nDubbo2.js github 地址：\nhttps://github.com/dubbo/dubbo2.js\nNodeZookeeperDubbo github 地址：\nhttps://github.com/omnip620/node-zookeeper-dubbo","source":"_posts/nodejs3.md","raw":"---\ntitle: node与dubbo接口\ndate: 2019/01/16\ntag: [dubbo, nodejs]\n---\n\n对于一个很少写后端服务的前端开发者来说，开发一个 nodejs 应用，并通过 nodejs 服务代理调用其它服务（如java）提供的 http 接口还是很容易理解的。\n无非就是将原本在 client 端的调用转到 nodejs 端来做。\n\n但是，随着业务的扩大（nodejs服务技术的积累），渐渐的 jser 们开始不再满足于单单作为一个 http 请求中转站了。\n开始为 nodejs 争取更大的适用范围，包括调用缓存服务（如:redis）、调用数据库（如:mysql)。\n当然，对于一些大厂，一些后端业务比较复杂的情形，更为常见的是通过“RPC”来进行数据调用。\n\n#### 什么是 RPC 调用？\n官方解释：RPC（Remote Proceduce Call）远程过程调用，是一种通过网络从远程计算机程序上请求服务的操作。\n我的理解是：\n1.可以在同一台机器上的不同进程之间进行数据交换。\n2.可以在同一机房不同机器之间进行数据交换。\n3.可以在不同机房、不同地域之间进行数据交换。\n\n从上面的解释可以看出，在 nodejs 端进行 http 请求转发其实也可以算是一种 RPC 调用。\n但是，此处，我想要介绍的却不是 http，而是另外的‘RPC’调用方式。\n\n#### 为什么 Nodejs 要接入 ‘另外的 RPC ’调用方式呢？\n其实，之前我们使用 nodejs 开发的后端服务使用http已经足够满足当前的业务需求了。\n那么，为什么还需要接入另外的 RPC 框架呢？\n\n下面是个人总结的原因：\n```html\n1.性能，对于内网调用，在 http 未经过特别优化的情况下，Http 调用性能并不好，三次握手就占据了大部分时间。\n2.通用性，我们公司我所在的部门后端服务之间的互相调用都是用的非 Http 协议，如果我们接入 Nodejs 需要后端同学专门为我们提供 http 接口。\n3.技术积累，虽然目前 http 服务能够满足业务，但是难保以后不会切这种模式。\n```\n\n#### 如何选择另外的‘RPC’框架？\nRPC 调用有很多种方式，互联网发展这么多年，目前市面上已经发展出了很多框架。\n其中比较常用的有：\n```html\nDubbo：阿里巴巴开源的一个分布式服务框架\nMotan：新浪微博开源的 Java 框架\ngRPC：Google 开发的开源 RPC 框架\nThrift：Facebook 开发的一个 RPC 框架，采用 thrift 作为 IDL\njsonrpc：一个无状态轻量级的 RPC 框架\n```\n\n没有最好的框架，只有最适合自己的才是最好的。\n经过一番了解与实践，我们的 Nodejs 服务最终的选择是 Dubbo。\n\n#### 为什么选择 Dubbo\n既然市面上有那么多 RPC 框架，为什么我们要选择 Dubbo 呢？\n原因如下：\n```html\n1.框架统一性，我厂 java 后端目前使用的 RPC 框架是 Dubbo，因此 Nodejs 同样使用 Dubbo 能减少一些麻烦。\n2.目前国内 nodejs 社区相对比较活跃，用的比较成熟的 rpc 框架也是 dubbo。\n3.Dubbo 框架是阿里开源的，文档是中文，而且很详细。\n```\n\n#### Dubbo 简介\n既然框架已经确定了，那么接下来就是如何接入 Dubbo 了，在此之前，我们需要明白 Dubbo 是什么？\n官方说法：\n```html\nDubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以 SOA 服务治理方案。\n```\nDubbo 是阿里开源的一个 java 的分布式服务框架，原来是专门为 java 服务的，之前一段时间停止维护了，但是后面又宣布开始维护了。于是，在 Nodejs 兴起之后，就有一些个人或者企业做起了 Nodejs 端对 Dubbo 的接入。\n\n其中相对用的比较多的有<a href=\"https://github.com/omnip620/node-zookeeper-dubbo\" target=\"_blank\">node-zookeeper-dubbo</a> 以及 <a href=\"https://github.com/dubbo/dubbo2.js\">dubbo2.js</a>（官方推荐）。\n\n如果仅仅只需要接入 Dubbo，通过上面两个框架就已经足够了，只要能够调通就能够正常的使用 java 方提供的 Dubbo 接口了。\n但是，显然这样是不够的（亲身经历），如果不搞明白 Dubbo 的大概原理，遇到问题就直接懵逼了。\n不说别的，至少 Dubbo 的大概框架得弄清楚一下，不然接口配置都不一定能配对。\n\n因此，下面再简单介绍一下 Dubbo 这个框架（可以直接看<a href=\"http://dubbo.apache.org/zh-cn/docs/user/quick-start.html\" target=\"_blank\">官方文档</a>然后再回来）。\n官方文档以及很详细了，就不过多介绍了。\n\n下面补充一下官方文档上我觉得“不够直观”或者我觉得比较重要的东西。\n\n#### Dubbo 组成。\n其实，主要就是这一张图。\n<img src=\"http://zhoushirong.github.io/img/dubbo-arc.png\" alt=\"Dubbo 架构\"/>\nDubbo 的核心就是上面这张图了，能看懂基本上也就明白了什么是 Dubbo 了。\n\nDubbo 分为几大块：\n1.服务提供者（Provider）\n2.服务消费者（Consumer）\n3.服务调度者（Registry）\n4.服务统计、管理者（Monitor）\n\n这里提供者就是服务的提供方了，可以是 java、也可以是 nodejs。\n当然，Nodejs 用作“服务提供方”的情形，阿里内部有这个操作，对于其它团队来说可能有些麻烦。\n因此，这里我们所说的 nodejs 不用作提供方，仅仅用作消费方。\n\n大致过程为：\n```html\n1.java 后端开发启动Dubbo服务，作为“服务提供者”，注册到“服务调度者（zookeeper）”\n2.nodejs 作为消费者，启动服务，作为“服务消费者”，“服务调度者（zookeeper）在订阅服务”\n3.服务调度者通知消费者服务状态。\n4.经过调度，nodejs 消费方与 java 服务提供方建立直连，并将调用情况以统计的方式发送到“服务的统计管理者”\n5.服务调度者与消费者和提供者建立长连接，实时监控服务状态，并及时通知提供者和消费者。\n```\n\n#### Dubbo 协议报文消息格式\nDubbo 默认使用 Dubbo 协议，Hessian2 序列化方式。适合传入参数数据包较小，消费者比提供者个数多的场景。\n\n下面是其中一帧数据的数据格式：\nheader：存放一些协议信息\n\n位数 | 0-7 | 8-15 | 16-23 | 24-31 | 32-95 | 96-127\n--|--\n含义 | magic heihgt | magic low | request and serializtion flag | response status | request id | body length\n\ndubbo 采用固定长度的消息头：16个字节（128bit），不固定长度的消息体来进行数据传输\n\n2byte（0-15）:类似java字节码文件里的魔数，用来判断是不是dubbo协议的数据包，类似 class 类文件里面的作用，用来标识一帧的开始，魔数是常量0xdabb。\n1byte（16-23）：消息标志位，16-20 序列 id, 21 event, 22 two way, 23 请求或响应标识。\n1byte（24-31） 状态，当消息类型为响应时，设置响应状态。24-31位。状态位, 设置请求响应状态，dubbo定义了一些响应的类型。\n8byte（32-95）： 消息ID, long类型，每一个请求的唯一识别id（由于采用异步通讯的方式，用来把请求request和返回的response对应上）\n4byte （96-127）：消息长度，96-127位。消息体 body 长度, int 类型，即记录Body Content有多少个字节。\n\n\n### 附录\nDubbo 协议：消息状态码\n```java\n/**\n* ok.\n*/\npublic static final byte OK = 20;\n\n/**\n* clien side timeout.\n*/\npublic static final byte CLIENT_TIMEOUT = 30;\n\n/**\n* server side timeout.\n*/\npublic static final byte SERVER_TIMEOUT = 31;\n\n/**\n* request format error.\n*/\npublic static final byte BAD_REQUEST = 40;\n\n/**\n* response format error.\n*/\npublic static final byte BAD_RESPONSE = 50;\n\n/**\n* service not found.\n*/\npublic static final byte SERVICE_NOT_FOUND = 60;\n\n/**\n* service error.\n*/\npublic static final byte SERVICE_ERROR = 70;\n\n/**\n* internal server error.\n*/\npublic static final byte SERVER_ERROR = 80;\n\n/**\n* internal server error.\n*/\npublic static final byte CLIENT_ERROR = 90;\n\n/**\n* server side threadpool exhausted and quick return.\n*/\npublic static final byte SERVER_THREADPOOL_EXHAUSTED_ERROR = 100;\n```\n\n\n### 传送门\n\nDubbo 官方文档：\nhttp://dubbo.apache.org/zh-cn/docs/user/quick-start.html\nDubbo2.js github 地址：\nhttps://github.com/dubbo/dubbo2.js\nNodeZookeeperDubbo github 地址：\nhttps://github.com/omnip620/node-zookeeper-dubbo","slug":"nodejs3","published":1,"updated":"2021-03-30T01:32:00.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufy0015a0vz5v0s2tyy","content":"<p>对于一个很少写后端服务的前端开发者来说，开发一个 nodejs 应用，并通过 nodejs 服务代理调用其它服务（如java）提供的 http 接口还是很容易理解的。<br>无非就是将原本在 client 端的调用转到 nodejs 端来做。</p>\n<p>但是，随着业务的扩大（nodejs服务技术的积累），渐渐的 jser 们开始不再满足于单单作为一个 http 请求中转站了。<br>开始为 nodejs 争取更大的适用范围，包括调用缓存服务（如:redis）、调用数据库（如:mysql)。<br>当然，对于一些大厂，一些后端业务比较复杂的情形，更为常见的是通过“RPC”来进行数据调用。</p>\n<h4 id=\"什么是-RPC-调用？\"><a href=\"#什么是-RPC-调用？\" class=\"headerlink\" title=\"什么是 RPC 调用？\"></a>什么是 RPC 调用？</h4><p>官方解释：RPC（Remote Proceduce Call）远程过程调用，是一种通过网络从远程计算机程序上请求服务的操作。<br>我的理解是：<br>1.可以在同一台机器上的不同进程之间进行数据交换。<br>2.可以在同一机房不同机器之间进行数据交换。<br>3.可以在不同机房、不同地域之间进行数据交换。</p>\n<p>从上面的解释可以看出，在 nodejs 端进行 http 请求转发其实也可以算是一种 RPC 调用。<br>但是，此处，我想要介绍的却不是 http，而是另外的‘RPC’调用方式。</p>\n<h4 id=\"为什么-Nodejs-要接入-‘另外的-RPC-’调用方式呢？\"><a href=\"#为什么-Nodejs-要接入-‘另外的-RPC-’调用方式呢？\" class=\"headerlink\" title=\"为什么 Nodejs 要接入 ‘另外的 RPC ’调用方式呢？\"></a>为什么 Nodejs 要接入 ‘另外的 RPC ’调用方式呢？</h4><p>其实，之前我们使用 nodejs 开发的后端服务使用http已经足够满足当前的业务需求了。<br>那么，为什么还需要接入另外的 RPC 框架呢？</p>\n<p>下面是个人总结的原因：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.性能，对于内网调用，在 http 未经过特别优化的情况下，Http 调用性能并不好，三次握手就占据了大部分时间。</span><br><span class=\"line\">2.通用性，我们公司我所在的部门后端服务之间的互相调用都是用的非 Http 协议，如果我们接入 Nodejs 需要后端同学专门为我们提供 http 接口。</span><br><span class=\"line\">3.技术积累，虽然目前 http 服务能够满足业务，但是难保以后不会切这种模式。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"如何选择另外的‘RPC’框架？\"><a href=\"#如何选择另外的‘RPC’框架？\" class=\"headerlink\" title=\"如何选择另外的‘RPC’框架？\"></a>如何选择另外的‘RPC’框架？</h4><p>RPC 调用有很多种方式，互联网发展这么多年，目前市面上已经发展出了很多框架。<br>其中比较常用的有：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dubbo：阿里巴巴开源的一个分布式服务框架</span><br><span class=\"line\">Motan：新浪微博开源的 Java 框架</span><br><span class=\"line\">gRPC：Google 开发的开源 RPC 框架</span><br><span class=\"line\">Thrift：Facebook 开发的一个 RPC 框架，采用 thrift 作为 IDL</span><br><span class=\"line\">jsonrpc：一个无状态轻量级的 RPC 框架</span><br></pre></td></tr></table></figure></p>\n<p>没有最好的框架，只有最适合自己的才是最好的。<br>经过一番了解与实践，我们的 Nodejs 服务最终的选择是 Dubbo。</p>\n<h4 id=\"为什么选择-Dubbo\"><a href=\"#为什么选择-Dubbo\" class=\"headerlink\" title=\"为什么选择 Dubbo\"></a>为什么选择 Dubbo</h4><p>既然市面上有那么多 RPC 框架，为什么我们要选择 Dubbo 呢？<br>原因如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.框架统一性，我厂 java 后端目前使用的 RPC 框架是 Dubbo，因此 Nodejs 同样使用 Dubbo 能减少一些麻烦。</span><br><span class=\"line\">2.目前国内 nodejs 社区相对比较活跃，用的比较成熟的 rpc 框架也是 dubbo。</span><br><span class=\"line\">3.Dubbo 框架是阿里开源的，文档是中文，而且很详细。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Dubbo-简介\"><a href=\"#Dubbo-简介\" class=\"headerlink\" title=\"Dubbo 简介\"></a>Dubbo 简介</h4><p>既然框架已经确定了，那么接下来就是如何接入 Dubbo 了，在此之前，我们需要明白 Dubbo 是什么？<br>官方说法：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以 SOA 服务治理方案。</span><br></pre></td></tr></table></figure><br>Dubbo 是阿里开源的一个 java 的分布式服务框架，原来是专门为 java 服务的，之前一段时间停止维护了，但是后面又宣布开始维护了。于是，在 Nodejs 兴起之后，就有一些个人或者企业做起了 Nodejs 端对 Dubbo 的接入。</p>\n<p>其中相对用的比较多的有<a href=\"https://github.com/omnip620/node-zookeeper-dubbo\" target=\"_blank\">node-zookeeper-dubbo</a> 以及 <a href=\"https://github.com/dubbo/dubbo2.js\">dubbo2.js</a>（官方推荐）。</p>\n<p>如果仅仅只需要接入 Dubbo，通过上面两个框架就已经足够了，只要能够调通就能够正常的使用 java 方提供的 Dubbo 接口了。<br>但是，显然这样是不够的（亲身经历），如果不搞明白 Dubbo 的大概原理，遇到问题就直接懵逼了。<br>不说别的，至少 Dubbo 的大概框架得弄清楚一下，不然接口配置都不一定能配对。</p>\n<p>因此，下面再简单介绍一下 Dubbo 这个框架（可以直接看<a href=\"http://dubbo.apache.org/zh-cn/docs/user/quick-start.html\" target=\"_blank\">官方文档</a>然后再回来）。<br>官方文档以及很详细了，就不过多介绍了。</p>\n<p>下面补充一下官方文档上我觉得“不够直观”或者我觉得比较重要的东西。</p>\n<h4 id=\"Dubbo-组成。\"><a href=\"#Dubbo-组成。\" class=\"headerlink\" title=\"Dubbo 组成。\"></a>Dubbo 组成。</h4><p>其实，主要就是这一张图。<br><img src=\"http://zhoushirong.github.io/img/dubbo-arc.png\" alt=\"Dubbo 架构\"/><br>Dubbo 的核心就是上面这张图了，能看懂基本上也就明白了什么是 Dubbo 了。</p>\n<p>Dubbo 分为几大块：<br>1.服务提供者（Provider）<br>2.服务消费者（Consumer）<br>3.服务调度者（Registry）<br>4.服务统计、管理者（Monitor）</p>\n<p>这里提供者就是服务的提供方了，可以是 java、也可以是 nodejs。<br>当然，Nodejs 用作“服务提供方”的情形，阿里内部有这个操作，对于其它团队来说可能有些麻烦。<br>因此，这里我们所说的 nodejs 不用作提供方，仅仅用作消费方。</p>\n<p>大致过程为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.java 后端开发启动Dubbo服务，作为“服务提供者”，注册到“服务调度者（zookeeper）”</span><br><span class=\"line\">2.nodejs 作为消费者，启动服务，作为“服务消费者”，“服务调度者（zookeeper）在订阅服务”</span><br><span class=\"line\">3.服务调度者通知消费者服务状态。</span><br><span class=\"line\">4.经过调度，nodejs 消费方与 java 服务提供方建立直连，并将调用情况以统计的方式发送到“服务的统计管理者”</span><br><span class=\"line\">5.服务调度者与消费者和提供者建立长连接，实时监控服务状态，并及时通知提供者和消费者。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Dubbo-协议报文消息格式\"><a href=\"#Dubbo-协议报文消息格式\" class=\"headerlink\" title=\"Dubbo 协议报文消息格式\"></a>Dubbo 协议报文消息格式</h4><p>Dubbo 默认使用 Dubbo 协议，Hessian2 序列化方式。适合传入参数数据包较小，消费者比提供者个数多的场景。</p>\n<p>下面是其中一帧数据的数据格式：<br>header：存放一些协议信息</p>\n<table>\n<thead>\n<tr>\n<th>位数</th>\n<th>0-7</th>\n<th>8-15</th>\n<th>16-23</th>\n<th>24-31</th>\n<th>32-95</th>\n<th>96-127</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>含义</td>\n<td>magic heihgt</td>\n<td>magic low</td>\n<td>request and serializtion flag</td>\n<td>response status</td>\n<td>request id</td>\n<td>body length</td>\n</tr>\n</tbody>\n</table>\n<p>dubbo 采用固定长度的消息头：16个字节（128bit），不固定长度的消息体来进行数据传输</p>\n<p>2byte（0-15）:类似java字节码文件里的魔数，用来判断是不是dubbo协议的数据包，类似 class 类文件里面的作用，用来标识一帧的开始，魔数是常量0xdabb。<br>1byte（16-23）：消息标志位，16-20 序列 id, 21 event, 22 two way, 23 请求或响应标识。<br>1byte（24-31） 状态，当消息类型为响应时，设置响应状态。24-31位。状态位, 设置请求响应状态，dubbo定义了一些响应的类型。<br>8byte（32-95）： 消息ID, long类型，每一个请求的唯一识别id（由于采用异步通讯的方式，用来把请求request和返回的response对应上）<br>4byte （96-127）：消息长度，96-127位。消息体 body 长度, int 类型，即记录Body Content有多少个字节。</p>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><p>Dubbo 协议：消息状态码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* ok.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> OK = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* clien side timeout.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> CLIENT_TIMEOUT = <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* server side timeout.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> SERVER_TIMEOUT = <span class=\"number\">31</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* request format error.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> BAD_REQUEST = <span class=\"number\">40</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* response format error.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> BAD_RESPONSE = <span class=\"number\">50</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* service not found.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> SERVICE_NOT_FOUND = <span class=\"number\">60</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* service error.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> SERVICE_ERROR = <span class=\"number\">70</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* internal server error.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> SERVER_ERROR = <span class=\"number\">80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* internal server error.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> CLIENT_ERROR = <span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* server side threadpool exhausted and quick return.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> SERVER_THREADPOOL_EXHAUSTED_ERROR = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>Dubbo 官方文档：<br><a href=\"http://dubbo.apache.org/zh-cn/docs/user/quick-start.html\">http://dubbo.apache.org/zh-cn/docs/user/quick-start.html</a><br>Dubbo2.js github 地址：<br><a href=\"https://github.com/dubbo/dubbo2.js\">https://github.com/dubbo/dubbo2.js</a><br>NodeZookeeperDubbo github 地址：<br><a href=\"https://github.com/omnip620/node-zookeeper-dubbo\">https://github.com/omnip620/node-zookeeper-dubbo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>对于一个很少写后端服务的前端开发者来说，开发一个 nodejs 应用，并通过 nodejs 服务代理调用其它服务（如java）提供的 http 接口还是很容易理解的。<br>无非就是将原本在 client 端的调用转到 nodejs 端来做。</p>\n<p>但是，随着业务的扩大（nodejs服务技术的积累），渐渐的 jser 们开始不再满足于单单作为一个 http 请求中转站了。<br>开始为 nodejs 争取更大的适用范围，包括调用缓存服务（如:redis）、调用数据库（如:mysql)。<br>当然，对于一些大厂，一些后端业务比较复杂的情形，更为常见的是通过“RPC”来进行数据调用。</p>\n<h4 id=\"什么是-RPC-调用？\"><a href=\"#什么是-RPC-调用？\" class=\"headerlink\" title=\"什么是 RPC 调用？\"></a>什么是 RPC 调用？</h4><p>官方解释：RPC（Remote Proceduce Call）远程过程调用，是一种通过网络从远程计算机程序上请求服务的操作。<br>我的理解是：<br>1.可以在同一台机器上的不同进程之间进行数据交换。<br>2.可以在同一机房不同机器之间进行数据交换。<br>3.可以在不同机房、不同地域之间进行数据交换。</p>\n<p>从上面的解释可以看出，在 nodejs 端进行 http 请求转发其实也可以算是一种 RPC 调用。<br>但是，此处，我想要介绍的却不是 http，而是另外的‘RPC’调用方式。</p>\n<h4 id=\"为什么-Nodejs-要接入-‘另外的-RPC-’调用方式呢？\"><a href=\"#为什么-Nodejs-要接入-‘另外的-RPC-’调用方式呢？\" class=\"headerlink\" title=\"为什么 Nodejs 要接入 ‘另外的 RPC ’调用方式呢？\"></a>为什么 Nodejs 要接入 ‘另外的 RPC ’调用方式呢？</h4><p>其实，之前我们使用 nodejs 开发的后端服务使用http已经足够满足当前的业务需求了。<br>那么，为什么还需要接入另外的 RPC 框架呢？</p>\n<p>下面是个人总结的原因：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.性能，对于内网调用，在 http 未经过特别优化的情况下，Http 调用性能并不好，三次握手就占据了大部分时间。</span><br><span class=\"line\">2.通用性，我们公司我所在的部门后端服务之间的互相调用都是用的非 Http 协议，如果我们接入 Nodejs 需要后端同学专门为我们提供 http 接口。</span><br><span class=\"line\">3.技术积累，虽然目前 http 服务能够满足业务，但是难保以后不会切这种模式。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"如何选择另外的‘RPC’框架？\"><a href=\"#如何选择另外的‘RPC’框架？\" class=\"headerlink\" title=\"如何选择另外的‘RPC’框架？\"></a>如何选择另外的‘RPC’框架？</h4><p>RPC 调用有很多种方式，互联网发展这么多年，目前市面上已经发展出了很多框架。<br>其中比较常用的有：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dubbo：阿里巴巴开源的一个分布式服务框架</span><br><span class=\"line\">Motan：新浪微博开源的 Java 框架</span><br><span class=\"line\">gRPC：Google 开发的开源 RPC 框架</span><br><span class=\"line\">Thrift：Facebook 开发的一个 RPC 框架，采用 thrift 作为 IDL</span><br><span class=\"line\">jsonrpc：一个无状态轻量级的 RPC 框架</span><br></pre></td></tr></table></figure></p>\n<p>没有最好的框架，只有最适合自己的才是最好的。<br>经过一番了解与实践，我们的 Nodejs 服务最终的选择是 Dubbo。</p>\n<h4 id=\"为什么选择-Dubbo\"><a href=\"#为什么选择-Dubbo\" class=\"headerlink\" title=\"为什么选择 Dubbo\"></a>为什么选择 Dubbo</h4><p>既然市面上有那么多 RPC 框架，为什么我们要选择 Dubbo 呢？<br>原因如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.框架统一性，我厂 java 后端目前使用的 RPC 框架是 Dubbo，因此 Nodejs 同样使用 Dubbo 能减少一些麻烦。</span><br><span class=\"line\">2.目前国内 nodejs 社区相对比较活跃，用的比较成熟的 rpc 框架也是 dubbo。</span><br><span class=\"line\">3.Dubbo 框架是阿里开源的，文档是中文，而且很详细。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Dubbo-简介\"><a href=\"#Dubbo-简介\" class=\"headerlink\" title=\"Dubbo 简介\"></a>Dubbo 简介</h4><p>既然框架已经确定了，那么接下来就是如何接入 Dubbo 了，在此之前，我们需要明白 Dubbo 是什么？<br>官方说法：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以 SOA 服务治理方案。</span><br></pre></td></tr></table></figure><br>Dubbo 是阿里开源的一个 java 的分布式服务框架，原来是专门为 java 服务的，之前一段时间停止维护了，但是后面又宣布开始维护了。于是，在 Nodejs 兴起之后，就有一些个人或者企业做起了 Nodejs 端对 Dubbo 的接入。</p>\n<p>其中相对用的比较多的有<a href=\"https://github.com/omnip620/node-zookeeper-dubbo\" target=\"_blank\">node-zookeeper-dubbo</a> 以及 <a href=\"https://github.com/dubbo/dubbo2.js\">dubbo2.js</a>（官方推荐）。</p>\n<p>如果仅仅只需要接入 Dubbo，通过上面两个框架就已经足够了，只要能够调通就能够正常的使用 java 方提供的 Dubbo 接口了。<br>但是，显然这样是不够的（亲身经历），如果不搞明白 Dubbo 的大概原理，遇到问题就直接懵逼了。<br>不说别的，至少 Dubbo 的大概框架得弄清楚一下，不然接口配置都不一定能配对。</p>\n<p>因此，下面再简单介绍一下 Dubbo 这个框架（可以直接看<a href=\"http://dubbo.apache.org/zh-cn/docs/user/quick-start.html\" target=\"_blank\">官方文档</a>然后再回来）。<br>官方文档以及很详细了，就不过多介绍了。</p>\n<p>下面补充一下官方文档上我觉得“不够直观”或者我觉得比较重要的东西。</p>\n<h4 id=\"Dubbo-组成。\"><a href=\"#Dubbo-组成。\" class=\"headerlink\" title=\"Dubbo 组成。\"></a>Dubbo 组成。</h4><p>其实，主要就是这一张图。<br><img src=\"http://zhoushirong.github.io/img/dubbo-arc.png\" alt=\"Dubbo 架构\"/><br>Dubbo 的核心就是上面这张图了，能看懂基本上也就明白了什么是 Dubbo 了。</p>\n<p>Dubbo 分为几大块：<br>1.服务提供者（Provider）<br>2.服务消费者（Consumer）<br>3.服务调度者（Registry）<br>4.服务统计、管理者（Monitor）</p>\n<p>这里提供者就是服务的提供方了，可以是 java、也可以是 nodejs。<br>当然，Nodejs 用作“服务提供方”的情形，阿里内部有这个操作，对于其它团队来说可能有些麻烦。<br>因此，这里我们所说的 nodejs 不用作提供方，仅仅用作消费方。</p>\n<p>大致过程为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.java 后端开发启动Dubbo服务，作为“服务提供者”，注册到“服务调度者（zookeeper）”</span><br><span class=\"line\">2.nodejs 作为消费者，启动服务，作为“服务消费者”，“服务调度者（zookeeper）在订阅服务”</span><br><span class=\"line\">3.服务调度者通知消费者服务状态。</span><br><span class=\"line\">4.经过调度，nodejs 消费方与 java 服务提供方建立直连，并将调用情况以统计的方式发送到“服务的统计管理者”</span><br><span class=\"line\">5.服务调度者与消费者和提供者建立长连接，实时监控服务状态，并及时通知提供者和消费者。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Dubbo-协议报文消息格式\"><a href=\"#Dubbo-协议报文消息格式\" class=\"headerlink\" title=\"Dubbo 协议报文消息格式\"></a>Dubbo 协议报文消息格式</h4><p>Dubbo 默认使用 Dubbo 协议，Hessian2 序列化方式。适合传入参数数据包较小，消费者比提供者个数多的场景。</p>\n<p>下面是其中一帧数据的数据格式：<br>header：存放一些协议信息</p>\n<table>\n<thead>\n<tr>\n<th>位数</th>\n<th>0-7</th>\n<th>8-15</th>\n<th>16-23</th>\n<th>24-31</th>\n<th>32-95</th>\n<th>96-127</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>含义</td>\n<td>magic heihgt</td>\n<td>magic low</td>\n<td>request and serializtion flag</td>\n<td>response status</td>\n<td>request id</td>\n<td>body length</td>\n</tr>\n</tbody>\n</table>\n<p>dubbo 采用固定长度的消息头：16个字节（128bit），不固定长度的消息体来进行数据传输</p>\n<p>2byte（0-15）:类似java字节码文件里的魔数，用来判断是不是dubbo协议的数据包，类似 class 类文件里面的作用，用来标识一帧的开始，魔数是常量0xdabb。<br>1byte（16-23）：消息标志位，16-20 序列 id, 21 event, 22 two way, 23 请求或响应标识。<br>1byte（24-31） 状态，当消息类型为响应时，设置响应状态。24-31位。状态位, 设置请求响应状态，dubbo定义了一些响应的类型。<br>8byte（32-95）： 消息ID, long类型，每一个请求的唯一识别id（由于采用异步通讯的方式，用来把请求request和返回的response对应上）<br>4byte （96-127）：消息长度，96-127位。消息体 body 长度, int 类型，即记录Body Content有多少个字节。</p>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><p>Dubbo 协议：消息状态码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* ok.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> OK = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* clien side timeout.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> CLIENT_TIMEOUT = <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* server side timeout.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> SERVER_TIMEOUT = <span class=\"number\">31</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* request format error.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> BAD_REQUEST = <span class=\"number\">40</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* response format error.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> BAD_RESPONSE = <span class=\"number\">50</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* service not found.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> SERVICE_NOT_FOUND = <span class=\"number\">60</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* service error.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> SERVICE_ERROR = <span class=\"number\">70</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* internal server error.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> SERVER_ERROR = <span class=\"number\">80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* internal server error.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> CLIENT_ERROR = <span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* server side threadpool exhausted and quick return.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> SERVER_THREADPOOL_EXHAUSTED_ERROR = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>Dubbo 官方文档：<br><a href=\"http://dubbo.apache.org/zh-cn/docs/user/quick-start.html\">http://dubbo.apache.org/zh-cn/docs/user/quick-start.html</a><br>Dubbo2.js github 地址：<br><a href=\"https://github.com/dubbo/dubbo2.js\">https://github.com/dubbo/dubbo2.js</a><br>NodeZookeeperDubbo github 地址：<br><a href=\"https://github.com/omnip620/node-zookeeper-dubbo\">https://github.com/omnip620/node-zookeeper-dubbo</a></p>\n"},{"layout":"default","title":"使用npm版本锁定的必要性","date":"2018-05-22T11:33:33.000Z","_content":"\n## {{page.title}}\n\n### 事情的背景\n我司的项目基本上都是后端java，前端随意。\n前端什么技术都有，react、vue、jquery、regular、seajs...\n好在构建工具不复杂，也就是用的gulp + webpack\n其实，还算是比较灵活了，虽然没有用nodejs，但是java的ftl模板也足够支持前后端分离了。\n\n发布是走的公司运维开发的发布系统，由于**历史原因**，发布构建的时候，每修改一次代码需要分两步发版，分别是：\n前端发布：webpack+gulp构建，然后发前端静态资源到cdn\n后端发布：webpack+gulp构建，然后发ftl文件以及java文件到源站。\n\n并且两次发布所在的目录是不同的，因此也就需要执行npm install - npm build多次，也就意味着有两套node_modules\n\n\n### 问题\n\n当然了，还是历史原因，我们项目中有部分代码是在本地构建之后提交到版本库的。\n而本次我的任务就是解决历史问题，然后将代码本地构建改为发版构建。\n\n于是，问题来了。\n\n我在将本地构建改为发布构建的时候突然发现某个js资源404了，经检查，原来是两次构建的文件hash值不一样。\n也就是说，前端发布的时候和后端发布的时候两次编译出来的文件hash值不一样。\n\n经过多次测试，发现：\n我本地是好的，多次构建都是完全一样的，哪怕是删除了package.json、node_modules\n而同样的某一台构建服务器上却是两次构建不一样，并且两次和我本机的构建hash也不一样。\n另外其它的构建服务器上却是两次构建一样，并且两次和我本机的构建hash不一样。\n\n### 分析\nhash值是根据文件内容算出来的，理论上来说不一样的文件内容计算出来的结果一定是不一样的。\n因此，一定是编译出来的文件某个地方不一样才导致的hash不同。\n\n既然有了猜想，便去验证一番，经过一番折腾终于拿到了构建机器两次构建之后的源码\n后经过一番对比，发现文件大部分内容都是一样的，只有极少部分变量名不同\n其中有一个地方引起了我的注意，那就是某个es6转换成es5代码之后的某个方法有些异常，虽然结果一样，但是语法、方法结构却不一样\n\n难道是babel？\n同样版本的构建为什么会出现不一样的文件？\n\n等等，同样的构建？突然想到，npm的package.json版本管理的原理。\n\n我们的package.json文件都是用的上尖括号（范版本）\n```shell\n\"dependencies\": {\n  \"vue\": \"^2.4.2\",\n  \"vue-resource\": \"^1.3.4\",\n  \"vue-router\": \"^2.7.0\",\n  \"vuex\": \"^3.0.1\"\n},\n```\n\n尖括号的意思是，匹配所有的次要版本，也就是说：\n\n```html\n如果当前配置的是 ^1.1.1\n当依赖包最新版本为 1.x.x的时候，下次npm install就会自动安装最新的版本。\n但是会忽略 2.0.0及以上版本\n```\n\n除此之外还有一种匹配模式是波浪号，匹配第二次要的版本\n\n```shell\n\"dependencies\": {\n  \"vue\": \"~2.4.2\",\n  \"vue-resource\": \"~1.3.4\",\n  \"vue-router\": \"~2.7.0\",\n  \"vuex\": \"~3.0.1\"\n},\n```\n\n比如\n\n```html\n如果~1.1.1，当最新版本为 1.1.x的时候，下次npm install就会自动更新最新的版本\n但是会忽略 2.2.0及以上版本\n```\n\n莫非是因为babel升级了一个小版本？而我们的node_module有的更新了，有的没有更新？\n这个还真的很有可能，因为我们的构建机器上的依赖包是优先缓存的，而之前为了做实验我做了清缓存的操作，有可能是有的更新了缓存，有的却没有更新。\n\n因为有了这个猜想，便去验证一番，如果是安装包的问题，那么是不是说只需要做到几次安装的node_module下的依赖包版本一致，就能解决这个问题了呢？\n\n### 实践\n\n解决版本锁定也很简单，加个npm-lock就可以了\n但是npm本身支持lock是在5.0.0以上的，而我们构建服务器因为nodejs版本还是6.x.x，因此对应npm可能不支持npm-lock\n好在我们发版构建工具支持yarn，yarn本身就支持yarn-lock，只需要把yarn-lock提交上去就可以了（之前由于历史原因，将yarn-lock忽略掉了）\n\n于是，我把yarn-lock提交上去之后，咦？好了！\n嗯，问题就这样好了，两次构建出来的hash值不但一致了，就连和我本地构建出来的文件hash也是一致的了。\n\n至此时，本人内心很平静，毫无波澜。\n\n### 总结与分析\n\n很明显，问题就是出在依赖包，因为使用了范版本，不同的机器安装的包是不一样的，那么构建出来的代码（尤其是压缩、babel等语法解析作用的包处理之后的代码）是非常可能不一样的。\n\nnpm早期版本其实也有解决这个问题的方案，那就是 npm shrinkwrap ，这个也是用作版本锁定的，并且到目前为止也是兼容的，其优先级高于npm-lock\n当然，最简单的还是使用yarn，至少可以少跑一个命令。\n\n以后为了解决各种奇怪的编译问题，还是做好版本锁定的好。\n\n\n\n### 补充\n\nnpm安装包加lock可以提升安全性，更好的让开发人员对安装包进行代码review，减少恶意安装包肆意更新带来的安全隐患\n\n\n\n--- 全文完 ---\n\n","source":"_posts/npm-lock.md","raw":"---\nlayout: default\ntitle: 使用npm版本锁定的必要性\ndate: 2018-05-22 19:33:33\ntag: [npm, npm-lock]\n---\n\n## {{page.title}}\n\n### 事情的背景\n我司的项目基本上都是后端java，前端随意。\n前端什么技术都有，react、vue、jquery、regular、seajs...\n好在构建工具不复杂，也就是用的gulp + webpack\n其实，还算是比较灵活了，虽然没有用nodejs，但是java的ftl模板也足够支持前后端分离了。\n\n发布是走的公司运维开发的发布系统，由于**历史原因**，发布构建的时候，每修改一次代码需要分两步发版，分别是：\n前端发布：webpack+gulp构建，然后发前端静态资源到cdn\n后端发布：webpack+gulp构建，然后发ftl文件以及java文件到源站。\n\n并且两次发布所在的目录是不同的，因此也就需要执行npm install - npm build多次，也就意味着有两套node_modules\n\n\n### 问题\n\n当然了，还是历史原因，我们项目中有部分代码是在本地构建之后提交到版本库的。\n而本次我的任务就是解决历史问题，然后将代码本地构建改为发版构建。\n\n于是，问题来了。\n\n我在将本地构建改为发布构建的时候突然发现某个js资源404了，经检查，原来是两次构建的文件hash值不一样。\n也就是说，前端发布的时候和后端发布的时候两次编译出来的文件hash值不一样。\n\n经过多次测试，发现：\n我本地是好的，多次构建都是完全一样的，哪怕是删除了package.json、node_modules\n而同样的某一台构建服务器上却是两次构建不一样，并且两次和我本机的构建hash也不一样。\n另外其它的构建服务器上却是两次构建一样，并且两次和我本机的构建hash不一样。\n\n### 分析\nhash值是根据文件内容算出来的，理论上来说不一样的文件内容计算出来的结果一定是不一样的。\n因此，一定是编译出来的文件某个地方不一样才导致的hash不同。\n\n既然有了猜想，便去验证一番，经过一番折腾终于拿到了构建机器两次构建之后的源码\n后经过一番对比，发现文件大部分内容都是一样的，只有极少部分变量名不同\n其中有一个地方引起了我的注意，那就是某个es6转换成es5代码之后的某个方法有些异常，虽然结果一样，但是语法、方法结构却不一样\n\n难道是babel？\n同样版本的构建为什么会出现不一样的文件？\n\n等等，同样的构建？突然想到，npm的package.json版本管理的原理。\n\n我们的package.json文件都是用的上尖括号（范版本）\n```shell\n\"dependencies\": {\n  \"vue\": \"^2.4.2\",\n  \"vue-resource\": \"^1.3.4\",\n  \"vue-router\": \"^2.7.0\",\n  \"vuex\": \"^3.0.1\"\n},\n```\n\n尖括号的意思是，匹配所有的次要版本，也就是说：\n\n```html\n如果当前配置的是 ^1.1.1\n当依赖包最新版本为 1.x.x的时候，下次npm install就会自动安装最新的版本。\n但是会忽略 2.0.0及以上版本\n```\n\n除此之外还有一种匹配模式是波浪号，匹配第二次要的版本\n\n```shell\n\"dependencies\": {\n  \"vue\": \"~2.4.2\",\n  \"vue-resource\": \"~1.3.4\",\n  \"vue-router\": \"~2.7.0\",\n  \"vuex\": \"~3.0.1\"\n},\n```\n\n比如\n\n```html\n如果~1.1.1，当最新版本为 1.1.x的时候，下次npm install就会自动更新最新的版本\n但是会忽略 2.2.0及以上版本\n```\n\n莫非是因为babel升级了一个小版本？而我们的node_module有的更新了，有的没有更新？\n这个还真的很有可能，因为我们的构建机器上的依赖包是优先缓存的，而之前为了做实验我做了清缓存的操作，有可能是有的更新了缓存，有的却没有更新。\n\n因为有了这个猜想，便去验证一番，如果是安装包的问题，那么是不是说只需要做到几次安装的node_module下的依赖包版本一致，就能解决这个问题了呢？\n\n### 实践\n\n解决版本锁定也很简单，加个npm-lock就可以了\n但是npm本身支持lock是在5.0.0以上的，而我们构建服务器因为nodejs版本还是6.x.x，因此对应npm可能不支持npm-lock\n好在我们发版构建工具支持yarn，yarn本身就支持yarn-lock，只需要把yarn-lock提交上去就可以了（之前由于历史原因，将yarn-lock忽略掉了）\n\n于是，我把yarn-lock提交上去之后，咦？好了！\n嗯，问题就这样好了，两次构建出来的hash值不但一致了，就连和我本地构建出来的文件hash也是一致的了。\n\n至此时，本人内心很平静，毫无波澜。\n\n### 总结与分析\n\n很明显，问题就是出在依赖包，因为使用了范版本，不同的机器安装的包是不一样的，那么构建出来的代码（尤其是压缩、babel等语法解析作用的包处理之后的代码）是非常可能不一样的。\n\nnpm早期版本其实也有解决这个问题的方案，那就是 npm shrinkwrap ，这个也是用作版本锁定的，并且到目前为止也是兼容的，其优先级高于npm-lock\n当然，最简单的还是使用yarn，至少可以少跑一个命令。\n\n以后为了解决各种奇怪的编译问题，还是做好版本锁定的好。\n\n\n\n### 补充\n\nnpm安装包加lock可以提升安全性，更好的让开发人员对安装包进行代码review，减少恶意安装包肆意更新带来的安全隐患\n\n\n\n--- 全文完 ---\n\n","slug":"npm-lock","published":1,"updated":"2021-03-30T01:32:00.322Z","comments":1,"photos":[],"link":"","_id":"ckn2g7ufy0016a0vz2v7h0e6n","content":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h3 id=\"事情的背景\"><a href=\"#事情的背景\" class=\"headerlink\" title=\"事情的背景\"></a>事情的背景</h3><p>我司的项目基本上都是后端java，前端随意。<br>前端什么技术都有，react、vue、jquery、regular、seajs…<br>好在构建工具不复杂，也就是用的gulp + webpack<br>其实，还算是比较灵活了，虽然没有用nodejs，但是java的ftl模板也足够支持前后端分离了。</p>\n<p>发布是走的公司运维开发的发布系统，由于<strong>历史原因</strong>，发布构建的时候，每修改一次代码需要分两步发版，分别是：<br>前端发布：webpack+gulp构建，然后发前端静态资源到cdn<br>后端发布：webpack+gulp构建，然后发ftl文件以及java文件到源站。</p>\n<p>并且两次发布所在的目录是不同的，因此也就需要执行npm install - npm build多次，也就意味着有两套node_modules</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>当然了，还是历史原因，我们项目中有部分代码是在本地构建之后提交到版本库的。<br>而本次我的任务就是解决历史问题，然后将代码本地构建改为发版构建。</p>\n<p>于是，问题来了。</p>\n<p>我在将本地构建改为发布构建的时候突然发现某个js资源404了，经检查，原来是两次构建的文件hash值不一样。<br>也就是说，前端发布的时候和后端发布的时候两次编译出来的文件hash值不一样。</p>\n<p>经过多次测试，发现：<br>我本地是好的，多次构建都是完全一样的，哪怕是删除了package.json、node_modules<br>而同样的某一台构建服务器上却是两次构建不一样，并且两次和我本机的构建hash也不一样。<br>另外其它的构建服务器上却是两次构建一样，并且两次和我本机的构建hash不一样。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>hash值是根据文件内容算出来的，理论上来说不一样的文件内容计算出来的结果一定是不一样的。<br>因此，一定是编译出来的文件某个地方不一样才导致的hash不同。</p>\n<p>既然有了猜想，便去验证一番，经过一番折腾终于拿到了构建机器两次构建之后的源码<br>后经过一番对比，发现文件大部分内容都是一样的，只有极少部分变量名不同<br>其中有一个地方引起了我的注意，那就是某个es6转换成es5代码之后的某个方法有些异常，虽然结果一样，但是语法、方法结构却不一样</p>\n<p>难道是babel？<br>同样版本的构建为什么会出现不一样的文件？</p>\n<p>等等，同样的构建？突然想到，npm的package.json版本管理的原理。</p>\n<p>我们的package.json文件都是用的上尖括号（范版本）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">  &quot;vue&quot;: &quot;^2.4.2&quot;,</span><br><span class=\"line\">  &quot;vue-resource&quot;: &quot;^1.3.4&quot;,</span><br><span class=\"line\">  &quot;vue-router&quot;: &quot;^2.7.0&quot;,</span><br><span class=\"line\">  &quot;vuex&quot;: &quot;^3.0.1&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>尖括号的意思是，匹配所有的次要版本，也就是说：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果当前配置的是 ^1.1.1</span><br><span class=\"line\">当依赖包最新版本为 1.x.x的时候，下次npm install就会自动安装最新的版本。</span><br><span class=\"line\">但是会忽略 2.0.0及以上版本</span><br></pre></td></tr></table></figure>\n<p>除此之外还有一种匹配模式是波浪号，匹配第二次要的版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">  &quot;vue&quot;: &quot;~2.4.2&quot;,</span><br><span class=\"line\">  &quot;vue-resource&quot;: &quot;~1.3.4&quot;,</span><br><span class=\"line\">  &quot;vue-router&quot;: &quot;~2.7.0&quot;,</span><br><span class=\"line\">  &quot;vuex&quot;: &quot;~3.0.1&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>比如</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果~1.1.1，当最新版本为 1.1.x的时候，下次npm install就会自动更新最新的版本</span><br><span class=\"line\">但是会忽略 2.2.0及以上版本</span><br></pre></td></tr></table></figure>\n<p>莫非是因为babel升级了一个小版本？而我们的node_module有的更新了，有的没有更新？<br>这个还真的很有可能，因为我们的构建机器上的依赖包是优先缓存的，而之前为了做实验我做了清缓存的操作，有可能是有的更新了缓存，有的却没有更新。</p>\n<p>因为有了这个猜想，便去验证一番，如果是安装包的问题，那么是不是说只需要做到几次安装的node_module下的依赖包版本一致，就能解决这个问题了呢？</p>\n<h3 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h3><p>解决版本锁定也很简单，加个npm-lock就可以了<br>但是npm本身支持lock是在5.0.0以上的，而我们构建服务器因为nodejs版本还是6.x.x，因此对应npm可能不支持npm-lock<br>好在我们发版构建工具支持yarn，yarn本身就支持yarn-lock，只需要把yarn-lock提交上去就可以了（之前由于历史原因，将yarn-lock忽略掉了）</p>\n<p>于是，我把yarn-lock提交上去之后，咦？好了！<br>嗯，问题就这样好了，两次构建出来的hash值不但一致了，就连和我本地构建出来的文件hash也是一致的了。</p>\n<p>至此时，本人内心很平静，毫无波澜。</p>\n<h3 id=\"总结与分析\"><a href=\"#总结与分析\" class=\"headerlink\" title=\"总结与分析\"></a>总结与分析</h3><p>很明显，问题就是出在依赖包，因为使用了范版本，不同的机器安装的包是不一样的，那么构建出来的代码（尤其是压缩、babel等语法解析作用的包处理之后的代码）是非常可能不一样的。</p>\n<p>npm早期版本其实也有解决这个问题的方案，那就是 npm shrinkwrap ，这个也是用作版本锁定的，并且到目前为止也是兼容的，其优先级高于npm-lock<br>当然，最简单的还是使用yarn，至少可以少跑一个命令。</p>\n<p>以后为了解决各种奇怪的编译问题，还是做好版本锁定的好。</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>npm安装包加lock可以提升安全性，更好的让开发人员对安装包进行代码review，减少恶意安装包肆意更新带来的安全隐患</p>\n<p>— 全文完 —</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h3 id=\"事情的背景\"><a href=\"#事情的背景\" class=\"headerlink\" title=\"事情的背景\"></a>事情的背景</h3><p>我司的项目基本上都是后端java，前端随意。<br>前端什么技术都有，react、vue、jquery、regular、seajs…<br>好在构建工具不复杂，也就是用的gulp + webpack<br>其实，还算是比较灵活了，虽然没有用nodejs，但是java的ftl模板也足够支持前后端分离了。</p>\n<p>发布是走的公司运维开发的发布系统，由于<strong>历史原因</strong>，发布构建的时候，每修改一次代码需要分两步发版，分别是：<br>前端发布：webpack+gulp构建，然后发前端静态资源到cdn<br>后端发布：webpack+gulp构建，然后发ftl文件以及java文件到源站。</p>\n<p>并且两次发布所在的目录是不同的，因此也就需要执行npm install - npm build多次，也就意味着有两套node_modules</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>当然了，还是历史原因，我们项目中有部分代码是在本地构建之后提交到版本库的。<br>而本次我的任务就是解决历史问题，然后将代码本地构建改为发版构建。</p>\n<p>于是，问题来了。</p>\n<p>我在将本地构建改为发布构建的时候突然发现某个js资源404了，经检查，原来是两次构建的文件hash值不一样。<br>也就是说，前端发布的时候和后端发布的时候两次编译出来的文件hash值不一样。</p>\n<p>经过多次测试，发现：<br>我本地是好的，多次构建都是完全一样的，哪怕是删除了package.json、node_modules<br>而同样的某一台构建服务器上却是两次构建不一样，并且两次和我本机的构建hash也不一样。<br>另外其它的构建服务器上却是两次构建一样，并且两次和我本机的构建hash不一样。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>hash值是根据文件内容算出来的，理论上来说不一样的文件内容计算出来的结果一定是不一样的。<br>因此，一定是编译出来的文件某个地方不一样才导致的hash不同。</p>\n<p>既然有了猜想，便去验证一番，经过一番折腾终于拿到了构建机器两次构建之后的源码<br>后经过一番对比，发现文件大部分内容都是一样的，只有极少部分变量名不同<br>其中有一个地方引起了我的注意，那就是某个es6转换成es5代码之后的某个方法有些异常，虽然结果一样，但是语法、方法结构却不一样</p>\n<p>难道是babel？<br>同样版本的构建为什么会出现不一样的文件？</p>\n<p>等等，同样的构建？突然想到，npm的package.json版本管理的原理。</p>\n<p>我们的package.json文件都是用的上尖括号（范版本）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">  &quot;vue&quot;: &quot;^2.4.2&quot;,</span><br><span class=\"line\">  &quot;vue-resource&quot;: &quot;^1.3.4&quot;,</span><br><span class=\"line\">  &quot;vue-router&quot;: &quot;^2.7.0&quot;,</span><br><span class=\"line\">  &quot;vuex&quot;: &quot;^3.0.1&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>尖括号的意思是，匹配所有的次要版本，也就是说：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果当前配置的是 ^1.1.1</span><br><span class=\"line\">当依赖包最新版本为 1.x.x的时候，下次npm install就会自动安装最新的版本。</span><br><span class=\"line\">但是会忽略 2.0.0及以上版本</span><br></pre></td></tr></table></figure>\n<p>除此之外还有一种匹配模式是波浪号，匹配第二次要的版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">  &quot;vue&quot;: &quot;~2.4.2&quot;,</span><br><span class=\"line\">  &quot;vue-resource&quot;: &quot;~1.3.4&quot;,</span><br><span class=\"line\">  &quot;vue-router&quot;: &quot;~2.7.0&quot;,</span><br><span class=\"line\">  &quot;vuex&quot;: &quot;~3.0.1&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>比如</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果~1.1.1，当最新版本为 1.1.x的时候，下次npm install就会自动更新最新的版本</span><br><span class=\"line\">但是会忽略 2.2.0及以上版本</span><br></pre></td></tr></table></figure>\n<p>莫非是因为babel升级了一个小版本？而我们的node_module有的更新了，有的没有更新？<br>这个还真的很有可能，因为我们的构建机器上的依赖包是优先缓存的，而之前为了做实验我做了清缓存的操作，有可能是有的更新了缓存，有的却没有更新。</p>\n<p>因为有了这个猜想，便去验证一番，如果是安装包的问题，那么是不是说只需要做到几次安装的node_module下的依赖包版本一致，就能解决这个问题了呢？</p>\n<h3 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h3><p>解决版本锁定也很简单，加个npm-lock就可以了<br>但是npm本身支持lock是在5.0.0以上的，而我们构建服务器因为nodejs版本还是6.x.x，因此对应npm可能不支持npm-lock<br>好在我们发版构建工具支持yarn，yarn本身就支持yarn-lock，只需要把yarn-lock提交上去就可以了（之前由于历史原因，将yarn-lock忽略掉了）</p>\n<p>于是，我把yarn-lock提交上去之后，咦？好了！<br>嗯，问题就这样好了，两次构建出来的hash值不但一致了，就连和我本地构建出来的文件hash也是一致的了。</p>\n<p>至此时，本人内心很平静，毫无波澜。</p>\n<h3 id=\"总结与分析\"><a href=\"#总结与分析\" class=\"headerlink\" title=\"总结与分析\"></a>总结与分析</h3><p>很明显，问题就是出在依赖包，因为使用了范版本，不同的机器安装的包是不一样的，那么构建出来的代码（尤其是压缩、babel等语法解析作用的包处理之后的代码）是非常可能不一样的。</p>\n<p>npm早期版本其实也有解决这个问题的方案，那就是 npm shrinkwrap ，这个也是用作版本锁定的，并且到目前为止也是兼容的，其优先级高于npm-lock<br>当然，最简单的还是使用yarn，至少可以少跑一个命令。</p>\n<p>以后为了解决各种奇怪的编译问题，还是做好版本锁定的好。</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>npm安装包加lock可以提升安全性，更好的让开发人员对安装包进行代码review，减少恶意安装包肆意更新带来的安全隐患</p>\n<p>— 全文完 —</p>\n"},{"title":"Javascript对象","date":"2016-10-10T16:00:00.000Z","_content":"\n《JavaScript高级程序设计学习笔记》之Javascript对象。\n面向对象（Object-Oriented, OO）的语言有一个标志，那就是它们都有类的概念\n而通过类可以创建任意多个具有相同属性和方法的对象。\nECMAScript没有类的概念，因此它的对象也与机遇类的语言中的对象有所不同\n**ES6新增了对象Class的语法糖，这里不讨论ES6**\n\n\n### 理解对象\n\n1.对象\n\n``` javascript\nvar person = new Object();\n\nperson.name = \"jack\";\n\nperson.sayName = function(){  \n  return this.name;\n}\n```\n\n2.属性 \n\nECMAScript中有两种属性\n\n1）数据属性，数据属性有4个描述其行为的特性\n\n``` html\n[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性改为访问器属性。\n\n[[Enumerable]]:能否通过for-in遍历\n\n[[Writabe]]:是否能修改属性的值\n\n[[value]]:包含这个属性的数据值。从这个位置读属性值，写属性值的时候把新的值保存在这个位置。默认为undefined\n```\n\n要修改属性的默认特性必须使用ECMAScript5的Object.defineProperty()方法。\n\n``` javascript\nvar person = {};\n\nObject.defineProperty(person, \"name\", {  \n  configurable:true, //设置false之后下次用defineProperty修改此属性就会抛错  \n  value: jack\n});\n\n```\n\n2）访问器属性\n\n访问器属性不包含数据值；它们包含一对getter和setter函数；\n\n读取访问器属性的时候会调用getter函数；写入访问器属性的时候会调用setter函数\n\n访问器属性有如下4个特性\n\n``` html\n[[Configurable]]:同上数据属性\n\n[[Enumerable]]:同上数据属性\n\n[[Get]]:在读取属性的时候调用的函数。默认undefined\n\n[[Set]]:在写入属性的时候调用的函数。默认为undefined\n```\n\n3) 访问器属性不能直接定义，必须使用Object.defineProperty()来定义\n\n``` javascript\nvar book = {\n  __year:2016,\n  edition:1\t\n};\n\nObject.defineProperty(book, \"year\", {\n  get: function() {\n    return this.__year;\n  },\n  set: function(newValue) {\n    if (newValue > 2016) {\n      this.__year  = newValue;\n      this.edition += newValue - 2016;\n    }\n  }\n});\n\nbook.year = 2017;\nconsole.log(book.edition); // 2\n```\n\n3) 定义多个属性\n\nECMAScript5定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。\n\n``` javascript\nvar book = {};\n\nObject.defineProperties(book, {\n  __year: { //数据属性\n    value:2016,\n    writable:false\n  },\n  edition: { //数据属性\n    value:1,\n    writable:true\n  },\n  year: { //访问器属性\n    get: function() {\n      return this.__year;\n    },\n    set: function(newValue) {\n      if (newValue > 2016) {\n        this.__year = newValue;\n        this.edition += newValue - 2016;\n      }\n    }\n  }\n});\n```\n\n4) 读取属性的特性\n\n使用ECMAScript5的Ojbect.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。\n\n``` javascript\n//...上面的例子\n\nvar descriptor = Object.getOwnPropertyDescriptor(book, \"__year\"); \nconsole.log(descriptor.value, descriptor.writable, descriptor.configurable, descriptor.value);\n\n```\n\n--------------------------------\n\n### 创建对象\n\n1.工厂模式\n\n2.构造函数模式\n\n3.原型模式\n\n4.组合使用构造函数模式和原型模式\n\n5.动态原型模式\n\n6.寄生构造函数模式\n\n7.稳妥构造函数模式\n\n---------------------------------\n\n### 继承\n\n许多OO语言都支持两种继承方式：\n\n``` html\n接口继承:继承方法签名\n\n实现继承:继承实际方法\n```\nJavaScript支持实现继承，且继承方式是依靠原型链实现的（es6的class类已经支持继承）\n\n1.原型链继承\n\n2.借用构造函数实现继承\n\n3.组合继承\n\n4.原型式继承\n\n5.寄生继承\n\n6.寄生组合式继承\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/object.md","raw":"---\ntitle: Javascript对象\ndate: 2016/10/11\ntag: [js, object]\ncategory: 技术\n---\n\n《JavaScript高级程序设计学习笔记》之Javascript对象。\n面向对象（Object-Oriented, OO）的语言有一个标志，那就是它们都有类的概念\n而通过类可以创建任意多个具有相同属性和方法的对象。\nECMAScript没有类的概念，因此它的对象也与机遇类的语言中的对象有所不同\n**ES6新增了对象Class的语法糖，这里不讨论ES6**\n\n\n### 理解对象\n\n1.对象\n\n``` javascript\nvar person = new Object();\n\nperson.name = \"jack\";\n\nperson.sayName = function(){  \n  return this.name;\n}\n```\n\n2.属性 \n\nECMAScript中有两种属性\n\n1）数据属性，数据属性有4个描述其行为的特性\n\n``` html\n[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性改为访问器属性。\n\n[[Enumerable]]:能否通过for-in遍历\n\n[[Writabe]]:是否能修改属性的值\n\n[[value]]:包含这个属性的数据值。从这个位置读属性值，写属性值的时候把新的值保存在这个位置。默认为undefined\n```\n\n要修改属性的默认特性必须使用ECMAScript5的Object.defineProperty()方法。\n\n``` javascript\nvar person = {};\n\nObject.defineProperty(person, \"name\", {  \n  configurable:true, //设置false之后下次用defineProperty修改此属性就会抛错  \n  value: jack\n});\n\n```\n\n2）访问器属性\n\n访问器属性不包含数据值；它们包含一对getter和setter函数；\n\n读取访问器属性的时候会调用getter函数；写入访问器属性的时候会调用setter函数\n\n访问器属性有如下4个特性\n\n``` html\n[[Configurable]]:同上数据属性\n\n[[Enumerable]]:同上数据属性\n\n[[Get]]:在读取属性的时候调用的函数。默认undefined\n\n[[Set]]:在写入属性的时候调用的函数。默认为undefined\n```\n\n3) 访问器属性不能直接定义，必须使用Object.defineProperty()来定义\n\n``` javascript\nvar book = {\n  __year:2016,\n  edition:1\t\n};\n\nObject.defineProperty(book, \"year\", {\n  get: function() {\n    return this.__year;\n  },\n  set: function(newValue) {\n    if (newValue > 2016) {\n      this.__year  = newValue;\n      this.edition += newValue - 2016;\n    }\n  }\n});\n\nbook.year = 2017;\nconsole.log(book.edition); // 2\n```\n\n3) 定义多个属性\n\nECMAScript5定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。\n\n``` javascript\nvar book = {};\n\nObject.defineProperties(book, {\n  __year: { //数据属性\n    value:2016,\n    writable:false\n  },\n  edition: { //数据属性\n    value:1,\n    writable:true\n  },\n  year: { //访问器属性\n    get: function() {\n      return this.__year;\n    },\n    set: function(newValue) {\n      if (newValue > 2016) {\n        this.__year = newValue;\n        this.edition += newValue - 2016;\n      }\n    }\n  }\n});\n```\n\n4) 读取属性的特性\n\n使用ECMAScript5的Ojbect.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。\n\n``` javascript\n//...上面的例子\n\nvar descriptor = Object.getOwnPropertyDescriptor(book, \"__year\"); \nconsole.log(descriptor.value, descriptor.writable, descriptor.configurable, descriptor.value);\n\n```\n\n--------------------------------\n\n### 创建对象\n\n1.工厂模式\n\n2.构造函数模式\n\n3.原型模式\n\n4.组合使用构造函数模式和原型模式\n\n5.动态原型模式\n\n6.寄生构造函数模式\n\n7.稳妥构造函数模式\n\n---------------------------------\n\n### 继承\n\n许多OO语言都支持两种继承方式：\n\n``` html\n接口继承:继承方法签名\n\n实现继承:继承实际方法\n```\nJavaScript支持实现继承，且继承方式是依靠原型链实现的（es6的class类已经支持继承）\n\n1.原型链继承\n\n2.借用构造函数实现继承\n\n3.组合继承\n\n4.原型式继承\n\n5.寄生继承\n\n6.寄生组合式继承\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"object","published":1,"updated":"2021-03-30T01:32:00.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ufz0017a0vz4dd1eumn","content":"<p>《JavaScript高级程序设计学习笔记》之Javascript对象。<br>面向对象（Object-Oriented, OO）的语言有一个标志，那就是它们都有类的概念<br>而通过类可以创建任意多个具有相同属性和方法的对象。<br>ECMAScript没有类的概念，因此它的对象也与机遇类的语言中的对象有所不同<br><strong>ES6新增了对象Class的语法糖，这里不讨论ES6</strong></p>\n<h3 id=\"理解对象\"><a href=\"#理解对象\" class=\"headerlink\" title=\"理解对象\"></a>理解对象</h3><p>1.对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">person.name = <span class=\"string\">&quot;jack&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">person.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.属性 </p>\n<p>ECMAScript中有两种属性</p>\n<p>1）数据属性，数据属性有4个描述其行为的特性</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性改为访问器属性。</span><br><span class=\"line\"></span><br><span class=\"line\">[[Enumerable]]:能否通过for-in遍历</span><br><span class=\"line\"></span><br><span class=\"line\">[[Writabe]]:是否能修改属性的值</span><br><span class=\"line\"></span><br><span class=\"line\">[[value]]:包含这个属性的数据值。从这个位置读属性值，写属性值的时候把新的值保存在这个位置。默认为undefined</span><br></pre></td></tr></table></figure>\n<p>要修改属性的默认特性必须使用ECMAScript5的Object.defineProperty()方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(person, <span class=\"string\">&quot;name&quot;</span>, &#123;  </span><br><span class=\"line\">  configurable:<span class=\"literal\">true</span>, <span class=\"comment\">//设置false之后下次用defineProperty修改此属性就会抛错  </span></span><br><span class=\"line\">  value: jack</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2）访问器属性</p>\n<p>访问器属性不包含数据值；它们包含一对getter和setter函数；</p>\n<p>读取访问器属性的时候会调用getter函数；写入访问器属性的时候会调用setter函数</p>\n<p>访问器属性有如下4个特性</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[Configurable]]:同上数据属性</span><br><span class=\"line\"></span><br><span class=\"line\">[[Enumerable]]:同上数据属性</span><br><span class=\"line\"></span><br><span class=\"line\">[[Get]]:在读取属性的时候调用的函数。默认undefined</span><br><span class=\"line\"></span><br><span class=\"line\">[[Set]]:在写入属性的时候调用的函数。默认为undefined</span><br></pre></td></tr></table></figure>\n<p>3) 访问器属性不能直接定义，必须使用Object.defineProperty()来定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> book = &#123;</span><br><span class=\"line\">  __year:<span class=\"number\">2016</span>,</span><br><span class=\"line\">  edition:<span class=\"number\">1</span>\t</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(book, <span class=\"string\">&quot;year&quot;</span>, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.__year;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newValue &gt; <span class=\"number\">2016</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.__year  = newValue;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.edition += newValue - <span class=\"number\">2016</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">book.year = <span class=\"number\">2017</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(book.edition); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>3) 定义多个属性</p>\n<p>ECMAScript5定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> book = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperties(book, &#123;</span><br><span class=\"line\">  __year: &#123; <span class=\"comment\">//数据属性</span></span><br><span class=\"line\">    value:<span class=\"number\">2016</span>,</span><br><span class=\"line\">    writable:<span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  edition: &#123; <span class=\"comment\">//数据属性</span></span><br><span class=\"line\">    value:<span class=\"number\">1</span>,</span><br><span class=\"line\">    writable:<span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  year: &#123; <span class=\"comment\">//访问器属性</span></span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.__year;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newValue &gt; <span class=\"number\">2016</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.__year = newValue;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.edition += newValue - <span class=\"number\">2016</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>4) 读取属性的特性</p>\n<p>使用ECMAScript5的Ojbect.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...上面的例子</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(book, <span class=\"string\">&quot;__year&quot;</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(descriptor.value, descriptor.writable, descriptor.configurable, descriptor.value);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><p>1.工厂模式</p>\n<p>2.构造函数模式</p>\n<p>3.原型模式</p>\n<p>4.组合使用构造函数模式和原型模式</p>\n<p>5.动态原型模式</p>\n<p>6.寄生构造函数模式</p>\n<p>7.稳妥构造函数模式</p>\n<hr>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>许多OO语言都支持两种继承方式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接口继承:继承方法签名</span><br><span class=\"line\"></span><br><span class=\"line\">实现继承:继承实际方法</span><br></pre></td></tr></table></figure>\n<p>JavaScript支持实现继承，且继承方式是依靠原型链实现的（es6的class类已经支持继承）</p>\n<p>1.原型链继承</p>\n<p>2.借用构造函数实现继承</p>\n<p>3.组合继承</p>\n<p>4.原型式继承</p>\n<p>5.寄生继承</p>\n<p>6.寄生组合式继承</p>\n","site":{"data":{}},"excerpt":"","more":"<p>《JavaScript高级程序设计学习笔记》之Javascript对象。<br>面向对象（Object-Oriented, OO）的语言有一个标志，那就是它们都有类的概念<br>而通过类可以创建任意多个具有相同属性和方法的对象。<br>ECMAScript没有类的概念，因此它的对象也与机遇类的语言中的对象有所不同<br><strong>ES6新增了对象Class的语法糖，这里不讨论ES6</strong></p>\n<h3 id=\"理解对象\"><a href=\"#理解对象\" class=\"headerlink\" title=\"理解对象\"></a>理解对象</h3><p>1.对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">person.name = <span class=\"string\">&quot;jack&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">person.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.属性 </p>\n<p>ECMAScript中有两种属性</p>\n<p>1）数据属性，数据属性有4个描述其行为的特性</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性改为访问器属性。</span><br><span class=\"line\"></span><br><span class=\"line\">[[Enumerable]]:能否通过for-in遍历</span><br><span class=\"line\"></span><br><span class=\"line\">[[Writabe]]:是否能修改属性的值</span><br><span class=\"line\"></span><br><span class=\"line\">[[value]]:包含这个属性的数据值。从这个位置读属性值，写属性值的时候把新的值保存在这个位置。默认为undefined</span><br></pre></td></tr></table></figure>\n<p>要修改属性的默认特性必须使用ECMAScript5的Object.defineProperty()方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(person, <span class=\"string\">&quot;name&quot;</span>, &#123;  </span><br><span class=\"line\">  configurable:<span class=\"literal\">true</span>, <span class=\"comment\">//设置false之后下次用defineProperty修改此属性就会抛错  </span></span><br><span class=\"line\">  value: jack</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2）访问器属性</p>\n<p>访问器属性不包含数据值；它们包含一对getter和setter函数；</p>\n<p>读取访问器属性的时候会调用getter函数；写入访问器属性的时候会调用setter函数</p>\n<p>访问器属性有如下4个特性</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[Configurable]]:同上数据属性</span><br><span class=\"line\"></span><br><span class=\"line\">[[Enumerable]]:同上数据属性</span><br><span class=\"line\"></span><br><span class=\"line\">[[Get]]:在读取属性的时候调用的函数。默认undefined</span><br><span class=\"line\"></span><br><span class=\"line\">[[Set]]:在写入属性的时候调用的函数。默认为undefined</span><br></pre></td></tr></table></figure>\n<p>3) 访问器属性不能直接定义，必须使用Object.defineProperty()来定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> book = &#123;</span><br><span class=\"line\">  __year:<span class=\"number\">2016</span>,</span><br><span class=\"line\">  edition:<span class=\"number\">1</span>\t</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(book, <span class=\"string\">&quot;year&quot;</span>, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.__year;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newValue &gt; <span class=\"number\">2016</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.__year  = newValue;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.edition += newValue - <span class=\"number\">2016</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">book.year = <span class=\"number\">2017</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(book.edition); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>3) 定义多个属性</p>\n<p>ECMAScript5定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> book = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperties(book, &#123;</span><br><span class=\"line\">  __year: &#123; <span class=\"comment\">//数据属性</span></span><br><span class=\"line\">    value:<span class=\"number\">2016</span>,</span><br><span class=\"line\">    writable:<span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  edition: &#123; <span class=\"comment\">//数据属性</span></span><br><span class=\"line\">    value:<span class=\"number\">1</span>,</span><br><span class=\"line\">    writable:<span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  year: &#123; <span class=\"comment\">//访问器属性</span></span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.__year;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newValue &gt; <span class=\"number\">2016</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.__year = newValue;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.edition += newValue - <span class=\"number\">2016</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>4) 读取属性的特性</p>\n<p>使用ECMAScript5的Ojbect.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...上面的例子</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(book, <span class=\"string\">&quot;__year&quot;</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(descriptor.value, descriptor.writable, descriptor.configurable, descriptor.value);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><p>1.工厂模式</p>\n<p>2.构造函数模式</p>\n<p>3.原型模式</p>\n<p>4.组合使用构造函数模式和原型模式</p>\n<p>5.动态原型模式</p>\n<p>6.寄生构造函数模式</p>\n<p>7.稳妥构造函数模式</p>\n<hr>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>许多OO语言都支持两种继承方式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接口继承:继承方法签名</span><br><span class=\"line\"></span><br><span class=\"line\">实现继承:继承实际方法</span><br></pre></td></tr></table></figure>\n<p>JavaScript支持实现继承，且继承方式是依靠原型链实现的（es6的class类已经支持继承）</p>\n<p>1.原型链继承</p>\n<p>2.借用构造函数实现继承</p>\n<p>3.组合继承</p>\n<p>4.原型式继承</p>\n<p>5.寄生继承</p>\n<p>6.寄生组合式继承</p>\n"},{"title":"javascript对象","date":"2020-12-31T16:00:00.000Z","_content":"\n之前学习对象的继承的时候遇到了很多对象的属性，这些属性理解起来还是比较费力的，理解了很多遍，也记忆了很多遍，同样的也忘记了很多遍\n现在给它做个小整理吧\n\n首先先从问题出发，下面表达式都返回 true。\n```javascript\n// 初始数据\nfunction A() {}\nconst a = new A()\nconst arr = []\nconst obj = {}\n\n// instanceof\nA instanceof Object\na instanceof A\na instanceof Object\narr instanceof Object\narr instanceof Array\n\n// prototype and __proto__\nA.prototype === a.__proto__\nArray.prototype === arr.__proto__\na.__proto__ === A.prototype // A.prototype === Object.getPrototypeOf(a)\nobj.__proto__ === Object.prototype\nObject.prototype.constructor === Object\n\n// constructor\na.constructor === A\nobj.constructor === Object\narr.constructor === Array\nObject.constructor === Array.constructor\n```\n#### 分析与总结：\nJS通过 \\_\\_proto\\_\\_ 和 prototype 的合作实现了原型链以及对象的继承。\n上面表达式结果的核心原理也是 \\_\\_proto\\_\\_ 和 prototype 的指向和流转原理，明白了这两个属性也差不多就‘懂了’对象了。\nes6中的class extends语法也是基于es5构造函数继承而封装的语法糖，也不外乎上面两个属性。\n```html\n每个js对象一定对应一个原型对象，且从该原型对象继承了属性和方法，对象的 __proto__ 属性的值就是它对应的原型对象\n只有函数才有 prototype 属性，创建函数的时候js会自动为函数添加 prototype 属性，该属性的值是一个有 constructor 属性的对象。\ninstanceOf 用于检测对象的 prototype 属性是否出现在某个实例的原型链上\n所有的对象都会从它的原型上继承一个 constructor 属性，这个属性指向父级对象(`被继承了constructor属性的对象`)，如：所有构造函数的实例都会从它的原型上继承一个 constructor 属性，这个属性指向该构造函数\n对象的 __proto__ 属性指向父级对象的原型（生产环境使用 Object.getPrototypeOf 代替 __proto__ ）\n对象的 prototype 属性的 __proto__ 属性表示方法的继承，指向父类的prototype属性\n```\n\n最后再来张图片吧\n\n![http://www.mollypages.org/tutorials/js.mp](http://zhoushirong.github.io/img/jsobj.jpg)\n\n### 传送门\n从__proto__和prototype来深入理解JS对象和原型链\nhttps://github.com/creeperyang/blog/issues/9","source":"_posts/object2.md","raw":"---\ntitle: javascript对象\ndate: 2021/01/01\ntag: [object,js,对象]\ncategory: 技术\n---\n\n之前学习对象的继承的时候遇到了很多对象的属性，这些属性理解起来还是比较费力的，理解了很多遍，也记忆了很多遍，同样的也忘记了很多遍\n现在给它做个小整理吧\n\n首先先从问题出发，下面表达式都返回 true。\n```javascript\n// 初始数据\nfunction A() {}\nconst a = new A()\nconst arr = []\nconst obj = {}\n\n// instanceof\nA instanceof Object\na instanceof A\na instanceof Object\narr instanceof Object\narr instanceof Array\n\n// prototype and __proto__\nA.prototype === a.__proto__\nArray.prototype === arr.__proto__\na.__proto__ === A.prototype // A.prototype === Object.getPrototypeOf(a)\nobj.__proto__ === Object.prototype\nObject.prototype.constructor === Object\n\n// constructor\na.constructor === A\nobj.constructor === Object\narr.constructor === Array\nObject.constructor === Array.constructor\n```\n#### 分析与总结：\nJS通过 \\_\\_proto\\_\\_ 和 prototype 的合作实现了原型链以及对象的继承。\n上面表达式结果的核心原理也是 \\_\\_proto\\_\\_ 和 prototype 的指向和流转原理，明白了这两个属性也差不多就‘懂了’对象了。\nes6中的class extends语法也是基于es5构造函数继承而封装的语法糖，也不外乎上面两个属性。\n```html\n每个js对象一定对应一个原型对象，且从该原型对象继承了属性和方法，对象的 __proto__ 属性的值就是它对应的原型对象\n只有函数才有 prototype 属性，创建函数的时候js会自动为函数添加 prototype 属性，该属性的值是一个有 constructor 属性的对象。\ninstanceOf 用于检测对象的 prototype 属性是否出现在某个实例的原型链上\n所有的对象都会从它的原型上继承一个 constructor 属性，这个属性指向父级对象(`被继承了constructor属性的对象`)，如：所有构造函数的实例都会从它的原型上继承一个 constructor 属性，这个属性指向该构造函数\n对象的 __proto__ 属性指向父级对象的原型（生产环境使用 Object.getPrototypeOf 代替 __proto__ ）\n对象的 prototype 属性的 __proto__ 属性表示方法的继承，指向父类的prototype属性\n```\n\n最后再来张图片吧\n\n![http://www.mollypages.org/tutorials/js.mp](http://zhoushirong.github.io/img/jsobj.jpg)\n\n### 传送门\n从__proto__和prototype来深入理解JS对象和原型链\nhttps://github.com/creeperyang/blog/issues/9","slug":"object2","published":1,"updated":"2021-03-30T01:32:00.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug00018a0vz1c1s6yg4","content":"<p>之前学习对象的继承的时候遇到了很多对象的属性，这些属性理解起来还是比较费力的，理解了很多遍，也记忆了很多遍，同样的也忘记了很多遍<br>现在给它做个小整理吧</p>\n<p>首先先从问题出发，下面表达式都返回 true。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> A()</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = []</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// instanceof</span></span><br><span class=\"line\">A <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span></span><br><span class=\"line\">a <span class=\"keyword\">instanceof</span> A</span><br><span class=\"line\">a <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span></span><br><span class=\"line\">arr <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span></span><br><span class=\"line\">arr <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// prototype and __proto__</span></span><br><span class=\"line\">A.prototype === a.__proto__</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype === arr.__proto__</span><br><span class=\"line\">a.__proto__ === A.prototype <span class=\"comment\">// A.prototype === Object.getPrototypeOf(a)</span></span><br><span class=\"line\">obj.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.constructor === <span class=\"built_in\">Object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// constructor</span></span><br><span class=\"line\">a.constructor === A</span><br><span class=\"line\">obj.constructor === <span class=\"built_in\">Object</span></span><br><span class=\"line\">arr.constructor === <span class=\"built_in\">Array</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.constructor === <span class=\"built_in\">Array</span>.constructor</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"分析与总结：\"><a href=\"#分析与总结：\" class=\"headerlink\" title=\"分析与总结：\"></a>分析与总结：</h4><p>JS通过 __proto__ 和 prototype 的合作实现了原型链以及对象的继承。<br>上面表达式结果的核心原理也是 __proto__ 和 prototype 的指向和流转原理，明白了这两个属性也差不多就‘懂了’对象了。<br>es6中的class extends语法也是基于es5构造函数继承而封装的语法糖，也不外乎上面两个属性。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每个js对象一定对应一个原型对象，且从该原型对象继承了属性和方法，对象的 __proto__ 属性的值就是它对应的原型对象</span><br><span class=\"line\">只有函数才有 prototype 属性，创建函数的时候js会自动为函数添加 prototype 属性，该属性的值是一个有 constructor 属性的对象。</span><br><span class=\"line\">instanceOf 用于检测对象的 prototype 属性是否出现在某个实例的原型链上</span><br><span class=\"line\">所有的对象都会从它的原型上继承一个 constructor 属性，这个属性指向父级对象(`被继承了constructor属性的对象`)，如：所有构造函数的实例都会从它的原型上继承一个 constructor 属性，这个属性指向该构造函数</span><br><span class=\"line\">对象的 __proto__ 属性指向父级对象的原型（生产环境使用 Object.getPrototypeOf 代替 __proto__ ）</span><br><span class=\"line\">对象的 prototype 属性的 __proto__ 属性表示方法的继承，指向父类的prototype属性</span><br></pre></td></tr></table></figure></p>\n<p>最后再来张图片吧</p>\n<p><img src=\"http://zhoushirong.github.io/img/jsobj.jpg\" alt=\"http://www.mollypages.org/tutorials/js.mp\"></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>从<strong>proto</strong>和prototype来深入理解JS对象和原型链<br><a href=\"https://github.com/creeperyang/blog/issues/9\">https://github.com/creeperyang/blog/issues/9</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前学习对象的继承的时候遇到了很多对象的属性，这些属性理解起来还是比较费力的，理解了很多遍，也记忆了很多遍，同样的也忘记了很多遍<br>现在给它做个小整理吧</p>\n<p>首先先从问题出发，下面表达式都返回 true。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> A()</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = []</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// instanceof</span></span><br><span class=\"line\">A <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span></span><br><span class=\"line\">a <span class=\"keyword\">instanceof</span> A</span><br><span class=\"line\">a <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span></span><br><span class=\"line\">arr <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span></span><br><span class=\"line\">arr <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// prototype and __proto__</span></span><br><span class=\"line\">A.prototype === a.__proto__</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype === arr.__proto__</span><br><span class=\"line\">a.__proto__ === A.prototype <span class=\"comment\">// A.prototype === Object.getPrototypeOf(a)</span></span><br><span class=\"line\">obj.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.constructor === <span class=\"built_in\">Object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// constructor</span></span><br><span class=\"line\">a.constructor === A</span><br><span class=\"line\">obj.constructor === <span class=\"built_in\">Object</span></span><br><span class=\"line\">arr.constructor === <span class=\"built_in\">Array</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.constructor === <span class=\"built_in\">Array</span>.constructor</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"分析与总结：\"><a href=\"#分析与总结：\" class=\"headerlink\" title=\"分析与总结：\"></a>分析与总结：</h4><p>JS通过 __proto__ 和 prototype 的合作实现了原型链以及对象的继承。<br>上面表达式结果的核心原理也是 __proto__ 和 prototype 的指向和流转原理，明白了这两个属性也差不多就‘懂了’对象了。<br>es6中的class extends语法也是基于es5构造函数继承而封装的语法糖，也不外乎上面两个属性。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每个js对象一定对应一个原型对象，且从该原型对象继承了属性和方法，对象的 __proto__ 属性的值就是它对应的原型对象</span><br><span class=\"line\">只有函数才有 prototype 属性，创建函数的时候js会自动为函数添加 prototype 属性，该属性的值是一个有 constructor 属性的对象。</span><br><span class=\"line\">instanceOf 用于检测对象的 prototype 属性是否出现在某个实例的原型链上</span><br><span class=\"line\">所有的对象都会从它的原型上继承一个 constructor 属性，这个属性指向父级对象(`被继承了constructor属性的对象`)，如：所有构造函数的实例都会从它的原型上继承一个 constructor 属性，这个属性指向该构造函数</span><br><span class=\"line\">对象的 __proto__ 属性指向父级对象的原型（生产环境使用 Object.getPrototypeOf 代替 __proto__ ）</span><br><span class=\"line\">对象的 prototype 属性的 __proto__ 属性表示方法的继承，指向父类的prototype属性</span><br></pre></td></tr></table></figure></p>\n<p>最后再来张图片吧</p>\n<p><img src=\"http://zhoushirong.github.io/img/jsobj.jpg\" alt=\"http://www.mollypages.org/tutorials/js.mp\"></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>从<strong>proto</strong>和prototype来深入理解JS对象和原型链<br><a href=\"https://github.com/creeperyang/blog/issues/9\">https://github.com/creeperyang/blog/issues/9</a></p>\n"},{"title":"回文字符串","date":"2021-01-24T16:00:00.000Z","_content":"\n#### 什么是回文字符串\n回文字符串就是一个字符串，从头读到尾和从尾读到头，字符出现的顺序是一样的。\n如：\n```html\na\naba\nabba\nabcba\n...\nabcdefgfedcba\n```\n\n#### 问题1：如何判断一个字符串是否回文字符串\n```javascript\n/**\n * 判断是否回文字符串\n */ \nfunction isPlalindrome(str) {\n  const len = str.length\n  let i = 0\n  while(i < len / 2) {\n    if (str[i] !== str[len - i - 1]) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n```\n\n#### 问题2：让任意字符串成为回文串的需要插入的最小字符数\n如：\n```html\n插入0次\na => a\n```\n```html\n插入1次\nab => aba || bab\n```\n```html\n插入2次\nabc => abcba || cbabc\n```\n\n#### 分析\n如果它最后要变成一个回文字符串，那么它最终的最左侧和最右侧的字符一定要是相同的。\n如果当前最左侧和最右侧的字符一样，便可继续遍历；如果不一样我们就进行填补。\n\n填补的方式有两种：\n1.在左侧填补一个最右侧的字符，左侧继续向前遍历。\n2.在右侧填补一个最左侧的字符，右侧继续向前遍历。\n\n对于这两种填补方式，它们的填补消耗都是 1 个字符，我们也无法确定哪一种是最优解。\n所以只有继续推导，直到最终遍历完成后便可得到全局最优解。\n\n\n基于上述思路，这里可以利用动态规划的方式来实现，或者说动态规划是对于这种思路方式的一种比较不错的实现。\n\n如上述思路中提到的内容，如果我们想知道区间 [left, right] 范围里的最优解，那么可能存在两种情况\n\n```html\ns[left] === s[right] (计数 +0)\n或者\ns[left] !== s[right] (计数 +1)\n```\n针对这两种情况，我们可以得到两种对应的结果\n```html\n+0 => [left + 1, right - 1] (加 0 的时候，说明相等，则指针向中间移动)\n+1 => min([left + 1, right], [left, right - 1]) (加 1 的时候，说明不相等，比较左移指针和右移指针哪个更优)\n```\n\n如果写成一个递推公式的话可以是\n```javascript\nf(left, right) = (s[left] === s[right]) \n  ? f(left + 1, right - 1)\n  : 1 + min(f(left + 1, right), f(left, right - 1))\n```\n对应的递归方法实现如下：\n```javascript\nconst minInsertions = str => {\n  const LEN = str.length\n  const f = (left = 0, right = LEN - 1) => { // abcdefg\n    if (left >= right) {\n      return 0\n    }\n    // console.log(left, right, str[left], str[right])\n    if (str[left] === str[right]) {\n      return f(left + 1, right - 1)\n    }\n    return 1 + Math.min(f(left + 1, right), f(left, right - 1))\n  }\n  return f()\n}\n```\n\n另一种实现方式是按照 ***动态规划（附录有简介）*** 方法。\n我们使用一个数组来记录递推的过程和中间值，具体流程如下：\n1）申明一个二维数组。\n2）初始化长度为 1 时候的每个字符串所需要的开销为 0，因为一个字符自身就是回文字符串。\n3）根据上面的递推公式，逐层的推出并保存每一层的值。\n4）最终取出 [0, s.length - 1] 对应的值就是我们的结果。\n```javascript\nconst minInsertions = str => { // abcdefg\n  const LEN = str.length // 7\n  const dp = [] // dp[i][j]的定义: 对字符串str[i..j]，最少需要进行dp[i][j]次插入才能变成回文串。\n  for (let i = 0; i < LEN; i++) {\n    dp[i] = new Array(LEN).fill(0) // dp[a] dp[b] ... dp[g]\n    dp[i][i + 1] = str[i] === str[i + 1] ? 0 : 1 // dp[ab] dp[bc] ... dp[fg]\n    // console.log(dp, str[i], str[i + 1])\n  }\n  // dp.length === 7; dp = [[0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0 , 0, 0, 0], ... , [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1]]\n  for (let i = 2; i < LEN; i++) {\n    for (j = 0; j < LEN - i; j++) { // LEN - i = 5,4,3,2,1;\n      // 状态转移方程（核心算法）\n      dp[j][j + i] = str[j] === str[j + i]\n        // 如果 str[j] === str[j + i]，则它的内层字符串的回文开销就是它的开销。\n        ? dp[j + 1][j + i - 1]\n        // 否则 取插入到右边的开销和插入到左边的开销的最小值 + 插入一次\n        // (j+i) - (j+1) = i-1，(j+i-1) - j = i-1；相差i-1个位置\n        // 如何保证此时的 dp[j + 1][j + i] 和 dp[j][j + i - 1] 在这之前已经被计算出来了？\n        // 当i=2的时候，(j+1 & j+i)/(j & j+i-1)均相临，所以一定是已知值的\n        // 当i>2的时候，(j+1 & j+i)/(j & j+i-1)间隔2，上一轮循环的时候一定依据计算得到了值，所以已知值\n        : 1 + Math.min(dp[j + 1][j + i], dp[j][j + i - 1]) \n    }\n  }\n  // console.log(dp)\n  return dp[0][LEN - 1] // dp[0][6] === 6\n}\n```\n上面的代码时间复杂度 O(n^2)，空间复杂度也是 O(n^2)。\n\n把空间复杂度压缩到 O(n)，不用二维数组，只用一维数组来记录递推的中间值。\n优化代码如下：\n```javascript\nconst minInsertions = str => { // abcdefg\n  let num = 0\n  const LEN = str.length\n  const dp = new Array(LEN).fill(0)\n  for (let i = LEN - 2; i >= 0; i--) { // i = 5,4,3,2,1,0\n    let prev = 0\n    for (let j = i + 1; j < LEN; j++) { // j = [6],[5,6],[4,5,6],[3,4,5,6],[2,3,4,5,6],[1,2,3,4,5,6]\n      // console.log(i, j, num++, JSON.stringify(dp))\n      const tmp = dp[j] // 0\n      if (str[i] === str[j]) { // 如果相等，则取上一个状态的值\n        dp[j] = prev\n      } else { // 不相等的时候，取 dp[j] 和 dp[j-1] 中的最小 + 1\n        dp[j] = 1 + Math.min(dp[j], dp[j - 1])\n      }\n      prev = tmp\n    }\n  }\n  return dp[LEN - 1]\n}\nminInsertions('abcdefg')\n```\n\n#### 问题3：找出让任意字符串成为回文串，所需要插入的最少数，并打印出最终的回文字符串\n问题1是计算出插入的最少字符数，并没有保存插入的字符和相应的插入位置\n所以，在原来的基础上需要打印出最终的回文字符串。\n分析：\n插入最少字符数只有一个最优解，打印出来的回文字符串可能有多个。\n所以需要把 dp[0][1]-- dp[i][j]最优的的所有字符串保存起来，得出结果之后再倒推回去\n\n```javascript\n/**\n * 补充最短回文字符串\n * 待补全，还没想到办法，留待日后解决。。。\n */ \nfunction getPlalindrome(str) { // abcdefg\n  // const LEN = str.length\n  // const dp = []\n  // for (let i = 0; i < LEN; i++) {\n  //   dp[i] = new Array(LEN).fill(0)\n  //   dp[i][i + 1] = str[i] === str[i + 1] ? 0 : 1\n  // }\n\n  // for (let i = 2; i < LEN; i++) {\n  //   for (j = 0; j < LEN - i; j++) {\n  //     if (str[j] === str[j + i]) {\n  //       dp[j][j + i] = dp[j + 1][j + i - 1]\n  //     } else {\n  //       if (dp[j + 1][j + i] > dp[j][j + i - 1]) {\n  //         dp[j][j + i] = 1 + dp[j][j + i - 1]\n  //       } else {\n  //         dp[j][j + i] = 1 + dp[j + 1][j + i]\n  //       }\n  //     }\n  //   }\n  // }\n  // return dp[0][LEN - 1]\n}\n\ngetPlalindrome('abcdefg')\n```\n### 传送门\n[知乎-让字符串成为回文串的最少插入次数](https://zhuanlan.zhihu.com/p/300617309)\n\n","source":"_posts/palindrome.md","raw":"\n---\ntitle: 回文字符串\ndate: 2021/01/25\ntag: [回文,算法]\ncategory: 笔记\n---\n\n#### 什么是回文字符串\n回文字符串就是一个字符串，从头读到尾和从尾读到头，字符出现的顺序是一样的。\n如：\n```html\na\naba\nabba\nabcba\n...\nabcdefgfedcba\n```\n\n#### 问题1：如何判断一个字符串是否回文字符串\n```javascript\n/**\n * 判断是否回文字符串\n */ \nfunction isPlalindrome(str) {\n  const len = str.length\n  let i = 0\n  while(i < len / 2) {\n    if (str[i] !== str[len - i - 1]) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n```\n\n#### 问题2：让任意字符串成为回文串的需要插入的最小字符数\n如：\n```html\n插入0次\na => a\n```\n```html\n插入1次\nab => aba || bab\n```\n```html\n插入2次\nabc => abcba || cbabc\n```\n\n#### 分析\n如果它最后要变成一个回文字符串，那么它最终的最左侧和最右侧的字符一定要是相同的。\n如果当前最左侧和最右侧的字符一样，便可继续遍历；如果不一样我们就进行填补。\n\n填补的方式有两种：\n1.在左侧填补一个最右侧的字符，左侧继续向前遍历。\n2.在右侧填补一个最左侧的字符，右侧继续向前遍历。\n\n对于这两种填补方式，它们的填补消耗都是 1 个字符，我们也无法确定哪一种是最优解。\n所以只有继续推导，直到最终遍历完成后便可得到全局最优解。\n\n\n基于上述思路，这里可以利用动态规划的方式来实现，或者说动态规划是对于这种思路方式的一种比较不错的实现。\n\n如上述思路中提到的内容，如果我们想知道区间 [left, right] 范围里的最优解，那么可能存在两种情况\n\n```html\ns[left] === s[right] (计数 +0)\n或者\ns[left] !== s[right] (计数 +1)\n```\n针对这两种情况，我们可以得到两种对应的结果\n```html\n+0 => [left + 1, right - 1] (加 0 的时候，说明相等，则指针向中间移动)\n+1 => min([left + 1, right], [left, right - 1]) (加 1 的时候，说明不相等，比较左移指针和右移指针哪个更优)\n```\n\n如果写成一个递推公式的话可以是\n```javascript\nf(left, right) = (s[left] === s[right]) \n  ? f(left + 1, right - 1)\n  : 1 + min(f(left + 1, right), f(left, right - 1))\n```\n对应的递归方法实现如下：\n```javascript\nconst minInsertions = str => {\n  const LEN = str.length\n  const f = (left = 0, right = LEN - 1) => { // abcdefg\n    if (left >= right) {\n      return 0\n    }\n    // console.log(left, right, str[left], str[right])\n    if (str[left] === str[right]) {\n      return f(left + 1, right - 1)\n    }\n    return 1 + Math.min(f(left + 1, right), f(left, right - 1))\n  }\n  return f()\n}\n```\n\n另一种实现方式是按照 ***动态规划（附录有简介）*** 方法。\n我们使用一个数组来记录递推的过程和中间值，具体流程如下：\n1）申明一个二维数组。\n2）初始化长度为 1 时候的每个字符串所需要的开销为 0，因为一个字符自身就是回文字符串。\n3）根据上面的递推公式，逐层的推出并保存每一层的值。\n4）最终取出 [0, s.length - 1] 对应的值就是我们的结果。\n```javascript\nconst minInsertions = str => { // abcdefg\n  const LEN = str.length // 7\n  const dp = [] // dp[i][j]的定义: 对字符串str[i..j]，最少需要进行dp[i][j]次插入才能变成回文串。\n  for (let i = 0; i < LEN; i++) {\n    dp[i] = new Array(LEN).fill(0) // dp[a] dp[b] ... dp[g]\n    dp[i][i + 1] = str[i] === str[i + 1] ? 0 : 1 // dp[ab] dp[bc] ... dp[fg]\n    // console.log(dp, str[i], str[i + 1])\n  }\n  // dp.length === 7; dp = [[0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0 , 0, 0, 0], ... , [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1]]\n  for (let i = 2; i < LEN; i++) {\n    for (j = 0; j < LEN - i; j++) { // LEN - i = 5,4,3,2,1;\n      // 状态转移方程（核心算法）\n      dp[j][j + i] = str[j] === str[j + i]\n        // 如果 str[j] === str[j + i]，则它的内层字符串的回文开销就是它的开销。\n        ? dp[j + 1][j + i - 1]\n        // 否则 取插入到右边的开销和插入到左边的开销的最小值 + 插入一次\n        // (j+i) - (j+1) = i-1，(j+i-1) - j = i-1；相差i-1个位置\n        // 如何保证此时的 dp[j + 1][j + i] 和 dp[j][j + i - 1] 在这之前已经被计算出来了？\n        // 当i=2的时候，(j+1 & j+i)/(j & j+i-1)均相临，所以一定是已知值的\n        // 当i>2的时候，(j+1 & j+i)/(j & j+i-1)间隔2，上一轮循环的时候一定依据计算得到了值，所以已知值\n        : 1 + Math.min(dp[j + 1][j + i], dp[j][j + i - 1]) \n    }\n  }\n  // console.log(dp)\n  return dp[0][LEN - 1] // dp[0][6] === 6\n}\n```\n上面的代码时间复杂度 O(n^2)，空间复杂度也是 O(n^2)。\n\n把空间复杂度压缩到 O(n)，不用二维数组，只用一维数组来记录递推的中间值。\n优化代码如下：\n```javascript\nconst minInsertions = str => { // abcdefg\n  let num = 0\n  const LEN = str.length\n  const dp = new Array(LEN).fill(0)\n  for (let i = LEN - 2; i >= 0; i--) { // i = 5,4,3,2,1,0\n    let prev = 0\n    for (let j = i + 1; j < LEN; j++) { // j = [6],[5,6],[4,5,6],[3,4,5,6],[2,3,4,5,6],[1,2,3,4,5,6]\n      // console.log(i, j, num++, JSON.stringify(dp))\n      const tmp = dp[j] // 0\n      if (str[i] === str[j]) { // 如果相等，则取上一个状态的值\n        dp[j] = prev\n      } else { // 不相等的时候，取 dp[j] 和 dp[j-1] 中的最小 + 1\n        dp[j] = 1 + Math.min(dp[j], dp[j - 1])\n      }\n      prev = tmp\n    }\n  }\n  return dp[LEN - 1]\n}\nminInsertions('abcdefg')\n```\n\n#### 问题3：找出让任意字符串成为回文串，所需要插入的最少数，并打印出最终的回文字符串\n问题1是计算出插入的最少字符数，并没有保存插入的字符和相应的插入位置\n所以，在原来的基础上需要打印出最终的回文字符串。\n分析：\n插入最少字符数只有一个最优解，打印出来的回文字符串可能有多个。\n所以需要把 dp[0][1]-- dp[i][j]最优的的所有字符串保存起来，得出结果之后再倒推回去\n\n```javascript\n/**\n * 补充最短回文字符串\n * 待补全，还没想到办法，留待日后解决。。。\n */ \nfunction getPlalindrome(str) { // abcdefg\n  // const LEN = str.length\n  // const dp = []\n  // for (let i = 0; i < LEN; i++) {\n  //   dp[i] = new Array(LEN).fill(0)\n  //   dp[i][i + 1] = str[i] === str[i + 1] ? 0 : 1\n  // }\n\n  // for (let i = 2; i < LEN; i++) {\n  //   for (j = 0; j < LEN - i; j++) {\n  //     if (str[j] === str[j + i]) {\n  //       dp[j][j + i] = dp[j + 1][j + i - 1]\n  //     } else {\n  //       if (dp[j + 1][j + i] > dp[j][j + i - 1]) {\n  //         dp[j][j + i] = 1 + dp[j][j + i - 1]\n  //       } else {\n  //         dp[j][j + i] = 1 + dp[j + 1][j + i]\n  //       }\n  //     }\n  //   }\n  // }\n  // return dp[0][LEN - 1]\n}\n\ngetPlalindrome('abcdefg')\n```\n### 传送门\n[知乎-让字符串成为回文串的最少插入次数](https://zhuanlan.zhihu.com/p/300617309)\n\n","slug":"palindrome","published":1,"updated":"2021-03-30T01:32:00.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug00019a0vz10wvd7hd","content":"<h4 id=\"什么是回文字符串\"><a href=\"#什么是回文字符串\" class=\"headerlink\" title=\"什么是回文字符串\"></a>什么是回文字符串</h4><p>回文字符串就是一个字符串，从头读到尾和从尾读到头，字符出现的顺序是一样的。<br>如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">aba</span><br><span class=\"line\">abba</span><br><span class=\"line\">abcba</span><br><span class=\"line\">...</span><br><span class=\"line\">abcdefgfedcba</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"问题1：如何判断一个字符串是否回文字符串\"><a href=\"#问题1：如何判断一个字符串是否回文字符串\" class=\"headerlink\" title=\"问题1：如何判断一个字符串是否回文字符串\"></a>问题1：如何判断一个字符串是否回文字符串</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 判断是否回文字符串</span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isPlalindrome</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = str.length</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">while</span>(<span class=\"params\">i &lt; len / <span class=\"number\">2</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str[i] !== str[len - i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"问题2：让任意字符串成为回文串的需要插入的最小字符数\"><a href=\"#问题2：让任意字符串成为回文串的需要插入的最小字符数\" class=\"headerlink\" title=\"问题2：让任意字符串成为回文串的需要插入的最小字符数\"></a>问题2：让任意字符串成为回文串的需要插入的最小字符数</h4><p>如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">插入0次</span><br><span class=\"line\">a =&gt; a</span><br></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">插入1次</span><br><span class=\"line\">ab =&gt; aba || bab</span><br></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">插入2次</span><br><span class=\"line\">abc =&gt; abcba || cbabc</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>如果它最后要变成一个回文字符串，那么它最终的最左侧和最右侧的字符一定要是相同的。<br>如果当前最左侧和最右侧的字符一样，便可继续遍历；如果不一样我们就进行填补。</p>\n<p>填补的方式有两种：<br>1.在左侧填补一个最右侧的字符，左侧继续向前遍历。<br>2.在右侧填补一个最左侧的字符，右侧继续向前遍历。</p>\n<p>对于这两种填补方式，它们的填补消耗都是 1 个字符，我们也无法确定哪一种是最优解。<br>所以只有继续推导，直到最终遍历完成后便可得到全局最优解。</p>\n<p>基于上述思路，这里可以利用动态规划的方式来实现，或者说动态规划是对于这种思路方式的一种比较不错的实现。</p>\n<p>如上述思路中提到的内容，如果我们想知道区间 [left, right] 范围里的最优解，那么可能存在两种情况</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s[left] === s[right] (计数 +0)</span><br><span class=\"line\">或者</span><br><span class=\"line\">s[left] !== s[right] (计数 +1)</span><br></pre></td></tr></table></figure>\n<p>针对这两种情况，我们可以得到两种对应的结果<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+0 =&gt; [left + 1, right - 1] (加 0 的时候，说明相等，则指针向中间移动)</span><br><span class=\"line\">+1 =&gt; min([left + 1, right], [left, right - 1]) (加 1 的时候，说明不相等，比较左移指针和右移指针哪个更优)</span><br></pre></td></tr></table></figure></p>\n<p>如果写成一个递推公式的话可以是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(left, right) = (s[left] === s[right]) </span><br><span class=\"line\">  ? f(left + <span class=\"number\">1</span>, right - <span class=\"number\">1</span>)</span><br><span class=\"line\">  : <span class=\"number\">1</span> + min(f(left + <span class=\"number\">1</span>, right), f(left, right - <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure><br>对应的递归方法实现如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> minInsertions = <span class=\"function\"><span class=\"params\">str</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> LEN = str.length</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = <span class=\"function\">(<span class=\"params\">left = <span class=\"number\">0</span>, right = LEN - <span class=\"number\">1</span></span>) =&gt;</span> &#123; <span class=\"comment\">// abcdefg</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &gt;= right) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// console.log(left, right, str[left], str[right])</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str[left] === str[right]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> f(left + <span class=\"number\">1</span>, right - <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> + <span class=\"built_in\">Math</span>.min(f(left + <span class=\"number\">1</span>, right), f(left, right - <span class=\"number\">1</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另一种实现方式是按照 <strong><em>动态规划（附录有简介）</em></strong> 方法。<br>我们使用一个数组来记录递推的过程和中间值，具体流程如下：<br>1）申明一个二维数组。<br>2）初始化长度为 1 时候的每个字符串所需要的开销为 0，因为一个字符自身就是回文字符串。<br>3）根据上面的递推公式，逐层的推出并保存每一层的值。<br>4）最终取出 [0, s.length - 1] 对应的值就是我们的结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> minInsertions = <span class=\"function\"><span class=\"params\">str</span> =&gt;</span> &#123; <span class=\"comment\">// abcdefg</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> LEN = str.length <span class=\"comment\">// 7</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> dp = [] <span class=\"comment\">// dp[i][j]的定义: 对字符串str[i..j]，最少需要进行dp[i][j]次插入才能变成回文串。</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; LEN; i++) &#123;</span><br><span class=\"line\">    dp[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(LEN).fill(<span class=\"number\">0</span>) <span class=\"comment\">// dp[a] dp[b] ... dp[g]</span></span><br><span class=\"line\">    dp[i][i + <span class=\"number\">1</span>] = str[i] === str[i + <span class=\"number\">1</span>] ? <span class=\"number\">0</span> : <span class=\"number\">1</span> <span class=\"comment\">// dp[ab] dp[bc] ... dp[fg]</span></span><br><span class=\"line\">    <span class=\"comment\">// console.log(dp, str[i], str[i + 1])</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// dp.length === 7; dp = [[0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0 , 0, 0, 0], ... , [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1]]</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt; LEN; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; LEN - i; j++) &#123; <span class=\"comment\">// LEN - i = 5,4,3,2,1;</span></span><br><span class=\"line\">      <span class=\"comment\">// 状态转移方程（核心算法）</span></span><br><span class=\"line\">      dp[j][j + i] = str[j] === str[j + i]</span><br><span class=\"line\">        <span class=\"comment\">// 如果 str[j] === str[j + i]，则它的内层字符串的回文开销就是它的开销。</span></span><br><span class=\"line\">        ? dp[j + <span class=\"number\">1</span>][j + i - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"comment\">// 否则 取插入到右边的开销和插入到左边的开销的最小值 + 插入一次</span></span><br><span class=\"line\">        <span class=\"comment\">// (j+i) - (j+1) = i-1，(j+i-1) - j = i-1；相差i-1个位置</span></span><br><span class=\"line\">        <span class=\"comment\">// 如何保证此时的 dp[j + 1][j + i] 和 dp[j][j + i - 1] 在这之前已经被计算出来了？</span></span><br><span class=\"line\">        <span class=\"comment\">// 当i=2的时候，(j+1 &amp; j+i)/(j &amp; j+i-1)均相临，所以一定是已知值的</span></span><br><span class=\"line\">        <span class=\"comment\">// 当i&gt;2的时候，(j+1 &amp; j+i)/(j &amp; j+i-1)间隔2，上一轮循环的时候一定依据计算得到了值，所以已知值</span></span><br><span class=\"line\">        : <span class=\"number\">1</span> + <span class=\"built_in\">Math</span>.min(dp[j + <span class=\"number\">1</span>][j + i], dp[j][j + i - <span class=\"number\">1</span>]) </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(dp)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][LEN - <span class=\"number\">1</span>] <span class=\"comment\">// dp[0][6] === 6</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码时间复杂度 O(n^2)，空间复杂度也是 O(n^2)。</p>\n<p>把空间复杂度压缩到 O(n)，不用二维数组，只用一维数组来记录递推的中间值。<br>优化代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> minInsertions = <span class=\"function\"><span class=\"params\">str</span> =&gt;</span> &#123; <span class=\"comment\">// abcdefg</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> num = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> LEN = str.length</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(LEN).fill(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = LEN - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123; <span class=\"comment\">// i = 5,4,3,2,1,0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> prev = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; LEN; j++) &#123; <span class=\"comment\">// j = [6],[5,6],[4,5,6],[3,4,5,6],[2,3,4,5,6],[1,2,3,4,5,6]</span></span><br><span class=\"line\">      <span class=\"comment\">// console.log(i, j, num++, JSON.stringify(dp))</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> tmp = dp[j] <span class=\"comment\">// 0</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (str[i] === str[j]) &#123; <span class=\"comment\">// 如果相等，则取上一个状态的值</span></span><br><span class=\"line\">        dp[j] = prev</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 不相等的时候，取 dp[j] 和 dp[j-1] 中的最小 + 1</span></span><br><span class=\"line\">        dp[j] = <span class=\"number\">1</span> + <span class=\"built_in\">Math</span>.min(dp[j], dp[j - <span class=\"number\">1</span>])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      prev = tmp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[LEN - <span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">minInsertions(<span class=\"string\">&#x27;abcdefg&#x27;</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"问题3：找出让任意字符串成为回文串，所需要插入的最少数，并打印出最终的回文字符串\"><a href=\"#问题3：找出让任意字符串成为回文串，所需要插入的最少数，并打印出最终的回文字符串\" class=\"headerlink\" title=\"问题3：找出让任意字符串成为回文串，所需要插入的最少数，并打印出最终的回文字符串\"></a>问题3：找出让任意字符串成为回文串，所需要插入的最少数，并打印出最终的回文字符串</h4><p>问题1是计算出插入的最少字符数，并没有保存插入的字符和相应的插入位置<br>所以，在原来的基础上需要打印出最终的回文字符串。<br>分析：<br>插入最少字符数只有一个最优解，打印出来的回文字符串可能有多个。<br>所以需要把 dp[0][1]– dp[i][j]最优的的所有字符串保存起来，得出结果之后再倒推回去</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 补充最短回文字符串</span></span><br><span class=\"line\"><span class=\"comment\"> * 待补全，还没想到办法，留待日后解决。。。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPlalindrome</span>(<span class=\"params\">str</span>) </span>&#123; <span class=\"comment\">// abcdefg</span></span><br><span class=\"line\">  <span class=\"comment\">// const LEN = str.length</span></span><br><span class=\"line\">  <span class=\"comment\">// const dp = []</span></span><br><span class=\"line\">  <span class=\"comment\">// for (let i = 0; i &lt; LEN; i++) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   dp[i] = new Array(LEN).fill(0)</span></span><br><span class=\"line\">  <span class=\"comment\">//   dp[i][i + 1] = str[i] === str[i + 1] ? 0 : 1</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// for (let i = 2; i &lt; LEN; i++) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   for (j = 0; j &lt; LEN - i; j++) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//     if (str[j] === str[j + i]) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//       dp[j][j + i] = dp[j + 1][j + i - 1]</span></span><br><span class=\"line\">  <span class=\"comment\">//     &#125; else &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//       if (dp[j + 1][j + i] &gt; dp[j][j + i - 1]) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//         dp[j][j + i] = 1 + dp[j][j + i - 1]</span></span><br><span class=\"line\">  <span class=\"comment\">//       &#125; else &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//         dp[j][j + i] = 1 + dp[j + 1][j + i]</span></span><br><span class=\"line\">  <span class=\"comment\">//       &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//   &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// return dp[0][LEN - 1]</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getPlalindrome(<span class=\"string\">&#x27;abcdefg&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://zhuanlan.zhihu.com/p/300617309\">知乎-让字符串成为回文串的最少插入次数</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是回文字符串\"><a href=\"#什么是回文字符串\" class=\"headerlink\" title=\"什么是回文字符串\"></a>什么是回文字符串</h4><p>回文字符串就是一个字符串，从头读到尾和从尾读到头，字符出现的顺序是一样的。<br>如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">aba</span><br><span class=\"line\">abba</span><br><span class=\"line\">abcba</span><br><span class=\"line\">...</span><br><span class=\"line\">abcdefgfedcba</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"问题1：如何判断一个字符串是否回文字符串\"><a href=\"#问题1：如何判断一个字符串是否回文字符串\" class=\"headerlink\" title=\"问题1：如何判断一个字符串是否回文字符串\"></a>问题1：如何判断一个字符串是否回文字符串</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 判断是否回文字符串</span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isPlalindrome</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = str.length</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">while</span>(<span class=\"params\">i &lt; len / <span class=\"number\">2</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str[i] !== str[len - i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"问题2：让任意字符串成为回文串的需要插入的最小字符数\"><a href=\"#问题2：让任意字符串成为回文串的需要插入的最小字符数\" class=\"headerlink\" title=\"问题2：让任意字符串成为回文串的需要插入的最小字符数\"></a>问题2：让任意字符串成为回文串的需要插入的最小字符数</h4><p>如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">插入0次</span><br><span class=\"line\">a =&gt; a</span><br></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">插入1次</span><br><span class=\"line\">ab =&gt; aba || bab</span><br></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">插入2次</span><br><span class=\"line\">abc =&gt; abcba || cbabc</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>如果它最后要变成一个回文字符串，那么它最终的最左侧和最右侧的字符一定要是相同的。<br>如果当前最左侧和最右侧的字符一样，便可继续遍历；如果不一样我们就进行填补。</p>\n<p>填补的方式有两种：<br>1.在左侧填补一个最右侧的字符，左侧继续向前遍历。<br>2.在右侧填补一个最左侧的字符，右侧继续向前遍历。</p>\n<p>对于这两种填补方式，它们的填补消耗都是 1 个字符，我们也无法确定哪一种是最优解。<br>所以只有继续推导，直到最终遍历完成后便可得到全局最优解。</p>\n<p>基于上述思路，这里可以利用动态规划的方式来实现，或者说动态规划是对于这种思路方式的一种比较不错的实现。</p>\n<p>如上述思路中提到的内容，如果我们想知道区间 [left, right] 范围里的最优解，那么可能存在两种情况</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s[left] === s[right] (计数 +0)</span><br><span class=\"line\">或者</span><br><span class=\"line\">s[left] !== s[right] (计数 +1)</span><br></pre></td></tr></table></figure>\n<p>针对这两种情况，我们可以得到两种对应的结果<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+0 =&gt; [left + 1, right - 1] (加 0 的时候，说明相等，则指针向中间移动)</span><br><span class=\"line\">+1 =&gt; min([left + 1, right], [left, right - 1]) (加 1 的时候，说明不相等，比较左移指针和右移指针哪个更优)</span><br></pre></td></tr></table></figure></p>\n<p>如果写成一个递推公式的话可以是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(left, right) = (s[left] === s[right]) </span><br><span class=\"line\">  ? f(left + <span class=\"number\">1</span>, right - <span class=\"number\">1</span>)</span><br><span class=\"line\">  : <span class=\"number\">1</span> + min(f(left + <span class=\"number\">1</span>, right), f(left, right - <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure><br>对应的递归方法实现如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> minInsertions = <span class=\"function\"><span class=\"params\">str</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> LEN = str.length</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = <span class=\"function\">(<span class=\"params\">left = <span class=\"number\">0</span>, right = LEN - <span class=\"number\">1</span></span>) =&gt;</span> &#123; <span class=\"comment\">// abcdefg</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &gt;= right) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// console.log(left, right, str[left], str[right])</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str[left] === str[right]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> f(left + <span class=\"number\">1</span>, right - <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> + <span class=\"built_in\">Math</span>.min(f(left + <span class=\"number\">1</span>, right), f(left, right - <span class=\"number\">1</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另一种实现方式是按照 <strong><em>动态规划（附录有简介）</em></strong> 方法。<br>我们使用一个数组来记录递推的过程和中间值，具体流程如下：<br>1）申明一个二维数组。<br>2）初始化长度为 1 时候的每个字符串所需要的开销为 0，因为一个字符自身就是回文字符串。<br>3）根据上面的递推公式，逐层的推出并保存每一层的值。<br>4）最终取出 [0, s.length - 1] 对应的值就是我们的结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> minInsertions = <span class=\"function\"><span class=\"params\">str</span> =&gt;</span> &#123; <span class=\"comment\">// abcdefg</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> LEN = str.length <span class=\"comment\">// 7</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> dp = [] <span class=\"comment\">// dp[i][j]的定义: 对字符串str[i..j]，最少需要进行dp[i][j]次插入才能变成回文串。</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; LEN; i++) &#123;</span><br><span class=\"line\">    dp[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(LEN).fill(<span class=\"number\">0</span>) <span class=\"comment\">// dp[a] dp[b] ... dp[g]</span></span><br><span class=\"line\">    dp[i][i + <span class=\"number\">1</span>] = str[i] === str[i + <span class=\"number\">1</span>] ? <span class=\"number\">0</span> : <span class=\"number\">1</span> <span class=\"comment\">// dp[ab] dp[bc] ... dp[fg]</span></span><br><span class=\"line\">    <span class=\"comment\">// console.log(dp, str[i], str[i + 1])</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// dp.length === 7; dp = [[0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0 , 0, 0, 0], ... , [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1]]</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt; LEN; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; LEN - i; j++) &#123; <span class=\"comment\">// LEN - i = 5,4,3,2,1;</span></span><br><span class=\"line\">      <span class=\"comment\">// 状态转移方程（核心算法）</span></span><br><span class=\"line\">      dp[j][j + i] = str[j] === str[j + i]</span><br><span class=\"line\">        <span class=\"comment\">// 如果 str[j] === str[j + i]，则它的内层字符串的回文开销就是它的开销。</span></span><br><span class=\"line\">        ? dp[j + <span class=\"number\">1</span>][j + i - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"comment\">// 否则 取插入到右边的开销和插入到左边的开销的最小值 + 插入一次</span></span><br><span class=\"line\">        <span class=\"comment\">// (j+i) - (j+1) = i-1，(j+i-1) - j = i-1；相差i-1个位置</span></span><br><span class=\"line\">        <span class=\"comment\">// 如何保证此时的 dp[j + 1][j + i] 和 dp[j][j + i - 1] 在这之前已经被计算出来了？</span></span><br><span class=\"line\">        <span class=\"comment\">// 当i=2的时候，(j+1 &amp; j+i)/(j &amp; j+i-1)均相临，所以一定是已知值的</span></span><br><span class=\"line\">        <span class=\"comment\">// 当i&gt;2的时候，(j+1 &amp; j+i)/(j &amp; j+i-1)间隔2，上一轮循环的时候一定依据计算得到了值，所以已知值</span></span><br><span class=\"line\">        : <span class=\"number\">1</span> + <span class=\"built_in\">Math</span>.min(dp[j + <span class=\"number\">1</span>][j + i], dp[j][j + i - <span class=\"number\">1</span>]) </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(dp)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][LEN - <span class=\"number\">1</span>] <span class=\"comment\">// dp[0][6] === 6</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码时间复杂度 O(n^2)，空间复杂度也是 O(n^2)。</p>\n<p>把空间复杂度压缩到 O(n)，不用二维数组，只用一维数组来记录递推的中间值。<br>优化代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> minInsertions = <span class=\"function\"><span class=\"params\">str</span> =&gt;</span> &#123; <span class=\"comment\">// abcdefg</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> num = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> LEN = str.length</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dp = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(LEN).fill(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = LEN - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123; <span class=\"comment\">// i = 5,4,3,2,1,0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> prev = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; LEN; j++) &#123; <span class=\"comment\">// j = [6],[5,6],[4,5,6],[3,4,5,6],[2,3,4,5,6],[1,2,3,4,5,6]</span></span><br><span class=\"line\">      <span class=\"comment\">// console.log(i, j, num++, JSON.stringify(dp))</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> tmp = dp[j] <span class=\"comment\">// 0</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (str[i] === str[j]) &#123; <span class=\"comment\">// 如果相等，则取上一个状态的值</span></span><br><span class=\"line\">        dp[j] = prev</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 不相等的时候，取 dp[j] 和 dp[j-1] 中的最小 + 1</span></span><br><span class=\"line\">        dp[j] = <span class=\"number\">1</span> + <span class=\"built_in\">Math</span>.min(dp[j], dp[j - <span class=\"number\">1</span>])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      prev = tmp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dp[LEN - <span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">minInsertions(<span class=\"string\">&#x27;abcdefg&#x27;</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"问题3：找出让任意字符串成为回文串，所需要插入的最少数，并打印出最终的回文字符串\"><a href=\"#问题3：找出让任意字符串成为回文串，所需要插入的最少数，并打印出最终的回文字符串\" class=\"headerlink\" title=\"问题3：找出让任意字符串成为回文串，所需要插入的最少数，并打印出最终的回文字符串\"></a>问题3：找出让任意字符串成为回文串，所需要插入的最少数，并打印出最终的回文字符串</h4><p>问题1是计算出插入的最少字符数，并没有保存插入的字符和相应的插入位置<br>所以，在原来的基础上需要打印出最终的回文字符串。<br>分析：<br>插入最少字符数只有一个最优解，打印出来的回文字符串可能有多个。<br>所以需要把 dp[0][1]– dp[i][j]最优的的所有字符串保存起来，得出结果之后再倒推回去</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 补充最短回文字符串</span></span><br><span class=\"line\"><span class=\"comment\"> * 待补全，还没想到办法，留待日后解决。。。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPlalindrome</span>(<span class=\"params\">str</span>) </span>&#123; <span class=\"comment\">// abcdefg</span></span><br><span class=\"line\">  <span class=\"comment\">// const LEN = str.length</span></span><br><span class=\"line\">  <span class=\"comment\">// const dp = []</span></span><br><span class=\"line\">  <span class=\"comment\">// for (let i = 0; i &lt; LEN; i++) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   dp[i] = new Array(LEN).fill(0)</span></span><br><span class=\"line\">  <span class=\"comment\">//   dp[i][i + 1] = str[i] === str[i + 1] ? 0 : 1</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// for (let i = 2; i &lt; LEN; i++) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   for (j = 0; j &lt; LEN - i; j++) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//     if (str[j] === str[j + i]) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//       dp[j][j + i] = dp[j + 1][j + i - 1]</span></span><br><span class=\"line\">  <span class=\"comment\">//     &#125; else &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//       if (dp[j + 1][j + i] &gt; dp[j][j + i - 1]) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//         dp[j][j + i] = 1 + dp[j][j + i - 1]</span></span><br><span class=\"line\">  <span class=\"comment\">//       &#125; else &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//         dp[j][j + i] = 1 + dp[j + 1][j + i]</span></span><br><span class=\"line\">  <span class=\"comment\">//       &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//   &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// return dp[0][LEN - 1]</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getPlalindrome(<span class=\"string\">&#x27;abcdefg&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://zhuanlan.zhihu.com/p/300617309\">知乎-让字符串成为回文串的最少插入次数</a></p>\n"},{"title":"用Nodejs连接Oracle数据库","date":"2019-03-24T16:00:00.000Z","_content":"\n用 nodejs 连接 oracle 目前最方便的方式是使用 oracledb 这个库。\n使用方法如下：\n```javascript\nconst oracledb = require('oracledb')\n\nconst createConnection = function(data_source) {\n  const { host_addr, host_port, db_name, username, pwd } = data_source\n  return new Promise((resolve, reject) => {\n    oracledb.getConnection({\n      user: username,\n      password: pwd,\n      connectString: `(DESCRIPTION =\n        (ADDRESS = \n          (PROTOCOL = TCP)\n          (HOST = ${host_addr})\n          (PORT = ${host_port})\n        )\n        (CONNECT_DATA =\n          (SERVICE_NAME= ${db_name})\n        )\n      )`\n    }, (err, connection) => {\n      if (err) {\n        console.error('connect oracle data source failed:', + err)\n        return\n      }\n      resolve(connection)\n    })\n  })\n}\n\ncreateConnection(params).then((connection) => {\n  connection.execute(sql, (err, result) => {\n    connection.close((err) => {\n      if (err) {\n        console.error(err) // TODO\n      }\n    })\n    console.log(result)\n  })\n})\n```\n\n*有一点需要特别注意: nodejs 连接 oracle 数据库可能不能直接进行连接，需要在 nodejs 应用所在的机器（服务器）上安装一个 oracle 即时客户端。*\n\n##### 安装详细教程见：\nhttps://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html\n\n##### 安装步骤简化版本如下：\n1.下载 oracle 即时客户端\n*Mac osx 系统*直接下载osx版本，直接解压后放置在当前用户下的 lib 目录下即可。\n```html\n~/lib/instantclient_18_1\n```\n\n除了Mac系统，对于 Linux 系统，根据不同的系统，去如下连接找到对应系统版本，将其上传到服务器上\nhttps://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html\n\n2-1.对于服务器安装，解压 oracle 即时客户端到对应目录下，如: ~/instantclient_18_3\n配置环境变量 LD_LIBRARY_PATH\n如: LD_LIBRARY_PATH=\"$HOME/xxxx/instantclient_18_3\"\n注意：*亲测：将此配置直接写在 profile 文件里面不生效；但是，在外面用 export LD_LIBRARY_PATH =\"$HOME/xxxx/instantclient_18_3” 手动设置就会生效*\n所以，不推荐使用此方式，而是用下面的这种 2-2 步骤\n\n\n2-2(推荐)，如果 2-1 未能生效，则选用下面的方式，创建 config 文件\n```shell\n# 这个命令的意思是将 instantclient 解压目录写入到动态配置软件库里面，也可以手动创建文件，文件内容就是instantclient的绝对路径\nsudo sh -c \"echo /xxx/instantclient_18_3 > \\ /etc/ld.so.conf.d/oracle-instantclient.conf\" \nsudo ldconfig # 重启服务\n```\n一般系统配置 config 文件之后就能正常使用了，但是有的系统还是会报错，有可能是缺少 libaio1 这个库。\n如果发现缺少这个库，则进行下面的第三步进行安装。\n\n3.安装 libaio1 库\n```shell\n# 有的是需要安装 libaio1, 有的是 libaio，具体根据系统决定。\n# 安装方式也不一定是apt-get，可能是rpm yum等。\napt-get install libaio1\n```\n\n装完上面的基本上就ok了，如果还是不行，那么...自己再想办法吧。\n\n-- end --\n","source":"_posts/oracle.md","raw":"---\ntitle: 用Nodejs连接Oracle数据库\ntag: [oracle, nodejs, 数据库]\ndate: 2019/03/25\ncategory: 技术\n---\n\n用 nodejs 连接 oracle 目前最方便的方式是使用 oracledb 这个库。\n使用方法如下：\n```javascript\nconst oracledb = require('oracledb')\n\nconst createConnection = function(data_source) {\n  const { host_addr, host_port, db_name, username, pwd } = data_source\n  return new Promise((resolve, reject) => {\n    oracledb.getConnection({\n      user: username,\n      password: pwd,\n      connectString: `(DESCRIPTION =\n        (ADDRESS = \n          (PROTOCOL = TCP)\n          (HOST = ${host_addr})\n          (PORT = ${host_port})\n        )\n        (CONNECT_DATA =\n          (SERVICE_NAME= ${db_name})\n        )\n      )`\n    }, (err, connection) => {\n      if (err) {\n        console.error('connect oracle data source failed:', + err)\n        return\n      }\n      resolve(connection)\n    })\n  })\n}\n\ncreateConnection(params).then((connection) => {\n  connection.execute(sql, (err, result) => {\n    connection.close((err) => {\n      if (err) {\n        console.error(err) // TODO\n      }\n    })\n    console.log(result)\n  })\n})\n```\n\n*有一点需要特别注意: nodejs 连接 oracle 数据库可能不能直接进行连接，需要在 nodejs 应用所在的机器（服务器）上安装一个 oracle 即时客户端。*\n\n##### 安装详细教程见：\nhttps://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html\n\n##### 安装步骤简化版本如下：\n1.下载 oracle 即时客户端\n*Mac osx 系统*直接下载osx版本，直接解压后放置在当前用户下的 lib 目录下即可。\n```html\n~/lib/instantclient_18_1\n```\n\n除了Mac系统，对于 Linux 系统，根据不同的系统，去如下连接找到对应系统版本，将其上传到服务器上\nhttps://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html\n\n2-1.对于服务器安装，解压 oracle 即时客户端到对应目录下，如: ~/instantclient_18_3\n配置环境变量 LD_LIBRARY_PATH\n如: LD_LIBRARY_PATH=\"$HOME/xxxx/instantclient_18_3\"\n注意：*亲测：将此配置直接写在 profile 文件里面不生效；但是，在外面用 export LD_LIBRARY_PATH =\"$HOME/xxxx/instantclient_18_3” 手动设置就会生效*\n所以，不推荐使用此方式，而是用下面的这种 2-2 步骤\n\n\n2-2(推荐)，如果 2-1 未能生效，则选用下面的方式，创建 config 文件\n```shell\n# 这个命令的意思是将 instantclient 解压目录写入到动态配置软件库里面，也可以手动创建文件，文件内容就是instantclient的绝对路径\nsudo sh -c \"echo /xxx/instantclient_18_3 > \\ /etc/ld.so.conf.d/oracle-instantclient.conf\" \nsudo ldconfig # 重启服务\n```\n一般系统配置 config 文件之后就能正常使用了，但是有的系统还是会报错，有可能是缺少 libaio1 这个库。\n如果发现缺少这个库，则进行下面的第三步进行安装。\n\n3.安装 libaio1 库\n```shell\n# 有的是需要安装 libaio1, 有的是 libaio，具体根据系统决定。\n# 安装方式也不一定是apt-get，可能是rpm yum等。\napt-get install libaio1\n```\n\n装完上面的基本上就ok了，如果还是不行，那么...自己再想办法吧。\n\n-- end --\n","slug":"oracle","published":1,"updated":"2021-03-30T01:32:00.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug1001aa0vzgj1y6k2e","content":"<p>用 nodejs 连接 oracle 目前最方便的方式是使用 oracledb 这个库。<br>使用方法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> oracledb = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;oracledb&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createConnection = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data_source</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; host_addr, host_port, db_name, username, pwd &#125; = data_source</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    oracledb.getConnection(&#123;</span><br><span class=\"line\">      user: username,</span><br><span class=\"line\">      password: pwd,</span><br><span class=\"line\">      connectString: <span class=\"string\">`(DESCRIPTION =</span></span><br><span class=\"line\"><span class=\"string\">        (ADDRESS = </span></span><br><span class=\"line\"><span class=\"string\">          (PROTOCOL = TCP)</span></span><br><span class=\"line\"><span class=\"string\">          (HOST = <span class=\"subst\">$&#123;host_addr&#125;</span>)</span></span><br><span class=\"line\"><span class=\"string\">          (PORT = <span class=\"subst\">$&#123;host_port&#125;</span>)</span></span><br><span class=\"line\"><span class=\"string\">        )</span></span><br><span class=\"line\"><span class=\"string\">        (CONNECT_DATA =</span></span><br><span class=\"line\"><span class=\"string\">          (SERVICE_NAME= <span class=\"subst\">$&#123;db_name&#125;</span>)</span></span><br><span class=\"line\"><span class=\"string\">        )</span></span><br><span class=\"line\"><span class=\"string\">      )`</span></span><br><span class=\"line\">    &#125;, <span class=\"function\">(<span class=\"params\">err, connection</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(<span class=\"string\">&#x27;connect oracle data source failed:&#x27;</span>, + err)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      resolve(connection)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">createConnection(params).then(<span class=\"function\">(<span class=\"params\">connection</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  connection.execute(sql, <span class=\"function\">(<span class=\"params\">err, result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    connection.close(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(err) <span class=\"comment\">// TODO</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><em>有一点需要特别注意: nodejs 连接 oracle 数据库可能不能直接进行连接，需要在 nodejs 应用所在的机器（服务器）上安装一个 oracle 即时客户端。</em></p>\n<h5 id=\"安装详细教程见：\"><a href=\"#安装详细教程见：\" class=\"headerlink\" title=\"安装详细教程见：\"></a>安装详细教程见：</h5><p><a href=\"https://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html\">https://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html</a></p>\n<h5 id=\"安装步骤简化版本如下：\"><a href=\"#安装步骤简化版本如下：\" class=\"headerlink\" title=\"安装步骤简化版本如下：\"></a>安装步骤简化版本如下：</h5><p>1.下载 oracle 即时客户端<br><em>Mac osx 系统</em>直接下载osx版本，直接解压后放置在当前用户下的 lib 目录下即可。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/lib/instantclient_18_1</span><br></pre></td></tr></table></figure></p>\n<p>除了Mac系统，对于 Linux 系统，根据不同的系统，去如下连接找到对应系统版本，将其上传到服务器上<br><a href=\"https://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html\">https://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html</a></p>\n<p>2-1.对于服务器安装，解压 oracle 即时客户端到对应目录下，如: ~/instantclient_18_3<br>配置环境变量 LD_LIBRARY_PATH<br>如: LD_LIBRARY_PATH=”$HOME/xxxx/instantclient_18_3”<br>注意：<em>亲测：将此配置直接写在 profile 文件里面不生效；但是，在外面用 export LD_LIBRARY_PATH =”$HOME/xxxx/instantclient_18_3” 手动设置就会生效</em><br>所以，不推荐使用此方式，而是用下面的这种 2-2 步骤</p>\n<p>2-2(推荐)，如果 2-1 未能生效，则选用下面的方式，创建 config 文件<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这个命令的意思是将 instantclient 解压目录写入到动态配置软件库里面，也可以手动创建文件，文件内容就是instantclient的绝对路径</span></span><br><span class=\"line\">sudo sh -c &quot;echo /xxx/instantclient_18_3 &gt; \\ /etc/ld.so.conf.d/oracle-instantclient.conf&quot; </span><br><span class=\"line\">sudo ldconfig # 重启服务</span><br></pre></td></tr></table></figure><br>一般系统配置 config 文件之后就能正常使用了，但是有的系统还是会报错，有可能是缺少 libaio1 这个库。<br>如果发现缺少这个库，则进行下面的第三步进行安装。</p>\n<p>3.安装 libaio1 库<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 有的是需要安装 libaio1, 有的是 libaio，具体根据系统决定。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 安装方式也不一定是apt-get，可能是rpm yum等。</span></span><br><span class=\"line\">apt-get install libaio1</span><br></pre></td></tr></table></figure></p>\n<p>装完上面的基本上就ok了，如果还是不行，那么…自己再想办法吧。</p>\n<p>– end –</p>\n","site":{"data":{}},"excerpt":"","more":"<p>用 nodejs 连接 oracle 目前最方便的方式是使用 oracledb 这个库。<br>使用方法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> oracledb = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;oracledb&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createConnection = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data_source</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; host_addr, host_port, db_name, username, pwd &#125; = data_source</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    oracledb.getConnection(&#123;</span><br><span class=\"line\">      user: username,</span><br><span class=\"line\">      password: pwd,</span><br><span class=\"line\">      connectString: <span class=\"string\">`(DESCRIPTION =</span></span><br><span class=\"line\"><span class=\"string\">        (ADDRESS = </span></span><br><span class=\"line\"><span class=\"string\">          (PROTOCOL = TCP)</span></span><br><span class=\"line\"><span class=\"string\">          (HOST = <span class=\"subst\">$&#123;host_addr&#125;</span>)</span></span><br><span class=\"line\"><span class=\"string\">          (PORT = <span class=\"subst\">$&#123;host_port&#125;</span>)</span></span><br><span class=\"line\"><span class=\"string\">        )</span></span><br><span class=\"line\"><span class=\"string\">        (CONNECT_DATA =</span></span><br><span class=\"line\"><span class=\"string\">          (SERVICE_NAME= <span class=\"subst\">$&#123;db_name&#125;</span>)</span></span><br><span class=\"line\"><span class=\"string\">        )</span></span><br><span class=\"line\"><span class=\"string\">      )`</span></span><br><span class=\"line\">    &#125;, <span class=\"function\">(<span class=\"params\">err, connection</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(<span class=\"string\">&#x27;connect oracle data source failed:&#x27;</span>, + err)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      resolve(connection)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">createConnection(params).then(<span class=\"function\">(<span class=\"params\">connection</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  connection.execute(sql, <span class=\"function\">(<span class=\"params\">err, result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    connection.close(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(err) <span class=\"comment\">// TODO</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><em>有一点需要特别注意: nodejs 连接 oracle 数据库可能不能直接进行连接，需要在 nodejs 应用所在的机器（服务器）上安装一个 oracle 即时客户端。</em></p>\n<h5 id=\"安装详细教程见：\"><a href=\"#安装详细教程见：\" class=\"headerlink\" title=\"安装详细教程见：\"></a>安装详细教程见：</h5><p><a href=\"https://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html\">https://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html</a></p>\n<h5 id=\"安装步骤简化版本如下：\"><a href=\"#安装步骤简化版本如下：\" class=\"headerlink\" title=\"安装步骤简化版本如下：\"></a>安装步骤简化版本如下：</h5><p>1.下载 oracle 即时客户端<br><em>Mac osx 系统</em>直接下载osx版本，直接解压后放置在当前用户下的 lib 目录下即可。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/lib/instantclient_18_1</span><br></pre></td></tr></table></figure></p>\n<p>除了Mac系统，对于 Linux 系统，根据不同的系统，去如下连接找到对应系统版本，将其上传到服务器上<br><a href=\"https://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html\">https://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html</a></p>\n<p>2-1.对于服务器安装，解压 oracle 即时客户端到对应目录下，如: ~/instantclient_18_3<br>配置环境变量 LD_LIBRARY_PATH<br>如: LD_LIBRARY_PATH=”$HOME/xxxx/instantclient_18_3”<br>注意：<em>亲测：将此配置直接写在 profile 文件里面不生效；但是，在外面用 export LD_LIBRARY_PATH =”$HOME/xxxx/instantclient_18_3” 手动设置就会生效</em><br>所以，不推荐使用此方式，而是用下面的这种 2-2 步骤</p>\n<p>2-2(推荐)，如果 2-1 未能生效，则选用下面的方式，创建 config 文件<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这个命令的意思是将 instantclient 解压目录写入到动态配置软件库里面，也可以手动创建文件，文件内容就是instantclient的绝对路径</span></span><br><span class=\"line\">sudo sh -c &quot;echo /xxx/instantclient_18_3 &gt; \\ /etc/ld.so.conf.d/oracle-instantclient.conf&quot; </span><br><span class=\"line\">sudo ldconfig # 重启服务</span><br></pre></td></tr></table></figure><br>一般系统配置 config 文件之后就能正常使用了，但是有的系统还是会报错，有可能是缺少 libaio1 这个库。<br>如果发现缺少这个库，则进行下面的第三步进行安装。</p>\n<p>3.安装 libaio1 库<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 有的是需要安装 libaio1, 有的是 libaio，具体根据系统决定。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 安装方式也不一定是apt-get，可能是rpm yum等。</span></span><br><span class=\"line\">apt-get install libaio1</span><br></pre></td></tr></table></figure></p>\n<p>装完上面的基本上就ok了，如果还是不行，那么…自己再想办法吧。</p>\n<p>– end –</p>\n"},{"title":"performance","date":"2019-09-04T16:00:00.000Z","_content":"\nPerformance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API\n\n### performance\n```javascript\n{\n  'memory': { // Chrome 添加的一个非标准扩展，提供了一个可获取到基本内存使用情况的对象。\n    'jsHeapSizeLimit': 2197815296, // 最大可使用的内存，单位byte\n    'totalJSHeapSize': 8406242, // 当前分配的内存大小\n    'usedJSHeapSize': 7743450, // 当前活动的JS内存\n  },\n  'navigation': { // 返回一个 PerformanceNavigation 对象。这个对象表示出现在当前浏览上下文的 navigation 类型\n    'type': 0,\n    'redirectCount': 0 // 获取某个资源重定向的次数\n  },\n  'onelementtimingbufferfull': null,\n  'oneventtimingbufferfull': null,\n  'onresourcetimingbufferfull': null,\n  'timeOrigin': 1567685364180.6497, // 高精度的时间戳，表示 performance 开始测量的时间\n  'timing': {\n    'redirectStart': 0, // 第一个HTTP的重定向开始的时刻的 Unix毫秒时间戳。如果重定向没有发生，或者其中一个重定向非同源，则该值返回 0。\n    'redirectEnd': 0, // 最后一次的HTTP重定向被完成且HTTP响应的最后一个字节被接收之时的 Unix毫秒时间戳。如果没有发生重定向，或者其中一个重定向不同源，则该值返回 0。\n    'secureConnectionStart': 0, // 安全连接握手开始的时刻的 Unix毫秒时间戳。如果只要你过的连接没有被请求，则它返回 0。\n    'navigationStart': 1567685364175, // 紧接着在相同的浏览环境下卸载前一个文档结束之时的 Unix毫秒时间戳。如果没有上一个文档，则它的值相当于 PerformanceTiming.fetchStart。\n    'fetchStart': 1567685364178, // 浏览器已经准备好去使用HTTP请求抓取文档之时的 Unix毫秒时间戳。这一时刻在检查应用的缓存之前。\n    'domainLookupStart': 1567685364178, // 域名开始解析之时的 Unix毫秒时间戳。如果一个持久连接被使用，或者该信息已经被本地资源或者缓存存储，则该值等同于 PerformanceTiming.fetchStart。\n    'domainLookupEnd': 1567685364178, // 解析域名结束时的 Unix毫秒时间戳。如果一个持久连接被使用，或者该信息已经被本地资源或者缓存存储，则该值等同于 PerformanceTiming.fetchStart。\n    'connectStart': 1567685364178, // 请求连接被发送到网络之时的Unix毫秒时间戳。如果传输层报告错误并且连接的建立重新开始，则把最后建立连接的开始时间作为该值。如果一个持久连接被使用，则该值与 PerformanceTiming.fetchStart 相同。\n    'connectEnd': 1567685364178, // 代表了网络链接建立的时间节点。如果传输层报告了错误或者链接又被重新建立，则采用最后一次链接建立的时间。如果链接是长久的，那么这个值等同于PerformanceTiming.fetchStart。链接被认为打开以所有的链接握手，SOCKS认证结束为标志。\n    'requestStart': 1567685364182, // 浏览器发送从服务器或者缓存获取实际文档的请求之时的 Unix毫秒时间戳。如果传输层在请求开始之后发生错误并且连接被重新打开，则该属性将会被设定为新的请求的相应的值 。\n    'responseStart': 1567685364514, // 浏览器从服务器、缓存或者本地资源接收到响应的第一个字节之时的 Unix毫秒时间戳。\n    'unloadEventStart': 1567685364524, //  unload 事件被触发之时的 Unix毫秒时间戳。如果没有上一个文档，或者上一个文档或需要重定向的页面之一不同源，则该值返回 0。\n    'unloadEventEnd': 1567685364525, // unload 事件处理程序结束之时的 Unix毫秒时间戳。如果没有上一个的文档，或者上一个文档或需要被跳转的页面的其中之一不同源，则该值返回 0。\n    'responseEnd': 1567685364522, // 为浏览器从服务器、缓存或者本地资源接收响应的最后一个字节或者连接被关闭之时的 Unix毫秒时间戳。\n    'domLoading': 1567685364536, // 解析器开始工作，即 Document.readyState 改变为 'loading' 并且 readystatechange 事件被触发之时的 Unix毫秒时间戳。\n    'domInteractive': 1567685364865, // 在主文档的解析器结束工作，即 Document.readyState 改变为 'interactive' 并且相当于 readystatechange 事件被触发之时的 Unix毫秒时间戳。这个属性被用于测量用户感受的加载网页的速度。然而，如果脚本被屏蔽发生，而不是被异步加载或者使用了自定义的 Web 字体，这里有一些警告可能会发生。在使用这个值作为网页加载用户体验的媒介时，请务必检查一下你是否处于以上的情况。\n    'domContentLoadedEventStart': 1567685364865, // 解析器发出 DOMContentLoaded 事件之前，即所有的需要被运行的脚本已经被解析之时的 Unix毫秒时间戳。\n    'domContentLoadedEventEnd': 1567685364866, // 以UNIX时间戳的形式表示一个时刻，这个时刻为所有需要尽早执行的脚本不管是否按顺序，都已经执行完毕。（译注：即DOM Ready）\n    'domComplete': 1567685365169, // 主文档的解析器结束工作，Document.readyState 变为 'complete'且相当于 readystatechange 事件被触发时的 Unix毫秒时间戳。\n    'loadEventStart': 1567685365169, // 为 load 事件被现在的文档触发之时的 Unix时间戳。如果这个事件没有被触发，则他返回 0。\n    'loadEventEnd': 1567685365171, // load 事件处理程序被终止，加载事件已经完成之时的 Unix毫秒时间戳。如果这个事件没有被触发，或者没能完成，则该值将会返回 0。\n  },\n}\n```\n\n### 其它 api\n```javascript\nperformance.now() // 1108998.7549999934\n```\n返回一个精确到毫秒的高精度时间戳，表示从 timeOrigin 到当前调用此方法经过的时间\n\n\n### 对performance.timing 进行排序\n```javascript \nconst timeOrigin = Math.floor(performance.timeOrigin)\nconst timing = performance.timing.toJSON()\nconst arr = []\n\n// 对 timing 从小到大排序\nfor( let [key, value] of Object.entries(timing)) {\n  const obj = {\n    id: key,\n    time: value,\n    timelen: value - timeOrigin > 0 ? value - timeOrigin : 0\n  }\n  arr.push(obj)\n}\narr.sort((a, b) => {\n  return a.time - b.time\n})\nconsole.log(arr)\n```\n\n\n\n### 传送门\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Performance","source":"_posts/performance.md","raw":"---\ntitle: performance\ndate: 2019/09/05\ntag: [js, 性能, chrome, performance]\n---\n\nPerformance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API\n\n### performance\n```javascript\n{\n  'memory': { // Chrome 添加的一个非标准扩展，提供了一个可获取到基本内存使用情况的对象。\n    'jsHeapSizeLimit': 2197815296, // 最大可使用的内存，单位byte\n    'totalJSHeapSize': 8406242, // 当前分配的内存大小\n    'usedJSHeapSize': 7743450, // 当前活动的JS内存\n  },\n  'navigation': { // 返回一个 PerformanceNavigation 对象。这个对象表示出现在当前浏览上下文的 navigation 类型\n    'type': 0,\n    'redirectCount': 0 // 获取某个资源重定向的次数\n  },\n  'onelementtimingbufferfull': null,\n  'oneventtimingbufferfull': null,\n  'onresourcetimingbufferfull': null,\n  'timeOrigin': 1567685364180.6497, // 高精度的时间戳，表示 performance 开始测量的时间\n  'timing': {\n    'redirectStart': 0, // 第一个HTTP的重定向开始的时刻的 Unix毫秒时间戳。如果重定向没有发生，或者其中一个重定向非同源，则该值返回 0。\n    'redirectEnd': 0, // 最后一次的HTTP重定向被完成且HTTP响应的最后一个字节被接收之时的 Unix毫秒时间戳。如果没有发生重定向，或者其中一个重定向不同源，则该值返回 0。\n    'secureConnectionStart': 0, // 安全连接握手开始的时刻的 Unix毫秒时间戳。如果只要你过的连接没有被请求，则它返回 0。\n    'navigationStart': 1567685364175, // 紧接着在相同的浏览环境下卸载前一个文档结束之时的 Unix毫秒时间戳。如果没有上一个文档，则它的值相当于 PerformanceTiming.fetchStart。\n    'fetchStart': 1567685364178, // 浏览器已经准备好去使用HTTP请求抓取文档之时的 Unix毫秒时间戳。这一时刻在检查应用的缓存之前。\n    'domainLookupStart': 1567685364178, // 域名开始解析之时的 Unix毫秒时间戳。如果一个持久连接被使用，或者该信息已经被本地资源或者缓存存储，则该值等同于 PerformanceTiming.fetchStart。\n    'domainLookupEnd': 1567685364178, // 解析域名结束时的 Unix毫秒时间戳。如果一个持久连接被使用，或者该信息已经被本地资源或者缓存存储，则该值等同于 PerformanceTiming.fetchStart。\n    'connectStart': 1567685364178, // 请求连接被发送到网络之时的Unix毫秒时间戳。如果传输层报告错误并且连接的建立重新开始，则把最后建立连接的开始时间作为该值。如果一个持久连接被使用，则该值与 PerformanceTiming.fetchStart 相同。\n    'connectEnd': 1567685364178, // 代表了网络链接建立的时间节点。如果传输层报告了错误或者链接又被重新建立，则采用最后一次链接建立的时间。如果链接是长久的，那么这个值等同于PerformanceTiming.fetchStart。链接被认为打开以所有的链接握手，SOCKS认证结束为标志。\n    'requestStart': 1567685364182, // 浏览器发送从服务器或者缓存获取实际文档的请求之时的 Unix毫秒时间戳。如果传输层在请求开始之后发生错误并且连接被重新打开，则该属性将会被设定为新的请求的相应的值 。\n    'responseStart': 1567685364514, // 浏览器从服务器、缓存或者本地资源接收到响应的第一个字节之时的 Unix毫秒时间戳。\n    'unloadEventStart': 1567685364524, //  unload 事件被触发之时的 Unix毫秒时间戳。如果没有上一个文档，或者上一个文档或需要重定向的页面之一不同源，则该值返回 0。\n    'unloadEventEnd': 1567685364525, // unload 事件处理程序结束之时的 Unix毫秒时间戳。如果没有上一个的文档，或者上一个文档或需要被跳转的页面的其中之一不同源，则该值返回 0。\n    'responseEnd': 1567685364522, // 为浏览器从服务器、缓存或者本地资源接收响应的最后一个字节或者连接被关闭之时的 Unix毫秒时间戳。\n    'domLoading': 1567685364536, // 解析器开始工作，即 Document.readyState 改变为 'loading' 并且 readystatechange 事件被触发之时的 Unix毫秒时间戳。\n    'domInteractive': 1567685364865, // 在主文档的解析器结束工作，即 Document.readyState 改变为 'interactive' 并且相当于 readystatechange 事件被触发之时的 Unix毫秒时间戳。这个属性被用于测量用户感受的加载网页的速度。然而，如果脚本被屏蔽发生，而不是被异步加载或者使用了自定义的 Web 字体，这里有一些警告可能会发生。在使用这个值作为网页加载用户体验的媒介时，请务必检查一下你是否处于以上的情况。\n    'domContentLoadedEventStart': 1567685364865, // 解析器发出 DOMContentLoaded 事件之前，即所有的需要被运行的脚本已经被解析之时的 Unix毫秒时间戳。\n    'domContentLoadedEventEnd': 1567685364866, // 以UNIX时间戳的形式表示一个时刻，这个时刻为所有需要尽早执行的脚本不管是否按顺序，都已经执行完毕。（译注：即DOM Ready）\n    'domComplete': 1567685365169, // 主文档的解析器结束工作，Document.readyState 变为 'complete'且相当于 readystatechange 事件被触发时的 Unix毫秒时间戳。\n    'loadEventStart': 1567685365169, // 为 load 事件被现在的文档触发之时的 Unix时间戳。如果这个事件没有被触发，则他返回 0。\n    'loadEventEnd': 1567685365171, // load 事件处理程序被终止，加载事件已经完成之时的 Unix毫秒时间戳。如果这个事件没有被触发，或者没能完成，则该值将会返回 0。\n  },\n}\n```\n\n### 其它 api\n```javascript\nperformance.now() // 1108998.7549999934\n```\n返回一个精确到毫秒的高精度时间戳，表示从 timeOrigin 到当前调用此方法经过的时间\n\n\n### 对performance.timing 进行排序\n```javascript \nconst timeOrigin = Math.floor(performance.timeOrigin)\nconst timing = performance.timing.toJSON()\nconst arr = []\n\n// 对 timing 从小到大排序\nfor( let [key, value] of Object.entries(timing)) {\n  const obj = {\n    id: key,\n    time: value,\n    timelen: value - timeOrigin > 0 ? value - timeOrigin : 0\n  }\n  arr.push(obj)\n}\narr.sort((a, b) => {\n  return a.time - b.time\n})\nconsole.log(arr)\n```\n\n\n\n### 传送门\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Performance","slug":"performance","published":1,"updated":"2021-03-30T01:32:00.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug1001ba0vzhimgh329","content":"<p>Performance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API</p>\n<h3 id=\"performance\"><a href=\"#performance\" class=\"headerlink\" title=\"performance\"></a>performance</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;memory&#x27;</span>: &#123; <span class=\"comment\">// Chrome 添加的一个非标准扩展，提供了一个可获取到基本内存使用情况的对象。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;jsHeapSizeLimit&#x27;</span>: <span class=\"number\">2197815296</span>, <span class=\"comment\">// 最大可使用的内存，单位byte</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;totalJSHeapSize&#x27;</span>: <span class=\"number\">8406242</span>, <span class=\"comment\">// 当前分配的内存大小</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;usedJSHeapSize&#x27;</span>: <span class=\"number\">7743450</span>, <span class=\"comment\">// 当前活动的JS内存</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&#x27;navigation&#x27;</span>: &#123; <span class=\"comment\">// 返回一个 PerformanceNavigation 对象。这个对象表示出现在当前浏览上下文的 navigation 类型</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;redirectCount&#x27;</span>: <span class=\"number\">0</span> <span class=\"comment\">// 获取某个资源重定向的次数</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onelementtimingbufferfull&#x27;</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;oneventtimingbufferfull&#x27;</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onresourcetimingbufferfull&#x27;</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;timeOrigin&#x27;</span>: <span class=\"number\">1567685364180.6497</span>, <span class=\"comment\">// 高精度的时间戳，表示 performance 开始测量的时间</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;timing&#x27;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;redirectStart&#x27;</span>: <span class=\"number\">0</span>, <span class=\"comment\">// 第一个HTTP的重定向开始的时刻的 Unix毫秒时间戳。如果重定向没有发生，或者其中一个重定向非同源，则该值返回 0。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;redirectEnd&#x27;</span>: <span class=\"number\">0</span>, <span class=\"comment\">// 最后一次的HTTP重定向被完成且HTTP响应的最后一个字节被接收之时的 Unix毫秒时间戳。如果没有发生重定向，或者其中一个重定向不同源，则该值返回 0。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;secureConnectionStart&#x27;</span>: <span class=\"number\">0</span>, <span class=\"comment\">// 安全连接握手开始的时刻的 Unix毫秒时间戳。如果只要你过的连接没有被请求，则它返回 0。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;navigationStart&#x27;</span>: <span class=\"number\">1567685364175</span>, <span class=\"comment\">// 紧接着在相同的浏览环境下卸载前一个文档结束之时的 Unix毫秒时间戳。如果没有上一个文档，则它的值相当于 PerformanceTiming.fetchStart。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;fetchStart&#x27;</span>: <span class=\"number\">1567685364178</span>, <span class=\"comment\">// 浏览器已经准备好去使用HTTP请求抓取文档之时的 Unix毫秒时间戳。这一时刻在检查应用的缓存之前。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domainLookupStart&#x27;</span>: <span class=\"number\">1567685364178</span>, <span class=\"comment\">// 域名开始解析之时的 Unix毫秒时间戳。如果一个持久连接被使用，或者该信息已经被本地资源或者缓存存储，则该值等同于 PerformanceTiming.fetchStart。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domainLookupEnd&#x27;</span>: <span class=\"number\">1567685364178</span>, <span class=\"comment\">// 解析域名结束时的 Unix毫秒时间戳。如果一个持久连接被使用，或者该信息已经被本地资源或者缓存存储，则该值等同于 PerformanceTiming.fetchStart。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;connectStart&#x27;</span>: <span class=\"number\">1567685364178</span>, <span class=\"comment\">// 请求连接被发送到网络之时的Unix毫秒时间戳。如果传输层报告错误并且连接的建立重新开始，则把最后建立连接的开始时间作为该值。如果一个持久连接被使用，则该值与 PerformanceTiming.fetchStart 相同。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;connectEnd&#x27;</span>: <span class=\"number\">1567685364178</span>, <span class=\"comment\">// 代表了网络链接建立的时间节点。如果传输层报告了错误或者链接又被重新建立，则采用最后一次链接建立的时间。如果链接是长久的，那么这个值等同于PerformanceTiming.fetchStart。链接被认为打开以所有的链接握手，SOCKS认证结束为标志。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;requestStart&#x27;</span>: <span class=\"number\">1567685364182</span>, <span class=\"comment\">// 浏览器发送从服务器或者缓存获取实际文档的请求之时的 Unix毫秒时间戳。如果传输层在请求开始之后发生错误并且连接被重新打开，则该属性将会被设定为新的请求的相应的值 。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;responseStart&#x27;</span>: <span class=\"number\">1567685364514</span>, <span class=\"comment\">// 浏览器从服务器、缓存或者本地资源接收到响应的第一个字节之时的 Unix毫秒时间戳。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;unloadEventStart&#x27;</span>: <span class=\"number\">1567685364524</span>, <span class=\"comment\">//  unload 事件被触发之时的 Unix毫秒时间戳。如果没有上一个文档，或者上一个文档或需要重定向的页面之一不同源，则该值返回 0。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;unloadEventEnd&#x27;</span>: <span class=\"number\">1567685364525</span>, <span class=\"comment\">// unload 事件处理程序结束之时的 Unix毫秒时间戳。如果没有上一个的文档，或者上一个文档或需要被跳转的页面的其中之一不同源，则该值返回 0。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;responseEnd&#x27;</span>: <span class=\"number\">1567685364522</span>, <span class=\"comment\">// 为浏览器从服务器、缓存或者本地资源接收响应的最后一个字节或者连接被关闭之时的 Unix毫秒时间戳。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domLoading&#x27;</span>: <span class=\"number\">1567685364536</span>, <span class=\"comment\">// 解析器开始工作，即 Document.readyState 改变为 &#x27;loading&#x27; 并且 readystatechange 事件被触发之时的 Unix毫秒时间戳。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domInteractive&#x27;</span>: <span class=\"number\">1567685364865</span>, <span class=\"comment\">// 在主文档的解析器结束工作，即 Document.readyState 改变为 &#x27;interactive&#x27; 并且相当于 readystatechange 事件被触发之时的 Unix毫秒时间戳。这个属性被用于测量用户感受的加载网页的速度。然而，如果脚本被屏蔽发生，而不是被异步加载或者使用了自定义的 Web 字体，这里有一些警告可能会发生。在使用这个值作为网页加载用户体验的媒介时，请务必检查一下你是否处于以上的情况。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domContentLoadedEventStart&#x27;</span>: <span class=\"number\">1567685364865</span>, <span class=\"comment\">// 解析器发出 DOMContentLoaded 事件之前，即所有的需要被运行的脚本已经被解析之时的 Unix毫秒时间戳。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domContentLoadedEventEnd&#x27;</span>: <span class=\"number\">1567685364866</span>, <span class=\"comment\">// 以UNIX时间戳的形式表示一个时刻，这个时刻为所有需要尽早执行的脚本不管是否按顺序，都已经执行完毕。（译注：即DOM Ready）</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domComplete&#x27;</span>: <span class=\"number\">1567685365169</span>, <span class=\"comment\">// 主文档的解析器结束工作，Document.readyState 变为 &#x27;complete&#x27;且相当于 readystatechange 事件被触发时的 Unix毫秒时间戳。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;loadEventStart&#x27;</span>: <span class=\"number\">1567685365169</span>, <span class=\"comment\">// 为 load 事件被现在的文档触发之时的 Unix时间戳。如果这个事件没有被触发，则他返回 0。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;loadEventEnd&#x27;</span>: <span class=\"number\">1567685365171</span>, <span class=\"comment\">// load 事件处理程序被终止，加载事件已经完成之时的 Unix毫秒时间戳。如果这个事件没有被触发，或者没能完成，则该值将会返回 0。</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"其它-api\"><a href=\"#其它-api\" class=\"headerlink\" title=\"其它 api\"></a>其它 api</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">performance.now() <span class=\"comment\">// 1108998.7549999934</span></span><br></pre></td></tr></table></figure>\n<p>返回一个精确到毫秒的高精度时间戳，表示从 timeOrigin 到当前调用此方法经过的时间</p>\n<h3 id=\"对performance-timing-进行排序\"><a href=\"#对performance-timing-进行排序\" class=\"headerlink\" title=\"对performance.timing 进行排序\"></a>对performance.timing 进行排序</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> timeOrigin = <span class=\"built_in\">Math</span>.floor(performance.timeOrigin)</span><br><span class=\"line\"><span class=\"keyword\">const</span> timing = performance.timing.toJSON()</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对 timing 从小到大排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">for</span>(<span class=\"params\"> <span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> <span class=\"built_in\">Object</span>.entries(timing)</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    id: key,</span><br><span class=\"line\">    time: value,</span><br><span class=\"line\">    timelen: value - timeOrigin &gt; <span class=\"number\">0</span> ? value - timeOrigin : <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  arr.push(obj)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a.time - b.time</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr)</span><br></pre></td></tr></table></figure>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Performance\">https://developer.mozilla.org/zh-CN/docs/Web/API/Performance</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Performance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API</p>\n<h3 id=\"performance\"><a href=\"#performance\" class=\"headerlink\" title=\"performance\"></a>performance</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;memory&#x27;</span>: &#123; <span class=\"comment\">// Chrome 添加的一个非标准扩展，提供了一个可获取到基本内存使用情况的对象。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;jsHeapSizeLimit&#x27;</span>: <span class=\"number\">2197815296</span>, <span class=\"comment\">// 最大可使用的内存，单位byte</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;totalJSHeapSize&#x27;</span>: <span class=\"number\">8406242</span>, <span class=\"comment\">// 当前分配的内存大小</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;usedJSHeapSize&#x27;</span>: <span class=\"number\">7743450</span>, <span class=\"comment\">// 当前活动的JS内存</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&#x27;navigation&#x27;</span>: &#123; <span class=\"comment\">// 返回一个 PerformanceNavigation 对象。这个对象表示出现在当前浏览上下文的 navigation 类型</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;redirectCount&#x27;</span>: <span class=\"number\">0</span> <span class=\"comment\">// 获取某个资源重定向的次数</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onelementtimingbufferfull&#x27;</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;oneventtimingbufferfull&#x27;</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;onresourcetimingbufferfull&#x27;</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;timeOrigin&#x27;</span>: <span class=\"number\">1567685364180.6497</span>, <span class=\"comment\">// 高精度的时间戳，表示 performance 开始测量的时间</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;timing&#x27;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;redirectStart&#x27;</span>: <span class=\"number\">0</span>, <span class=\"comment\">// 第一个HTTP的重定向开始的时刻的 Unix毫秒时间戳。如果重定向没有发生，或者其中一个重定向非同源，则该值返回 0。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;redirectEnd&#x27;</span>: <span class=\"number\">0</span>, <span class=\"comment\">// 最后一次的HTTP重定向被完成且HTTP响应的最后一个字节被接收之时的 Unix毫秒时间戳。如果没有发生重定向，或者其中一个重定向不同源，则该值返回 0。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;secureConnectionStart&#x27;</span>: <span class=\"number\">0</span>, <span class=\"comment\">// 安全连接握手开始的时刻的 Unix毫秒时间戳。如果只要你过的连接没有被请求，则它返回 0。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;navigationStart&#x27;</span>: <span class=\"number\">1567685364175</span>, <span class=\"comment\">// 紧接着在相同的浏览环境下卸载前一个文档结束之时的 Unix毫秒时间戳。如果没有上一个文档，则它的值相当于 PerformanceTiming.fetchStart。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;fetchStart&#x27;</span>: <span class=\"number\">1567685364178</span>, <span class=\"comment\">// 浏览器已经准备好去使用HTTP请求抓取文档之时的 Unix毫秒时间戳。这一时刻在检查应用的缓存之前。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domainLookupStart&#x27;</span>: <span class=\"number\">1567685364178</span>, <span class=\"comment\">// 域名开始解析之时的 Unix毫秒时间戳。如果一个持久连接被使用，或者该信息已经被本地资源或者缓存存储，则该值等同于 PerformanceTiming.fetchStart。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domainLookupEnd&#x27;</span>: <span class=\"number\">1567685364178</span>, <span class=\"comment\">// 解析域名结束时的 Unix毫秒时间戳。如果一个持久连接被使用，或者该信息已经被本地资源或者缓存存储，则该值等同于 PerformanceTiming.fetchStart。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;connectStart&#x27;</span>: <span class=\"number\">1567685364178</span>, <span class=\"comment\">// 请求连接被发送到网络之时的Unix毫秒时间戳。如果传输层报告错误并且连接的建立重新开始，则把最后建立连接的开始时间作为该值。如果一个持久连接被使用，则该值与 PerformanceTiming.fetchStart 相同。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;connectEnd&#x27;</span>: <span class=\"number\">1567685364178</span>, <span class=\"comment\">// 代表了网络链接建立的时间节点。如果传输层报告了错误或者链接又被重新建立，则采用最后一次链接建立的时间。如果链接是长久的，那么这个值等同于PerformanceTiming.fetchStart。链接被认为打开以所有的链接握手，SOCKS认证结束为标志。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;requestStart&#x27;</span>: <span class=\"number\">1567685364182</span>, <span class=\"comment\">// 浏览器发送从服务器或者缓存获取实际文档的请求之时的 Unix毫秒时间戳。如果传输层在请求开始之后发生错误并且连接被重新打开，则该属性将会被设定为新的请求的相应的值 。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;responseStart&#x27;</span>: <span class=\"number\">1567685364514</span>, <span class=\"comment\">// 浏览器从服务器、缓存或者本地资源接收到响应的第一个字节之时的 Unix毫秒时间戳。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;unloadEventStart&#x27;</span>: <span class=\"number\">1567685364524</span>, <span class=\"comment\">//  unload 事件被触发之时的 Unix毫秒时间戳。如果没有上一个文档，或者上一个文档或需要重定向的页面之一不同源，则该值返回 0。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;unloadEventEnd&#x27;</span>: <span class=\"number\">1567685364525</span>, <span class=\"comment\">// unload 事件处理程序结束之时的 Unix毫秒时间戳。如果没有上一个的文档，或者上一个文档或需要被跳转的页面的其中之一不同源，则该值返回 0。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;responseEnd&#x27;</span>: <span class=\"number\">1567685364522</span>, <span class=\"comment\">// 为浏览器从服务器、缓存或者本地资源接收响应的最后一个字节或者连接被关闭之时的 Unix毫秒时间戳。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domLoading&#x27;</span>: <span class=\"number\">1567685364536</span>, <span class=\"comment\">// 解析器开始工作，即 Document.readyState 改变为 &#x27;loading&#x27; 并且 readystatechange 事件被触发之时的 Unix毫秒时间戳。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domInteractive&#x27;</span>: <span class=\"number\">1567685364865</span>, <span class=\"comment\">// 在主文档的解析器结束工作，即 Document.readyState 改变为 &#x27;interactive&#x27; 并且相当于 readystatechange 事件被触发之时的 Unix毫秒时间戳。这个属性被用于测量用户感受的加载网页的速度。然而，如果脚本被屏蔽发生，而不是被异步加载或者使用了自定义的 Web 字体，这里有一些警告可能会发生。在使用这个值作为网页加载用户体验的媒介时，请务必检查一下你是否处于以上的情况。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domContentLoadedEventStart&#x27;</span>: <span class=\"number\">1567685364865</span>, <span class=\"comment\">// 解析器发出 DOMContentLoaded 事件之前，即所有的需要被运行的脚本已经被解析之时的 Unix毫秒时间戳。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domContentLoadedEventEnd&#x27;</span>: <span class=\"number\">1567685364866</span>, <span class=\"comment\">// 以UNIX时间戳的形式表示一个时刻，这个时刻为所有需要尽早执行的脚本不管是否按顺序，都已经执行完毕。（译注：即DOM Ready）</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;domComplete&#x27;</span>: <span class=\"number\">1567685365169</span>, <span class=\"comment\">// 主文档的解析器结束工作，Document.readyState 变为 &#x27;complete&#x27;且相当于 readystatechange 事件被触发时的 Unix毫秒时间戳。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;loadEventStart&#x27;</span>: <span class=\"number\">1567685365169</span>, <span class=\"comment\">// 为 load 事件被现在的文档触发之时的 Unix时间戳。如果这个事件没有被触发，则他返回 0。</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;loadEventEnd&#x27;</span>: <span class=\"number\">1567685365171</span>, <span class=\"comment\">// load 事件处理程序被终止，加载事件已经完成之时的 Unix毫秒时间戳。如果这个事件没有被触发，或者没能完成，则该值将会返回 0。</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"其它-api\"><a href=\"#其它-api\" class=\"headerlink\" title=\"其它 api\"></a>其它 api</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">performance.now() <span class=\"comment\">// 1108998.7549999934</span></span><br></pre></td></tr></table></figure>\n<p>返回一个精确到毫秒的高精度时间戳，表示从 timeOrigin 到当前调用此方法经过的时间</p>\n<h3 id=\"对performance-timing-进行排序\"><a href=\"#对performance-timing-进行排序\" class=\"headerlink\" title=\"对performance.timing 进行排序\"></a>对performance.timing 进行排序</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> timeOrigin = <span class=\"built_in\">Math</span>.floor(performance.timeOrigin)</span><br><span class=\"line\"><span class=\"keyword\">const</span> timing = performance.timing.toJSON()</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对 timing 从小到大排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">for</span>(<span class=\"params\"> <span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> <span class=\"built_in\">Object</span>.entries(timing)</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    id: key,</span><br><span class=\"line\">    time: value,</span><br><span class=\"line\">    timelen: value - timeOrigin &gt; <span class=\"number\">0</span> ? value - timeOrigin : <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  arr.push(obj)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a.time - b.time</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr)</span><br></pre></td></tr></table></figure>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Performance\">https://developer.mozilla.org/zh-CN/docs/Web/API/Performance</a></p>\n"},{"title":"pm2简单用法","date":"2016-03-28T16:00:00.000Z","_content":"\npm2是nodejs的进程管理工具能够让你的nodejs进程永远处于启动状态\n是nodejs项目常用的进程管理工具\n\n\n启动如下\n``` shell\nset NODE_ENV=production&& npm start\n\nset port=端口号\n```\n\n``` shell\npm2 start app.json --env production\n\npm2 restart app.json --env production\n```\n\n**linux 使用 export代替set**\n``` shell\nexport -p 列出当前的所有环境变量\n```\n\n如果使用了pm2，app.json\n\n\n### pm2正式项目配置举例\n``` \n{\n  \"apps\":[{\n    \"name\":\"appName\",\n    \"script\":\"bin/www\",\n    \"log_date_format\":\"YYYY-MM-DD HH:mm:SS\",\n    \"merge_logs\":true,\n    \"log_file\":\"../logpath/file.log\",\n    \"error_file\":\"../logpath/err.log\",\n    \"out_file\":\"../logpath/out.log\",\n    \"pid_file\":\"../logpath/file.pid\",\n    \"exec_mode\":\"fork_mode\",\n    \"watch\":true,\n    \"env\":{\n      \"NODE_ENV\":\"development\",\n      \"PORT\":80\n    },\n    \"env_test\":{\n      \"NODE_ENV\":\"test\",\n    },\n    \"env_production\":{\n      \"NODE_ENV\":\"production\",\n      \"PORT\":80\n    }\n  }]\n}\n```\n示例启动\n``` shell\npm2 start app.json --env test\n```\n\n\npm2传送门：\n\n[https://github.com/Unitech/pm2](https://github.com/Unitech/pm2)\n\nnodejs传送门：\n\n[https://nodejs.org/dist/latest-v5.x/docs/api/](https://nodejs.org/dist/latest-v5.x/docs/api/)\n\nnodejs中文传送门：\n[http://nodeapi.ucdok.com/#/api/](http://nodeapi.ucdok.com/#/api/)\n\n\n","source":"_posts/pm2.md","raw":"---\ntitle: pm2简单用法\ndate: 2016/03/29\ntag: [pm2, nodejs]\ncategory: 技术\n---\n\npm2是nodejs的进程管理工具能够让你的nodejs进程永远处于启动状态\n是nodejs项目常用的进程管理工具\n\n\n启动如下\n``` shell\nset NODE_ENV=production&& npm start\n\nset port=端口号\n```\n\n``` shell\npm2 start app.json --env production\n\npm2 restart app.json --env production\n```\n\n**linux 使用 export代替set**\n``` shell\nexport -p 列出当前的所有环境变量\n```\n\n如果使用了pm2，app.json\n\n\n### pm2正式项目配置举例\n``` \n{\n  \"apps\":[{\n    \"name\":\"appName\",\n    \"script\":\"bin/www\",\n    \"log_date_format\":\"YYYY-MM-DD HH:mm:SS\",\n    \"merge_logs\":true,\n    \"log_file\":\"../logpath/file.log\",\n    \"error_file\":\"../logpath/err.log\",\n    \"out_file\":\"../logpath/out.log\",\n    \"pid_file\":\"../logpath/file.pid\",\n    \"exec_mode\":\"fork_mode\",\n    \"watch\":true,\n    \"env\":{\n      \"NODE_ENV\":\"development\",\n      \"PORT\":80\n    },\n    \"env_test\":{\n      \"NODE_ENV\":\"test\",\n    },\n    \"env_production\":{\n      \"NODE_ENV\":\"production\",\n      \"PORT\":80\n    }\n  }]\n}\n```\n示例启动\n``` shell\npm2 start app.json --env test\n```\n\n\npm2传送门：\n\n[https://github.com/Unitech/pm2](https://github.com/Unitech/pm2)\n\nnodejs传送门：\n\n[https://nodejs.org/dist/latest-v5.x/docs/api/](https://nodejs.org/dist/latest-v5.x/docs/api/)\n\nnodejs中文传送门：\n[http://nodeapi.ucdok.com/#/api/](http://nodeapi.ucdok.com/#/api/)\n\n\n","slug":"pm2","published":1,"updated":"2021-03-30T01:32:00.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug2001ca0vz7ocga25a","content":"<p>pm2是nodejs的进程管理工具能够让你的nodejs进程永远处于启动状态<br>是nodejs项目常用的进程管理工具</p>\n<p>启动如下<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set NODE_ENV=production&amp;&amp; npm start</span><br><span class=\"line\"></span><br><span class=\"line\">set port=端口号</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 start app.json --env production</span><br><span class=\"line\"></span><br><span class=\"line\">pm2 restart app.json --env production</span><br></pre></td></tr></table></figure>\n<p><strong>linux 使用 export代替set</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export -p 列出当前的所有环境变量</span><br></pre></td></tr></table></figure></p>\n<p>如果使用了pm2，app.json</p>\n<h3 id=\"pm2正式项目配置举例\"><a href=\"#pm2正式项目配置举例\" class=\"headerlink\" title=\"pm2正式项目配置举例\"></a>pm2正式项目配置举例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;apps&quot;:[&#123;</span><br><span class=\"line\">    &quot;name&quot;:&quot;appName&quot;,</span><br><span class=\"line\">    &quot;script&quot;:&quot;bin&#x2F;www&quot;,</span><br><span class=\"line\">    &quot;log_date_format&quot;:&quot;YYYY-MM-DD HH:mm:SS&quot;,</span><br><span class=\"line\">    &quot;merge_logs&quot;:true,</span><br><span class=\"line\">    &quot;log_file&quot;:&quot;..&#x2F;logpath&#x2F;file.log&quot;,</span><br><span class=\"line\">    &quot;error_file&quot;:&quot;..&#x2F;logpath&#x2F;err.log&quot;,</span><br><span class=\"line\">    &quot;out_file&quot;:&quot;..&#x2F;logpath&#x2F;out.log&quot;,</span><br><span class=\"line\">    &quot;pid_file&quot;:&quot;..&#x2F;logpath&#x2F;file.pid&quot;,</span><br><span class=\"line\">    &quot;exec_mode&quot;:&quot;fork_mode&quot;,</span><br><span class=\"line\">    &quot;watch&quot;:true,</span><br><span class=\"line\">    &quot;env&quot;:&#123;</span><br><span class=\"line\">      &quot;NODE_ENV&quot;:&quot;development&quot;,</span><br><span class=\"line\">      &quot;PORT&quot;:80</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;env_test&quot;:&#123;</span><br><span class=\"line\">      &quot;NODE_ENV&quot;:&quot;test&quot;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;env_production&quot;:&#123;</span><br><span class=\"line\">      &quot;NODE_ENV&quot;:&quot;production&quot;,</span><br><span class=\"line\">      &quot;PORT&quot;:80</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例启动<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 start app.json --env test</span><br></pre></td></tr></table></figure></p>\n<p>pm2传送门：</p>\n<p><a href=\"https://github.com/Unitech/pm2\">https://github.com/Unitech/pm2</a></p>\n<p>nodejs传送门：</p>\n<p><a href=\"https://nodejs.org/dist/latest-v5.x/docs/api/\">https://nodejs.org/dist/latest-v5.x/docs/api/</a></p>\n<p>nodejs中文传送门：<br><a href=\"http://nodeapi.ucdok.com/#/api/\">http://nodeapi.ucdok.com/#/api/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>pm2是nodejs的进程管理工具能够让你的nodejs进程永远处于启动状态<br>是nodejs项目常用的进程管理工具</p>\n<p>启动如下<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set NODE_ENV=production&amp;&amp; npm start</span><br><span class=\"line\"></span><br><span class=\"line\">set port=端口号</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 start app.json --env production</span><br><span class=\"line\"></span><br><span class=\"line\">pm2 restart app.json --env production</span><br></pre></td></tr></table></figure>\n<p><strong>linux 使用 export代替set</strong><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export -p 列出当前的所有环境变量</span><br></pre></td></tr></table></figure></p>\n<p>如果使用了pm2，app.json</p>\n<h3 id=\"pm2正式项目配置举例\"><a href=\"#pm2正式项目配置举例\" class=\"headerlink\" title=\"pm2正式项目配置举例\"></a>pm2正式项目配置举例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;apps&quot;:[&#123;</span><br><span class=\"line\">    &quot;name&quot;:&quot;appName&quot;,</span><br><span class=\"line\">    &quot;script&quot;:&quot;bin&#x2F;www&quot;,</span><br><span class=\"line\">    &quot;log_date_format&quot;:&quot;YYYY-MM-DD HH:mm:SS&quot;,</span><br><span class=\"line\">    &quot;merge_logs&quot;:true,</span><br><span class=\"line\">    &quot;log_file&quot;:&quot;..&#x2F;logpath&#x2F;file.log&quot;,</span><br><span class=\"line\">    &quot;error_file&quot;:&quot;..&#x2F;logpath&#x2F;err.log&quot;,</span><br><span class=\"line\">    &quot;out_file&quot;:&quot;..&#x2F;logpath&#x2F;out.log&quot;,</span><br><span class=\"line\">    &quot;pid_file&quot;:&quot;..&#x2F;logpath&#x2F;file.pid&quot;,</span><br><span class=\"line\">    &quot;exec_mode&quot;:&quot;fork_mode&quot;,</span><br><span class=\"line\">    &quot;watch&quot;:true,</span><br><span class=\"line\">    &quot;env&quot;:&#123;</span><br><span class=\"line\">      &quot;NODE_ENV&quot;:&quot;development&quot;,</span><br><span class=\"line\">      &quot;PORT&quot;:80</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;env_test&quot;:&#123;</span><br><span class=\"line\">      &quot;NODE_ENV&quot;:&quot;test&quot;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;env_production&quot;:&#123;</span><br><span class=\"line\">      &quot;NODE_ENV&quot;:&quot;production&quot;,</span><br><span class=\"line\">      &quot;PORT&quot;:80</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例启动<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 start app.json --env test</span><br></pre></td></tr></table></figure></p>\n<p>pm2传送门：</p>\n<p><a href=\"https://github.com/Unitech/pm2\">https://github.com/Unitech/pm2</a></p>\n<p>nodejs传送门：</p>\n<p><a href=\"https://nodejs.org/dist/latest-v5.x/docs/api/\">https://nodejs.org/dist/latest-v5.x/docs/api/</a></p>\n<p>nodejs中文传送门：<br><a href=\"http://nodeapi.ucdok.com/#/api/\">http://nodeapi.ucdok.com/#/api/</a></p>\n"},{"layout":"default","title":"一个localhost引发的血案。","date":"2018-05-21T11:41:48.000Z","_content":"\n## {{page.title}}\n\n本来一天都开开心心，直到跑了一个npm run dev。\n原本百分百没有问题的项目，npm run dev的时候某个接口突然跑不通了，一直报504错误。\n看了下代码，这个接口是做了本地代理的mock数据接口，之前一直好好的。\n查了很久，检查了N遍代码，切了master分支，皆不行。不得已让同事跑了一下此项目，结果 —— 在他们那能正常运行。\n嗯，既然如此，真相只有一个：本地环境的问题。\n于是开始了漫长的试错与调试。\n尝试了如下方法，重装nodejs（怀疑是node 10.0.0的问题），重装node_module，重装gulp，干掉nginx，干掉其它一切可能占用端口的软件，甚至最后重启了电脑。结果 —— 全部铺盖。\n\n两个小时以后。。。\n\n算了，去node_module看源码吧（基本上80%把握确定是代理的问题）\n于是决定重头开始，仔细分析控制台的错误码，错误信息如下：\n\n```html\n[HPM] Error occurred while trying to proxy request /repay/get_api_info from localhost:8084 to http://localhost:8088 (ENOTFOUND) (https://nodejs.org/api/errors.html#errors_common_system_errors)\n```\n拿着此错误码google了一下，无果。大家遇到的错误都和我的不一样。即使有一样的也没有人解决。\n\n算了，还是去看看代理的源码吧。于是找到如下文件。\n\n```html\n/node_modules/http-proxy-middleware/lib/index.js\n```\n\n经过人肉搜索，终于找到抛出错误信息的位置（如下代码所示）。\n原来这个错误是经过加工的，而且真正抛出错误的地方还不是此模块，而是它依赖的另外一个模块（/node_modules/http-proxy）\n先不管这些，先将错误信息打印出来看看详细错误。（如下的console.log(err)）\n\n```javascript\nfunction logError(err, req, res) {\n  var hostname = (req.headers && req.headers.host) || (req.hostname || req.host);     // (websocket) || (node0.10 || node 4/5)\n  var target = proxyOptions.target.host || proxyOptions.target;\n  var errReference = 'https://nodejs.org/api/errors.html#errors_common_system_errors'; // link to Node Common Systems Errors page\n  // ------------>  在此处打印错误日志\n  console.log(err)\n  logger.error('[HPM] Error occurred while trying to proxy request %s from %s to %s (%s) (%s)', req.url, hostname, target, err.code, errReference);\n}\n```\n\n最终打印错误信息如下：\n\n```html\n{ Error: getaddrinfo ENOTFOUND localhost localhost:8088\n    at errnoException (dns.js:50:10)\n    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:92:26)\n  code: 'ENOTFOUND',\n  errno: 'ENOTFOUND',\n  syscall: 'getaddrinfo',\n  hostname: 'localhost',\n  host: 'localhost',\n  port: '8088' }\n```\n\ngoogle搜索了一下关键字 *getaddrinfo ENOTFOUND localhost*\n找到这个报错的原因，是本地的host没有绑定\n\n```shell\n127.0.0.1 localhost\n```\n\n嗯？应该有的啊，算了去hosts看看，这一看才发现不知道什么时候被注释掉了。\n于是，去除注释，npm run dev，\n咦？好了？wtf!!!!.\n\n事情经过就是这样，就这样解决了。\n\n### 分析总结\n分析：\n本来这个127.0.0.1 localhost是存在的，只是因为之前装了一个SwitchHosts软件，SwitchHosts会修改原来的文件/etc/hosts，将其内容剪切到另外的位置，也就是SwitchHosts软件存放host的位置的。同时会将默认的配置选项开启，所以正常情况是不会对原有的host造成影响的。\n于是我检查了一下我的host文件配置，发现原来是自己把SwitchHosts的那个基础配置选项关掉了，所以才导致找不到这个localhost。\n解决办法将其打开即可（当然，直接在hosts文件补上也行）。\n\n总结：\n此问题的解决和运气有一定的关系，同时，自己的解决问题的思路也有问题，浪费了很多时间。\n如果一开始就认真分析错误日志，可能早就解决了。\n\n---全文完---\n\n\n\n\n","source":"_posts/proxy-error.md","raw":"---\nlayout: default\ntitle: 一个localhost引发的血案。\ndate: 2018-05-21 19:41:48\ntags: [npm,proxy]\ncategory: 技术\n---\n\n## {{page.title}}\n\n本来一天都开开心心，直到跑了一个npm run dev。\n原本百分百没有问题的项目，npm run dev的时候某个接口突然跑不通了，一直报504错误。\n看了下代码，这个接口是做了本地代理的mock数据接口，之前一直好好的。\n查了很久，检查了N遍代码，切了master分支，皆不行。不得已让同事跑了一下此项目，结果 —— 在他们那能正常运行。\n嗯，既然如此，真相只有一个：本地环境的问题。\n于是开始了漫长的试错与调试。\n尝试了如下方法，重装nodejs（怀疑是node 10.0.0的问题），重装node_module，重装gulp，干掉nginx，干掉其它一切可能占用端口的软件，甚至最后重启了电脑。结果 —— 全部铺盖。\n\n两个小时以后。。。\n\n算了，去node_module看源码吧（基本上80%把握确定是代理的问题）\n于是决定重头开始，仔细分析控制台的错误码，错误信息如下：\n\n```html\n[HPM] Error occurred while trying to proxy request /repay/get_api_info from localhost:8084 to http://localhost:8088 (ENOTFOUND) (https://nodejs.org/api/errors.html#errors_common_system_errors)\n```\n拿着此错误码google了一下，无果。大家遇到的错误都和我的不一样。即使有一样的也没有人解决。\n\n算了，还是去看看代理的源码吧。于是找到如下文件。\n\n```html\n/node_modules/http-proxy-middleware/lib/index.js\n```\n\n经过人肉搜索，终于找到抛出错误信息的位置（如下代码所示）。\n原来这个错误是经过加工的，而且真正抛出错误的地方还不是此模块，而是它依赖的另外一个模块（/node_modules/http-proxy）\n先不管这些，先将错误信息打印出来看看详细错误。（如下的console.log(err)）\n\n```javascript\nfunction logError(err, req, res) {\n  var hostname = (req.headers && req.headers.host) || (req.hostname || req.host);     // (websocket) || (node0.10 || node 4/5)\n  var target = proxyOptions.target.host || proxyOptions.target;\n  var errReference = 'https://nodejs.org/api/errors.html#errors_common_system_errors'; // link to Node Common Systems Errors page\n  // ------------>  在此处打印错误日志\n  console.log(err)\n  logger.error('[HPM] Error occurred while trying to proxy request %s from %s to %s (%s) (%s)', req.url, hostname, target, err.code, errReference);\n}\n```\n\n最终打印错误信息如下：\n\n```html\n{ Error: getaddrinfo ENOTFOUND localhost localhost:8088\n    at errnoException (dns.js:50:10)\n    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:92:26)\n  code: 'ENOTFOUND',\n  errno: 'ENOTFOUND',\n  syscall: 'getaddrinfo',\n  hostname: 'localhost',\n  host: 'localhost',\n  port: '8088' }\n```\n\ngoogle搜索了一下关键字 *getaddrinfo ENOTFOUND localhost*\n找到这个报错的原因，是本地的host没有绑定\n\n```shell\n127.0.0.1 localhost\n```\n\n嗯？应该有的啊，算了去hosts看看，这一看才发现不知道什么时候被注释掉了。\n于是，去除注释，npm run dev，\n咦？好了？wtf!!!!.\n\n事情经过就是这样，就这样解决了。\n\n### 分析总结\n分析：\n本来这个127.0.0.1 localhost是存在的，只是因为之前装了一个SwitchHosts软件，SwitchHosts会修改原来的文件/etc/hosts，将其内容剪切到另外的位置，也就是SwitchHosts软件存放host的位置的。同时会将默认的配置选项开启，所以正常情况是不会对原有的host造成影响的。\n于是我检查了一下我的host文件配置，发现原来是自己把SwitchHosts的那个基础配置选项关掉了，所以才导致找不到这个localhost。\n解决办法将其打开即可（当然，直接在hosts文件补上也行）。\n\n总结：\n此问题的解决和运气有一定的关系，同时，自己的解决问题的思路也有问题，浪费了很多时间。\n如果一开始就认真分析错误日志，可能早就解决了。\n\n---全文完---\n\n\n\n\n","slug":"proxy-error","published":1,"updated":"2021-03-30T01:32:00.323Z","comments":1,"photos":[],"link":"","_id":"ckn2g7ug3001da0vz3nn7fhxo","content":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>本来一天都开开心心，直到跑了一个npm run dev。<br>原本百分百没有问题的项目，npm run dev的时候某个接口突然跑不通了，一直报504错误。<br>看了下代码，这个接口是做了本地代理的mock数据接口，之前一直好好的。<br>查了很久，检查了N遍代码，切了master分支，皆不行。不得已让同事跑了一下此项目，结果 —— 在他们那能正常运行。<br>嗯，既然如此，真相只有一个：本地环境的问题。<br>于是开始了漫长的试错与调试。<br>尝试了如下方法，重装nodejs（怀疑是node 10.0.0的问题），重装node_module，重装gulp，干掉nginx，干掉其它一切可能占用端口的软件，甚至最后重启了电脑。结果 —— 全部铺盖。</p>\n<p>两个小时以后。。。</p>\n<p>算了，去node_module看源码吧（基本上80%把握确定是代理的问题）<br>于是决定重头开始，仔细分析控制台的错误码，错误信息如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HPM] Error occurred while trying to proxy request /repay/get_api_info from localhost:8084 to http://localhost:8088 (ENOTFOUND) (https://nodejs.org/api/errors.html#errors_common_system_errors)</span><br></pre></td></tr></table></figure>\n<p>拿着此错误码google了一下，无果。大家遇到的错误都和我的不一样。即使有一样的也没有人解决。</p>\n<p>算了，还是去看看代理的源码吧。于是找到如下文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/node_modules/http-proxy-middleware/lib/index.js</span><br></pre></td></tr></table></figure>\n<p>经过人肉搜索，终于找到抛出错误信息的位置（如下代码所示）。<br>原来这个错误是经过加工的，而且真正抛出错误的地方还不是此模块，而是它依赖的另外一个模块（/node_modules/http-proxy）<br>先不管这些，先将错误信息打印出来看看详细错误。（如下的console.log(err)）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logError</span>(<span class=\"params\">err, req, res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hostname = (req.headers &amp;&amp; req.headers.host) || (req.hostname || req.host);     <span class=\"comment\">// (websocket) || (node0.10 || node 4/5)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> target = proxyOptions.target.host || proxyOptions.target;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> errReference = <span class=\"string\">&#x27;https://nodejs.org/api/errors.html#errors_common_system_errors&#x27;</span>; <span class=\"comment\">// link to Node Common Systems Errors page</span></span><br><span class=\"line\">  <span class=\"comment\">// ------------&gt;  在此处打印错误日志</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">  logger.error(<span class=\"string\">&#x27;[HPM] Error occurred while trying to proxy request %s from %s to %s (%s) (%s)&#x27;</span>, req.url, hostname, target, err.code, errReference);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终打印错误信息如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; Error: getaddrinfo ENOTFOUND localhost localhost:8088</span><br><span class=\"line\">    at errnoException (dns.js:50:10)</span><br><span class=\"line\">    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:92:26)</span><br><span class=\"line\">  code: &#x27;ENOTFOUND&#x27;,</span><br><span class=\"line\">  errno: &#x27;ENOTFOUND&#x27;,</span><br><span class=\"line\">  syscall: &#x27;getaddrinfo&#x27;,</span><br><span class=\"line\">  hostname: &#x27;localhost&#x27;,</span><br><span class=\"line\">  host: &#x27;localhost&#x27;,</span><br><span class=\"line\">  port: &#x27;8088&#x27; &#125;</span><br></pre></td></tr></table></figure>\n<p>google搜索了一下关键字 <em>getaddrinfo ENOTFOUND localhost</em><br>找到这个报错的原因，是本地的host没有绑定</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1 localhost</span><br></pre></td></tr></table></figure>\n<p>嗯？应该有的啊，算了去hosts看看，这一看才发现不知道什么时候被注释掉了。<br>于是，去除注释，npm run dev，<br>咦？好了？wtf!!!!.</p>\n<p>事情经过就是这样，就这样解决了。</p>\n<h3 id=\"分析总结\"><a href=\"#分析总结\" class=\"headerlink\" title=\"分析总结\"></a>分析总结</h3><p>分析：<br>本来这个127.0.0.1 localhost是存在的，只是因为之前装了一个SwitchHosts软件，SwitchHosts会修改原来的文件/etc/hosts，将其内容剪切到另外的位置，也就是SwitchHosts软件存放host的位置的。同时会将默认的配置选项开启，所以正常情况是不会对原有的host造成影响的。<br>于是我检查了一下我的host文件配置，发现原来是自己把SwitchHosts的那个基础配置选项关掉了，所以才导致找不到这个localhost。<br>解决办法将其打开即可（当然，直接在hosts文件补上也行）。</p>\n<p>总结：<br>此问题的解决和运气有一定的关系，同时，自己的解决问题的思路也有问题，浪费了很多时间。<br>如果一开始就认真分析错误日志，可能早就解决了。</p>\n<p>—全文完—</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>本来一天都开开心心，直到跑了一个npm run dev。<br>原本百分百没有问题的项目，npm run dev的时候某个接口突然跑不通了，一直报504错误。<br>看了下代码，这个接口是做了本地代理的mock数据接口，之前一直好好的。<br>查了很久，检查了N遍代码，切了master分支，皆不行。不得已让同事跑了一下此项目，结果 —— 在他们那能正常运行。<br>嗯，既然如此，真相只有一个：本地环境的问题。<br>于是开始了漫长的试错与调试。<br>尝试了如下方法，重装nodejs（怀疑是node 10.0.0的问题），重装node_module，重装gulp，干掉nginx，干掉其它一切可能占用端口的软件，甚至最后重启了电脑。结果 —— 全部铺盖。</p>\n<p>两个小时以后。。。</p>\n<p>算了，去node_module看源码吧（基本上80%把握确定是代理的问题）<br>于是决定重头开始，仔细分析控制台的错误码，错误信息如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HPM] Error occurred while trying to proxy request /repay/get_api_info from localhost:8084 to http://localhost:8088 (ENOTFOUND) (https://nodejs.org/api/errors.html#errors_common_system_errors)</span><br></pre></td></tr></table></figure>\n<p>拿着此错误码google了一下，无果。大家遇到的错误都和我的不一样。即使有一样的也没有人解决。</p>\n<p>算了，还是去看看代理的源码吧。于是找到如下文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/node_modules/http-proxy-middleware/lib/index.js</span><br></pre></td></tr></table></figure>\n<p>经过人肉搜索，终于找到抛出错误信息的位置（如下代码所示）。<br>原来这个错误是经过加工的，而且真正抛出错误的地方还不是此模块，而是它依赖的另外一个模块（/node_modules/http-proxy）<br>先不管这些，先将错误信息打印出来看看详细错误。（如下的console.log(err)）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logError</span>(<span class=\"params\">err, req, res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hostname = (req.headers &amp;&amp; req.headers.host) || (req.hostname || req.host);     <span class=\"comment\">// (websocket) || (node0.10 || node 4/5)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> target = proxyOptions.target.host || proxyOptions.target;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> errReference = <span class=\"string\">&#x27;https://nodejs.org/api/errors.html#errors_common_system_errors&#x27;</span>; <span class=\"comment\">// link to Node Common Systems Errors page</span></span><br><span class=\"line\">  <span class=\"comment\">// ------------&gt;  在此处打印错误日志</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">  logger.error(<span class=\"string\">&#x27;[HPM] Error occurred while trying to proxy request %s from %s to %s (%s) (%s)&#x27;</span>, req.url, hostname, target, err.code, errReference);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终打印错误信息如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; Error: getaddrinfo ENOTFOUND localhost localhost:8088</span><br><span class=\"line\">    at errnoException (dns.js:50:10)</span><br><span class=\"line\">    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:92:26)</span><br><span class=\"line\">  code: &#x27;ENOTFOUND&#x27;,</span><br><span class=\"line\">  errno: &#x27;ENOTFOUND&#x27;,</span><br><span class=\"line\">  syscall: &#x27;getaddrinfo&#x27;,</span><br><span class=\"line\">  hostname: &#x27;localhost&#x27;,</span><br><span class=\"line\">  host: &#x27;localhost&#x27;,</span><br><span class=\"line\">  port: &#x27;8088&#x27; &#125;</span><br></pre></td></tr></table></figure>\n<p>google搜索了一下关键字 <em>getaddrinfo ENOTFOUND localhost</em><br>找到这个报错的原因，是本地的host没有绑定</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1 localhost</span><br></pre></td></tr></table></figure>\n<p>嗯？应该有的啊，算了去hosts看看，这一看才发现不知道什么时候被注释掉了。<br>于是，去除注释，npm run dev，<br>咦？好了？wtf!!!!.</p>\n<p>事情经过就是这样，就这样解决了。</p>\n<h3 id=\"分析总结\"><a href=\"#分析总结\" class=\"headerlink\" title=\"分析总结\"></a>分析总结</h3><p>分析：<br>本来这个127.0.0.1 localhost是存在的，只是因为之前装了一个SwitchHosts软件，SwitchHosts会修改原来的文件/etc/hosts，将其内容剪切到另外的位置，也就是SwitchHosts软件存放host的位置的。同时会将默认的配置选项开启，所以正常情况是不会对原有的host造成影响的。<br>于是我检查了一下我的host文件配置，发现原来是自己把SwitchHosts的那个基础配置选项关掉了，所以才导致找不到这个localhost。<br>解决办法将其打开即可（当然，直接在hosts文件补上也行）。</p>\n<p>总结：<br>此问题的解决和运气有一定的关系，同时，自己的解决问题的思路也有问题，浪费了很多时间。<br>如果一开始就认真分析错误日志，可能早就解决了。</p>\n<p>—全文完—</p>\n"},{"title":"手写apply/call/bind/new等代码","date":"2020-09-29T16:00:00.000Z","_content":"\n1.手写 apply\n```javascript\nFunction.prototype.apply1 = function(context = window, args) {\n  const fn = Symbol('fn')\n  context[fn] = this\n  const res = context[fn](...args)\n  delete context[fn]\n  return res\n}\n\n// 思路：将要改变this指向的方法挂到目标this上执行并返回\nFunction.prototype.apply2 = function (context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('not funciton')\n  }\n  context = context || window\n  context.fn = this\n  let result\n  if (arguments[1]) {\n    result = context.fn(...arguments[1])\n  } else {\n    result = context.fn()\n  }\n  delete context.fn\n  return result\n}\n```\n2.手写 call\n```javascript\nFunction.prototype.call1 = function(context = window, ...args) {\n  const fn = Symbol('fn')\n  context[fn] = this\n  const res = context[fn](...args)\n  delete context[fn]\n  return res\n}\n\n// 思路：将要改变this指向的方法挂到目标this上执行并返回\nFunction.prototype.call2 = function (context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('not funciton')\n  }\n  context = context || window\n  context.fn = this\n  let arg = [...arguments].slice(1)\n  let result = context.fn(...arg)\n  delete context.fn\n  return result\n} \n```\n3.手写 bind 方法\n```javascript\nFunction.prototype.bind1 = function(context, ...args) {\n  let self = this\n  return function F() {\n    if (this instanceof F) {\n      return new self(...args, ...arguments)\n    }\n    return self.apply(context, [...args, ...arguments])\n  }\n}\n\n\n// 思路：类似call，但返回的是函数\nFunction.prototype.bind2 = function (context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  let _this = this\n  let arg = [...arguments].slice(1)\n  return function F() {\n    // 处理函数使用new的情况\n    if (this instanceof F) {\n      return new _this(...arg, ...arguments)\n    } else {\n      return _this.apply(context, arg.concat(...arguments))\n    }\n  }\n}\n```\n\n测试代码：\n```javascript\nvar obj = {\n  a: 1,\n  showA(n, m) {\n    return this.a + n + m\n  },\n}\nfunction test1() {\n  this.a = 4\n  var s = obj.showA.bind(this, 10)\n  console.log('result:',s(20)) // 34\n}\nfunction test2() {\n  this.a = 2\n  var s = obj.showA.apply(this, [1, 2])\n  console.log('result:', s) // 5\n}\nfunction test3() {\n  this.a = 3\n  var s = obj.showA.call(this, 2, 3)\n  console.log('result:', s) // 8\n}\ntest1()\ntest2()\ntest3()\n```\n\n4.实现一个 new\nnew 关键字调用的基本过程\n1）创建一个新对象\n2）继承父类原型的方法\n3）添加父类属性到新对象上，并初始化，并保存方法的执行结果\n4）如果执行结果有返回值，并且是一个对象，返回执行的结果，否则返回新创建的对象\n\n```javascript\nfunction _new1(obj, ...args) {\n  var newObj = Object.create(obj.prototype)\n  var result = obj.apply(newObj, args) // obj里面的this变成了newObj，所以，newObj有了obj的属性\n  return (typeof result === 'object' && result !== null ) ? result : newObj\n}\n\nfunction _new2 (fun) {\n  return function () {\n    // 创建一个新对象且将其隐式原型指向构造函数原型\n    let obj = {\n      __proto__ : fun.prototype\n    }\n    // 执行构造函数\n    fun.call(obj, ...arguments)\n    // 返回该对象\n    return obj\n  }\n}\n\nfunction Person(firstName, lastName) {\n  this.firstName = firstName\n  this.lastName = lastName\n}\nPerson.prototype.getFullName = function() {\n  return this.firstName + ' ' + this.lastName\n}\nvar newPerson = new Person('jack', 'bob')\nvar _newPerson = _new(Person, 'jack', 'bob')\n```\n\n5.手写instanceof\n```javascript\n// 思路：右边变量的原型存在于左边变量的原型链上\nfunction instanceOf(left, right) {\n  let leftValue = left.__proto__\n  let rightValue = right.prototype\n  while (true) {\n    if (leftValue === null) {\n      return false\n    }\n    if (leftValue === rightValue) {\n      return true\n    }\n    leftValue = leftValue.__proto__\n  }\n}\n```\n\n6.手写create\n```javascript\n// 思路：将传入的对象作为原型\nfunction create(obj) {\n  function F() {}\n  F.prototype = obj\n  return new F()\n}\n```\n","source":"_posts/qa1.md","raw":"---\ntitle: 手写apply/call/bind/new等代码\ndate: 2020/09/30\ntag: [基础,apply,call,bind,new,instance,create]\ncategory: 技术\n---\n\n1.手写 apply\n```javascript\nFunction.prototype.apply1 = function(context = window, args) {\n  const fn = Symbol('fn')\n  context[fn] = this\n  const res = context[fn](...args)\n  delete context[fn]\n  return res\n}\n\n// 思路：将要改变this指向的方法挂到目标this上执行并返回\nFunction.prototype.apply2 = function (context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('not funciton')\n  }\n  context = context || window\n  context.fn = this\n  let result\n  if (arguments[1]) {\n    result = context.fn(...arguments[1])\n  } else {\n    result = context.fn()\n  }\n  delete context.fn\n  return result\n}\n```\n2.手写 call\n```javascript\nFunction.prototype.call1 = function(context = window, ...args) {\n  const fn = Symbol('fn')\n  context[fn] = this\n  const res = context[fn](...args)\n  delete context[fn]\n  return res\n}\n\n// 思路：将要改变this指向的方法挂到目标this上执行并返回\nFunction.prototype.call2 = function (context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('not funciton')\n  }\n  context = context || window\n  context.fn = this\n  let arg = [...arguments].slice(1)\n  let result = context.fn(...arg)\n  delete context.fn\n  return result\n} \n```\n3.手写 bind 方法\n```javascript\nFunction.prototype.bind1 = function(context, ...args) {\n  let self = this\n  return function F() {\n    if (this instanceof F) {\n      return new self(...args, ...arguments)\n    }\n    return self.apply(context, [...args, ...arguments])\n  }\n}\n\n\n// 思路：类似call，但返回的是函数\nFunction.prototype.bind2 = function (context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  let _this = this\n  let arg = [...arguments].slice(1)\n  return function F() {\n    // 处理函数使用new的情况\n    if (this instanceof F) {\n      return new _this(...arg, ...arguments)\n    } else {\n      return _this.apply(context, arg.concat(...arguments))\n    }\n  }\n}\n```\n\n测试代码：\n```javascript\nvar obj = {\n  a: 1,\n  showA(n, m) {\n    return this.a + n + m\n  },\n}\nfunction test1() {\n  this.a = 4\n  var s = obj.showA.bind(this, 10)\n  console.log('result:',s(20)) // 34\n}\nfunction test2() {\n  this.a = 2\n  var s = obj.showA.apply(this, [1, 2])\n  console.log('result:', s) // 5\n}\nfunction test3() {\n  this.a = 3\n  var s = obj.showA.call(this, 2, 3)\n  console.log('result:', s) // 8\n}\ntest1()\ntest2()\ntest3()\n```\n\n4.实现一个 new\nnew 关键字调用的基本过程\n1）创建一个新对象\n2）继承父类原型的方法\n3）添加父类属性到新对象上，并初始化，并保存方法的执行结果\n4）如果执行结果有返回值，并且是一个对象，返回执行的结果，否则返回新创建的对象\n\n```javascript\nfunction _new1(obj, ...args) {\n  var newObj = Object.create(obj.prototype)\n  var result = obj.apply(newObj, args) // obj里面的this变成了newObj，所以，newObj有了obj的属性\n  return (typeof result === 'object' && result !== null ) ? result : newObj\n}\n\nfunction _new2 (fun) {\n  return function () {\n    // 创建一个新对象且将其隐式原型指向构造函数原型\n    let obj = {\n      __proto__ : fun.prototype\n    }\n    // 执行构造函数\n    fun.call(obj, ...arguments)\n    // 返回该对象\n    return obj\n  }\n}\n\nfunction Person(firstName, lastName) {\n  this.firstName = firstName\n  this.lastName = lastName\n}\nPerson.prototype.getFullName = function() {\n  return this.firstName + ' ' + this.lastName\n}\nvar newPerson = new Person('jack', 'bob')\nvar _newPerson = _new(Person, 'jack', 'bob')\n```\n\n5.手写instanceof\n```javascript\n// 思路：右边变量的原型存在于左边变量的原型链上\nfunction instanceOf(left, right) {\n  let leftValue = left.__proto__\n  let rightValue = right.prototype\n  while (true) {\n    if (leftValue === null) {\n      return false\n    }\n    if (leftValue === rightValue) {\n      return true\n    }\n    leftValue = leftValue.__proto__\n  }\n}\n```\n\n6.手写create\n```javascript\n// 思路：将传入的对象作为原型\nfunction create(obj) {\n  function F() {}\n  F.prototype = obj\n  return new F()\n}\n```\n","slug":"qa1","published":1,"updated":"2021-03-30T01:32:00.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug3001ea0vz8co81pjr","content":"<p>1.手写 apply<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.apply1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context = <span class=\"built_in\">window</span>, args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;fn&#x27;</span>)</span><br><span class=\"line\">  context[fn] = <span class=\"built_in\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = context[fn](...args)</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context[fn]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 思路：将要改变this指向的方法挂到目标this上执行并返回</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.apply2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">this</span> !== <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&#x27;not funciton&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  context = context || <span class=\"built_in\">window</span></span><br><span class=\"line\">  context.fn = <span class=\"built_in\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">    result = context.fn(...arguments[<span class=\"number\">1</span>])</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    result = context.fn()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context.fn</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>2.手写 call<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.call1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context = <span class=\"built_in\">window</span>, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;fn&#x27;</span>)</span><br><span class=\"line\">  context[fn] = <span class=\"built_in\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = context[fn](...args)</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context[fn]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 思路：将要改变this指向的方法挂到目标this上执行并返回</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.call2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">this</span> !== <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&#x27;not funciton&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  context = context || <span class=\"built_in\">window</span></span><br><span class=\"line\">  context.fn = <span class=\"built_in\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg = [...arguments].slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = context.fn(...arg)</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context.fn</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure><br>3.手写 bind 方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"built_in\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> <span class=\"keyword\">instanceof</span> F) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> self(...args, ...arguments)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.apply(context, [...args, ...arguments])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 思路：类似call，但返回的是函数</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">this</span> !== <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&#x27;Error&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _this = <span class=\"built_in\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg = [...arguments].slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理函数使用new的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> <span class=\"keyword\">instanceof</span> F) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _this(...arg, ...arguments)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _this.apply(context, arg.concat(...arguments))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">showA</span>(<span class=\"params\">n, m</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.a + n + m</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.a = <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = obj.showA.bind(<span class=\"built_in\">this</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;result:&#x27;</span>,s(<span class=\"number\">20</span>)) <span class=\"comment\">// 34</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.a = <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = obj.showA.apply(<span class=\"built_in\">this</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;result:&#x27;</span>, s) <span class=\"comment\">// 5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.a = <span class=\"number\">3</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = obj.showA.call(<span class=\"built_in\">this</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;result:&#x27;</span>, s) <span class=\"comment\">// 8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test1()</span><br><span class=\"line\">test2()</span><br><span class=\"line\">test3()</span><br></pre></td></tr></table></figure></p>\n<p>4.实现一个 new<br>new 关键字调用的基本过程<br>1）创建一个新对象<br>2）继承父类原型的方法<br>3）添加父类属性到新对象上，并初始化，并保存方法的执行结果<br>4）如果执行结果有返回值，并且是一个对象，返回执行的结果，否则返回新创建的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_new1</span>(<span class=\"params\">obj, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = <span class=\"built_in\">Object</span>.create(obj.prototype)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = obj.apply(newObj, args) <span class=\"comment\">// obj里面的this变成了newObj，所以，newObj有了obj的属性</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">typeof</span> result === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; result !== <span class=\"literal\">null</span> ) ? result : newObj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_new2</span> (<span class=\"params\">fun</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个新对象且将其隐式原型指向构造函数原型</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">      __proto__ : fun.prototype</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 执行构造函数</span></span><br><span class=\"line\">    fun.call(obj, ...arguments)</span><br><span class=\"line\">    <span class=\"comment\">// 返回该对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">firstName, lastName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.firstName = firstName</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.lastName = lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.getFullName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.firstName + <span class=\"string\">&#x27; &#x27;</span> + <span class=\"built_in\">this</span>.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newPerson = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"string\">&#x27;bob&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> _newPerson = _new(Person, <span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"string\">&#x27;bob&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>5.手写instanceof<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 思路：右边变量的原型存在于左边变量的原型链上</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">instanceOf</span>(<span class=\"params\">left, right</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> leftValue = left.__proto__</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rightValue = right.prototype</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leftValue === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leftValue === rightValue) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    leftValue = leftValue.__proto__</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>6.手写create<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 思路：将传入的对象作为原型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = obj</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.手写 apply<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.apply1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context = <span class=\"built_in\">window</span>, args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;fn&#x27;</span>)</span><br><span class=\"line\">  context[fn] = <span class=\"built_in\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = context[fn](...args)</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context[fn]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 思路：将要改变this指向的方法挂到目标this上执行并返回</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.apply2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">this</span> !== <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&#x27;not funciton&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  context = context || <span class=\"built_in\">window</span></span><br><span class=\"line\">  context.fn = <span class=\"built_in\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">    result = context.fn(...arguments[<span class=\"number\">1</span>])</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    result = context.fn()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context.fn</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>2.手写 call<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.call1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context = <span class=\"built_in\">window</span>, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fn = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;fn&#x27;</span>)</span><br><span class=\"line\">  context[fn] = <span class=\"built_in\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = context[fn](...args)</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context[fn]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 思路：将要改变this指向的方法挂到目标this上执行并返回</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.call2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">this</span> !== <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&#x27;not funciton&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  context = context || <span class=\"built_in\">window</span></span><br><span class=\"line\">  context.fn = <span class=\"built_in\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg = [...arguments].slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = context.fn(...arg)</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> context.fn</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure><br>3.手写 bind 方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"built_in\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> <span class=\"keyword\">instanceof</span> F) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> self(...args, ...arguments)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.apply(context, [...args, ...arguments])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 思路：类似call，但返回的是函数</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">this</span> !== <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&#x27;Error&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _this = <span class=\"built_in\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg = [...arguments].slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理函数使用new的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> <span class=\"keyword\">instanceof</span> F) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _this(...arg, ...arguments)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _this.apply(context, arg.concat(...arguments))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">showA</span>(<span class=\"params\">n, m</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.a + n + m</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.a = <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = obj.showA.bind(<span class=\"built_in\">this</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;result:&#x27;</span>,s(<span class=\"number\">20</span>)) <span class=\"comment\">// 34</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.a = <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = obj.showA.apply(<span class=\"built_in\">this</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;result:&#x27;</span>, s) <span class=\"comment\">// 5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.a = <span class=\"number\">3</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> s = obj.showA.call(<span class=\"built_in\">this</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;result:&#x27;</span>, s) <span class=\"comment\">// 8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test1()</span><br><span class=\"line\">test2()</span><br><span class=\"line\">test3()</span><br></pre></td></tr></table></figure></p>\n<p>4.实现一个 new<br>new 关键字调用的基本过程<br>1）创建一个新对象<br>2）继承父类原型的方法<br>3）添加父类属性到新对象上，并初始化，并保存方法的执行结果<br>4）如果执行结果有返回值，并且是一个对象，返回执行的结果，否则返回新创建的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_new1</span>(<span class=\"params\">obj, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = <span class=\"built_in\">Object</span>.create(obj.prototype)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = obj.apply(newObj, args) <span class=\"comment\">// obj里面的this变成了newObj，所以，newObj有了obj的属性</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">typeof</span> result === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; result !== <span class=\"literal\">null</span> ) ? result : newObj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_new2</span> (<span class=\"params\">fun</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个新对象且将其隐式原型指向构造函数原型</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">      __proto__ : fun.prototype</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 执行构造函数</span></span><br><span class=\"line\">    fun.call(obj, ...arguments)</span><br><span class=\"line\">    <span class=\"comment\">// 返回该对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">firstName, lastName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.firstName = firstName</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.lastName = lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.getFullName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.firstName + <span class=\"string\">&#x27; &#x27;</span> + <span class=\"built_in\">this</span>.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newPerson = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"string\">&#x27;bob&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> _newPerson = _new(Person, <span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"string\">&#x27;bob&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>5.手写instanceof<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 思路：右边变量的原型存在于左边变量的原型链上</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">instanceOf</span>(<span class=\"params\">left, right</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> leftValue = left.__proto__</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rightValue = right.prototype</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leftValue === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leftValue === rightValue) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    leftValue = leftValue.__proto__</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>6.手写create<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 思路：将传入的对象作为原型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = obj</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"js的简单排序算法","date":"2020-09-30T16:00:00.000Z","_content":"\n1.冒泡排序如何实现，时间复杂度是多少，如何改进\n```javascript\nvar arr = [1,8,4,5,7,9,6,2,3]\nfunction swap(arr, i, j) {\n  var temp = arr[i]\n  arr[i] = arr[j]\n  arr[j] = temp\n}\nfunction bubbleSort1(arr) { // O(n^2\n  for (var i = 0; i < arr.length - 1; i++) {\n    var flag = true\n    for (var j = 0; j < arr.length - 1 - i; j++) {\n      if (arr[j] > arr[j+1]) {\n        swap(arr, j, j+1)\n        flag = false\n      }\n    }\n    if (flag) {\n      break\n    }\n  }\n  return arr\n}\nfunction bubbleSort2(arr) {\n  var endPos = arr.length - 1\n  while(endPos > 0) {\n    var thisTurnEndPos = endPos\n    for (var i = 0; i < thisTurnEndPos; i++) {\n      if (arr[i] > arr[i+1]) {\n        swap(arr, i, i+1)\n        endPos = i // 记录本次循环最后交换的位置\n      }\n    }\n    if (thisTurnEndPos === endPos) { // 如果最后交换的位置不变则说明整体有序，排序完成\n      return arr\n    }\n  }\n  return arr\n}\n\nfunction bubbleSort3(arr) {\n  var start = 0\n  var end = arr.length - 1\n  var startPos = start\n  var endPos = end\n  while (start < end) {\n    var isSorted = true\n    for (var i = start; i < end; i++) {\n      if (arr[i] > arr[i+1]) {\n        swap(arr, i, i+1)\n        endPos = i\n        isSorted = false\n      }\n    }\n    if (isSorted) return arr\n    end = endPos\n\n    for (var j = end; j > start; j--) {\n      if (arr[j] < arr[j-1]) {\n        swap(arr, j, j-1)\n        startPos = j\n        isSorted = false\n      }\n    }\n    if (isSorted) return arr\n    start = startPos\n  }\n  return arr\n}\nvar s0 = Date.now()\nbubbleSort1([].concat(arr))\nvar s1 = Date.now()\nbubbleSort2([].concat(arr))\nvar s2 = Date.now()\nbubbleSort3([].concat(arr))\nvar s3 = Date.now()\nconsole.log(s1-s0, s2-s1, s3-s2)\n```\n冒泡排序平均时间复杂度是O(n\\*n)，最好的情况是O(n)、最差的情况是O(n\\*n)\n空间复杂度是O(1)\n特点：外层for循环控制循环次数、内层for循环进行两数交换，找出最大的数放到最后\n改进：\n1）处理在排序过程中数组整体已经有序的情况，设置标志位\n2）数组局部有序，遍历过程中记录最后一次交换的位置，设置为下一次交换的终点\n3）同时将最大最小值归位，双向冒泡排序\n\n\n2.实现一个快速排序算法\n```javascript\n/**\n * 快速排序\n * 1.选择一个基准\n * 2.遍历，小于基准放左边，大于基准放右边\n * 3.递归\n * @param arr \n */\nfunction quickSort(arr) {\n  if (arr.length <= 1) return arr\n  var pivotIndex = Math.floor(arr.length / 2)\n  var pivot = arr.splice(pivotIndex, 1)\n  var left = []\n  var right = []\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] < pivot) {\n      left.push(arr[i])\n    } else {\n      right.push(arr[i])\n    }\n  }\n  return quickSort(left).concat(pivot).concat(quickSort(right))\n}\n\nvar arr = [1, 8, 4, 5, 7, 9, 6, 2, 3]\nquickSort(arr)\n```\n3.实现插入排序算法\n1）循环数组，每次取一个数，判断是否比已排序数最大的大\n2）如果大则放在后面，如果小则继续比较，如果最小则放在最前面\n\n```javascript\n/**\n * 插入排序1\n */\nfunction insertSort(arr) {\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = i - 1; j >= 0; j--) {\n      if (arr[i] >= arr[j]) {\n        arr.splice(j + 1, 0, arr.splice(i, 1)[0])\n        break\n      } else if (j === 0) {\n        arr.splice(j, 0, arr.splice(i, 1)[0])\n      }\n    }\n  }\n  return arr\n}\n/**\n * 插入排序2\n */\nfunction insertSort(arr) {\n  if (arr.length <= 1) return arr\n  var newArr = arr.splice(0, 1)\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = newArr.length - 1; j >= 0; j--) {\n      if (arr[i] >= newArr[j]) {\n        newArr.splice(j + 1, 0, arr[i])\n        break\n      } else if (j === 0) {\n        newArr.unshift(arr[i])\n      }\n    }\n  }\n  return newArr\n}\n\nvar arr = [1, 8, 4, 5, 7, 9, 6, 2, 3]\ninsertSort(arr)\n```\n\n4.实现选择排序算法\n每次循环选取一个最小的数字放到前面的有序序列中\n\n```javascript\nfunction swap(arr, i, j) {\n  var temp = arr[i]\n  arr[i] = arr[j]\n  arr[j] = temp\n}\nfunction selectSort(arr) {\n  for (var i = 0; i < arr.length; i++) {\n    var minIndex = i\n    for (var j = i + 1; j < arr.length; j++) {\n      if (arr[j] < arr[minIndex]) {\n        minIndex = j\n      }\n    }\n    swap(arr, i, minIndex)\n  }\n  return arr\n}\n\nvar arr = [1, 8, 4, 5, 7, 9, 6, 2, 3]\nselectSort(arr)\n```\n","source":"_posts/qa2.md","raw":"---\ntitle: js的简单排序算法\ndate: 2020/09/31\ntag: [基础,冒泡算法,选择算法,快速算法,插入算法,算法]\ncategory: 技术\n---\n\n1.冒泡排序如何实现，时间复杂度是多少，如何改进\n```javascript\nvar arr = [1,8,4,5,7,9,6,2,3]\nfunction swap(arr, i, j) {\n  var temp = arr[i]\n  arr[i] = arr[j]\n  arr[j] = temp\n}\nfunction bubbleSort1(arr) { // O(n^2\n  for (var i = 0; i < arr.length - 1; i++) {\n    var flag = true\n    for (var j = 0; j < arr.length - 1 - i; j++) {\n      if (arr[j] > arr[j+1]) {\n        swap(arr, j, j+1)\n        flag = false\n      }\n    }\n    if (flag) {\n      break\n    }\n  }\n  return arr\n}\nfunction bubbleSort2(arr) {\n  var endPos = arr.length - 1\n  while(endPos > 0) {\n    var thisTurnEndPos = endPos\n    for (var i = 0; i < thisTurnEndPos; i++) {\n      if (arr[i] > arr[i+1]) {\n        swap(arr, i, i+1)\n        endPos = i // 记录本次循环最后交换的位置\n      }\n    }\n    if (thisTurnEndPos === endPos) { // 如果最后交换的位置不变则说明整体有序，排序完成\n      return arr\n    }\n  }\n  return arr\n}\n\nfunction bubbleSort3(arr) {\n  var start = 0\n  var end = arr.length - 1\n  var startPos = start\n  var endPos = end\n  while (start < end) {\n    var isSorted = true\n    for (var i = start; i < end; i++) {\n      if (arr[i] > arr[i+1]) {\n        swap(arr, i, i+1)\n        endPos = i\n        isSorted = false\n      }\n    }\n    if (isSorted) return arr\n    end = endPos\n\n    for (var j = end; j > start; j--) {\n      if (arr[j] < arr[j-1]) {\n        swap(arr, j, j-1)\n        startPos = j\n        isSorted = false\n      }\n    }\n    if (isSorted) return arr\n    start = startPos\n  }\n  return arr\n}\nvar s0 = Date.now()\nbubbleSort1([].concat(arr))\nvar s1 = Date.now()\nbubbleSort2([].concat(arr))\nvar s2 = Date.now()\nbubbleSort3([].concat(arr))\nvar s3 = Date.now()\nconsole.log(s1-s0, s2-s1, s3-s2)\n```\n冒泡排序平均时间复杂度是O(n\\*n)，最好的情况是O(n)、最差的情况是O(n\\*n)\n空间复杂度是O(1)\n特点：外层for循环控制循环次数、内层for循环进行两数交换，找出最大的数放到最后\n改进：\n1）处理在排序过程中数组整体已经有序的情况，设置标志位\n2）数组局部有序，遍历过程中记录最后一次交换的位置，设置为下一次交换的终点\n3）同时将最大最小值归位，双向冒泡排序\n\n\n2.实现一个快速排序算法\n```javascript\n/**\n * 快速排序\n * 1.选择一个基准\n * 2.遍历，小于基准放左边，大于基准放右边\n * 3.递归\n * @param arr \n */\nfunction quickSort(arr) {\n  if (arr.length <= 1) return arr\n  var pivotIndex = Math.floor(arr.length / 2)\n  var pivot = arr.splice(pivotIndex, 1)\n  var left = []\n  var right = []\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] < pivot) {\n      left.push(arr[i])\n    } else {\n      right.push(arr[i])\n    }\n  }\n  return quickSort(left).concat(pivot).concat(quickSort(right))\n}\n\nvar arr = [1, 8, 4, 5, 7, 9, 6, 2, 3]\nquickSort(arr)\n```\n3.实现插入排序算法\n1）循环数组，每次取一个数，判断是否比已排序数最大的大\n2）如果大则放在后面，如果小则继续比较，如果最小则放在最前面\n\n```javascript\n/**\n * 插入排序1\n */\nfunction insertSort(arr) {\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = i - 1; j >= 0; j--) {\n      if (arr[i] >= arr[j]) {\n        arr.splice(j + 1, 0, arr.splice(i, 1)[0])\n        break\n      } else if (j === 0) {\n        arr.splice(j, 0, arr.splice(i, 1)[0])\n      }\n    }\n  }\n  return arr\n}\n/**\n * 插入排序2\n */\nfunction insertSort(arr) {\n  if (arr.length <= 1) return arr\n  var newArr = arr.splice(0, 1)\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = newArr.length - 1; j >= 0; j--) {\n      if (arr[i] >= newArr[j]) {\n        newArr.splice(j + 1, 0, arr[i])\n        break\n      } else if (j === 0) {\n        newArr.unshift(arr[i])\n      }\n    }\n  }\n  return newArr\n}\n\nvar arr = [1, 8, 4, 5, 7, 9, 6, 2, 3]\ninsertSort(arr)\n```\n\n4.实现选择排序算法\n每次循环选取一个最小的数字放到前面的有序序列中\n\n```javascript\nfunction swap(arr, i, j) {\n  var temp = arr[i]\n  arr[i] = arr[j]\n  arr[j] = temp\n}\nfunction selectSort(arr) {\n  for (var i = 0; i < arr.length; i++) {\n    var minIndex = i\n    for (var j = i + 1; j < arr.length; j++) {\n      if (arr[j] < arr[minIndex]) {\n        minIndex = j\n      }\n    }\n    swap(arr, i, minIndex)\n  }\n  return arr\n}\n\nvar arr = [1, 8, 4, 5, 7, 9, 6, 2, 3]\nselectSort(arr)\n```\n","slug":"qa2","published":1,"updated":"2021-03-30T01:32:00.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug4001fa0vz3rodeq56","content":"<p>1.冒泡排序如何实现，时间复杂度是多少，如何改进<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">6</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">arr, i, j</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> temp = arr[i]</span><br><span class=\"line\">  arr[i] = arr[j]</span><br><span class=\"line\">  arr[j] = temp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort1</span>(<span class=\"params\">arr</span>) </span>&#123; <span class=\"comment\">// O(n^2</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> flag = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; arr.length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(arr, j, j+<span class=\"number\">1</span>)</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort2</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> endPos = arr.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">while</span>(<span class=\"params\">endPos &gt; <span class=\"number\">0</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> thisTurnEndPos = endPos</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; thisTurnEndPos; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] &gt; arr[i+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(arr, i, i+<span class=\"number\">1</span>)</span><br><span class=\"line\">        endPos = i <span class=\"comment\">// 记录本次循环最后交换的位置</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (thisTurnEndPos === endPos) &#123; <span class=\"comment\">// 如果最后交换的位置不变则说明整体有序，排序完成</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort3</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> start = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> end = arr.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> startPos = start</span><br><span class=\"line\">  <span class=\"keyword\">var</span> endPos = end</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (start &lt; end) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isSorted = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = start; i &lt; end; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] &gt; arr[i+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(arr, i, i+<span class=\"number\">1</span>)</span><br><span class=\"line\">        endPos = i</span><br><span class=\"line\">        isSorted = <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSorted) <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">    end = endPos</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = end; j &gt; start; j--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arr[j-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(arr, j, j-<span class=\"number\">1</span>)</span><br><span class=\"line\">        startPos = j</span><br><span class=\"line\">        isSorted = <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSorted) <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">    start = startPos</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s0 = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">bubbleSort1([].concat(arr))</span><br><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">bubbleSort2([].concat(arr))</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">bubbleSort3([].concat(arr))</span><br><span class=\"line\"><span class=\"keyword\">var</span> s3 = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s1-s0, s2-s1, s3-s2)</span><br></pre></td></tr></table></figure><br>冒泡排序平均时间复杂度是O(n*n)，最好的情况是O(n)、最差的情况是O(n*n)<br>空间复杂度是O(1)<br>特点：外层for循环控制循环次数、内层for循环进行两数交换，找出最大的数放到最后<br>改进：<br>1）处理在排序过程中数组整体已经有序的情况，设置标志位<br>2）数组局部有序，遍历过程中记录最后一次交换的位置，设置为下一次交换的终点<br>3）同时将最大最小值归位，双向冒泡排序</p>\n<p>2.实现一个快速排序算法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 快速排序</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.选择一个基准</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.遍历，小于基准放左边，大于基准放右边</span></span><br><span class=\"line\"><span class=\"comment\"> * 3.递归</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>arr </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">  <span class=\"keyword\">var</span> pivotIndex = <span class=\"built_in\">Math</span>.floor(arr.length / <span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> pivot = arr.splice(pivotIndex, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> right = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class=\"line\">      left.push(arr[i])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      right.push(arr[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quickSort(left).concat(pivot).concat(quickSort(right))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">quickSort(arr)</span><br></pre></td></tr></table></figure><br>3.实现插入排序算法<br>1）循环数组，每次取一个数，判断是否比已排序数最大的大<br>2）如果大则放在后面，如果小则继续比较，如果最小则放在最前面</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 插入排序1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] &gt;= arr[j]) &#123;</span><br><span class=\"line\">        arr.splice(j + <span class=\"number\">1</span>, <span class=\"number\">0</span>, arr.splice(i, <span class=\"number\">1</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        arr.splice(j, <span class=\"number\">0</span>, arr.splice(i, <span class=\"number\">1</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 插入排序2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newArr = arr.splice(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = newArr.length - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] &gt;= newArr[j]) &#123;</span><br><span class=\"line\">        newArr.splice(j + <span class=\"number\">1</span>, <span class=\"number\">0</span>, arr[i])</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        newArr.unshift(arr[i])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newArr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">insertSort(arr)</span><br></pre></td></tr></table></figure>\n<p>4.实现选择排序算法<br>每次循环选取一个最小的数字放到前面的有序序列中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">arr, i, j</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> temp = arr[i]</span><br><span class=\"line\">  arr[i] = arr[j]</span><br><span class=\"line\">  arr[j] = temp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> minIndex = i</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class=\"line\">        minIndex = j</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swap(arr, i, minIndex)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">selectSort(arr)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>1.冒泡排序如何实现，时间复杂度是多少，如何改进<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">6</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">arr, i, j</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> temp = arr[i]</span><br><span class=\"line\">  arr[i] = arr[j]</span><br><span class=\"line\">  arr[j] = temp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort1</span>(<span class=\"params\">arr</span>) </span>&#123; <span class=\"comment\">// O(n^2</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> flag = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; arr.length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(arr, j, j+<span class=\"number\">1</span>)</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort2</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> endPos = arr.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">while</span>(<span class=\"params\">endPos &gt; <span class=\"number\">0</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> thisTurnEndPos = endPos</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; thisTurnEndPos; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] &gt; arr[i+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(arr, i, i+<span class=\"number\">1</span>)</span><br><span class=\"line\">        endPos = i <span class=\"comment\">// 记录本次循环最后交换的位置</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (thisTurnEndPos === endPos) &#123; <span class=\"comment\">// 如果最后交换的位置不变则说明整体有序，排序完成</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort3</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> start = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> end = arr.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> startPos = start</span><br><span class=\"line\">  <span class=\"keyword\">var</span> endPos = end</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (start &lt; end) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isSorted = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = start; i &lt; end; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] &gt; arr[i+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(arr, i, i+<span class=\"number\">1</span>)</span><br><span class=\"line\">        endPos = i</span><br><span class=\"line\">        isSorted = <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSorted) <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">    end = endPos</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = end; j &gt; start; j--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arr[j-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(arr, j, j-<span class=\"number\">1</span>)</span><br><span class=\"line\">        startPos = j</span><br><span class=\"line\">        isSorted = <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSorted) <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">    start = startPos</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s0 = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">bubbleSort1([].concat(arr))</span><br><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">bubbleSort2([].concat(arr))</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">bubbleSort3([].concat(arr))</span><br><span class=\"line\"><span class=\"keyword\">var</span> s3 = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s1-s0, s2-s1, s3-s2)</span><br></pre></td></tr></table></figure><br>冒泡排序平均时间复杂度是O(n*n)，最好的情况是O(n)、最差的情况是O(n*n)<br>空间复杂度是O(1)<br>特点：外层for循环控制循环次数、内层for循环进行两数交换，找出最大的数放到最后<br>改进：<br>1）处理在排序过程中数组整体已经有序的情况，设置标志位<br>2）数组局部有序，遍历过程中记录最后一次交换的位置，设置为下一次交换的终点<br>3）同时将最大最小值归位，双向冒泡排序</p>\n<p>2.实现一个快速排序算法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 快速排序</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.选择一个基准</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.遍历，小于基准放左边，大于基准放右边</span></span><br><span class=\"line\"><span class=\"comment\"> * 3.递归</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>arr </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">  <span class=\"keyword\">var</span> pivotIndex = <span class=\"built_in\">Math</span>.floor(arr.length / <span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> pivot = arr.splice(pivotIndex, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> right = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class=\"line\">      left.push(arr[i])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      right.push(arr[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quickSort(left).concat(pivot).concat(quickSort(right))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">quickSort(arr)</span><br></pre></td></tr></table></figure><br>3.实现插入排序算法<br>1）循环数组，每次取一个数，判断是否比已排序数最大的大<br>2）如果大则放在后面，如果小则继续比较，如果最小则放在最前面</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 插入排序1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] &gt;= arr[j]) &#123;</span><br><span class=\"line\">        arr.splice(j + <span class=\"number\">1</span>, <span class=\"number\">0</span>, arr.splice(i, <span class=\"number\">1</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        arr.splice(j, <span class=\"number\">0</span>, arr.splice(i, <span class=\"number\">1</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 插入排序2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newArr = arr.splice(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = newArr.length - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] &gt;= newArr[j]) &#123;</span><br><span class=\"line\">        newArr.splice(j + <span class=\"number\">1</span>, <span class=\"number\">0</span>, arr[i])</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        newArr.unshift(arr[i])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newArr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">insertSort(arr)</span><br></pre></td></tr></table></figure>\n<p>4.实现选择排序算法<br>每次循环选取一个最小的数字放到前面的有序序列中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">arr, i, j</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> temp = arr[i]</span><br><span class=\"line\">  arr[i] = arr[j]</span><br><span class=\"line\">  arr[j] = temp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> minIndex = i</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class=\"line\">        minIndex = j</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swap(arr, i, minIndex)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">selectSort(arr)</span><br></pre></td></tr></table></figure>\n"},{"title":"关于js的二叉树","date":"2020-10-12T16:00:00.000Z","_content":"\n1.将二叉树的顺序存储数组转换为链表结构\n```javascript\n// 输入\nvar arr = [3, 9, 20, null, null, 15, 7]\n\n/**\n * 仅适用于完全二叉树\n */\nfunction toBeLink1(arr, x, obj) {\n  obj = obj || {}\n  x = x || 0\n  obj.value = arr[x]\n  var lIndex = 2 * x + 1 // 左侧子节点序是父节点序列的2倍（下标从0开始，所以未 2*x + 1）\n  var rIndex = 2 * x + 2 // 右侧子节点序是父节点序列的2倍+1（下标从0开始，所以未 2*x + 2）\n  if (arr[lIndex] === 0 || arr[lIndex]) {\n    toBeLink(arr, lIndex, obj.left = {})\n  }\n  if (arr[rIndex] === 0 || arr[rIndex]) {\n    toBeLink(arr, rIndex, obj.right = {})\n  }\n  return obj\n}\n\n/**\n* 适用所有二叉树 - 方法1\n*/\nclass TreeNode {\n  constructor(value) {\n    this.value = value\n  }\n  insert(values) {\n    if (!values.length) return this\n    const queue = [this]\n    let i = 0\n    while (queue.length > 0) {\n      const current = queue.shift()\n      for (let side of ['left', 'right']) {\n        if (!current[side]) {\n          if (values[i] !== null) {\n            current[side] = new TreeNode(values[i])\n          }\n          i++\n          if (i >= values.length) return this\n        }\n        if (current[side]) queue.push(current[side])\n      }\n    }\n    return this\n  }\n}\n\nfunction toBeLink(arr) {\n  if (arr.length === 0) return {}\n  const myTree = new TreeNode(arr[0])\n  myTree.insert(arr.slice(1))\n  return myTree\n}\n\n/**\n* 适用所有二叉树 - 方法2\n*/\nfunction toBeLink(arr, obj = {}, queue = []) {\n  if (!arr || arr[0] === null || arr[0] === '' || arr[0] === undefined) return obj\n  // 根节点初始化\n  obj.value = arr[0]\n  queue.push(obj)\n\n  let i = 1\n  while(i <= arr.length) {\n    const current = queue.shift()\n    for (let side of ['left', 'right']) {\n      const arri = arr[i]\n      i++\n      console.log(i, arr.length)\n      if (i > arr.length) return obj\n      if (arri === null) continue\n\n      current[side] = { value: arri }\n      if (arri !== undefined) {\n        queue.push(current[side])\n      }\n    }\n  }\n}\n/**\n* 适用所有二叉树 - 方法2 - 纯 es5 版本\n*/\nfunction toBeLink(arr) {\n  if (arr.length === 0 || arr[0] === null) return {}\n  var obj = { value: arr[0] }\n  var queue = [obj]\n  var i = 1\n  var sideArr = ['left', 'right']\n  while (i <= arr.length) {\n    var current = queue.shift()\n    for (var j = 0; j < sideArr.length; j++) {\n      var arri = arr[i]\n      var side = sideArr[j]\n      i++\n      if (i > arr.length) return obj\n      if (arri === null) continue\n\n      current[side] = { value: arri }\n      queue.push(current[side])\n    }\n  }\n}\n\n// 输出\nvar root = {\n  value: 3,\n  left: {\n    value: 9,\n  },\n  right: {\n    value: 20,\n    left: {\n      value: 15,\n    },\n    right: {\n      value: 7,\n    }\n  }\n}\n```\n\n2.给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n示例：给定二叉树 [3,9,20,null,null,15,7]\n最大深度是 3\n```javascript\nvar maxDepth = function(root) {\n  if(!root) return 0 \n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\n}\nvar root = toBeLink(arr)\nmaxDepth(root) // 3\n```\n\n5.返回二叉树前序遍历(根左右)、中序遍历(左跟右)、后序遍历(左右跟)\n```javascript\nvar arr = [1, null, 2, 3] // return [1, 2, 3]\nvar root = toBeLink(arr)\n\n/**\n * 前序遍历\n */\nfunction getTreeLeft(root, stack = []) {\n  if (root.value === undefined) return stack\n  stack.push(root.value)\n  getTreeLeft(root.left, stack)\n  getTreeLeft(root.right, stack)\n  return stack\n}\n\n/**\n * 中序遍历\n */\nfunction getTreeCenter(root, stack = []) {\n  if (root.value === undefined) return stack\n  getTreeCenter(root.left, stack)\n  stack.push(root.value)\n  getTreeCenter(root.right, stack)\n  return stack\n}\n\n/**\n * 后序遍历\n */\nfunction getTreeRight(root, stack = []) {\n  if (root.value === undefined) return stack\n  getTreeRight(root.right, stack)\n  stack.push(root.value)\n  getTreeRight(root.left, stack)\n  return stack\n}\n\ngetTreeLeft(root)\n```\n\n3.获取二叉树的所有叶子节点的路径\n```javascript\nfunction findAllPath(root) {\n  var paths = []\n  var genPath = (root, path) => {\n    if (!root.value) return path\n\n    path += '>' + root.value\n    if (root.left === undefined && root.right === undefined) {\n      paths.push(path)\n    } else {\n      genPath(root.left, path)\n      genPath(root.right, path)\n    }\n  }\n  genPath(root, '')\n  return paths\n}\n```\n\n4.找到路径和为 target 的二叉树路径\n```javascript\nfunction findAllPath(root, target) {\n  let paths = []\n  let genPath = (root, path) => {\n    path = Object.assign({}, path)\n    path.str = path.str ? path.str + '->' + root.value : root.value\n    path.sum = path.sum ? path.sum + root.value : root.value\n\n    if (path.sum === target) {\n      console.log('target path is ', path)\n    }\n    if (root.left === undefined && root.right === undefined) {\n      return paths.push(path)\n    }\n    if (root.left !== undefined) {\n      genPath(root.left, path)\n    }\n    if (root.right !== undefined) {\n      genPath(root.right, path)\n    }\n  }\n  genPath(root, {})\n  return paths\n}\n```","source":"_posts/qa3.md","raw":"---\ntitle: 关于js的二叉树\ndate: 2020/10/13\ntag: [基础,二叉树,算法]\ncategory: 技术\n---\n\n1.将二叉树的顺序存储数组转换为链表结构\n```javascript\n// 输入\nvar arr = [3, 9, 20, null, null, 15, 7]\n\n/**\n * 仅适用于完全二叉树\n */\nfunction toBeLink1(arr, x, obj) {\n  obj = obj || {}\n  x = x || 0\n  obj.value = arr[x]\n  var lIndex = 2 * x + 1 // 左侧子节点序是父节点序列的2倍（下标从0开始，所以未 2*x + 1）\n  var rIndex = 2 * x + 2 // 右侧子节点序是父节点序列的2倍+1（下标从0开始，所以未 2*x + 2）\n  if (arr[lIndex] === 0 || arr[lIndex]) {\n    toBeLink(arr, lIndex, obj.left = {})\n  }\n  if (arr[rIndex] === 0 || arr[rIndex]) {\n    toBeLink(arr, rIndex, obj.right = {})\n  }\n  return obj\n}\n\n/**\n* 适用所有二叉树 - 方法1\n*/\nclass TreeNode {\n  constructor(value) {\n    this.value = value\n  }\n  insert(values) {\n    if (!values.length) return this\n    const queue = [this]\n    let i = 0\n    while (queue.length > 0) {\n      const current = queue.shift()\n      for (let side of ['left', 'right']) {\n        if (!current[side]) {\n          if (values[i] !== null) {\n            current[side] = new TreeNode(values[i])\n          }\n          i++\n          if (i >= values.length) return this\n        }\n        if (current[side]) queue.push(current[side])\n      }\n    }\n    return this\n  }\n}\n\nfunction toBeLink(arr) {\n  if (arr.length === 0) return {}\n  const myTree = new TreeNode(arr[0])\n  myTree.insert(arr.slice(1))\n  return myTree\n}\n\n/**\n* 适用所有二叉树 - 方法2\n*/\nfunction toBeLink(arr, obj = {}, queue = []) {\n  if (!arr || arr[0] === null || arr[0] === '' || arr[0] === undefined) return obj\n  // 根节点初始化\n  obj.value = arr[0]\n  queue.push(obj)\n\n  let i = 1\n  while(i <= arr.length) {\n    const current = queue.shift()\n    for (let side of ['left', 'right']) {\n      const arri = arr[i]\n      i++\n      console.log(i, arr.length)\n      if (i > arr.length) return obj\n      if (arri === null) continue\n\n      current[side] = { value: arri }\n      if (arri !== undefined) {\n        queue.push(current[side])\n      }\n    }\n  }\n}\n/**\n* 适用所有二叉树 - 方法2 - 纯 es5 版本\n*/\nfunction toBeLink(arr) {\n  if (arr.length === 0 || arr[0] === null) return {}\n  var obj = { value: arr[0] }\n  var queue = [obj]\n  var i = 1\n  var sideArr = ['left', 'right']\n  while (i <= arr.length) {\n    var current = queue.shift()\n    for (var j = 0; j < sideArr.length; j++) {\n      var arri = arr[i]\n      var side = sideArr[j]\n      i++\n      if (i > arr.length) return obj\n      if (arri === null) continue\n\n      current[side] = { value: arri }\n      queue.push(current[side])\n    }\n  }\n}\n\n// 输出\nvar root = {\n  value: 3,\n  left: {\n    value: 9,\n  },\n  right: {\n    value: 20,\n    left: {\n      value: 15,\n    },\n    right: {\n      value: 7,\n    }\n  }\n}\n```\n\n2.给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n示例：给定二叉树 [3,9,20,null,null,15,7]\n最大深度是 3\n```javascript\nvar maxDepth = function(root) {\n  if(!root) return 0 \n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\n}\nvar root = toBeLink(arr)\nmaxDepth(root) // 3\n```\n\n5.返回二叉树前序遍历(根左右)、中序遍历(左跟右)、后序遍历(左右跟)\n```javascript\nvar arr = [1, null, 2, 3] // return [1, 2, 3]\nvar root = toBeLink(arr)\n\n/**\n * 前序遍历\n */\nfunction getTreeLeft(root, stack = []) {\n  if (root.value === undefined) return stack\n  stack.push(root.value)\n  getTreeLeft(root.left, stack)\n  getTreeLeft(root.right, stack)\n  return stack\n}\n\n/**\n * 中序遍历\n */\nfunction getTreeCenter(root, stack = []) {\n  if (root.value === undefined) return stack\n  getTreeCenter(root.left, stack)\n  stack.push(root.value)\n  getTreeCenter(root.right, stack)\n  return stack\n}\n\n/**\n * 后序遍历\n */\nfunction getTreeRight(root, stack = []) {\n  if (root.value === undefined) return stack\n  getTreeRight(root.right, stack)\n  stack.push(root.value)\n  getTreeRight(root.left, stack)\n  return stack\n}\n\ngetTreeLeft(root)\n```\n\n3.获取二叉树的所有叶子节点的路径\n```javascript\nfunction findAllPath(root) {\n  var paths = []\n  var genPath = (root, path) => {\n    if (!root.value) return path\n\n    path += '>' + root.value\n    if (root.left === undefined && root.right === undefined) {\n      paths.push(path)\n    } else {\n      genPath(root.left, path)\n      genPath(root.right, path)\n    }\n  }\n  genPath(root, '')\n  return paths\n}\n```\n\n4.找到路径和为 target 的二叉树路径\n```javascript\nfunction findAllPath(root, target) {\n  let paths = []\n  let genPath = (root, path) => {\n    path = Object.assign({}, path)\n    path.str = path.str ? path.str + '->' + root.value : root.value\n    path.sum = path.sum ? path.sum + root.value : root.value\n\n    if (path.sum === target) {\n      console.log('target path is ', path)\n    }\n    if (root.left === undefined && root.right === undefined) {\n      return paths.push(path)\n    }\n    if (root.left !== undefined) {\n      genPath(root.left, path)\n    }\n    if (root.right !== undefined) {\n      genPath(root.right, path)\n    }\n  }\n  genPath(root, {})\n  return paths\n}\n```","slug":"qa3","published":1,"updated":"2021-03-30T01:32:00.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug5001ga0vz9ezgbn2x","content":"<p>1.将二叉树的顺序存储数组转换为链表结构<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输入</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">20</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"number\">15</span>, <span class=\"number\">7</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 仅适用于完全二叉树</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toBeLink1</span>(<span class=\"params\">arr, x, obj</span>) </span>&#123;</span><br><span class=\"line\">  obj = obj || &#123;&#125;</span><br><span class=\"line\">  x = x || <span class=\"number\">0</span></span><br><span class=\"line\">  obj.value = arr[x]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> lIndex = <span class=\"number\">2</span> * x + <span class=\"number\">1</span> <span class=\"comment\">// 左侧子节点序是父节点序列的2倍（下标从0开始，所以未 2*x + 1）</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> rIndex = <span class=\"number\">2</span> * x + <span class=\"number\">2</span> <span class=\"comment\">// 右侧子节点序是父节点序列的2倍+1（下标从0开始，所以未 2*x + 2）</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr[lIndex] === <span class=\"number\">0</span> || arr[lIndex]) &#123;</span><br><span class=\"line\">    toBeLink(arr, lIndex, obj.left = &#123;&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr[rIndex] === <span class=\"number\">0</span> || arr[rIndex]) &#123;</span><br><span class=\"line\">    toBeLink(arr, rIndex, obj.right = &#123;&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 适用所有二叉树 - 方法1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value = value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">values</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!values.length) <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> queue = [<span class=\"built_in\">this</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> current = queue.shift()</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> side <span class=\"keyword\">of</span> [<span class=\"string\">&#x27;left&#x27;</span>, <span class=\"string\">&#x27;right&#x27;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!current[side]) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (values[i] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            current[side] = <span class=\"keyword\">new</span> TreeNode(values[i])</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          i++</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (i &gt;= values.length) <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current[side]) queue.push(current[side])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toBeLink</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myTree = <span class=\"keyword\">new</span> TreeNode(arr[<span class=\"number\">0</span>])</span><br><span class=\"line\">  myTree.insert(arr.slice(<span class=\"number\">1</span>))</span><br><span class=\"line\">  <span class=\"keyword\">return</span> myTree</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 适用所有二叉树 - 方法2</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toBeLink</span>(<span class=\"params\">arr, obj = &#123;&#125;, queue = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!arr || arr[<span class=\"number\">0</span>] === <span class=\"literal\">null</span> || arr[<span class=\"number\">0</span>] === <span class=\"string\">&#x27;&#x27;</span> || arr[<span class=\"number\">0</span>] === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  <span class=\"comment\">// 根节点初始化</span></span><br><span class=\"line\">  obj.value = arr[<span class=\"number\">0</span>]</span><br><span class=\"line\">  queue.push(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">while</span>(<span class=\"params\">i &lt;= arr.length</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> current = queue.shift()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> side <span class=\"keyword\">of</span> [<span class=\"string\">&#x27;left&#x27;</span>, <span class=\"string\">&#x27;right&#x27;</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> arri = arr[i]</span><br><span class=\"line\">      i++</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i, arr.length)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i &gt; arr.length) <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arri === <span class=\"literal\">null</span>) <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">      current[side] = &#123; <span class=\"attr\">value</span>: arri &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arri !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        queue.push(current[side])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 适用所有二叉树 - 方法2 - 纯 es5 版本</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toBeLink</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length === <span class=\"number\">0</span> || arr[<span class=\"number\">0</span>] === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">value</span>: arr[<span class=\"number\">0</span>] &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> queue = [obj]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> sideArr = [<span class=\"string\">&#x27;left&#x27;</span>, <span class=\"string\">&#x27;right&#x27;</span>]</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt;= arr.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = queue.shift()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; sideArr.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> arri = arr[i]</span><br><span class=\"line\">      <span class=\"keyword\">var</span> side = sideArr[j]</span><br><span class=\"line\">      i++</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i &gt; arr.length) <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arri === <span class=\"literal\">null</span>) <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">      current[side] = &#123; <span class=\"attr\">value</span>: arri &#125;</span><br><span class=\"line\">      queue.push(current[side])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> root = &#123;</span><br><span class=\"line\">  value: <span class=\"number\">3</span>,</span><br><span class=\"line\">  left: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">9</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  right: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">20</span>,</span><br><span class=\"line\">    left: &#123;</span><br><span class=\"line\">      value: <span class=\"number\">15</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    right: &#123;</span><br><span class=\"line\">      value: <span class=\"number\">7</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：给定二叉树 [3,9,20,null,null,15,7]<br>最大深度是 3<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxDepth = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span> + <span class=\"built_in\">Math</span>.max(maxDepth(root.left), maxDepth(root.right))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> root = toBeLink(arr)</span><br><span class=\"line\">maxDepth(root) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>5.返回二叉树前序遍历(根左右)、中序遍历(左跟右)、后序遍历(左右跟)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"literal\">null</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>] <span class=\"comment\">// return [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> root = toBeLink(arr)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 前序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTreeLeft</span>(<span class=\"params\">root, stack = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.value === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> stack</span><br><span class=\"line\">  stack.push(root.value)</span><br><span class=\"line\">  getTreeLeft(root.left, stack)</span><br><span class=\"line\">  getTreeLeft(root.right, stack)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stack</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 中序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTreeCenter</span>(<span class=\"params\">root, stack = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.value === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> stack</span><br><span class=\"line\">  getTreeCenter(root.left, stack)</span><br><span class=\"line\">  stack.push(root.value)</span><br><span class=\"line\">  getTreeCenter(root.right, stack)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stack</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 后序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTreeRight</span>(<span class=\"params\">root, stack = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.value === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> stack</span><br><span class=\"line\">  getTreeRight(root.right, stack)</span><br><span class=\"line\">  stack.push(root.value)</span><br><span class=\"line\">  getTreeRight(root.left, stack)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stack</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getTreeLeft(root)</span><br></pre></td></tr></table></figure></p>\n<p>3.获取二叉树的所有叶子节点的路径<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findAllPath</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> paths = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> genPath = <span class=\"function\">(<span class=\"params\">root, path</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root.value) <span class=\"keyword\">return</span> path</span><br><span class=\"line\"></span><br><span class=\"line\">    path += <span class=\"string\">&#x27;&gt;&#x27;</span> + root.value</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.left === <span class=\"literal\">undefined</span> &amp;&amp; root.right === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      paths.push(path)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      genPath(root.left, path)</span><br><span class=\"line\">      genPath(root.right, path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  genPath(root, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> paths</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.找到路径和为 target 的二叉树路径<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findAllPath</span>(<span class=\"params\">root, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> paths = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> genPath = <span class=\"function\">(<span class=\"params\">root, path</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    path = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, path)</span><br><span class=\"line\">    path.str = path.str ? path.str + <span class=\"string\">&#x27;-&gt;&#x27;</span> + root.value : root.value</span><br><span class=\"line\">    path.sum = path.sum ? path.sum + root.value : root.value</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path.sum === target) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;target path is &#x27;</span>, path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.left === <span class=\"literal\">undefined</span> &amp;&amp; root.right === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> paths.push(path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.left !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      genPath(root.left, path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.right !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      genPath(root.right, path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  genPath(root, &#123;&#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> paths</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.将二叉树的顺序存储数组转换为链表结构<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输入</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">20</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"number\">15</span>, <span class=\"number\">7</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 仅适用于完全二叉树</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toBeLink1</span>(<span class=\"params\">arr, x, obj</span>) </span>&#123;</span><br><span class=\"line\">  obj = obj || &#123;&#125;</span><br><span class=\"line\">  x = x || <span class=\"number\">0</span></span><br><span class=\"line\">  obj.value = arr[x]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> lIndex = <span class=\"number\">2</span> * x + <span class=\"number\">1</span> <span class=\"comment\">// 左侧子节点序是父节点序列的2倍（下标从0开始，所以未 2*x + 1）</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> rIndex = <span class=\"number\">2</span> * x + <span class=\"number\">2</span> <span class=\"comment\">// 右侧子节点序是父节点序列的2倍+1（下标从0开始，所以未 2*x + 2）</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr[lIndex] === <span class=\"number\">0</span> || arr[lIndex]) &#123;</span><br><span class=\"line\">    toBeLink(arr, lIndex, obj.left = &#123;&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr[rIndex] === <span class=\"number\">0</span> || arr[rIndex]) &#123;</span><br><span class=\"line\">    toBeLink(arr, rIndex, obj.right = &#123;&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 适用所有二叉树 - 方法1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value = value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">values</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!values.length) <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> queue = [<span class=\"built_in\">this</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> current = queue.shift()</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> side <span class=\"keyword\">of</span> [<span class=\"string\">&#x27;left&#x27;</span>, <span class=\"string\">&#x27;right&#x27;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!current[side]) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (values[i] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            current[side] = <span class=\"keyword\">new</span> TreeNode(values[i])</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          i++</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (i &gt;= values.length) <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current[side]) queue.push(current[side])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toBeLink</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> myTree = <span class=\"keyword\">new</span> TreeNode(arr[<span class=\"number\">0</span>])</span><br><span class=\"line\">  myTree.insert(arr.slice(<span class=\"number\">1</span>))</span><br><span class=\"line\">  <span class=\"keyword\">return</span> myTree</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 适用所有二叉树 - 方法2</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toBeLink</span>(<span class=\"params\">arr, obj = &#123;&#125;, queue = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!arr || arr[<span class=\"number\">0</span>] === <span class=\"literal\">null</span> || arr[<span class=\"number\">0</span>] === <span class=\"string\">&#x27;&#x27;</span> || arr[<span class=\"number\">0</span>] === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  <span class=\"comment\">// 根节点初始化</span></span><br><span class=\"line\">  obj.value = arr[<span class=\"number\">0</span>]</span><br><span class=\"line\">  queue.push(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">while</span>(<span class=\"params\">i &lt;= arr.length</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> current = queue.shift()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> side <span class=\"keyword\">of</span> [<span class=\"string\">&#x27;left&#x27;</span>, <span class=\"string\">&#x27;right&#x27;</span>]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> arri = arr[i]</span><br><span class=\"line\">      i++</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i, arr.length)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i &gt; arr.length) <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arri === <span class=\"literal\">null</span>) <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">      current[side] = &#123; <span class=\"attr\">value</span>: arri &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arri !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        queue.push(current[side])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 适用所有二叉树 - 方法2 - 纯 es5 版本</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toBeLink</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length === <span class=\"number\">0</span> || arr[<span class=\"number\">0</span>] === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">value</span>: arr[<span class=\"number\">0</span>] &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> queue = [obj]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> sideArr = [<span class=\"string\">&#x27;left&#x27;</span>, <span class=\"string\">&#x27;right&#x27;</span>]</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt;= arr.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = queue.shift()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; sideArr.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> arri = arr[i]</span><br><span class=\"line\">      <span class=\"keyword\">var</span> side = sideArr[j]</span><br><span class=\"line\">      i++</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i &gt; arr.length) <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arri === <span class=\"literal\">null</span>) <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">      current[side] = &#123; <span class=\"attr\">value</span>: arri &#125;</span><br><span class=\"line\">      queue.push(current[side])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> root = &#123;</span><br><span class=\"line\">  value: <span class=\"number\">3</span>,</span><br><span class=\"line\">  left: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">9</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  right: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">20</span>,</span><br><span class=\"line\">    left: &#123;</span><br><span class=\"line\">      value: <span class=\"number\">15</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    right: &#123;</span><br><span class=\"line\">      value: <span class=\"number\">7</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：给定二叉树 [3,9,20,null,null,15,7]<br>最大深度是 3<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxDepth = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span> + <span class=\"built_in\">Math</span>.max(maxDepth(root.left), maxDepth(root.right))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> root = toBeLink(arr)</span><br><span class=\"line\">maxDepth(root) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>5.返回二叉树前序遍历(根左右)、中序遍历(左跟右)、后序遍历(左右跟)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"literal\">null</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>] <span class=\"comment\">// return [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> root = toBeLink(arr)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 前序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTreeLeft</span>(<span class=\"params\">root, stack = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.value === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> stack</span><br><span class=\"line\">  stack.push(root.value)</span><br><span class=\"line\">  getTreeLeft(root.left, stack)</span><br><span class=\"line\">  getTreeLeft(root.right, stack)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stack</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 中序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTreeCenter</span>(<span class=\"params\">root, stack = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.value === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> stack</span><br><span class=\"line\">  getTreeCenter(root.left, stack)</span><br><span class=\"line\">  stack.push(root.value)</span><br><span class=\"line\">  getTreeCenter(root.right, stack)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stack</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 后序遍历</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTreeRight</span>(<span class=\"params\">root, stack = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (root.value === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> stack</span><br><span class=\"line\">  getTreeRight(root.right, stack)</span><br><span class=\"line\">  stack.push(root.value)</span><br><span class=\"line\">  getTreeRight(root.left, stack)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stack</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getTreeLeft(root)</span><br></pre></td></tr></table></figure></p>\n<p>3.获取二叉树的所有叶子节点的路径<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findAllPath</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> paths = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> genPath = <span class=\"function\">(<span class=\"params\">root, path</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root.value) <span class=\"keyword\">return</span> path</span><br><span class=\"line\"></span><br><span class=\"line\">    path += <span class=\"string\">&#x27;&gt;&#x27;</span> + root.value</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.left === <span class=\"literal\">undefined</span> &amp;&amp; root.right === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      paths.push(path)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      genPath(root.left, path)</span><br><span class=\"line\">      genPath(root.right, path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  genPath(root, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> paths</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.找到路径和为 target 的二叉树路径<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findAllPath</span>(<span class=\"params\">root, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> paths = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> genPath = <span class=\"function\">(<span class=\"params\">root, path</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    path = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, path)</span><br><span class=\"line\">    path.str = path.str ? path.str + <span class=\"string\">&#x27;-&gt;&#x27;</span> + root.value : root.value</span><br><span class=\"line\">    path.sum = path.sum ? path.sum + root.value : root.value</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path.sum === target) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;target path is &#x27;</span>, path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.left === <span class=\"literal\">undefined</span> &amp;&amp; root.right === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> paths.push(path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.left !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      genPath(root.left, path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.right !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      genPath(root.right, path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  genPath(root, &#123;&#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> paths</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"JS数组操作","date":"2020-10-13T16:00:00.000Z","_content":"\n1、当前字符串中包含字母和数字, 用一个方法实现出现最多的字母和数字 \na)如果只有字母, 那么只返回出现最多的字母, 只有数字情况同理\nb)如果有相同次数多的字母或数字出现,将按照第一次出现的顺序返回\n列表如下:\n```javascript\nconst str = \"abcdccbdb58575\" \n[\"b\",\"c\",\"5\"] // 数组 a:1, b:3, c:3, d: 2, 5:3, 7:1, 8:1\n```\n```javascript\n// 方法一\nconst str = \"abcdccbdb58575\" \nconst obj = {}\nArray.from(\n  new Set(\n    str.split('').map(i => {\n      obj[i] = obj[i] ? obj[i]+1 : 1\n      return i\n    })\n  )\n)\n.sort((a, b) => obj[b] - obj[a])\n.filter((item, index, arr) => obj[item] === obj[arr[0]])\n\n// 方法二\nconst obj = {}\nconst str = \"abcdccbdb58575\"\nstr.split('').forEach((i, index) => {\n  if (!obj[i]) {\n    obj[i] = {\n      index,\n      value: 1\n    }\n  } else {\n     obj[i].value = obj[i].value + 1\n  }\n})\nObject.keys(obj)\n.sort((a, b) => {\n  return obj[b].value - obj[a].value\n})\n.filter((item, index, arr) => obj[item].value === obj[arr[0]].value)\n.sort((a, b) => obj[a].index - obj[b].index)\n\n// 方法三\nconst str = \"abcdccbdb58575\"\nconst map = new Map()\nstr.split('').forEach(i => {\n  const v = map.get(i)\n  map.set(i, v ? v + 1 : 1)\n})\nlet max\nfor (let m of map) {\n  if (!max) {\n    max = m\n    continue\n  }\n  if (m[1] > max[1]) {\n    map.delete(max[0])\n    max = m\n    continue\n  }\n  if (m[1] < max[1]) {\n    map.delete(m[0])\n  }\n}\nconsole.log([...map.keys()])\n```\n\n2、已知有一个数组类似 var list=[{age:12, group:1},{age:20, group:3},{age:12, group:23}]\n请实现对数组的排序,先按age升序排序再按 group降序排序,结果类似[age:12, group:23},{age:12,goup:1},tage:20, group:3]\n\n```javascript\nfunction compare(key, order) { \n  return (a,b) => { // return 大于0，b在前面；小于0，a在前面\n    if (order === 'desc') { // 升序\n      return a[key] - b[key] // 如果结果大于0，则b在前面 [b, a]，此为升序\n    }\n    return b[key] - a[key] // 如果结果大于0，则b在前面 [b, a]，此为降序\n  }\n}\nlist.sort(compare('age', 'desc'))\nlist.sort(compare('name'))\n```\n\n3、将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组\n```javascript\nvar arr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10]\n// 方法一\nArray.from(new Set(arr.toString().split(','))).sort((a, b) => a - b).map(Number)\n// 方法二\nArray.from(new Set(arr.flat(Infinity))).sort((a, b) => a - b)\n// 附录，flat方法兼容方法\nfunction flat(arr) {\n  return arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flat(val) : val), [])\n}\n```\n\n\n4、请把两个数组\n['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 和 \n['A', 'B', 'C', 'D'] 合并为 \n['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']\n```javascript\nvar arr1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']\nvar arr2 = ['A', 'B', 'C', 'D']\n\narr2.map(item => item+'3').concat(arr1).sort().map(item => item.replace('3', ''))\n```\n\n5.合并两个有序数组\n给你两个有序整数数组 nums1和nums2，请你将nums2合并到nums1，使nums1成为一个有序数组\n说明：\n初始化nums1和nums2的元素数量分别为m，n，你可以假设nums1有足够的空间（空间大小大于等于m+n）来保存nums2的元素\n```javascript\n// 输入：\nvar nums1 = [1, 2, 3, 0, 0, 0], m = 3\nvar nums2 = [2, 5, 6], n = 3\n\nfunction deal(nums1, m, nums2, n) {\n  nums1.splice(m, n, ...nums2)\n  nums1.sort((a, b) => a - b)\n  return nums1\n}\ndeal(nums1, m, nums2, n) // [1, 2, 2, 3, 5, 6]\n```\n\n\n6.已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]\n编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组\n```javascript\n\nfunction deal1(arr) {\n  return Array.from(new Set(arr.toString().replace(/\\[|\\]/g, '').split(','))).map(item => +item).sort((a, b) => a - b)\n}\nfunction _flat(arr) {\n  return arr.reduce((acc, item) => {\n    return acc.concat(Array.isArray(item) ? _flat(item) : item)\n  }, [])\n}\nfunction deal(arr) {\n  return Array.from(new Set(_flat(arr))).sort((a, b) => a - b)\n}\nvar arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]\ndeal(arr)\n```\n\n7.某公司1到12月份的销售额存在一个对象里面\n如：{1:222, 2:123, 5: 888}, 请把数据处理为如下结构\n[222, 123, null, null, 888, null, null, null, null, null, null, null]\n```javascript\nvar data = { 1: 222, 2: 123, 5: 888 }\nnew Array(12).fill(null).map((i, index) => {\n  return data[index + 1] || null\n})\n```\n\n8.给定两个数组，用一个方法来计算他们的公共元素\n```javascript\nvar nums1 = [1, 2, 2, 1]\nvar nums2 = [2, 3, 4, 5, 6, 1, 1]\n// 返回[1, 2, 1]\n\n// answer\nfunction getIntersection(items1, items2) {\n  var arr1 = [...items1]\n  var arr2 = [...items2]\n  return arr1.filter(item => {\n    var index = arr2.indexOf(item)\n    if (index > -1) {\n      arr2.splice(index, 1)\n      return true\n    }\n  })\n}\ngetIntersection(nums1, nums2) // [1, 2, 1]\n```\n9.随机生成一个长度为10，数值区间为[0, 100)的整数类型的数组，如：[2, 10, 3, 4, 5, 11, 10, 11, 20, 30]\n将其排列成一个新的数据，要求升序排列，10分位相同的数为一个子数组\n新的数组形式如：[[2, 3, 4, 5], [10, 11], [20], [30]]\n\n```javascript\nconst getRandomNumber = () => Math.floor(Math.random() * 100)\nconst arr = Array.from({ length: 10 }).map(item => getRandomNumber())\nconst sortArr = Array.from(new Set(arr)).sort((a, b) => a - b)\nconst newArr = []\nsortArr.forEach(item => {\n  const i = Math.floor(item/10)\n  newArr[i] = newArr[i] || []\n  newArr[i].push(item)\n})\nconsole.log(newArr)\n```\n\n10.旋转数组\n给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数。\n```html\n输入：[1, 2, 3, 4, 5, 6, 7] k = n\n输出：[5, 6, 7, 1, 2, 3, 4]\n解释：\n向右旋转1步：[7, 1, 2, 3, 4, 5, 6]\n向右旋转2步：[6, 7, 1, 2, 3, 4, 5]\n向右旋转3步：[5, 6, 7, 1, 2, 3, 4]\n```\n```javascript\nvar arr = [1, 2, 3, 4, 5, 6, 7]\nfunction arrReverse(arr, k) {\n  return arr.splice(arr.length - k).concat(arr)\n}\nvar newArr = arrReverse(arr, 4)\nconsole.log(newArr)\n```\n\n11.算法题【移动零】，给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序\n输入：[0, 1, 0, 3, 12]\n输出：[1, 3, 12, 0, 0]\n补充：必须在原数组上操作，不能拷贝额外的数组\n```javascript\n// answer1\nfunction dealArr(arr) {\n  var j = 0\n  for (var i = j; i < arr.length - j; i++) {\n    if (arr[i] === 0) {\n      arr.splice(i, 1)\n      arr.push(0)\n      j++\n      i--\n    }\n  }\n  return arr\n}\n\nconsole.log(dealArr([0, 1, 0, 3, 12]))\n```\n\n12.在不新增数组的情况下去重数组\n```javascript\n// 方法1\n// 排序数组，再从前往后遍历数组\n// 当相邻两个值不相等的时候 len 指针移动 1 位\n// 最终 len 的值即为新数组的大小\nlet removeDuplicates = nums => {\n  nums.sort()\n  let len = 1\n  \n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] !== nums[i-1]) {\n      nums[len++] = nums[i]\n    }\n  }\n  nums.splice(len)\n  return nums\n}\n\n// 方法2 优化版本，不需要排序\n// 从后往前遍历，依次用最后一个不重复的值替换当前位置有重复的值\n// 最后，删除多余的数\nlet removeDuplicates2 = nums => {\n  let len = nums.length - 1\n  for (let i = len; i >= 0; i--) {\n    if (nums.indexOf(nums[i]) !== i) {\n      nums[i] = nums[len--] // 最后的一个不重复的值替换当前 nums[i](有重复) 的值\n    }\n  }\n  nums.splice(len + 1)\n  return nums\n}\nremoveDuplicates2([1,2,3,1]) // [1,2,3]\n```\n","source":"_posts/qa4.md","raw":"---\ntitle: JS数组操作\ndate: 2020/10/14\ntag: [基础,数组]\ncategory: 技术\n---\n\n1、当前字符串中包含字母和数字, 用一个方法实现出现最多的字母和数字 \na)如果只有字母, 那么只返回出现最多的字母, 只有数字情况同理\nb)如果有相同次数多的字母或数字出现,将按照第一次出现的顺序返回\n列表如下:\n```javascript\nconst str = \"abcdccbdb58575\" \n[\"b\",\"c\",\"5\"] // 数组 a:1, b:3, c:3, d: 2, 5:3, 7:1, 8:1\n```\n```javascript\n// 方法一\nconst str = \"abcdccbdb58575\" \nconst obj = {}\nArray.from(\n  new Set(\n    str.split('').map(i => {\n      obj[i] = obj[i] ? obj[i]+1 : 1\n      return i\n    })\n  )\n)\n.sort((a, b) => obj[b] - obj[a])\n.filter((item, index, arr) => obj[item] === obj[arr[0]])\n\n// 方法二\nconst obj = {}\nconst str = \"abcdccbdb58575\"\nstr.split('').forEach((i, index) => {\n  if (!obj[i]) {\n    obj[i] = {\n      index,\n      value: 1\n    }\n  } else {\n     obj[i].value = obj[i].value + 1\n  }\n})\nObject.keys(obj)\n.sort((a, b) => {\n  return obj[b].value - obj[a].value\n})\n.filter((item, index, arr) => obj[item].value === obj[arr[0]].value)\n.sort((a, b) => obj[a].index - obj[b].index)\n\n// 方法三\nconst str = \"abcdccbdb58575\"\nconst map = new Map()\nstr.split('').forEach(i => {\n  const v = map.get(i)\n  map.set(i, v ? v + 1 : 1)\n})\nlet max\nfor (let m of map) {\n  if (!max) {\n    max = m\n    continue\n  }\n  if (m[1] > max[1]) {\n    map.delete(max[0])\n    max = m\n    continue\n  }\n  if (m[1] < max[1]) {\n    map.delete(m[0])\n  }\n}\nconsole.log([...map.keys()])\n```\n\n2、已知有一个数组类似 var list=[{age:12, group:1},{age:20, group:3},{age:12, group:23}]\n请实现对数组的排序,先按age升序排序再按 group降序排序,结果类似[age:12, group:23},{age:12,goup:1},tage:20, group:3]\n\n```javascript\nfunction compare(key, order) { \n  return (a,b) => { // return 大于0，b在前面；小于0，a在前面\n    if (order === 'desc') { // 升序\n      return a[key] - b[key] // 如果结果大于0，则b在前面 [b, a]，此为升序\n    }\n    return b[key] - a[key] // 如果结果大于0，则b在前面 [b, a]，此为降序\n  }\n}\nlist.sort(compare('age', 'desc'))\nlist.sort(compare('name'))\n```\n\n3、将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组\n```javascript\nvar arr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10]\n// 方法一\nArray.from(new Set(arr.toString().split(','))).sort((a, b) => a - b).map(Number)\n// 方法二\nArray.from(new Set(arr.flat(Infinity))).sort((a, b) => a - b)\n// 附录，flat方法兼容方法\nfunction flat(arr) {\n  return arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flat(val) : val), [])\n}\n```\n\n\n4、请把两个数组\n['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 和 \n['A', 'B', 'C', 'D'] 合并为 \n['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']\n```javascript\nvar arr1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']\nvar arr2 = ['A', 'B', 'C', 'D']\n\narr2.map(item => item+'3').concat(arr1).sort().map(item => item.replace('3', ''))\n```\n\n5.合并两个有序数组\n给你两个有序整数数组 nums1和nums2，请你将nums2合并到nums1，使nums1成为一个有序数组\n说明：\n初始化nums1和nums2的元素数量分别为m，n，你可以假设nums1有足够的空间（空间大小大于等于m+n）来保存nums2的元素\n```javascript\n// 输入：\nvar nums1 = [1, 2, 3, 0, 0, 0], m = 3\nvar nums2 = [2, 5, 6], n = 3\n\nfunction deal(nums1, m, nums2, n) {\n  nums1.splice(m, n, ...nums2)\n  nums1.sort((a, b) => a - b)\n  return nums1\n}\ndeal(nums1, m, nums2, n) // [1, 2, 2, 3, 5, 6]\n```\n\n\n6.已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]\n编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组\n```javascript\n\nfunction deal1(arr) {\n  return Array.from(new Set(arr.toString().replace(/\\[|\\]/g, '').split(','))).map(item => +item).sort((a, b) => a - b)\n}\nfunction _flat(arr) {\n  return arr.reduce((acc, item) => {\n    return acc.concat(Array.isArray(item) ? _flat(item) : item)\n  }, [])\n}\nfunction deal(arr) {\n  return Array.from(new Set(_flat(arr))).sort((a, b) => a - b)\n}\nvar arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]\ndeal(arr)\n```\n\n7.某公司1到12月份的销售额存在一个对象里面\n如：{1:222, 2:123, 5: 888}, 请把数据处理为如下结构\n[222, 123, null, null, 888, null, null, null, null, null, null, null]\n```javascript\nvar data = { 1: 222, 2: 123, 5: 888 }\nnew Array(12).fill(null).map((i, index) => {\n  return data[index + 1] || null\n})\n```\n\n8.给定两个数组，用一个方法来计算他们的公共元素\n```javascript\nvar nums1 = [1, 2, 2, 1]\nvar nums2 = [2, 3, 4, 5, 6, 1, 1]\n// 返回[1, 2, 1]\n\n// answer\nfunction getIntersection(items1, items2) {\n  var arr1 = [...items1]\n  var arr2 = [...items2]\n  return arr1.filter(item => {\n    var index = arr2.indexOf(item)\n    if (index > -1) {\n      arr2.splice(index, 1)\n      return true\n    }\n  })\n}\ngetIntersection(nums1, nums2) // [1, 2, 1]\n```\n9.随机生成一个长度为10，数值区间为[0, 100)的整数类型的数组，如：[2, 10, 3, 4, 5, 11, 10, 11, 20, 30]\n将其排列成一个新的数据，要求升序排列，10分位相同的数为一个子数组\n新的数组形式如：[[2, 3, 4, 5], [10, 11], [20], [30]]\n\n```javascript\nconst getRandomNumber = () => Math.floor(Math.random() * 100)\nconst arr = Array.from({ length: 10 }).map(item => getRandomNumber())\nconst sortArr = Array.from(new Set(arr)).sort((a, b) => a - b)\nconst newArr = []\nsortArr.forEach(item => {\n  const i = Math.floor(item/10)\n  newArr[i] = newArr[i] || []\n  newArr[i].push(item)\n})\nconsole.log(newArr)\n```\n\n10.旋转数组\n给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数。\n```html\n输入：[1, 2, 3, 4, 5, 6, 7] k = n\n输出：[5, 6, 7, 1, 2, 3, 4]\n解释：\n向右旋转1步：[7, 1, 2, 3, 4, 5, 6]\n向右旋转2步：[6, 7, 1, 2, 3, 4, 5]\n向右旋转3步：[5, 6, 7, 1, 2, 3, 4]\n```\n```javascript\nvar arr = [1, 2, 3, 4, 5, 6, 7]\nfunction arrReverse(arr, k) {\n  return arr.splice(arr.length - k).concat(arr)\n}\nvar newArr = arrReverse(arr, 4)\nconsole.log(newArr)\n```\n\n11.算法题【移动零】，给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序\n输入：[0, 1, 0, 3, 12]\n输出：[1, 3, 12, 0, 0]\n补充：必须在原数组上操作，不能拷贝额外的数组\n```javascript\n// answer1\nfunction dealArr(arr) {\n  var j = 0\n  for (var i = j; i < arr.length - j; i++) {\n    if (arr[i] === 0) {\n      arr.splice(i, 1)\n      arr.push(0)\n      j++\n      i--\n    }\n  }\n  return arr\n}\n\nconsole.log(dealArr([0, 1, 0, 3, 12]))\n```\n\n12.在不新增数组的情况下去重数组\n```javascript\n// 方法1\n// 排序数组，再从前往后遍历数组\n// 当相邻两个值不相等的时候 len 指针移动 1 位\n// 最终 len 的值即为新数组的大小\nlet removeDuplicates = nums => {\n  nums.sort()\n  let len = 1\n  \n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] !== nums[i-1]) {\n      nums[len++] = nums[i]\n    }\n  }\n  nums.splice(len)\n  return nums\n}\n\n// 方法2 优化版本，不需要排序\n// 从后往前遍历，依次用最后一个不重复的值替换当前位置有重复的值\n// 最后，删除多余的数\nlet removeDuplicates2 = nums => {\n  let len = nums.length - 1\n  for (let i = len; i >= 0; i--) {\n    if (nums.indexOf(nums[i]) !== i) {\n      nums[i] = nums[len--] // 最后的一个不重复的值替换当前 nums[i](有重复) 的值\n    }\n  }\n  nums.splice(len + 1)\n  return nums\n}\nremoveDuplicates2([1,2,3,1]) // [1,2,3]\n```\n","slug":"qa4","published":1,"updated":"2021-03-30T01:32:00.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug5001ha0vzb2yj0ukf","content":"<p>1、当前字符串中包含字母和数字, 用一个方法实现出现最多的字母和数字<br>a)如果只有字母, 那么只返回出现最多的字母, 只有数字情况同理<br>b)如果有相同次数多的字母或数字出现,将按照第一次出现的顺序返回<br>列表如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">&quot;abcdccbdb58575&quot;</span> </span><br><span class=\"line\">[<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;c&quot;</span>,<span class=\"string\">&quot;5&quot;</span>] <span class=\"comment\">// 数组 a:1, b:3, c:3, d: 2, 5:3, 7:1, 8:1</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">&quot;abcdccbdb58575&quot;</span> </span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(</span><br><span class=\"line\">    str.split(<span class=\"string\">&#x27;&#x27;</span>).map(<span class=\"function\"><span class=\"params\">i</span> =&gt;</span> &#123;</span><br><span class=\"line\">      obj[i] = obj[i] ? obj[i]+<span class=\"number\">1</span> : <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> obj[b] - obj[a])</span><br><span class=\"line\">.filter(<span class=\"function\">(<span class=\"params\">item, index, arr</span>) =&gt;</span> obj[item] === obj[arr[<span class=\"number\">0</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">&quot;abcdccbdb58575&quot;</span></span><br><span class=\"line\">str.split(<span class=\"string\">&#x27;&#x27;</span>).forEach(<span class=\"function\">(<span class=\"params\">i, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!obj[i]) &#123;</span><br><span class=\"line\">    obj[i] = &#123;</span><br><span class=\"line\">      index,</span><br><span class=\"line\">      value: <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     obj[i].value = obj[i].value + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[b].value - obj[a].value</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.filter(<span class=\"function\">(<span class=\"params\">item, index, arr</span>) =&gt;</span> obj[item].value === obj[arr[<span class=\"number\">0</span>]].value)</span><br><span class=\"line\">.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> obj[a].index - obj[b].index)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法三</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">&quot;abcdccbdb58575&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">str.split(<span class=\"string\">&#x27;&#x27;</span>).forEach(<span class=\"function\"><span class=\"params\">i</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> v = map.get(i)</span><br><span class=\"line\">  map.set(i, v ? v + <span class=\"number\">1</span> : <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> max</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> m <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!max) &#123;</span><br><span class=\"line\">    max = m</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m[<span class=\"number\">1</span>] &gt; max[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">    map.delete(max[<span class=\"number\">0</span>])</span><br><span class=\"line\">    max = m</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m[<span class=\"number\">1</span>] &lt; max[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">    map.delete(m[<span class=\"number\">0</span>])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([...map.keys()])</span><br></pre></td></tr></table></figure></p>\n<p>2、已知有一个数组类似 var list=[{age:12, group:1},{age:20, group:3},{age:12, group:23}]<br>请实现对数组的排序,先按age升序排序再按 group降序排序,结果类似[age:12, group:23},{age:12,goup:1},tage:20, group:3]</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">key, order</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a,b</span>) =&gt;</span> &#123; <span class=\"comment\">// return 大于0，b在前面；小于0，a在前面</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (order === <span class=\"string\">&#x27;desc&#x27;</span>) &#123; <span class=\"comment\">// 升序</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> a[key] - b[key] <span class=\"comment\">// 如果结果大于0，则b在前面 [b, a]，此为升序</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b[key] - a[key] <span class=\"comment\">// 如果结果大于0，则b在前面 [b, a]，此为降序</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">list.sort(compare(<span class=\"string\">&#x27;age&#x27;</span>, <span class=\"string\">&#x27;desc&#x27;</span>))</span><br><span class=\"line\">list.sort(compare(<span class=\"string\">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure>\n<p>3、将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>], [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, [<span class=\"number\">11</span>, <span class=\"number\">12</span>, [<span class=\"number\">12</span>, <span class=\"number\">13</span>, [<span class=\"number\">14</span>]]]], <span class=\"number\">10</span>]</span><br><span class=\"line\"><span class=\"comment\">// 方法一</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr.toString().split(<span class=\"string\">&#x27;,&#x27;</span>))).sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b).map(<span class=\"built_in\">Number</span>)</span><br><span class=\"line\"><span class=\"comment\">// 方法二</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr.flat(<span class=\"literal\">Infinity</span>))).sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\"><span class=\"comment\">// 附录，flat方法兼容方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flat</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">acc, val</span>) =&gt;</span> acc.concat(<span class=\"built_in\">Array</span>.isArray(val) ? flat(val) : val), [])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4、请把两个数组<br>[‘A1’, ‘A2’, ‘B1’, ‘B2’, ‘C1’, ‘C2’, ‘D1’, ‘D2’] 和<br>[‘A’, ‘B’, ‘C’, ‘D’] 合并为<br>[‘A1’, ‘A2’, ‘A’, ‘B1’, ‘B2’, ‘B’, ‘C1’, ‘C2’, ‘C’, ‘D1’, ‘D2’, ‘D’]<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">&#x27;A1&#x27;</span>, <span class=\"string\">&#x27;A2&#x27;</span>, <span class=\"string\">&#x27;B1&#x27;</span>, <span class=\"string\">&#x27;B2&#x27;</span>, <span class=\"string\">&#x27;C1&#x27;</span>, <span class=\"string\">&#x27;C2&#x27;</span>, <span class=\"string\">&#x27;D1&#x27;</span>, <span class=\"string\">&#x27;D2&#x27;</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">arr2.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item+<span class=\"string\">&#x27;3&#x27;</span>).concat(arr1).sort().map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.replace(<span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>))</span><br></pre></td></tr></table></figure></p>\n<p>5.合并两个有序数组<br>给你两个有序整数数组 nums1和nums2，请你将nums2合并到nums1，使nums1成为一个有序数组<br>说明：<br>初始化nums1和nums2的元素数量分别为m，n，你可以假设nums1有足够的空间（空间大小大于等于m+n）来保存nums2的元素<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输入：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>], m = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums2 = [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>], n = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deal</span>(<span class=\"params\">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class=\"line\">  nums1.splice(m, n, ...nums2)</span><br><span class=\"line\">  nums1.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">deal(nums1, m, nums2, n) <span class=\"comment\">// [1, 2, 2, 3, 5, 6]</span></span><br></pre></td></tr></table></figure></p>\n<p>6.已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]<br>编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deal1</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr.toString().replace(<span class=\"regexp\">/\\[|\\]/g</span>, <span class=\"string\">&#x27;&#x27;</span>).split(<span class=\"string\">&#x27;,&#x27;</span>))).map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> +item).sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_flat</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">acc, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> acc.concat(<span class=\"built_in\">Array</span>.isArray(item) ? _flat(item) : item)</span><br><span class=\"line\">  &#125;, [])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deal</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(_flat(arr))).sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [ [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>], [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, [<span class=\"number\">11</span>, <span class=\"number\">12</span>, [<span class=\"number\">12</span>, <span class=\"number\">13</span>, [<span class=\"number\">14</span>] ] ] ], <span class=\"number\">10</span>]</span><br><span class=\"line\">deal(arr)</span><br></pre></td></tr></table></figure></p>\n<p>7.某公司1到12月份的销售额存在一个对象里面<br>如：{1:222, 2:123, 5: 888}, 请把数据处理为如下结构<br>[222, 123, null, null, 888, null, null, null, null, null, null, null]<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"number\">1</span>: <span class=\"number\">222</span>, <span class=\"number\">2</span>: <span class=\"number\">123</span>, <span class=\"number\">5</span>: <span class=\"number\">888</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">12</span>).fill(<span class=\"literal\">null</span>).map(<span class=\"function\">(<span class=\"params\">i, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data[index + <span class=\"number\">1</span>] || <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>8.给定两个数组，用一个方法来计算他们的公共元素<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nums1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> nums2 = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"comment\">// 返回[1, 2, 1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// answer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getIntersection</span>(<span class=\"params\">items1, items2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr1 = [...items1]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr2 = [...items2]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr1.filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> index = arr2.indexOf(item)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      arr2.splice(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getIntersection(nums1, nums2) <span class=\"comment\">// [1, 2, 1]</span></span><br></pre></td></tr></table></figure><br>9.随机生成一个长度为10，数值区间为[0, 100)的整数类型的数组，如：[2, 10, 3, 4, 5, 11, 10, 11, 20, 30]<br>将其排列成一个新的数据，要求升序排列，10分位相同的数为一个子数组<br>新的数组形式如：[[2, 3, 4, 5], [10, 11], [20], [30]]</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getRandomNumber = <span class=\"function\">() =&gt;</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"built_in\">Array</span>.from(&#123; <span class=\"attr\">length</span>: <span class=\"number\">10</span> &#125;).map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> getRandomNumber())</span><br><span class=\"line\"><span class=\"keyword\">const</span> sortArr = <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr)).sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\"><span class=\"keyword\">const</span> newArr = []</span><br><span class=\"line\">sortArr.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> i = <span class=\"built_in\">Math</span>.floor(item/<span class=\"number\">10</span>)</span><br><span class=\"line\">  newArr[i] = newArr[i] || []</span><br><span class=\"line\">  newArr[i].push(item)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArr)</span><br></pre></td></tr></table></figure>\n<p>10.旋转数组<br>给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1, 2, 3, 4, 5, 6, 7] k = n</span><br><span class=\"line\">输出：[5, 6, 7, 1, 2, 3, 4]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">向右旋转1步：[7, 1, 2, 3, 4, 5, 6]</span><br><span class=\"line\">向右旋转2步：[6, 7, 1, 2, 3, 4, 5]</span><br><span class=\"line\">向右旋转3步：[5, 6, 7, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">arrReverse</span>(<span class=\"params\">arr, k</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.splice(arr.length - k).concat(arr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newArr = arrReverse(arr, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArr)</span><br></pre></td></tr></table></figure></p>\n<p>11.算法题【移动零】，给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序<br>输入：[0, 1, 0, 3, 12]<br>输出：[1, 3, 12, 0, 0]<br>补充：必须在原数组上操作，不能拷贝额外的数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// answer1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dealArr</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> j = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = j; i &lt; arr.length - j; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[i] === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      arr.splice(i, <span class=\"number\">1</span>)</span><br><span class=\"line\">      arr.push(<span class=\"number\">0</span>)</span><br><span class=\"line\">      j++</span><br><span class=\"line\">      i--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dealArr([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>]))</span><br></pre></td></tr></table></figure></p>\n<p>12.在不新增数组的情况下去重数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1</span></span><br><span class=\"line\"><span class=\"comment\">// 排序数组，再从前往后遍历数组</span></span><br><span class=\"line\"><span class=\"comment\">// 当相邻两个值不相等的时候 len 指针移动 1 位</span></span><br><span class=\"line\"><span class=\"comment\">// 最终 len 的值即为新数组的大小</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> removeDuplicates = <span class=\"function\"><span class=\"params\">nums</span> =&gt;</span> &#123;</span><br><span class=\"line\">  nums.sort()</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = <span class=\"number\">1</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] !== nums[i-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      nums[len++] = nums[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nums.splice(len)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2 优化版本，不需要排序</span></span><br><span class=\"line\"><span class=\"comment\">// 从后往前遍历，依次用最后一个不重复的值替换当前位置有重复的值</span></span><br><span class=\"line\"><span class=\"comment\">// 最后，删除多余的数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> removeDuplicates2 = <span class=\"function\"><span class=\"params\">nums</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = len; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.indexOf(nums[i]) !== i) &#123;</span><br><span class=\"line\">      nums[i] = nums[len--] <span class=\"comment\">// 最后的一个不重复的值替换当前 nums[i](有重复) 的值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nums.splice(len + <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">removeDuplicates2([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]) <span class=\"comment\">// [1,2,3]</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1、当前字符串中包含字母和数字, 用一个方法实现出现最多的字母和数字<br>a)如果只有字母, 那么只返回出现最多的字母, 只有数字情况同理<br>b)如果有相同次数多的字母或数字出现,将按照第一次出现的顺序返回<br>列表如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">&quot;abcdccbdb58575&quot;</span> </span><br><span class=\"line\">[<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;c&quot;</span>,<span class=\"string\">&quot;5&quot;</span>] <span class=\"comment\">// 数组 a:1, b:3, c:3, d: 2, 5:3, 7:1, 8:1</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">&quot;abcdccbdb58575&quot;</span> </span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(</span><br><span class=\"line\">    str.split(<span class=\"string\">&#x27;&#x27;</span>).map(<span class=\"function\"><span class=\"params\">i</span> =&gt;</span> &#123;</span><br><span class=\"line\">      obj[i] = obj[i] ? obj[i]+<span class=\"number\">1</span> : <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> obj[b] - obj[a])</span><br><span class=\"line\">.filter(<span class=\"function\">(<span class=\"params\">item, index, arr</span>) =&gt;</span> obj[item] === obj[arr[<span class=\"number\">0</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">&quot;abcdccbdb58575&quot;</span></span><br><span class=\"line\">str.split(<span class=\"string\">&#x27;&#x27;</span>).forEach(<span class=\"function\">(<span class=\"params\">i, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!obj[i]) &#123;</span><br><span class=\"line\">    obj[i] = &#123;</span><br><span class=\"line\">      index,</span><br><span class=\"line\">      value: <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     obj[i].value = obj[i].value + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[b].value - obj[a].value</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.filter(<span class=\"function\">(<span class=\"params\">item, index, arr</span>) =&gt;</span> obj[item].value === obj[arr[<span class=\"number\">0</span>]].value)</span><br><span class=\"line\">.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> obj[a].index - obj[b].index)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法三</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">&quot;abcdccbdb58575&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">str.split(<span class=\"string\">&#x27;&#x27;</span>).forEach(<span class=\"function\"><span class=\"params\">i</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> v = map.get(i)</span><br><span class=\"line\">  map.set(i, v ? v + <span class=\"number\">1</span> : <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> max</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> m <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!max) &#123;</span><br><span class=\"line\">    max = m</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m[<span class=\"number\">1</span>] &gt; max[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">    map.delete(max[<span class=\"number\">0</span>])</span><br><span class=\"line\">    max = m</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m[<span class=\"number\">1</span>] &lt; max[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">    map.delete(m[<span class=\"number\">0</span>])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([...map.keys()])</span><br></pre></td></tr></table></figure></p>\n<p>2、已知有一个数组类似 var list=[{age:12, group:1},{age:20, group:3},{age:12, group:23}]<br>请实现对数组的排序,先按age升序排序再按 group降序排序,结果类似[age:12, group:23},{age:12,goup:1},tage:20, group:3]</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">key, order</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a,b</span>) =&gt;</span> &#123; <span class=\"comment\">// return 大于0，b在前面；小于0，a在前面</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (order === <span class=\"string\">&#x27;desc&#x27;</span>) &#123; <span class=\"comment\">// 升序</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> a[key] - b[key] <span class=\"comment\">// 如果结果大于0，则b在前面 [b, a]，此为升序</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b[key] - a[key] <span class=\"comment\">// 如果结果大于0，则b在前面 [b, a]，此为降序</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">list.sort(compare(<span class=\"string\">&#x27;age&#x27;</span>, <span class=\"string\">&#x27;desc&#x27;</span>))</span><br><span class=\"line\">list.sort(compare(<span class=\"string\">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure>\n<p>3、将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>], [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, [<span class=\"number\">11</span>, <span class=\"number\">12</span>, [<span class=\"number\">12</span>, <span class=\"number\">13</span>, [<span class=\"number\">14</span>]]]], <span class=\"number\">10</span>]</span><br><span class=\"line\"><span class=\"comment\">// 方法一</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr.toString().split(<span class=\"string\">&#x27;,&#x27;</span>))).sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b).map(<span class=\"built_in\">Number</span>)</span><br><span class=\"line\"><span class=\"comment\">// 方法二</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr.flat(<span class=\"literal\">Infinity</span>))).sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\"><span class=\"comment\">// 附录，flat方法兼容方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flat</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">acc, val</span>) =&gt;</span> acc.concat(<span class=\"built_in\">Array</span>.isArray(val) ? flat(val) : val), [])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4、请把两个数组<br>[‘A1’, ‘A2’, ‘B1’, ‘B2’, ‘C1’, ‘C2’, ‘D1’, ‘D2’] 和<br>[‘A’, ‘B’, ‘C’, ‘D’] 合并为<br>[‘A1’, ‘A2’, ‘A’, ‘B1’, ‘B2’, ‘B’, ‘C1’, ‘C2’, ‘C’, ‘D1’, ‘D2’, ‘D’]<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">&#x27;A1&#x27;</span>, <span class=\"string\">&#x27;A2&#x27;</span>, <span class=\"string\">&#x27;B1&#x27;</span>, <span class=\"string\">&#x27;B2&#x27;</span>, <span class=\"string\">&#x27;C1&#x27;</span>, <span class=\"string\">&#x27;C2&#x27;</span>, <span class=\"string\">&#x27;D1&#x27;</span>, <span class=\"string\">&#x27;D2&#x27;</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">arr2.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item+<span class=\"string\">&#x27;3&#x27;</span>).concat(arr1).sort().map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.replace(<span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>))</span><br></pre></td></tr></table></figure></p>\n<p>5.合并两个有序数组<br>给你两个有序整数数组 nums1和nums2，请你将nums2合并到nums1，使nums1成为一个有序数组<br>说明：<br>初始化nums1和nums2的元素数量分别为m，n，你可以假设nums1有足够的空间（空间大小大于等于m+n）来保存nums2的元素<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输入：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>], m = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums2 = [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>], n = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deal</span>(<span class=\"params\">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class=\"line\">  nums1.splice(m, n, ...nums2)</span><br><span class=\"line\">  nums1.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">deal(nums1, m, nums2, n) <span class=\"comment\">// [1, 2, 2, 3, 5, 6]</span></span><br></pre></td></tr></table></figure></p>\n<p>6.已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]<br>编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deal1</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr.toString().replace(<span class=\"regexp\">/\\[|\\]/g</span>, <span class=\"string\">&#x27;&#x27;</span>).split(<span class=\"string\">&#x27;,&#x27;</span>))).map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> +item).sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_flat</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">acc, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> acc.concat(<span class=\"built_in\">Array</span>.isArray(item) ? _flat(item) : item)</span><br><span class=\"line\">  &#125;, [])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deal</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(_flat(arr))).sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [ [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>], [<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, [<span class=\"number\">11</span>, <span class=\"number\">12</span>, [<span class=\"number\">12</span>, <span class=\"number\">13</span>, [<span class=\"number\">14</span>] ] ] ], <span class=\"number\">10</span>]</span><br><span class=\"line\">deal(arr)</span><br></pre></td></tr></table></figure></p>\n<p>7.某公司1到12月份的销售额存在一个对象里面<br>如：{1:222, 2:123, 5: 888}, 请把数据处理为如下结构<br>[222, 123, null, null, 888, null, null, null, null, null, null, null]<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"number\">1</span>: <span class=\"number\">222</span>, <span class=\"number\">2</span>: <span class=\"number\">123</span>, <span class=\"number\">5</span>: <span class=\"number\">888</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">12</span>).fill(<span class=\"literal\">null</span>).map(<span class=\"function\">(<span class=\"params\">i, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data[index + <span class=\"number\">1</span>] || <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>8.给定两个数组，用一个方法来计算他们的公共元素<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nums1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> nums2 = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"comment\">// 返回[1, 2, 1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// answer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getIntersection</span>(<span class=\"params\">items1, items2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr1 = [...items1]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr2 = [...items2]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr1.filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> index = arr2.indexOf(item)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      arr2.splice(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getIntersection(nums1, nums2) <span class=\"comment\">// [1, 2, 1]</span></span><br></pre></td></tr></table></figure><br>9.随机生成一个长度为10，数值区间为[0, 100)的整数类型的数组，如：[2, 10, 3, 4, 5, 11, 10, 11, 20, 30]<br>将其排列成一个新的数据，要求升序排列，10分位相同的数为一个子数组<br>新的数组形式如：[[2, 3, 4, 5], [10, 11], [20], [30]]</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getRandomNumber = <span class=\"function\">() =&gt;</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"built_in\">Array</span>.from(&#123; <span class=\"attr\">length</span>: <span class=\"number\">10</span> &#125;).map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> getRandomNumber())</span><br><span class=\"line\"><span class=\"keyword\">const</span> sortArr = <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr)).sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\"><span class=\"keyword\">const</span> newArr = []</span><br><span class=\"line\">sortArr.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> i = <span class=\"built_in\">Math</span>.floor(item/<span class=\"number\">10</span>)</span><br><span class=\"line\">  newArr[i] = newArr[i] || []</span><br><span class=\"line\">  newArr[i].push(item)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArr)</span><br></pre></td></tr></table></figure>\n<p>10.旋转数组<br>给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1, 2, 3, 4, 5, 6, 7] k = n</span><br><span class=\"line\">输出：[5, 6, 7, 1, 2, 3, 4]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">向右旋转1步：[7, 1, 2, 3, 4, 5, 6]</span><br><span class=\"line\">向右旋转2步：[6, 7, 1, 2, 3, 4, 5]</span><br><span class=\"line\">向右旋转3步：[5, 6, 7, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">arrReverse</span>(<span class=\"params\">arr, k</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.splice(arr.length - k).concat(arr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newArr = arrReverse(arr, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArr)</span><br></pre></td></tr></table></figure></p>\n<p>11.算法题【移动零】，给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序<br>输入：[0, 1, 0, 3, 12]<br>输出：[1, 3, 12, 0, 0]<br>补充：必须在原数组上操作，不能拷贝额外的数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// answer1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dealArr</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> j = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = j; i &lt; arr.length - j; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[i] === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      arr.splice(i, <span class=\"number\">1</span>)</span><br><span class=\"line\">      arr.push(<span class=\"number\">0</span>)</span><br><span class=\"line\">      j++</span><br><span class=\"line\">      i--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dealArr([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>]))</span><br></pre></td></tr></table></figure></p>\n<p>12.在不新增数组的情况下去重数组<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1</span></span><br><span class=\"line\"><span class=\"comment\">// 排序数组，再从前往后遍历数组</span></span><br><span class=\"line\"><span class=\"comment\">// 当相邻两个值不相等的时候 len 指针移动 1 位</span></span><br><span class=\"line\"><span class=\"comment\">// 最终 len 的值即为新数组的大小</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> removeDuplicates = <span class=\"function\"><span class=\"params\">nums</span> =&gt;</span> &#123;</span><br><span class=\"line\">  nums.sort()</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = <span class=\"number\">1</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] !== nums[i-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      nums[len++] = nums[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nums.splice(len)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2 优化版本，不需要排序</span></span><br><span class=\"line\"><span class=\"comment\">// 从后往前遍历，依次用最后一个不重复的值替换当前位置有重复的值</span></span><br><span class=\"line\"><span class=\"comment\">// 最后，删除多余的数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> removeDuplicates2 = <span class=\"function\"><span class=\"params\">nums</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = nums.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = len; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.indexOf(nums[i]) !== i) &#123;</span><br><span class=\"line\">      nums[i] = nums[len--] <span class=\"comment\">// 最后的一个不重复的值替换当前 nums[i](有重复) 的值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nums.splice(len + <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">removeDuplicates2([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]) <span class=\"comment\">// [1,2,3]</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"js对象和类的操作","date":"2020-10-18T16:00:00.000Z","_content":"\n1.对象深度优先遍历和广度优先遍历的实现\n如图：\n<img src=\"http://zhoushirong.github.io/img/map.png\" alt=\"ssh-l图片\" width=\"630\" height=\"215\">\n\n```javascript\nconst obj = {\n  a1: {\n    a1b1: 1,\n    a1b2: 2\n  },\n  a2: {\n    a2b1: 3,\n    a2b2: 4,\n    a2b3: 5\n  }\n}\n// 深度优先遍历\nconst depthArr = []\nfunction depthFirst(obj) {\n  for (let i in obj) {\n    depthArr.push(i)\n    if (Object.prototype.toString.call(obj[i]) === '[object Object]') {\n      depthFirst(obj[i])\n    }\n  }\n  return depthArr\n}\n\n// 广度优先遍历\nconst breadthArr = []\nfunction breadthFirst(obj) {\n  const arr = Object.keys(obj)\n  breadthArr = breadthArr.concat(arr)\n  arr.forEach(i => {\n    if (Object.prototype.toString.call(obj[i]) === '[object Object]') {\n      breadthFirst(obj[i])\n    }\n  })\n}\n\ndepthFirst(obj) // ['a1', 'a1b1', 'a1b2', 'a2', 'a2b1', 'a2b2', 'a2b3']\nbreadthFirst(obj) // ['a1', 'a2', 'a1b1', 'a1b2', 'a2b1', 'a2b2', 'a2b3']\nconsole.log(depthArr, breadthArr)\n```\n\n2.用深度优先思想实现一个深拷贝函数\n深度拷贝最主要需要考虑的因素就是需要考虑js的各种数据类型\n1）6种基本类型(number,string,null,undefined,boolean,symbol)不需要处理，直接复制返回即可\n2）几种特殊类型 date、regexp、set、map，直接new一遍即可\n3）需要着重处理的类型 Array、Object，直接使用递归处理即可\n4）递归处理Array、Object的过程中需要考虑循环引用，循环引用处理可以利用WeakMap将每次递归的对象存储起来，如果一样，直接返回\n\n```javascript\nconst obj = {\n  a1: {\n    a1b1: 1,\n    a1b2: 2\n  },\n  a2: {\n    a2b1: 3,\n    a2b2: 4,\n    a2b3: 5\n  },\n  fn1: function() {\n    console.log('fn1')\n  },\n  symbolData: Symbol('symbolData'),\n  booleanData: false,\n  date: new Date(),\n  nullData: null,\n  arrData: [1, 2, 3, { arr1: { a:1, b: 2 }, arr2: [] }],\n  numberData: 1,\n  strData: 'abc',\n  regexData: new RegExp('abcdefg'),\n  setData: new Set(),\n  mapData: new Map(),\n}\nobj.obj = obj // 循环引用\n\nfunction isType(target, type) {\n  if (!type) {\n    return Object.prototype.toString.call(target).slice(8, -1)\n  }\n  return Object.prototype.toString.call(target) === `[object ${type}]`\n}\nfunction depthFirstClone(obj, hash = new WeakMap()) {\n  const oType = isType(obj)\n  if (oType !== 'Object' && oType !== 'Array') return obj\n  if (hash.has(obj)) return hash.get(obj)\n\n  const newObj = oType === 'Array' ? [] : {}\n  hash.set(obj, newObj)\n\n  for (let i in obj) {\n    if (\n      typeof obj[i] === 'string' ||\n      typeof obj[i] === 'number' ||\n      typeof obj[i] === 'boolean' ||\n      typeof obj[i] === 'symbol' ||\n      obj[i] === undefined ||\n      obj[i] === null\n    ) {\n      newObj[i] = obj[i]\n      continue\n    }\n    if (isType(obj[i], 'Function')) {\n      newObj[i] = obj[i]\n      continue\n    }\n    if (isType(obj[i], 'Set')) {\n      newObj[i] = new Set(obj[i])\n      continue\n    }\n    if (isType(obj[i], 'Map')) {\n      newObj[i] = new Map(obj[i])\n      continue\n    }\n    if (isType(obj[i], 'Date')) {\n      newObj[i] = new Date(obj[i])\n      continue\n    }\n    if (isType(obj[i], 'RegExp')) {\n      newObj[i] = new RegExp(obj[i])\n      continue\n    }\n    if (isType(obj[i], 'Array') || isType(obj[i], 'Object')) {\n      newObj[i] = depthFirstClone(obj[i], hash)\n      continue\n    }\n  }\n  return newObj\n}\nlet cloneObj = depthFirstClone(obj)\n```\n\n3.实现一个LazyMan类，实现以下功能\n```javascript\nLazyMan('Tony') // Hi I am Tony\nLazyMan('Tony').sleep(10).eat('lunch') \n// Hi I am Tony \n// 等待10s\n// I am eating lunch\nLazyMan('Tony').eat('lunch').sleep(10).eat('dinner')\n// Hi I am Tony \n// I am eating lunch\n// 等待10s\n// I am eating dinner\nLazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food')\n// Hi I am Tony \n// 等待5s\n// I am eating lunch\n// I am eating dinner\n// 等待10s\n// I am eating junk food\n```\n```javascript\nclass LazyManClass {\n  constructor(name) {\n    this.name = name\n    this.task = []\n    console.log(`Hi I am ${this.name}`)\n    setTimeout(() => this.next())\n  }\n  sleepFirst(time) {\n    const fn = () => {\n      console.log(`sleep ${time}ms`)\n      setTimeout(() => {\n        this.next()\n      }, time)\n    }\n    this.task.unshift(fn)\n    return this\n  }\n  sleep(time) {\n    const fn = () => {\n      console.log(`sleep ${time}ms`)\n      setTimeout(() => {\n        this.next()\n      }, time)\n    }\n    this.task.push(fn)\n    return this\n  }\n  eat(food) {\n    this.task.push(() => {\n      console.log(`I am eating ${food}`)\n      this.next()\n    })\n    return this\n  }\n  next() {\n    const fn = this.task.shift()\n    fn && fn()\n  }\n}\nfunction LazyMan(name) {\n  return new LazyManClass(name)\n}\nLazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5000).sleep(10000).eat('junk food')\n```\n\n\n4、定义一个列表类List,该类包含成员方法 add()、all() 和属性 length,要求构造函数和add0方法的参数为动态参数\n```javascript\n  // 构造函数示例：\n  var ls = new List('A', 'B','C')\n  // add方法示例\n  ls.add('D','E');\n  // length属性\n  ls.length; // =>5\n  // items属性\n  ls.all(); // =>【A,B,\"C,\"D,\"E]\n```\n\n```javascript\nclass List {\n  constructor() {\n    this.args = [...arguments]\n  }\n  add() {\n    this.args = Array.prototype.concat(this.args, [...arguments])\n  }\n  all() {\n    return this.args\n  }\n  get length() {\n    return this.args.length\n  }\n}\n\nlet ls = new List('A', 'B', 'C')\nls.add('D', 'E')\nconsole.log(ls.length)\nls.all()\n```\n\n\n5.实现convert方法，把原始list转换成树形结构，要求尽可能降低时间复杂度\n以下数据结构中，id代表部门编号，name是部门名称，parentId是父部门编号，为0代表一级部门，现在要求实现一个convert方法，把原始list转换成树形结构，parantId为多少就挂载在该id的属性children数组下\n```javascript\nlet list = [\n  { id: 1, name: '部门A', parentId: 0 },\n  { id: 2, name: '部门B', parentId: 0 },\n  { id: 3, name: '部门C', parentId: 1 },\n  { id: 4, name: '部门D', parentId: 1 },\n  { id: 5, name: '部门E', parentId: 2 },\n  { id: 6, name: '部门F', parentId: 3 },\n  { id: 7, name: '部门G', parentId: 2 },\n  { id: 8, name: '部门H', parentId: 4 },\n  // ...\n]\nfunction convert(list) {\n  const res = []\n  const map = {}\n  list.forEach(item => map[item.id] = item)\n  list.forEach(item => {\n    if (item.parentId === 0) return res.push(item)\n    const parent = map[item.parentId]\n    if (parent.children) {\n      parent.children.push(item)\n    } else {\n      parent.children = [item]\n    }\n  })\n  return res\n}\n\nlet result = convert(list)\nresult = [{\n  id: 1,\n  name: '部门A',\n  parentId: 0,\n  children: [{\n    id: 3,\n    name: '部门3',\n    parentId: 1,\n    children: [{\n      id: 6,\n      name: '部门6',\n      parentId: 3,\n    }]\n  }]\n}, /* ... */]\n```\n\n6.将entry转换为output、将output转换为entry：\n```javascript\nvar entry = {\n  'a.b.c.dd': 'abcdd',\n  'a.d.xx': 'adxx',\n  'a.e': 'ae',\n}\n// =>\nvar output = {\n  a: {\n    b: {\n      c: {\n        dd: 'abcdd'\n      }\n    },\n    d: {\n      xx: 'adxx'\n    },\n    e: 'ae'\n  }\n}\n```\n\n```javascript\n// entry => output\nfunction gen(obj = {}, str, val) {\n  str.split('.').reduce((acc, i, idx, source) => {\n    if (!acc[i]) {\n      acc[i] = idx === source.length - 1 ? val : {}\n    }\n    return acc[i]\n  }, obj)\n  return obj\n}\nfunction generater(obj) {\n  const newObj = {}\n  for (let i in obj) {\n    gen(newObj, i, obj[i])\n  }\n  return newObj\n}\ngenerater(entry)\n```\n\n```javascript\n// output => entry answer1\nconst isObj = val => Object.prototype.toString.call(val) === '[object Object]'\nfunction fn(obj = {}, key, newObj = {}) {\n  for (let i in obj) {\n    const nkey = key ? key + '.' + i : i\n    if (isObj(obj[i])) {\n      fn(obj[i], nkey, newObj)\n    } else {\n      newObj[nkey] = obj[i]\n    }\n  }\n  return newObj\n}\n// output => entry answer2\nfunction fn(obj = {}) {\n  const queue = Object.entries(obj)\n  const res = {}\n  while(queue.length) {\n    const [key, obj] = queue.pop()\n    for (const [k, v] of Object.entries(obj)) {\n      if (!isObj(v)) {\n        res[`${key}.${k}`] = v\n      } else {\n        queue.push([`${key}.${k}`, v])\n      }\n    }\n  }\n  return res\n}\n```\n\n7.实现一个简单的仓储系统，可以不断转入和转出货物，货物最多有两层子类目，数字代表该子类目转入/转出的数量。转出时不能出现爆仓情况。\n```javascript\n/*\n * cargo 说明：\n * key代表类目/子类目名称\n * value 为 number时，代表这个类目的数量，为object 时，代表下一层货物的集合，最多嵌套两层\n * {\n *  productA:{  // 代表货物的类目名称\n *    a:1, // 1 代表子类目 a 的数量\n *    b:2,\n *    c:{   // c 代表货物的子类名称\n *      c1:1, // c1代表货物的子类名称\n *    }\n *   }，\n *  productB:{\n *      e:6\n *   }\n * }\n *\n * 爆仓情况：如转入 {productA:{a:3,c:1}} 转出 {productA:{a:4}},就会发生子类目a爆仓，此时要返回报错。\n */\n\nclass Depository {\n  constructor() {\n    this.product = {}\n  }\n  compineProduct(cargo, product) {\n    for (let i in cargo) {\n      if (!product[i]) {\n        product[i] = {}\n      }\n      if (typeof cargo[i] === 'number') {\n        if (typeof product[i] === 'number') {\n          product[i] += cargo[i]\n        } else {\n          product[i] = cargo[i]\n        }\n      } else {\n        this.compineProduct(cargo[i], product[i])\n      }\n    }\n  }\n  reduceProduct(cargo, product) {\n    for (let i in cargo) {\n      if (!product[i]) {\n        throw `货物${i}不存在`\n      }\n      if (typeof cargo[i] === 'number') {\n        if (product[i] - cargo[i] <= 0) {\n          throw `货物${i}爆仓`\n        }\n        product[i] -= cargo[i]\n      } else {\n        this.reduceProduct(cargo[i], product[i])\n      }\n    }\n  }\n  // 转入货物\n  transferIn(cargo) {\n    if (!cargo) return this.product\n    this.compineProduct(cargo, this.product)\n    return this.product\n  }\n  // 转出货物\n  transferOut(cargo) {\n    if (!cargo) return this.product\n    this.reduceProduct(cargo, this.product)\n    return this.product\n  }\n}\n```\n\n8.使用Javascript Proxy实现简单的数据绑定 \n```html\n<input id=\"inputField\" value=\"\" type=\"text\" placeholder=\"\" />\n<p id=\"showField\"></p>\n```\n```javascript\nconst proxy1 = {\n  get(target, propKey) {\n    console.log(`getting:${propKey}`)\n    return Reflect.get(target, propKey)\n  },\n  set(target, propKey, value) {\n    console.log(`setting:${propKey}、${value}`)\n    handler(value)\n    return Reflect.set(target, propKey, value)\n  }\n}\n\nfunction handler(value) {\n  document.querySelector('#showField').innerHTML = value\n}\n\nvar obj = new Proxy({}, proxy1)\ndocument.querySelector('#inputField').addEventListener('input', (e) => {\n  obj.txt = e.target.value\n})\n```\n[demo](https://www.epoos.com/demo/vue/proxy.html)","source":"_posts/qa5.md","raw":"---\ntitle: js对象和类的操作\ndate: 2020/10/19\ntag: [基础,对象]\ncategory: 技术\n---\n\n1.对象深度优先遍历和广度优先遍历的实现\n如图：\n<img src=\"http://zhoushirong.github.io/img/map.png\" alt=\"ssh-l图片\" width=\"630\" height=\"215\">\n\n```javascript\nconst obj = {\n  a1: {\n    a1b1: 1,\n    a1b2: 2\n  },\n  a2: {\n    a2b1: 3,\n    a2b2: 4,\n    a2b3: 5\n  }\n}\n// 深度优先遍历\nconst depthArr = []\nfunction depthFirst(obj) {\n  for (let i in obj) {\n    depthArr.push(i)\n    if (Object.prototype.toString.call(obj[i]) === '[object Object]') {\n      depthFirst(obj[i])\n    }\n  }\n  return depthArr\n}\n\n// 广度优先遍历\nconst breadthArr = []\nfunction breadthFirst(obj) {\n  const arr = Object.keys(obj)\n  breadthArr = breadthArr.concat(arr)\n  arr.forEach(i => {\n    if (Object.prototype.toString.call(obj[i]) === '[object Object]') {\n      breadthFirst(obj[i])\n    }\n  })\n}\n\ndepthFirst(obj) // ['a1', 'a1b1', 'a1b2', 'a2', 'a2b1', 'a2b2', 'a2b3']\nbreadthFirst(obj) // ['a1', 'a2', 'a1b1', 'a1b2', 'a2b1', 'a2b2', 'a2b3']\nconsole.log(depthArr, breadthArr)\n```\n\n2.用深度优先思想实现一个深拷贝函数\n深度拷贝最主要需要考虑的因素就是需要考虑js的各种数据类型\n1）6种基本类型(number,string,null,undefined,boolean,symbol)不需要处理，直接复制返回即可\n2）几种特殊类型 date、regexp、set、map，直接new一遍即可\n3）需要着重处理的类型 Array、Object，直接使用递归处理即可\n4）递归处理Array、Object的过程中需要考虑循环引用，循环引用处理可以利用WeakMap将每次递归的对象存储起来，如果一样，直接返回\n\n```javascript\nconst obj = {\n  a1: {\n    a1b1: 1,\n    a1b2: 2\n  },\n  a2: {\n    a2b1: 3,\n    a2b2: 4,\n    a2b3: 5\n  },\n  fn1: function() {\n    console.log('fn1')\n  },\n  symbolData: Symbol('symbolData'),\n  booleanData: false,\n  date: new Date(),\n  nullData: null,\n  arrData: [1, 2, 3, { arr1: { a:1, b: 2 }, arr2: [] }],\n  numberData: 1,\n  strData: 'abc',\n  regexData: new RegExp('abcdefg'),\n  setData: new Set(),\n  mapData: new Map(),\n}\nobj.obj = obj // 循环引用\n\nfunction isType(target, type) {\n  if (!type) {\n    return Object.prototype.toString.call(target).slice(8, -1)\n  }\n  return Object.prototype.toString.call(target) === `[object ${type}]`\n}\nfunction depthFirstClone(obj, hash = new WeakMap()) {\n  const oType = isType(obj)\n  if (oType !== 'Object' && oType !== 'Array') return obj\n  if (hash.has(obj)) return hash.get(obj)\n\n  const newObj = oType === 'Array' ? [] : {}\n  hash.set(obj, newObj)\n\n  for (let i in obj) {\n    if (\n      typeof obj[i] === 'string' ||\n      typeof obj[i] === 'number' ||\n      typeof obj[i] === 'boolean' ||\n      typeof obj[i] === 'symbol' ||\n      obj[i] === undefined ||\n      obj[i] === null\n    ) {\n      newObj[i] = obj[i]\n      continue\n    }\n    if (isType(obj[i], 'Function')) {\n      newObj[i] = obj[i]\n      continue\n    }\n    if (isType(obj[i], 'Set')) {\n      newObj[i] = new Set(obj[i])\n      continue\n    }\n    if (isType(obj[i], 'Map')) {\n      newObj[i] = new Map(obj[i])\n      continue\n    }\n    if (isType(obj[i], 'Date')) {\n      newObj[i] = new Date(obj[i])\n      continue\n    }\n    if (isType(obj[i], 'RegExp')) {\n      newObj[i] = new RegExp(obj[i])\n      continue\n    }\n    if (isType(obj[i], 'Array') || isType(obj[i], 'Object')) {\n      newObj[i] = depthFirstClone(obj[i], hash)\n      continue\n    }\n  }\n  return newObj\n}\nlet cloneObj = depthFirstClone(obj)\n```\n\n3.实现一个LazyMan类，实现以下功能\n```javascript\nLazyMan('Tony') // Hi I am Tony\nLazyMan('Tony').sleep(10).eat('lunch') \n// Hi I am Tony \n// 等待10s\n// I am eating lunch\nLazyMan('Tony').eat('lunch').sleep(10).eat('dinner')\n// Hi I am Tony \n// I am eating lunch\n// 等待10s\n// I am eating dinner\nLazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food')\n// Hi I am Tony \n// 等待5s\n// I am eating lunch\n// I am eating dinner\n// 等待10s\n// I am eating junk food\n```\n```javascript\nclass LazyManClass {\n  constructor(name) {\n    this.name = name\n    this.task = []\n    console.log(`Hi I am ${this.name}`)\n    setTimeout(() => this.next())\n  }\n  sleepFirst(time) {\n    const fn = () => {\n      console.log(`sleep ${time}ms`)\n      setTimeout(() => {\n        this.next()\n      }, time)\n    }\n    this.task.unshift(fn)\n    return this\n  }\n  sleep(time) {\n    const fn = () => {\n      console.log(`sleep ${time}ms`)\n      setTimeout(() => {\n        this.next()\n      }, time)\n    }\n    this.task.push(fn)\n    return this\n  }\n  eat(food) {\n    this.task.push(() => {\n      console.log(`I am eating ${food}`)\n      this.next()\n    })\n    return this\n  }\n  next() {\n    const fn = this.task.shift()\n    fn && fn()\n  }\n}\nfunction LazyMan(name) {\n  return new LazyManClass(name)\n}\nLazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5000).sleep(10000).eat('junk food')\n```\n\n\n4、定义一个列表类List,该类包含成员方法 add()、all() 和属性 length,要求构造函数和add0方法的参数为动态参数\n```javascript\n  // 构造函数示例：\n  var ls = new List('A', 'B','C')\n  // add方法示例\n  ls.add('D','E');\n  // length属性\n  ls.length; // =>5\n  // items属性\n  ls.all(); // =>【A,B,\"C,\"D,\"E]\n```\n\n```javascript\nclass List {\n  constructor() {\n    this.args = [...arguments]\n  }\n  add() {\n    this.args = Array.prototype.concat(this.args, [...arguments])\n  }\n  all() {\n    return this.args\n  }\n  get length() {\n    return this.args.length\n  }\n}\n\nlet ls = new List('A', 'B', 'C')\nls.add('D', 'E')\nconsole.log(ls.length)\nls.all()\n```\n\n\n5.实现convert方法，把原始list转换成树形结构，要求尽可能降低时间复杂度\n以下数据结构中，id代表部门编号，name是部门名称，parentId是父部门编号，为0代表一级部门，现在要求实现一个convert方法，把原始list转换成树形结构，parantId为多少就挂载在该id的属性children数组下\n```javascript\nlet list = [\n  { id: 1, name: '部门A', parentId: 0 },\n  { id: 2, name: '部门B', parentId: 0 },\n  { id: 3, name: '部门C', parentId: 1 },\n  { id: 4, name: '部门D', parentId: 1 },\n  { id: 5, name: '部门E', parentId: 2 },\n  { id: 6, name: '部门F', parentId: 3 },\n  { id: 7, name: '部门G', parentId: 2 },\n  { id: 8, name: '部门H', parentId: 4 },\n  // ...\n]\nfunction convert(list) {\n  const res = []\n  const map = {}\n  list.forEach(item => map[item.id] = item)\n  list.forEach(item => {\n    if (item.parentId === 0) return res.push(item)\n    const parent = map[item.parentId]\n    if (parent.children) {\n      parent.children.push(item)\n    } else {\n      parent.children = [item]\n    }\n  })\n  return res\n}\n\nlet result = convert(list)\nresult = [{\n  id: 1,\n  name: '部门A',\n  parentId: 0,\n  children: [{\n    id: 3,\n    name: '部门3',\n    parentId: 1,\n    children: [{\n      id: 6,\n      name: '部门6',\n      parentId: 3,\n    }]\n  }]\n}, /* ... */]\n```\n\n6.将entry转换为output、将output转换为entry：\n```javascript\nvar entry = {\n  'a.b.c.dd': 'abcdd',\n  'a.d.xx': 'adxx',\n  'a.e': 'ae',\n}\n// =>\nvar output = {\n  a: {\n    b: {\n      c: {\n        dd: 'abcdd'\n      }\n    },\n    d: {\n      xx: 'adxx'\n    },\n    e: 'ae'\n  }\n}\n```\n\n```javascript\n// entry => output\nfunction gen(obj = {}, str, val) {\n  str.split('.').reduce((acc, i, idx, source) => {\n    if (!acc[i]) {\n      acc[i] = idx === source.length - 1 ? val : {}\n    }\n    return acc[i]\n  }, obj)\n  return obj\n}\nfunction generater(obj) {\n  const newObj = {}\n  for (let i in obj) {\n    gen(newObj, i, obj[i])\n  }\n  return newObj\n}\ngenerater(entry)\n```\n\n```javascript\n// output => entry answer1\nconst isObj = val => Object.prototype.toString.call(val) === '[object Object]'\nfunction fn(obj = {}, key, newObj = {}) {\n  for (let i in obj) {\n    const nkey = key ? key + '.' + i : i\n    if (isObj(obj[i])) {\n      fn(obj[i], nkey, newObj)\n    } else {\n      newObj[nkey] = obj[i]\n    }\n  }\n  return newObj\n}\n// output => entry answer2\nfunction fn(obj = {}) {\n  const queue = Object.entries(obj)\n  const res = {}\n  while(queue.length) {\n    const [key, obj] = queue.pop()\n    for (const [k, v] of Object.entries(obj)) {\n      if (!isObj(v)) {\n        res[`${key}.${k}`] = v\n      } else {\n        queue.push([`${key}.${k}`, v])\n      }\n    }\n  }\n  return res\n}\n```\n\n7.实现一个简单的仓储系统，可以不断转入和转出货物，货物最多有两层子类目，数字代表该子类目转入/转出的数量。转出时不能出现爆仓情况。\n```javascript\n/*\n * cargo 说明：\n * key代表类目/子类目名称\n * value 为 number时，代表这个类目的数量，为object 时，代表下一层货物的集合，最多嵌套两层\n * {\n *  productA:{  // 代表货物的类目名称\n *    a:1, // 1 代表子类目 a 的数量\n *    b:2,\n *    c:{   // c 代表货物的子类名称\n *      c1:1, // c1代表货物的子类名称\n *    }\n *   }，\n *  productB:{\n *      e:6\n *   }\n * }\n *\n * 爆仓情况：如转入 {productA:{a:3,c:1}} 转出 {productA:{a:4}},就会发生子类目a爆仓，此时要返回报错。\n */\n\nclass Depository {\n  constructor() {\n    this.product = {}\n  }\n  compineProduct(cargo, product) {\n    for (let i in cargo) {\n      if (!product[i]) {\n        product[i] = {}\n      }\n      if (typeof cargo[i] === 'number') {\n        if (typeof product[i] === 'number') {\n          product[i] += cargo[i]\n        } else {\n          product[i] = cargo[i]\n        }\n      } else {\n        this.compineProduct(cargo[i], product[i])\n      }\n    }\n  }\n  reduceProduct(cargo, product) {\n    for (let i in cargo) {\n      if (!product[i]) {\n        throw `货物${i}不存在`\n      }\n      if (typeof cargo[i] === 'number') {\n        if (product[i] - cargo[i] <= 0) {\n          throw `货物${i}爆仓`\n        }\n        product[i] -= cargo[i]\n      } else {\n        this.reduceProduct(cargo[i], product[i])\n      }\n    }\n  }\n  // 转入货物\n  transferIn(cargo) {\n    if (!cargo) return this.product\n    this.compineProduct(cargo, this.product)\n    return this.product\n  }\n  // 转出货物\n  transferOut(cargo) {\n    if (!cargo) return this.product\n    this.reduceProduct(cargo, this.product)\n    return this.product\n  }\n}\n```\n\n8.使用Javascript Proxy实现简单的数据绑定 \n```html\n<input id=\"inputField\" value=\"\" type=\"text\" placeholder=\"\" />\n<p id=\"showField\"></p>\n```\n```javascript\nconst proxy1 = {\n  get(target, propKey) {\n    console.log(`getting:${propKey}`)\n    return Reflect.get(target, propKey)\n  },\n  set(target, propKey, value) {\n    console.log(`setting:${propKey}、${value}`)\n    handler(value)\n    return Reflect.set(target, propKey, value)\n  }\n}\n\nfunction handler(value) {\n  document.querySelector('#showField').innerHTML = value\n}\n\nvar obj = new Proxy({}, proxy1)\ndocument.querySelector('#inputField').addEventListener('input', (e) => {\n  obj.txt = e.target.value\n})\n```\n[demo](https://www.epoos.com/demo/vue/proxy.html)","slug":"qa5","published":1,"updated":"2021-03-30T01:32:00.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug6001ia0vz6y2r0ih1","content":"<p>1.对象深度优先遍历和广度优先遍历的实现<br>如图：<br><img src=\"http://zhoushirong.github.io/img/map.png\" alt=\"ssh-l图片\" width=\"630\" height=\"215\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  a1: &#123;</span><br><span class=\"line\">    a1b1: <span class=\"number\">1</span>,</span><br><span class=\"line\">    a1b2: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  a2: &#123;</span><br><span class=\"line\">    a2b1: <span class=\"number\">3</span>,</span><br><span class=\"line\">    a2b2: <span class=\"number\">4</span>,</span><br><span class=\"line\">    a2b3: <span class=\"number\">5</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 深度优先遍历</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> depthArr = []</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">depthFirst</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    depthArr.push(i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(obj[i]) === <span class=\"string\">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class=\"line\">      depthFirst(obj[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> depthArr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 广度优先遍历</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> breadthArr = []</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">breadthFirst</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">  breadthArr = breadthArr.concat(arr)</span><br><span class=\"line\">  arr.forEach(<span class=\"function\"><span class=\"params\">i</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(obj[i]) === <span class=\"string\">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class=\"line\">      breadthFirst(obj[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">depthFirst(obj) <span class=\"comment\">// [&#x27;a1&#x27;, &#x27;a1b1&#x27;, &#x27;a1b2&#x27;, &#x27;a2&#x27;, &#x27;a2b1&#x27;, &#x27;a2b2&#x27;, &#x27;a2b3&#x27;]</span></span><br><span class=\"line\">breadthFirst(obj) <span class=\"comment\">// [&#x27;a1&#x27;, &#x27;a2&#x27;, &#x27;a1b1&#x27;, &#x27;a1b2&#x27;, &#x27;a2b1&#x27;, &#x27;a2b2&#x27;, &#x27;a2b3&#x27;]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(depthArr, breadthArr)</span><br></pre></td></tr></table></figure>\n<p>2.用深度优先思想实现一个深拷贝函数<br>深度拷贝最主要需要考虑的因素就是需要考虑js的各种数据类型<br>1）6种基本类型(number,string,null,undefined,boolean,symbol)不需要处理，直接复制返回即可<br>2）几种特殊类型 date、regexp、set、map，直接new一遍即可<br>3）需要着重处理的类型 Array、Object，直接使用递归处理即可<br>4）递归处理Array、Object的过程中需要考虑循环引用，循环引用处理可以利用WeakMap将每次递归的对象存储起来，如果一样，直接返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  a1: &#123;</span><br><span class=\"line\">    a1b1: <span class=\"number\">1</span>,</span><br><span class=\"line\">    a1b2: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  a2: &#123;</span><br><span class=\"line\">    a2b1: <span class=\"number\">3</span>,</span><br><span class=\"line\">    a2b2: <span class=\"number\">4</span>,</span><br><span class=\"line\">    a2b3: <span class=\"number\">5</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  fn1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;fn1&#x27;</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  symbolData: <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;symbolData&#x27;</span>),</span><br><span class=\"line\">  booleanData: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  date: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">  nullData: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  arrData: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, &#123; <span class=\"attr\">arr1</span>: &#123; <span class=\"attr\">a</span>:<span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;, <span class=\"attr\">arr2</span>: [] &#125;],</span><br><span class=\"line\">  numberData: <span class=\"number\">1</span>,</span><br><span class=\"line\">  strData: <span class=\"string\">&#x27;abc&#x27;</span>,</span><br><span class=\"line\">  regexData: <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&#x27;abcdefg&#x27;</span>),</span><br><span class=\"line\">  setData: <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(),</span><br><span class=\"line\">  mapData: <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.obj = obj <span class=\"comment\">// 循环引用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isType</span>(<span class=\"params\">target, type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(target).slice(<span class=\"number\">8</span>, -<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(target) === <span class=\"string\">`[object <span class=\"subst\">$&#123;type&#125;</span>]`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">depthFirstClone</span>(<span class=\"params\">obj, hash = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>()</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oType = isType(obj)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oType !== <span class=\"string\">&#x27;Object&#x27;</span> &amp;&amp; oType !== <span class=\"string\">&#x27;Array&#x27;</span>) <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hash.has(obj)) <span class=\"keyword\">return</span> hash.get(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> newObj = oType === <span class=\"string\">&#x27;Array&#x27;</span> ? [] : &#123;&#125;</span><br><span class=\"line\">  hash.set(obj, newObj)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> obj[i] === <span class=\"string\">&#x27;string&#x27;</span> ||</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> obj[i] === <span class=\"string\">&#x27;number&#x27;</span> ||</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> obj[i] === <span class=\"string\">&#x27;boolean&#x27;</span> ||</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> obj[i] === <span class=\"string\">&#x27;symbol&#x27;</span> ||</span><br><span class=\"line\">      obj[i] === <span class=\"literal\">undefined</span> ||</span><br><span class=\"line\">      obj[i] === <span class=\"literal\">null</span></span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      newObj[i] = obj[i]</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(obj[i], <span class=\"string\">&#x27;Function&#x27;</span>)) &#123;</span><br><span class=\"line\">      newObj[i] = obj[i]</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(obj[i], <span class=\"string\">&#x27;Set&#x27;</span>)) &#123;</span><br><span class=\"line\">      newObj[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(obj[i])</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(obj[i], <span class=\"string\">&#x27;Map&#x27;</span>)) &#123;</span><br><span class=\"line\">      newObj[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(obj[i])</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(obj[i], <span class=\"string\">&#x27;Date&#x27;</span>)) &#123;</span><br><span class=\"line\">      newObj[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(obj[i])</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(obj[i], <span class=\"string\">&#x27;RegExp&#x27;</span>)) &#123;</span><br><span class=\"line\">      newObj[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(obj[i])</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(obj[i], <span class=\"string\">&#x27;Array&#x27;</span>) || isType(obj[i], <span class=\"string\">&#x27;Object&#x27;</span>)) &#123;</span><br><span class=\"line\">      newObj[i] = depthFirstClone(obj[i], hash)</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cloneObj = depthFirstClone(obj)</span><br></pre></td></tr></table></figure>\n<p>3.实现一个LazyMan类，实现以下功能<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LazyMan(<span class=\"string\">&#x27;Tony&#x27;</span>) <span class=\"comment\">// Hi I am Tony</span></span><br><span class=\"line\">LazyMan(<span class=\"string\">&#x27;Tony&#x27;</span>).sleep(<span class=\"number\">10</span>).eat(<span class=\"string\">&#x27;lunch&#x27;</span>) </span><br><span class=\"line\"><span class=\"comment\">// Hi I am Tony </span></span><br><span class=\"line\"><span class=\"comment\">// 等待10s</span></span><br><span class=\"line\"><span class=\"comment\">// I am eating lunch</span></span><br><span class=\"line\">LazyMan(<span class=\"string\">&#x27;Tony&#x27;</span>).eat(<span class=\"string\">&#x27;lunch&#x27;</span>).sleep(<span class=\"number\">10</span>).eat(<span class=\"string\">&#x27;dinner&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// Hi I am Tony </span></span><br><span class=\"line\"><span class=\"comment\">// I am eating lunch</span></span><br><span class=\"line\"><span class=\"comment\">// 等待10s</span></span><br><span class=\"line\"><span class=\"comment\">// I am eating dinner</span></span><br><span class=\"line\">LazyMan(<span class=\"string\">&#x27;Tony&#x27;</span>).eat(<span class=\"string\">&#x27;lunch&#x27;</span>).eat(<span class=\"string\">&#x27;dinner&#x27;</span>).sleepFirst(<span class=\"number\">5</span>).sleep(<span class=\"number\">10</span>).eat(<span class=\"string\">&#x27;junk food&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// Hi I am Tony </span></span><br><span class=\"line\"><span class=\"comment\">// 等待5s</span></span><br><span class=\"line\"><span class=\"comment\">// I am eating lunch</span></span><br><span class=\"line\"><span class=\"comment\">// I am eating dinner</span></span><br><span class=\"line\"><span class=\"comment\">// 等待10s</span></span><br><span class=\"line\"><span class=\"comment\">// I am eating junk food</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazyManClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.task = []</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi I am <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">this</span>.next())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">sleepFirst</span>(<span class=\"params\">time</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fn = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`sleep <span class=\"subst\">$&#123;time&#125;</span>ms`</span>)</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next()</span><br><span class=\"line\">      &#125;, time)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.task.unshift(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">sleep</span>(<span class=\"params\">time</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fn = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`sleep <span class=\"subst\">$&#123;time&#125;</span>ms`</span>)</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next()</span><br><span class=\"line\">      &#125;, time)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.task.push(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">eat</span>(<span class=\"params\">food</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.task.push(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`I am eating <span class=\"subst\">$&#123;food&#125;</span>`</span>)</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.next()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">next</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fn = <span class=\"built_in\">this</span>.task.shift()</span><br><span class=\"line\">    fn &amp;&amp; fn()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LazyManClass(name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LazyMan(<span class=\"string\">&#x27;Tony&#x27;</span>).eat(<span class=\"string\">&#x27;lunch&#x27;</span>).eat(<span class=\"string\">&#x27;dinner&#x27;</span>).sleepFirst(<span class=\"number\">5000</span>).sleep(<span class=\"number\">10000</span>).eat(<span class=\"string\">&#x27;junk food&#x27;</span>)</span><br></pre></td></tr></table></figure></p>\n<p>4、定义一个列表类List,该类包含成员方法 add()、all() 和属性 length,要求构造函数和add0方法的参数为动态参数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造函数示例：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ls = <span class=\"keyword\">new</span> List(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>,<span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// add方法示例</span></span><br><span class=\"line\">ls.add(<span class=\"string\">&#x27;D&#x27;</span>,<span class=\"string\">&#x27;E&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// length属性</span></span><br><span class=\"line\">ls.length; <span class=\"comment\">// =&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">// items属性</span></span><br><span class=\"line\">ls.all(); <span class=\"comment\">// =&gt;【A,B,&quot;C,&quot;D,&quot;E]</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.args = [...arguments]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.args = <span class=\"built_in\">Array</span>.prototype.concat(<span class=\"built_in\">this</span>.args, [...arguments])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">all</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.args</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">length</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.args.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> ls = <span class=\"keyword\">new</span> List(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">ls.add(<span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ls.length)</span><br><span class=\"line\">ls.all()</span><br></pre></td></tr></table></figure>\n<p>5.实现convert方法，把原始list转换成树形结构，要求尽可能降低时间复杂度<br>以下数据结构中，id代表部门编号，name是部门名称，parentId是父部门编号，为0代表一级部门，现在要求实现一个convert方法，把原始list转换成树形结构，parantId为多少就挂载在该id的属性children数组下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门A&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门B&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门C&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">1</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">4</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门D&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">1</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">5</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门E&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">6</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门F&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">3</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">7</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门G&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">8</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门H&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">4</span> &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">convert</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> map = &#123;&#125;</span><br><span class=\"line\">  list.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> map[item.id] = item)</span><br><span class=\"line\">  list.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item.parentId === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res.push(item)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parent = map[item.parentId]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent.children) &#123;</span><br><span class=\"line\">      parent.children.push(item)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      parent.children = [item]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = convert(list)</span><br><span class=\"line\">result = [&#123;</span><br><span class=\"line\">  id: <span class=\"number\">1</span>,</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;部门A&#x27;</span>,</span><br><span class=\"line\">  parentId: <span class=\"number\">0</span>,</span><br><span class=\"line\">  children: [&#123;</span><br><span class=\"line\">    id: <span class=\"number\">3</span>,</span><br><span class=\"line\">    name: <span class=\"string\">&#x27;部门3&#x27;</span>,</span><br><span class=\"line\">    parentId: <span class=\"number\">1</span>,</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">      id: <span class=\"number\">6</span>,</span><br><span class=\"line\">      name: <span class=\"string\">&#x27;部门6&#x27;</span>,</span><br><span class=\"line\">      parentId: <span class=\"number\">3</span>,</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;, <span class=\"comment\">/* ... */</span>]</span><br></pre></td></tr></table></figure></p>\n<p>6.将entry转换为output、将output转换为entry：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> entry = &#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;a.b.c.dd&#x27;</span>: <span class=\"string\">&#x27;abcdd&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;a.d.xx&#x27;</span>: <span class=\"string\">&#x27;adxx&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;a.e&#x27;</span>: <span class=\"string\">&#x27;ae&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// =&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> output = &#123;</span><br><span class=\"line\">  a: &#123;</span><br><span class=\"line\">    b: &#123;</span><br><span class=\"line\">      c: &#123;</span><br><span class=\"line\">        dd: <span class=\"string\">&#x27;abcdd&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    d: &#123;</span><br><span class=\"line\">      xx: <span class=\"string\">&#x27;adxx&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    e: <span class=\"string\">&#x27;ae&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// entry =&gt; output</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gen</span>(<span class=\"params\">obj = &#123;&#125;, str, val</span>) </span>&#123;</span><br><span class=\"line\">  str.split(<span class=\"string\">&#x27;.&#x27;</span>).reduce(<span class=\"function\">(<span class=\"params\">acc, i, idx, source</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!acc[i]) &#123;</span><br><span class=\"line\">      acc[i] = idx === source.length - <span class=\"number\">1</span> ? val : &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> acc[i]</span><br><span class=\"line\">  &#125;, obj)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generater</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newObj = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    gen(newObj, i, obj[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">generater(entry)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// output =&gt; entry answer1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isObj = <span class=\"function\"><span class=\"params\">val</span> =&gt;</span> <span class=\"built_in\">Object</span>.prototype.toString.call(val) === <span class=\"string\">&#x27;[object Object]&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">obj = &#123;&#125;, key, newObj = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nkey = key ? key + <span class=\"string\">&#x27;.&#x27;</span> + i : i</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isObj(obj[i])) &#123;</span><br><span class=\"line\">      fn(obj[i], nkey, newObj)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      newObj[nkey] = obj[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output =&gt; entry answer2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">obj = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"built_in\">Object</span>.entries(obj)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">while</span>(<span class=\"params\">queue.length</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [key, obj] = queue.pop()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> [k, v] <span class=\"keyword\">of</span> <span class=\"built_in\">Object</span>.entries(obj)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isObj(v)) &#123;</span><br><span class=\"line\">        res[<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>.<span class=\"subst\">$&#123;k&#125;</span>`</span>] = v</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        queue.push([<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>.<span class=\"subst\">$&#123;k&#125;</span>`</span>, v])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>7.实现一个简单的仓储系统，可以不断转入和转出货物，货物最多有两层子类目，数字代表该子类目转入/转出的数量。转出时不能出现爆仓情况。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * cargo 说明：</span></span><br><span class=\"line\"><span class=\"comment\"> * key代表类目/子类目名称</span></span><br><span class=\"line\"><span class=\"comment\"> * value 为 number时，代表这个类目的数量，为object 时，代表下一层货物的集合，最多嵌套两层</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *  productA:&#123;  // 代表货物的类目名称</span></span><br><span class=\"line\"><span class=\"comment\"> *    a:1, // 1 代表子类目 a 的数量</span></span><br><span class=\"line\"><span class=\"comment\"> *    b:2,</span></span><br><span class=\"line\"><span class=\"comment\"> *    c:&#123;   // c 代表货物的子类名称</span></span><br><span class=\"line\"><span class=\"comment\"> *      c1:1, // c1代表货物的子类名称</span></span><br><span class=\"line\"><span class=\"comment\"> *    &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#125;，</span></span><br><span class=\"line\"><span class=\"comment\"> *  productB:&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *      e:6</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 爆仓情况：如转入 &#123;productA:&#123;a:3,c:1&#125;&#125; 转出 &#123;productA:&#123;a:4&#125;&#125;,就会发生子类目a爆仓，此时要返回报错。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Depository</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.product = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">compineProduct</span>(<span class=\"params\">cargo, product</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> cargo) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!product[i]) &#123;</span><br><span class=\"line\">        product[i] = &#123;&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> cargo[i] === <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> product[i] === <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">          product[i] += cargo[i]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          product[i] = cargo[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.compineProduct(cargo[i], product[i])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">reduceProduct</span>(<span class=\"params\">cargo, product</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> cargo) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!product[i]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">`货物<span class=\"subst\">$&#123;i&#125;</span>不存在`</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> cargo[i] === <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (product[i] - cargo[i] &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"string\">`货物<span class=\"subst\">$&#123;i&#125;</span>爆仓`</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        product[i] -= cargo[i]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.reduceProduct(cargo[i], product[i])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 转入货物</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">transferIn</span>(<span class=\"params\">cargo</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cargo) <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.product</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compineProduct(cargo, <span class=\"built_in\">this</span>.product)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.product</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 转出货物</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">transferOut</span>(<span class=\"params\">cargo</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cargo) <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.product</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.reduceProduct(cargo, <span class=\"built_in\">this</span>.product)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.product</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>8.使用Javascript Proxy实现简单的数据绑定<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;inputField&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;showField&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> proxy1 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">target, propKey</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting:<span class=\"subst\">$&#123;propKey&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, propKey)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">target, propKey, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting:<span class=\"subst\">$&#123;propKey&#125;</span>、<span class=\"subst\">$&#123;value&#125;</span>`</span>)</span><br><span class=\"line\">    handler(value)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, propKey, value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;#showField&#x27;</span>).innerHTML = value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, proxy1)</span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;#inputField&#x27;</span>).addEventListener(<span class=\"string\">&#x27;input&#x27;</span>, <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  obj.txt = e.target.value</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br><a href=\"https://www.epoos.com/demo/vue/proxy.html\">demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.对象深度优先遍历和广度优先遍历的实现<br>如图：<br><img src=\"http://zhoushirong.github.io/img/map.png\" alt=\"ssh-l图片\" width=\"630\" height=\"215\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  a1: &#123;</span><br><span class=\"line\">    a1b1: <span class=\"number\">1</span>,</span><br><span class=\"line\">    a1b2: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  a2: &#123;</span><br><span class=\"line\">    a2b1: <span class=\"number\">3</span>,</span><br><span class=\"line\">    a2b2: <span class=\"number\">4</span>,</span><br><span class=\"line\">    a2b3: <span class=\"number\">5</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 深度优先遍历</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> depthArr = []</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">depthFirst</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    depthArr.push(i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(obj[i]) === <span class=\"string\">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class=\"line\">      depthFirst(obj[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> depthArr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 广度优先遍历</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> breadthArr = []</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">breadthFirst</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">  breadthArr = breadthArr.concat(arr)</span><br><span class=\"line\">  arr.forEach(<span class=\"function\"><span class=\"params\">i</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(obj[i]) === <span class=\"string\">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class=\"line\">      breadthFirst(obj[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">depthFirst(obj) <span class=\"comment\">// [&#x27;a1&#x27;, &#x27;a1b1&#x27;, &#x27;a1b2&#x27;, &#x27;a2&#x27;, &#x27;a2b1&#x27;, &#x27;a2b2&#x27;, &#x27;a2b3&#x27;]</span></span><br><span class=\"line\">breadthFirst(obj) <span class=\"comment\">// [&#x27;a1&#x27;, &#x27;a2&#x27;, &#x27;a1b1&#x27;, &#x27;a1b2&#x27;, &#x27;a2b1&#x27;, &#x27;a2b2&#x27;, &#x27;a2b3&#x27;]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(depthArr, breadthArr)</span><br></pre></td></tr></table></figure>\n<p>2.用深度优先思想实现一个深拷贝函数<br>深度拷贝最主要需要考虑的因素就是需要考虑js的各种数据类型<br>1）6种基本类型(number,string,null,undefined,boolean,symbol)不需要处理，直接复制返回即可<br>2）几种特殊类型 date、regexp、set、map，直接new一遍即可<br>3）需要着重处理的类型 Array、Object，直接使用递归处理即可<br>4）递归处理Array、Object的过程中需要考虑循环引用，循环引用处理可以利用WeakMap将每次递归的对象存储起来，如果一样，直接返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  a1: &#123;</span><br><span class=\"line\">    a1b1: <span class=\"number\">1</span>,</span><br><span class=\"line\">    a1b2: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  a2: &#123;</span><br><span class=\"line\">    a2b1: <span class=\"number\">3</span>,</span><br><span class=\"line\">    a2b2: <span class=\"number\">4</span>,</span><br><span class=\"line\">    a2b3: <span class=\"number\">5</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  fn1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;fn1&#x27;</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  symbolData: <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;symbolData&#x27;</span>),</span><br><span class=\"line\">  booleanData: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  date: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">  nullData: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  arrData: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, &#123; <span class=\"attr\">arr1</span>: &#123; <span class=\"attr\">a</span>:<span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;, <span class=\"attr\">arr2</span>: [] &#125;],</span><br><span class=\"line\">  numberData: <span class=\"number\">1</span>,</span><br><span class=\"line\">  strData: <span class=\"string\">&#x27;abc&#x27;</span>,</span><br><span class=\"line\">  regexData: <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&#x27;abcdefg&#x27;</span>),</span><br><span class=\"line\">  setData: <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(),</span><br><span class=\"line\">  mapData: <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.obj = obj <span class=\"comment\">// 循环引用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isType</span>(<span class=\"params\">target, type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(target).slice(<span class=\"number\">8</span>, -<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(target) === <span class=\"string\">`[object <span class=\"subst\">$&#123;type&#125;</span>]`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">depthFirstClone</span>(<span class=\"params\">obj, hash = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>()</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oType = isType(obj)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oType !== <span class=\"string\">&#x27;Object&#x27;</span> &amp;&amp; oType !== <span class=\"string\">&#x27;Array&#x27;</span>) <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hash.has(obj)) <span class=\"keyword\">return</span> hash.get(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> newObj = oType === <span class=\"string\">&#x27;Array&#x27;</span> ? [] : &#123;&#125;</span><br><span class=\"line\">  hash.set(obj, newObj)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> obj[i] === <span class=\"string\">&#x27;string&#x27;</span> ||</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> obj[i] === <span class=\"string\">&#x27;number&#x27;</span> ||</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> obj[i] === <span class=\"string\">&#x27;boolean&#x27;</span> ||</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> obj[i] === <span class=\"string\">&#x27;symbol&#x27;</span> ||</span><br><span class=\"line\">      obj[i] === <span class=\"literal\">undefined</span> ||</span><br><span class=\"line\">      obj[i] === <span class=\"literal\">null</span></span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      newObj[i] = obj[i]</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(obj[i], <span class=\"string\">&#x27;Function&#x27;</span>)) &#123;</span><br><span class=\"line\">      newObj[i] = obj[i]</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(obj[i], <span class=\"string\">&#x27;Set&#x27;</span>)) &#123;</span><br><span class=\"line\">      newObj[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(obj[i])</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(obj[i], <span class=\"string\">&#x27;Map&#x27;</span>)) &#123;</span><br><span class=\"line\">      newObj[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(obj[i])</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(obj[i], <span class=\"string\">&#x27;Date&#x27;</span>)) &#123;</span><br><span class=\"line\">      newObj[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(obj[i])</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(obj[i], <span class=\"string\">&#x27;RegExp&#x27;</span>)) &#123;</span><br><span class=\"line\">      newObj[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(obj[i])</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isType(obj[i], <span class=\"string\">&#x27;Array&#x27;</span>) || isType(obj[i], <span class=\"string\">&#x27;Object&#x27;</span>)) &#123;</span><br><span class=\"line\">      newObj[i] = depthFirstClone(obj[i], hash)</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cloneObj = depthFirstClone(obj)</span><br></pre></td></tr></table></figure>\n<p>3.实现一个LazyMan类，实现以下功能<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LazyMan(<span class=\"string\">&#x27;Tony&#x27;</span>) <span class=\"comment\">// Hi I am Tony</span></span><br><span class=\"line\">LazyMan(<span class=\"string\">&#x27;Tony&#x27;</span>).sleep(<span class=\"number\">10</span>).eat(<span class=\"string\">&#x27;lunch&#x27;</span>) </span><br><span class=\"line\"><span class=\"comment\">// Hi I am Tony </span></span><br><span class=\"line\"><span class=\"comment\">// 等待10s</span></span><br><span class=\"line\"><span class=\"comment\">// I am eating lunch</span></span><br><span class=\"line\">LazyMan(<span class=\"string\">&#x27;Tony&#x27;</span>).eat(<span class=\"string\">&#x27;lunch&#x27;</span>).sleep(<span class=\"number\">10</span>).eat(<span class=\"string\">&#x27;dinner&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// Hi I am Tony </span></span><br><span class=\"line\"><span class=\"comment\">// I am eating lunch</span></span><br><span class=\"line\"><span class=\"comment\">// 等待10s</span></span><br><span class=\"line\"><span class=\"comment\">// I am eating dinner</span></span><br><span class=\"line\">LazyMan(<span class=\"string\">&#x27;Tony&#x27;</span>).eat(<span class=\"string\">&#x27;lunch&#x27;</span>).eat(<span class=\"string\">&#x27;dinner&#x27;</span>).sleepFirst(<span class=\"number\">5</span>).sleep(<span class=\"number\">10</span>).eat(<span class=\"string\">&#x27;junk food&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// Hi I am Tony </span></span><br><span class=\"line\"><span class=\"comment\">// 等待5s</span></span><br><span class=\"line\"><span class=\"comment\">// I am eating lunch</span></span><br><span class=\"line\"><span class=\"comment\">// I am eating dinner</span></span><br><span class=\"line\"><span class=\"comment\">// 等待10s</span></span><br><span class=\"line\"><span class=\"comment\">// I am eating junk food</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazyManClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.task = []</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi I am <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">this</span>.next())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">sleepFirst</span>(<span class=\"params\">time</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fn = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`sleep <span class=\"subst\">$&#123;time&#125;</span>ms`</span>)</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next()</span><br><span class=\"line\">      &#125;, time)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.task.unshift(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">sleep</span>(<span class=\"params\">time</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fn = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`sleep <span class=\"subst\">$&#123;time&#125;</span>ms`</span>)</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next()</span><br><span class=\"line\">      &#125;, time)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.task.push(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">eat</span>(<span class=\"params\">food</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.task.push(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`I am eating <span class=\"subst\">$&#123;food&#125;</span>`</span>)</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.next()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">next</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fn = <span class=\"built_in\">this</span>.task.shift()</span><br><span class=\"line\">    fn &amp;&amp; fn()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LazyManClass(name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LazyMan(<span class=\"string\">&#x27;Tony&#x27;</span>).eat(<span class=\"string\">&#x27;lunch&#x27;</span>).eat(<span class=\"string\">&#x27;dinner&#x27;</span>).sleepFirst(<span class=\"number\">5000</span>).sleep(<span class=\"number\">10000</span>).eat(<span class=\"string\">&#x27;junk food&#x27;</span>)</span><br></pre></td></tr></table></figure></p>\n<p>4、定义一个列表类List,该类包含成员方法 add()、all() 和属性 length,要求构造函数和add0方法的参数为动态参数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造函数示例：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ls = <span class=\"keyword\">new</span> List(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>,<span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// add方法示例</span></span><br><span class=\"line\">ls.add(<span class=\"string\">&#x27;D&#x27;</span>,<span class=\"string\">&#x27;E&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// length属性</span></span><br><span class=\"line\">ls.length; <span class=\"comment\">// =&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">// items属性</span></span><br><span class=\"line\">ls.all(); <span class=\"comment\">// =&gt;【A,B,&quot;C,&quot;D,&quot;E]</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.args = [...arguments]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.args = <span class=\"built_in\">Array</span>.prototype.concat(<span class=\"built_in\">this</span>.args, [...arguments])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">all</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.args</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">length</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.args.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> ls = <span class=\"keyword\">new</span> List(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>)</span><br><span class=\"line\">ls.add(<span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ls.length)</span><br><span class=\"line\">ls.all()</span><br></pre></td></tr></table></figure>\n<p>5.实现convert方法，把原始list转换成树形结构，要求尽可能降低时间复杂度<br>以下数据结构中，id代表部门编号，name是部门名称，parentId是父部门编号，为0代表一级部门，现在要求实现一个convert方法，把原始list转换成树形结构，parantId为多少就挂载在该id的属性children数组下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门A&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门B&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门C&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">1</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">4</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门D&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">1</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">5</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门E&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">6</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门F&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">3</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">7</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门G&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">8</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;部门H&#x27;</span>, <span class=\"attr\">parentId</span>: <span class=\"number\">4</span> &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">convert</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> map = &#123;&#125;</span><br><span class=\"line\">  list.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> map[item.id] = item)</span><br><span class=\"line\">  list.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item.parentId === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res.push(item)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parent = map[item.parentId]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent.children) &#123;</span><br><span class=\"line\">      parent.children.push(item)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      parent.children = [item]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = convert(list)</span><br><span class=\"line\">result = [&#123;</span><br><span class=\"line\">  id: <span class=\"number\">1</span>,</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;部门A&#x27;</span>,</span><br><span class=\"line\">  parentId: <span class=\"number\">0</span>,</span><br><span class=\"line\">  children: [&#123;</span><br><span class=\"line\">    id: <span class=\"number\">3</span>,</span><br><span class=\"line\">    name: <span class=\"string\">&#x27;部门3&#x27;</span>,</span><br><span class=\"line\">    parentId: <span class=\"number\">1</span>,</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">      id: <span class=\"number\">6</span>,</span><br><span class=\"line\">      name: <span class=\"string\">&#x27;部门6&#x27;</span>,</span><br><span class=\"line\">      parentId: <span class=\"number\">3</span>,</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;, <span class=\"comment\">/* ... */</span>]</span><br></pre></td></tr></table></figure></p>\n<p>6.将entry转换为output、将output转换为entry：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> entry = &#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;a.b.c.dd&#x27;</span>: <span class=\"string\">&#x27;abcdd&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;a.d.xx&#x27;</span>: <span class=\"string\">&#x27;adxx&#x27;</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;a.e&#x27;</span>: <span class=\"string\">&#x27;ae&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// =&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> output = &#123;</span><br><span class=\"line\">  a: &#123;</span><br><span class=\"line\">    b: &#123;</span><br><span class=\"line\">      c: &#123;</span><br><span class=\"line\">        dd: <span class=\"string\">&#x27;abcdd&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    d: &#123;</span><br><span class=\"line\">      xx: <span class=\"string\">&#x27;adxx&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    e: <span class=\"string\">&#x27;ae&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// entry =&gt; output</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gen</span>(<span class=\"params\">obj = &#123;&#125;, str, val</span>) </span>&#123;</span><br><span class=\"line\">  str.split(<span class=\"string\">&#x27;.&#x27;</span>).reduce(<span class=\"function\">(<span class=\"params\">acc, i, idx, source</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!acc[i]) &#123;</span><br><span class=\"line\">      acc[i] = idx === source.length - <span class=\"number\">1</span> ? val : &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> acc[i]</span><br><span class=\"line\">  &#125;, obj)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generater</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newObj = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    gen(newObj, i, obj[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">generater(entry)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// output =&gt; entry answer1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isObj = <span class=\"function\"><span class=\"params\">val</span> =&gt;</span> <span class=\"built_in\">Object</span>.prototype.toString.call(val) === <span class=\"string\">&#x27;[object Object]&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">obj = &#123;&#125;, key, newObj = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nkey = key ? key + <span class=\"string\">&#x27;.&#x27;</span> + i : i</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isObj(obj[i])) &#123;</span><br><span class=\"line\">      fn(obj[i], nkey, newObj)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      newObj[nkey] = obj[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output =&gt; entry answer2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">obj = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue = <span class=\"built_in\">Object</span>.entries(obj)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">while</span>(<span class=\"params\">queue.length</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [key, obj] = queue.pop()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> [k, v] <span class=\"keyword\">of</span> <span class=\"built_in\">Object</span>.entries(obj)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isObj(v)) &#123;</span><br><span class=\"line\">        res[<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>.<span class=\"subst\">$&#123;k&#125;</span>`</span>] = v</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        queue.push([<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>.<span class=\"subst\">$&#123;k&#125;</span>`</span>, v])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>7.实现一个简单的仓储系统，可以不断转入和转出货物，货物最多有两层子类目，数字代表该子类目转入/转出的数量。转出时不能出现爆仓情况。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * cargo 说明：</span></span><br><span class=\"line\"><span class=\"comment\"> * key代表类目/子类目名称</span></span><br><span class=\"line\"><span class=\"comment\"> * value 为 number时，代表这个类目的数量，为object 时，代表下一层货物的集合，最多嵌套两层</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *  productA:&#123;  // 代表货物的类目名称</span></span><br><span class=\"line\"><span class=\"comment\"> *    a:1, // 1 代表子类目 a 的数量</span></span><br><span class=\"line\"><span class=\"comment\"> *    b:2,</span></span><br><span class=\"line\"><span class=\"comment\"> *    c:&#123;   // c 代表货物的子类名称</span></span><br><span class=\"line\"><span class=\"comment\"> *      c1:1, // c1代表货物的子类名称</span></span><br><span class=\"line\"><span class=\"comment\"> *    &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#125;，</span></span><br><span class=\"line\"><span class=\"comment\"> *  productB:&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *      e:6</span></span><br><span class=\"line\"><span class=\"comment\"> *   &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 爆仓情况：如转入 &#123;productA:&#123;a:3,c:1&#125;&#125; 转出 &#123;productA:&#123;a:4&#125;&#125;,就会发生子类目a爆仓，此时要返回报错。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Depository</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.product = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">compineProduct</span>(<span class=\"params\">cargo, product</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> cargo) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!product[i]) &#123;</span><br><span class=\"line\">        product[i] = &#123;&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> cargo[i] === <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> product[i] === <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">          product[i] += cargo[i]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          product[i] = cargo[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.compineProduct(cargo[i], product[i])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">reduceProduct</span>(<span class=\"params\">cargo, product</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> cargo) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!product[i]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">`货物<span class=\"subst\">$&#123;i&#125;</span>不存在`</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> cargo[i] === <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (product[i] - cargo[i] &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"string\">`货物<span class=\"subst\">$&#123;i&#125;</span>爆仓`</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        product[i] -= cargo[i]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.reduceProduct(cargo[i], product[i])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 转入货物</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">transferIn</span>(<span class=\"params\">cargo</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cargo) <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.product</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.compineProduct(cargo, <span class=\"built_in\">this</span>.product)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.product</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 转出货物</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">transferOut</span>(<span class=\"params\">cargo</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cargo) <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.product</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.reduceProduct(cargo, <span class=\"built_in\">this</span>.product)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.product</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>8.使用Javascript Proxy实现简单的数据绑定<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;inputField&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;showField&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> proxy1 = &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">target, propKey</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting:<span class=\"subst\">$&#123;propKey&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, propKey)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">target, propKey, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting:<span class=\"subst\">$&#123;propKey&#125;</span>、<span class=\"subst\">$&#123;value&#125;</span>`</span>)</span><br><span class=\"line\">    handler(value)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, propKey, value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;#showField&#x27;</span>).innerHTML = value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, proxy1)</span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;#inputField&#x27;</span>).addEventListener(<span class=\"string\">&#x27;input&#x27;</span>, <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  obj.txt = e.target.value</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br><a href=\"https://www.epoos.com/demo/vue/proxy.html\">demo</a></p>\n"},{"title":"关于DOM的基础操作","date":"2020-12-13T16:00:00.000Z","_content":"\n\n1.手写前端路由\n手写路由两个核心\n1）改变url地址，页面不刷新\n2）如何检测url变化\n\n```javascript\n/**\n * hash 实现 \n * 1）hash改变页面不会刷新\n * 2）通过hashchange监听hash变化\n * history 实现\n * 1）history提供了pushState、replaceState方法改变url的path不会引起页面刷新\n * 2）popstate事件监听url路径变化\n * 注意：浏览器前进、后退改变url的时候会触发popstate事件，\n *      javascript的history： go/back/forword 会触发该事件\n *      但是通过pushState、replaceState以及a标签改变url的时候不会触发\n */\nclass HistoryRoute {\n\tconstructor() {\n\t\tthis.current = null\n\t}\n}\nclass VueRouter {\n\tconstructor(options) {\n\t\tthis.mode = options.mode || \"hash\"\n\t\tthis.routes = options.routes || [] //你传递的这个路由是一个数组表\n\t\tthis.routesMap = this.createMap(this.routes)\n\t\tthis.history = new HistoryRoute();\n\t\tthis.init()\n\n\t}\n\tinit() {\n\t\tif (this.mode === \"hash\") {\n\t\t\t// 先判断用户打开时有没有hash值，没有的话跳转到#/\n\t\t\tlocation.hash ? '' : location.hash = \"/\";\n\t\t\twindow.addEventListener(\"load\", () => {\n\t\t\t\tthis.history.current = location.hash.slice(1)\n\t\t\t})\n\t\t\twindow.addEventListener(\"hashchange\", () => {\n\t\t\t\tthis.history.current = location.hash.slice(1)\n\t\t\t})\n\t\t} else {\n\t\t\tlocation.pathname ? '' : location.pathname = \"/\";\n\t\t\twindow.addEventListener('load', () => {\n\t\t\t\tthis.history.current = location.pathname\n\t\t\t})\n\t\t\twindow.addEventListener(\"popstate\", () => {\n\t\t\t\tthis.history.current = location.pathname\n\t\t\t})\n\t\t}\n\t}\n\n\tcreateMap(routes) {\n\t\treturn routes.reduce((pre, current) => {\n\t\t\tpre[current.path] = current.component\n\t\t\treturn pre;\n\t\t}, {})\n\t}\n}\n```\n\n2、实现下面的字符串格式化函数 format( String, Object),避免出现XSS :\n```javascript\n  document\n  .body\n  .innerHTML = \n  format('<div>I am {name}, my website is <a href=\"{website}\">{website}</a></div>',{\n    name: 'James',\n    website: 'http://www.qq.com'\n  })\n```\n```javascript\nconst str = '<div>I am { name }, my website is <a href=\"{website}\">{website}</a></div>'\nconst data = {\n  name: 'James',\n  website: 'http://www.qq.com'\n}\nfunction format(str, data) {\n  return str\n  .replace(/&/g, '&amp')\n  .replace(/</g, '&lt;')\n  .replace(/>/g, '&gt;')\n  .replace(/ /g, '&nbsp;')\n  .replace(/\\'/g, '&#39;')\n  .replace(/\\\"/g, '&quot;')\n  .replace(/\\{(.*?)\\}/g, (i, k) => data[k.trim()])\n}\nformat(str, data)\n```\n\n\n3、通过JS在下面的ul中插入10000条 li 节点,并在点击 li 时打印其下标\n```html\n<ul id=\"list></ul>\n```\n```javascript\nconst ul = document.querySelector('#ul')\nconst fragment = document.createDocumentFragment()\nul.innerHTML= ''\nfor (let i = 0; i < 10000; i++) {\n  const li = document.createElement('li')\n  li.innerText = i\n  li.setAttribute('data-index', i)\n  fragment.appendChild(li)\n}\nul.appendChild(fragment)\nul.addEventListener('click', (e) => {\n  console.log(e.target.dataset.index)\n})\n```\n\n4.在输入框中如何判断输入的是一个正确的网址\n```javascript\nvar url = 'https://www.abc.com'\nfunction checkUrl(url) {\n  try {\n    return new URL(url)\n  } catch(e) {\n    return false\n  }\n}\ncheckUrl(url)\n```\n\n\n5、请按照如下布局在pc端实现htm和css样式，要求:\na)A区域是 header部分,高度100像素,宽度根据屏幕自适应,居顶部展示\nb)B区域固定宽度200像素,居左侧展示\nc)C区域根据屏幕宽度自适应\nd)D区域固定宽度200像素,居右侧展示\ne)E区域高度80像素,宽度自适应,当整体内容不够满屏展示,E居屏幕底部展示\nf)当整体内容超出屏幕高度,出现垂直滚动\n\ndemo：\n[https://www.epoos.com/demo/learn/layout1.html](https://www.epoos.com/demo/learn/layout1.html)\n\n```html\n<style>\n.header {\n  background:#396;\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 60px;\n  z-index: 2;\n}\n.header-none {\n  height: 60px;\n}\n.left {\n  background:#963;\n  position: absolute;\n  left: 0;\n  top: 60px;\n  width: 200px;\n}\n.content {\n  background:#693;\n  width: 100%;\n  min-height: 100%;\n  padding: 60px 200px 30px 200px;\n  margin-top: -60px;\n  box-sizing: border-box;\n}\n.right {\n  position: absolute;\n  right: 0;\n  top: 60px;\n  background:#369;\n  width: 200px;\n}\n.footer {\n  background:cornsilk;\n  float: left;\n  width: 100%;\n  height: 30px;\n  margin-top: -30px;\n}\n</style>\n\n<body>\n<div class=\"header\">header</div>\n<div class=\"header-none\"></div>\n<div class=\"left\">left</div>\n<div class=\"content\" contenteditable=\"true\"></div>\n<div class=\"right\">right</div>\n<div class=\"footer\">footer</div>\n</body>\n```\n","source":"_posts/qa6.md","raw":"---\ntitle: 关于DOM的基础操作\ndate: 2020/12/14\ntag: [基础,面试,试题]\ncategory: 技术\n---\n\n\n1.手写前端路由\n手写路由两个核心\n1）改变url地址，页面不刷新\n2）如何检测url变化\n\n```javascript\n/**\n * hash 实现 \n * 1）hash改变页面不会刷新\n * 2）通过hashchange监听hash变化\n * history 实现\n * 1）history提供了pushState、replaceState方法改变url的path不会引起页面刷新\n * 2）popstate事件监听url路径变化\n * 注意：浏览器前进、后退改变url的时候会触发popstate事件，\n *      javascript的history： go/back/forword 会触发该事件\n *      但是通过pushState、replaceState以及a标签改变url的时候不会触发\n */\nclass HistoryRoute {\n\tconstructor() {\n\t\tthis.current = null\n\t}\n}\nclass VueRouter {\n\tconstructor(options) {\n\t\tthis.mode = options.mode || \"hash\"\n\t\tthis.routes = options.routes || [] //你传递的这个路由是一个数组表\n\t\tthis.routesMap = this.createMap(this.routes)\n\t\tthis.history = new HistoryRoute();\n\t\tthis.init()\n\n\t}\n\tinit() {\n\t\tif (this.mode === \"hash\") {\n\t\t\t// 先判断用户打开时有没有hash值，没有的话跳转到#/\n\t\t\tlocation.hash ? '' : location.hash = \"/\";\n\t\t\twindow.addEventListener(\"load\", () => {\n\t\t\t\tthis.history.current = location.hash.slice(1)\n\t\t\t})\n\t\t\twindow.addEventListener(\"hashchange\", () => {\n\t\t\t\tthis.history.current = location.hash.slice(1)\n\t\t\t})\n\t\t} else {\n\t\t\tlocation.pathname ? '' : location.pathname = \"/\";\n\t\t\twindow.addEventListener('load', () => {\n\t\t\t\tthis.history.current = location.pathname\n\t\t\t})\n\t\t\twindow.addEventListener(\"popstate\", () => {\n\t\t\t\tthis.history.current = location.pathname\n\t\t\t})\n\t\t}\n\t}\n\n\tcreateMap(routes) {\n\t\treturn routes.reduce((pre, current) => {\n\t\t\tpre[current.path] = current.component\n\t\t\treturn pre;\n\t\t}, {})\n\t}\n}\n```\n\n2、实现下面的字符串格式化函数 format( String, Object),避免出现XSS :\n```javascript\n  document\n  .body\n  .innerHTML = \n  format('<div>I am {name}, my website is <a href=\"{website}\">{website}</a></div>',{\n    name: 'James',\n    website: 'http://www.qq.com'\n  })\n```\n```javascript\nconst str = '<div>I am { name }, my website is <a href=\"{website}\">{website}</a></div>'\nconst data = {\n  name: 'James',\n  website: 'http://www.qq.com'\n}\nfunction format(str, data) {\n  return str\n  .replace(/&/g, '&amp')\n  .replace(/</g, '&lt;')\n  .replace(/>/g, '&gt;')\n  .replace(/ /g, '&nbsp;')\n  .replace(/\\'/g, '&#39;')\n  .replace(/\\\"/g, '&quot;')\n  .replace(/\\{(.*?)\\}/g, (i, k) => data[k.trim()])\n}\nformat(str, data)\n```\n\n\n3、通过JS在下面的ul中插入10000条 li 节点,并在点击 li 时打印其下标\n```html\n<ul id=\"list></ul>\n```\n```javascript\nconst ul = document.querySelector('#ul')\nconst fragment = document.createDocumentFragment()\nul.innerHTML= ''\nfor (let i = 0; i < 10000; i++) {\n  const li = document.createElement('li')\n  li.innerText = i\n  li.setAttribute('data-index', i)\n  fragment.appendChild(li)\n}\nul.appendChild(fragment)\nul.addEventListener('click', (e) => {\n  console.log(e.target.dataset.index)\n})\n```\n\n4.在输入框中如何判断输入的是一个正确的网址\n```javascript\nvar url = 'https://www.abc.com'\nfunction checkUrl(url) {\n  try {\n    return new URL(url)\n  } catch(e) {\n    return false\n  }\n}\ncheckUrl(url)\n```\n\n\n5、请按照如下布局在pc端实现htm和css样式，要求:\na)A区域是 header部分,高度100像素,宽度根据屏幕自适应,居顶部展示\nb)B区域固定宽度200像素,居左侧展示\nc)C区域根据屏幕宽度自适应\nd)D区域固定宽度200像素,居右侧展示\ne)E区域高度80像素,宽度自适应,当整体内容不够满屏展示,E居屏幕底部展示\nf)当整体内容超出屏幕高度,出现垂直滚动\n\ndemo：\n[https://www.epoos.com/demo/learn/layout1.html](https://www.epoos.com/demo/learn/layout1.html)\n\n```html\n<style>\n.header {\n  background:#396;\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 60px;\n  z-index: 2;\n}\n.header-none {\n  height: 60px;\n}\n.left {\n  background:#963;\n  position: absolute;\n  left: 0;\n  top: 60px;\n  width: 200px;\n}\n.content {\n  background:#693;\n  width: 100%;\n  min-height: 100%;\n  padding: 60px 200px 30px 200px;\n  margin-top: -60px;\n  box-sizing: border-box;\n}\n.right {\n  position: absolute;\n  right: 0;\n  top: 60px;\n  background:#369;\n  width: 200px;\n}\n.footer {\n  background:cornsilk;\n  float: left;\n  width: 100%;\n  height: 30px;\n  margin-top: -30px;\n}\n</style>\n\n<body>\n<div class=\"header\">header</div>\n<div class=\"header-none\"></div>\n<div class=\"left\">left</div>\n<div class=\"content\" contenteditable=\"true\"></div>\n<div class=\"right\">right</div>\n<div class=\"footer\">footer</div>\n</body>\n```\n","slug":"qa6","published":1,"updated":"2021-03-30T01:32:00.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug6001ja0vz05tq1xa0","content":"<p>1.手写前端路由<br>手写路由两个核心<br>1）改变url地址，页面不刷新<br>2）如何检测url变化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * hash 实现 </span></span><br><span class=\"line\"><span class=\"comment\"> * 1）hash改变页面不会刷新</span></span><br><span class=\"line\"><span class=\"comment\"> * 2）通过hashchange监听hash变化</span></span><br><span class=\"line\"><span class=\"comment\"> * history 实现</span></span><br><span class=\"line\"><span class=\"comment\"> * 1）history提供了pushState、replaceState方法改变url的path不会引起页面刷新</span></span><br><span class=\"line\"><span class=\"comment\"> * 2）popstate事件监听url路径变化</span></span><br><span class=\"line\"><span class=\"comment\"> * 注意：浏览器前进、后退改变url的时候会触发popstate事件，</span></span><br><span class=\"line\"><span class=\"comment\"> *      javascript的history： go/back/forword 会触发该事件</span></span><br><span class=\"line\"><span class=\"comment\"> *      但是通过pushState、replaceState以及a标签改变url的时候不会触发</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HistoryRoute</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.current = <span class=\"literal\">null</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VueRouter</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">options</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.mode = options.mode || <span class=\"string\">&quot;hash&quot;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.routes = options.routes || [] <span class=\"comment\">//你传递的这个路由是一个数组表</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.routesMap = <span class=\"built_in\">this</span>.createMap(<span class=\"built_in\">this</span>.routes)</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.history = <span class=\"keyword\">new</span> HistoryRoute();</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.init()</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">init</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.mode === <span class=\"string\">&quot;hash&quot;</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 先判断用户打开时有没有hash值，没有的话跳转到#/</span></span><br><span class=\"line\">\t\t\tlocation.hash ? <span class=\"string\">&#x27;&#x27;</span> : location.hash = <span class=\"string\">&quot;/&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;load&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">this</span>.history.current = location.hash.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;hashchange&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">this</span>.history.current = location.hash.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tlocation.pathname ? <span class=\"string\">&#x27;&#x27;</span> : location.pathname = <span class=\"string\">&quot;/&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;load&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">this</span>.history.current = location.pathname</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;popstate&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">this</span>.history.current = location.pathname</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">createMap</span>(<span class=\"params\">routes</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> routes.reduce(<span class=\"function\">(<span class=\"params\">pre, current</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\tpre[current.path] = current.component</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">\t\t&#125;, &#123;&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、实现下面的字符串格式化函数 format( String, Object),避免出现XSS :<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span></span><br><span class=\"line\">.body</span><br><span class=\"line\">.innerHTML = </span><br><span class=\"line\">format(<span class=\"string\">&#x27;&lt;div&gt;I am &#123;name&#125;, my website is &lt;a href=&quot;&#123;website&#125;&quot;&gt;&#123;website&#125;&lt;/a&gt;&lt;/div&gt;&#x27;</span>,&#123;</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;James&#x27;</span>,</span><br><span class=\"line\">  website: <span class=\"string\">&#x27;http://www.qq.com&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">&#x27;&lt;div&gt;I am &#123; name &#125;, my website is &lt;a href=&quot;&#123;website&#125;&quot;&gt;&#123;website&#125;&lt;/a&gt;&lt;/div&gt;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;James&#x27;</span>,</span><br><span class=\"line\">  website: <span class=\"string\">&#x27;http://www.qq.com&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">format</span>(<span class=\"params\">str, data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/&amp;/g</span>, <span class=\"string\">&#x27;&amp;amp&#x27;</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/&lt;/g</span>, <span class=\"string\">&#x27;&amp;lt;&#x27;</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/&gt;/g</span>, <span class=\"string\">&#x27;&amp;gt;&#x27;</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/ /g</span>, <span class=\"string\">&#x27;&amp;nbsp;&#x27;</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/\\&#x27;/g</span>, <span class=\"string\">&#x27;&amp;#39;&#x27;</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/\\&quot;/g</span>, <span class=\"string\">&#x27;&amp;quot;&#x27;</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/\\&#123;(.*?)\\&#125;/g</span>, <span class=\"function\">(<span class=\"params\">i, k</span>) =&gt;</span> data[k.trim()])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">format(str, data)</span><br></pre></td></tr></table></figure></p>\n<p>3、通过JS在下面的ul中插入10000条 li 节点,并在点击 li 时打印其下标<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;list&gt;&lt;/ul&gt;</span></span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ul = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;#ul&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment()</span><br><span class=\"line\">ul.innerHTML= <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;li&#x27;</span>)</span><br><span class=\"line\">  li.innerText = i</span><br><span class=\"line\">  li.setAttribute(<span class=\"string\">&#x27;data-index&#x27;</span>, i)</span><br><span class=\"line\">  fragment.appendChild(li)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ul.appendChild(fragment)</span><br><span class=\"line\">ul.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.target.dataset.index)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>4.在输入框中如何判断输入的是一个正确的网址<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">&#x27;https://www.abc.com&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkUrl</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> URL(url)</span><br><span class=\"line\">  &#125; <span class=\"function\"><span class=\"title\">catch</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkUrl(url)</span><br></pre></td></tr></table></figure></p>\n<p>5、请按照如下布局在pc端实现htm和css样式，要求:<br>a)A区域是 header部分,高度100像素,宽度根据屏幕自适应,居顶部展示<br>b)B区域固定宽度200像素,居左侧展示<br>c)C区域根据屏幕宽度自适应<br>d)D区域固定宽度200像素,居右侧展示<br>e)E区域高度80像素,宽度自适应,当整体内容不够满屏展示,E居屏幕底部展示<br>f)当整体内容超出屏幕高度,出现垂直滚动</p>\n<p>demo：<br><a href=\"https://www.epoos.com/demo/learn/layout1.html\">https://www.epoos.com/demo/learn/layout1.html</a></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.header</span> &#123;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-tag\">background</span>:<span class=\"selector-id\">#396</span>;</span></span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 60px;</span><br><span class=\"line\">  z-index: 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.header-none</span> &#123;</span></span><br><span class=\"line\">  height: 60px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.left</span> &#123;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-tag\">background</span>:<span class=\"selector-id\">#963</span>;</span></span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  top: 60px;</span><br><span class=\"line\">  width: 200px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.content</span> &#123;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-tag\">background</span>:<span class=\"selector-id\">#693</span>;</span></span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  min-height: 100%;</span><br><span class=\"line\">  padding: 60px 200px 30px 200px;</span><br><span class=\"line\">  margin-top: -60px;</span><br><span class=\"line\">  box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.right</span> &#123;</span></span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  top: 60px;</span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-tag\">background</span>:<span class=\"selector-id\">#369</span>;</span></span><br><span class=\"line\">  width: 200px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.footer</span> &#123;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-tag\">background</span><span class=\"selector-pseudo\">:cornsilk</span>;</span></span><br><span class=\"line\">  float: left;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 30px;</span><br><span class=\"line\">  margin-top: -30px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;header&quot;</span>&gt;</span>header<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;header-none&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;left&quot;</span>&gt;</span>left<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content&quot;</span> <span class=\"attr\">contenteditable</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;right&quot;</span>&gt;</span>right<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;footer&quot;</span>&gt;</span>footer<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>1.手写前端路由<br>手写路由两个核心<br>1）改变url地址，页面不刷新<br>2）如何检测url变化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * hash 实现 </span></span><br><span class=\"line\"><span class=\"comment\"> * 1）hash改变页面不会刷新</span></span><br><span class=\"line\"><span class=\"comment\"> * 2）通过hashchange监听hash变化</span></span><br><span class=\"line\"><span class=\"comment\"> * history 实现</span></span><br><span class=\"line\"><span class=\"comment\"> * 1）history提供了pushState、replaceState方法改变url的path不会引起页面刷新</span></span><br><span class=\"line\"><span class=\"comment\"> * 2）popstate事件监听url路径变化</span></span><br><span class=\"line\"><span class=\"comment\"> * 注意：浏览器前进、后退改变url的时候会触发popstate事件，</span></span><br><span class=\"line\"><span class=\"comment\"> *      javascript的history： go/back/forword 会触发该事件</span></span><br><span class=\"line\"><span class=\"comment\"> *      但是通过pushState、replaceState以及a标签改变url的时候不会触发</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HistoryRoute</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.current = <span class=\"literal\">null</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VueRouter</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">options</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.mode = options.mode || <span class=\"string\">&quot;hash&quot;</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.routes = options.routes || [] <span class=\"comment\">//你传递的这个路由是一个数组表</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.routesMap = <span class=\"built_in\">this</span>.createMap(<span class=\"built_in\">this</span>.routes)</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.history = <span class=\"keyword\">new</span> HistoryRoute();</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.init()</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">init</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.mode === <span class=\"string\">&quot;hash&quot;</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 先判断用户打开时有没有hash值，没有的话跳转到#/</span></span><br><span class=\"line\">\t\t\tlocation.hash ? <span class=\"string\">&#x27;&#x27;</span> : location.hash = <span class=\"string\">&quot;/&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;load&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">this</span>.history.current = location.hash.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;hashchange&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">this</span>.history.current = location.hash.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tlocation.pathname ? <span class=\"string\">&#x27;&#x27;</span> : location.pathname = <span class=\"string\">&quot;/&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;load&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">this</span>.history.current = location.pathname</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;popstate&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">this</span>.history.current = location.pathname</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">createMap</span>(<span class=\"params\">routes</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> routes.reduce(<span class=\"function\">(<span class=\"params\">pre, current</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\tpre[current.path] = current.component</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">\t\t&#125;, &#123;&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、实现下面的字符串格式化函数 format( String, Object),避免出现XSS :<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span></span><br><span class=\"line\">.body</span><br><span class=\"line\">.innerHTML = </span><br><span class=\"line\">format(<span class=\"string\">&#x27;&lt;div&gt;I am &#123;name&#125;, my website is &lt;a href=&quot;&#123;website&#125;&quot;&gt;&#123;website&#125;&lt;/a&gt;&lt;/div&gt;&#x27;</span>,&#123;</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;James&#x27;</span>,</span><br><span class=\"line\">  website: <span class=\"string\">&#x27;http://www.qq.com&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">&#x27;&lt;div&gt;I am &#123; name &#125;, my website is &lt;a href=&quot;&#123;website&#125;&quot;&gt;&#123;website&#125;&lt;/a&gt;&lt;/div&gt;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;James&#x27;</span>,</span><br><span class=\"line\">  website: <span class=\"string\">&#x27;http://www.qq.com&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">format</span>(<span class=\"params\">str, data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/&amp;/g</span>, <span class=\"string\">&#x27;&amp;amp&#x27;</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/&lt;/g</span>, <span class=\"string\">&#x27;&amp;lt;&#x27;</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/&gt;/g</span>, <span class=\"string\">&#x27;&amp;gt;&#x27;</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/ /g</span>, <span class=\"string\">&#x27;&amp;nbsp;&#x27;</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/\\&#x27;/g</span>, <span class=\"string\">&#x27;&amp;#39;&#x27;</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/\\&quot;/g</span>, <span class=\"string\">&#x27;&amp;quot;&#x27;</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/\\&#123;(.*?)\\&#125;/g</span>, <span class=\"function\">(<span class=\"params\">i, k</span>) =&gt;</span> data[k.trim()])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">format(str, data)</span><br></pre></td></tr></table></figure></p>\n<p>3、通过JS在下面的ul中插入10000条 li 节点,并在点击 li 时打印其下标<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;list&gt;&lt;/ul&gt;</span></span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ul = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;#ul&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment()</span><br><span class=\"line\">ul.innerHTML= <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;li&#x27;</span>)</span><br><span class=\"line\">  li.innerText = i</span><br><span class=\"line\">  li.setAttribute(<span class=\"string\">&#x27;data-index&#x27;</span>, i)</span><br><span class=\"line\">  fragment.appendChild(li)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ul.appendChild(fragment)</span><br><span class=\"line\">ul.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.target.dataset.index)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>4.在输入框中如何判断输入的是一个正确的网址<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">&#x27;https://www.abc.com&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkUrl</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> URL(url)</span><br><span class=\"line\">  &#125; <span class=\"function\"><span class=\"title\">catch</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkUrl(url)</span><br></pre></td></tr></table></figure></p>\n<p>5、请按照如下布局在pc端实现htm和css样式，要求:<br>a)A区域是 header部分,高度100像素,宽度根据屏幕自适应,居顶部展示<br>b)B区域固定宽度200像素,居左侧展示<br>c)C区域根据屏幕宽度自适应<br>d)D区域固定宽度200像素,居右侧展示<br>e)E区域高度80像素,宽度自适应,当整体内容不够满屏展示,E居屏幕底部展示<br>f)当整体内容超出屏幕高度,出现垂直滚动</p>\n<p>demo：<br><a href=\"https://www.epoos.com/demo/learn/layout1.html\">https://www.epoos.com/demo/learn/layout1.html</a></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.header</span> &#123;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-tag\">background</span>:<span class=\"selector-id\">#396</span>;</span></span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 60px;</span><br><span class=\"line\">  z-index: 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.header-none</span> &#123;</span></span><br><span class=\"line\">  height: 60px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.left</span> &#123;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-tag\">background</span>:<span class=\"selector-id\">#963</span>;</span></span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  top: 60px;</span><br><span class=\"line\">  width: 200px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.content</span> &#123;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-tag\">background</span>:<span class=\"selector-id\">#693</span>;</span></span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  min-height: 100%;</span><br><span class=\"line\">  padding: 60px 200px 30px 200px;</span><br><span class=\"line\">  margin-top: -60px;</span><br><span class=\"line\">  box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.right</span> &#123;</span></span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  top: 60px;</span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-tag\">background</span>:<span class=\"selector-id\">#369</span>;</span></span><br><span class=\"line\">  width: 200px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-class\">.footer</span> &#123;</span></span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-tag\">background</span><span class=\"selector-pseudo\">:cornsilk</span>;</span></span><br><span class=\"line\">  float: left;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 30px;</span><br><span class=\"line\">  margin-top: -30px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;header&quot;</span>&gt;</span>header<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;header-none&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;left&quot;</span>&gt;</span>left<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content&quot;</span> <span class=\"attr\">contenteditable</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;right&quot;</span>&gt;</span>right<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;footer&quot;</span>&gt;</span>footer<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n"},{"title":"一些面试题集合","date":"2020-12-14T16:00:00.000Z","_content":"\n\n1.关于事件监听\n```javascript\nconst event = require('events')\nconst emitter = new event.EventEmitter()\nsetTimeout(() => {\n   emitter.emit('some_event', 123)\n}, 3000)\n\nemitter.on('some_event', (evt) => {\n  console.log('receive:',evt)\n})\n```\n\n```javascript\n// 组件通信，一个触发与监听的过程\nclass EventEmitter {\n  constructor () {\n    // 存储事件\n    this.events = this.events || new Map()\n  }\n  // 监听事件\n  addListener (type, fn) {\n    if (!this.events.get(type)) {\n      this.events.set(type, fn)\n    }\n  }\n  // 触发事件\n  emit (type) {\n    let handle = this.events.get(type)\n    handle.apply(this, [...arguments].slice(1))\n  }\n}\n```\n\n2.手写Promise\n```javascript\n// 未添加异步处理等其他边界情况\n// ①自动执行函数，②三个状态，③then\nclass Promise {\n  constructor (fn) {\n    // 三个状态\n    this.state = 'pending'\n    this.value = undefined\n    this.reason = undefined\n    let resolve = value => {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled'\n        this.value = value\n      }\n    }\n    let reject = value => {\n      if (this.state === 'pending') {\n        this.state = 'rejected'\n        this.reason = value\n      }\n    }\n    // 自动执行函数\n    try {\n      fn(resolve, reject)\n    } catch (e) {\n      reject(e)\n    }\n  }\n  // then\n  then(onFulfilled, onRejected) {\n    switch (this.state) {\n      case 'fulfilled':\n        onFulfilled()\n        break\n      case 'rejected':\n        onRejected()\n        break\n      default:\n    }\n  }\n}\n```\n\n4.下面代码中a在什么情况下会打印1\n```javascript\nvar a = ?;\nif (a == 1 && a == 2 && a == 3) {\n  console.log(1)\n}\n// answer1\na = console.log(1)\n// answer2\nvar a = { num: 0 }\na.valueOf = () => ++a.num\nif (a == 1 && a == 2 && a == 3) {\n  console.log(1)\n}\n// answer3\nObject.defineProperty(window, 'a', {\n  get() { \n    return this.value = this.value ? ++this.value : 1\n  }\n})\nif (a == 1 && a == 2 && a == 3) {\n  console.log(1)\n}\n```\n\n5.实现一个 sleep 函数，比如 sleep(1000),意味着等等1000毫秒，可从Promise、Generator、Async/Await等角度实现\n```javascript\n// answer1\nfunction sleep(time) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, time)\n  })\n}\nlet start = Date.now()\nsleep(3000).then(() => {\n  console.log(Date.now() - start)\n})\n```\n\n6.实现(5).add(3).minus(2)功能\n```javascript\nNumber.prototype.add = function (i = 0) { return this.valueOf() + i }\nNumber.prototype.minus = function (i = 0) { return this.valueOf() - i }\nvar result = (5).add(3).minus(2)\nconsole.log(result)\n```\n\n7.实现加法运算，解决浮点数问题\n```javascript\nfunction digitLength(a, b) {\n  var as = a.toString()\n  var bs = b.toString()\n\n  var t1 = as.split('.')\n  var t2 = bs.split('.')\n  var len1 = t1[1] ? t1[1].length : 0\n  var len2 = t2[1] ? t2[1].length : 0\n\n  return Math.pow(10, len1 > len2 ? len1 : len2)\n}\n\nfunction add(a = 0, b = 0) {\n  var max = digitLength(a, b)\n  return (a * max + b * max) / max\n}\nfunction minus(a = 0, b = 0) {\n  var max = digitLength(a, b)\n  return (a * max - b * max) / max\n}\nfunction multiply(a = 0, b = 0) {\n  var max = digitLength(a, b)\n  return ((a * max) * (b * max)) / (max*max)\n}\nfunction devide(a = 0, b = 0) {\n  var max = digitLength(a, b)\n  return (a * max) / (b * max)\n}\nadd(0.1, 0.2) // 0.3\nminus(0.3, 0.2) // 0.1\nmultiply(0.7, 0.2) // 0.14\ndevide(0.7, 0.2) // 3.5\n```\n\n\n8.如何把一个字符串大小写取反，如 Abc => aBC\n```javascript\nvar str = 'aBcDefGhij'\nfunction capitalReverse1(str) {\n  var arr = str.split('').map(s => s === s.toUpperCase() ? s.toLowerCase() : s.toUpperCase())\n  return arr.join('')\n}\nfunction capitalReverse2(str) {\n  return str.replace(/./ig, (a) => a === a.toUpperCase() ? a.toLowerCase() : a.toUpperCase())\n}\nvar newStr = capitalReverse2(str)\nconsole.log(newStr)\n```\n\n9.实现一个字符串匹配算法，从长度为n的字符串S中，查找是否存在字符串T，T的长度是m，若存在则返回所在位置\n```javascript\nvar S = 'abcdefghijklmnopqrstuvwxyz'\nvar T = 'cdef'\nfunction findStr(t, s) {\n  try {\n    return new RegExp(t).exec(s).index\n  } catch(e) {\n    return -1\n  }\n}\nvar index = findStr(T, S)\nconsole.log(index) // 2\n```\n\n\n10、请用闭包定义一个函数,实现每隔1秒,输出从1到500\n```javascript\nfunction interval(num) {\n  let i = 0\n  const timer = setInterval(function() {\n    if (i >= num) return clearInterval(timer)\n    console.log(++i)\n  }, 1000)\n}\ninterval(10)\n```\n\n\n11、改造下面代码，使之输出0-9\n```javascript\n// question code\nfor (var i = 0; i < 10; i++) {\n  setTimeout(() => {\n    console.log(i)\n  }, 1000)\n}\n// answer1\nfor (let i = 0; i<10;i++) {\n  setTimeout(() => {\n    console.log(i)\n  }, 1000)\n}\n// answer2\nfor (var i = 0; i < 10; i++) {\n  setTimeout(((i) => {\n    console.log(i)\n  })(i), 1000)\n}\n// answer3\nfor (var i = 0; i < 10; i++) {\n  setTimeout((i) => {\n    console.log(i)\n  }, 1000, i)\n}\n// answer4\nfor (var i = 0; i < 10; i++) {\n  setTimeout(console.log, 1000, i)\n}\n```\n\n\n12.打印出1-10000之间的所有对称数，例如：121、1331等\n```javascript\n// answer1\nfunction printNum(min, max) { // 1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,...,9999\n  for ( var i = min; i <= max; i++) {\n    var stri = i.toString()\n    if (stri.length % 2 === 0) { // 偶数\n      var halfStri1 = stri.slice(0, stri.length / 2)\n      var halfStri2 = stri.slice(stri.length / 2).split('').reverse().join('')\n      if (halfStri1 === halfStri2) {\n        console.log(i)\n      }\n    } else { // 奇数\n      var c = Math.floor(stri.length / 2)\n      var halfStri1 = stri.slice(0, c)\n      var halfStri2 = stri.slice(c+1).split('').reverse().join('')\n      if (halfStri1 === halfStri2) {\n        console.log(i)\n      }\n    }\n  }\n}\n// answer2\nfunction printNum(min, max) {\n  for (var i = min; i <= max; i++) {\n    var stri = i.toString()\n    var reverseI = stri.split('').reverse().join('')\n    if (stri === reverseI) {\n      console.log(i)\n    }\n  }\n}\n// answer3\nfunction printNum(min, max) {\n  for (var i = 1; i < 10 ; i++) {\n    console.log(i) // 1, ..., 9\n    console.log(i * 11) // 11, 22, 33, ..., 99\n    for (var j = 0; j < 10; j++) {\n      console.log(i * 101 + j * 10) // 101, 111, ..., 191, 202, 212, ... ,999\n      console.log(i * 1001 + j * 110) // 1001, 1111, ..., 9999\n    }\n  }\n}\n\nprintNum(1, 100000)\n```\n\n13.请实现一个add函数，满足以下功能\n```javascript\nadd(1) // 1\nadd(1)(2) // 3\nadd(1)(2)(3) // 6\nadd(1)(2, 3) // 6\nadd(1, 2)(3) // 6\n```\n```javascript\nfunction add() {\n  let args = [...arguments]\n  let fn = function() {\n    args = args.concat([...arguments])\n    return fn\n  }\n  fn.toString = () => args.reduce((acc, item) => acc + item)\n  return fn\n}\nadd(1,2)(3)(4, 5)\n```\n\n14.算法题之【两数之和】\n给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。\n你可以假设每个输入值对应一种答案，且相同的元素不能重复利用。\n示例：\n```html\n给定 nums = [2, 7, 11, 5], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n```\n```javascript\n// answer1\nfunction calc1(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j]\n      }\n    }\n  }\n}\n// answer2\nfunction calc2(nums, target) {\n  let map = {}\n  for (let [i, n] of nums.entries()) {\n    map[n] = i\n  }\n  for (let i = 0; i < nums.length; i++) {\n    let k = target - nums[i]\n    if (map[k]) {\n      return [i, map[k]]\n    }\n  }\n}\n\nvar nums = [2, 7, 11, 5]\nvar target = 9\ncalc2(nums, target)\n```\n","source":"_posts/qa7.md","raw":"---\ntitle: 一些面试题集合\ndate: 2020/12/15\ntag: [基础,面试,试题]\ncategory: 技术\n---\n\n\n1.关于事件监听\n```javascript\nconst event = require('events')\nconst emitter = new event.EventEmitter()\nsetTimeout(() => {\n   emitter.emit('some_event', 123)\n}, 3000)\n\nemitter.on('some_event', (evt) => {\n  console.log('receive:',evt)\n})\n```\n\n```javascript\n// 组件通信，一个触发与监听的过程\nclass EventEmitter {\n  constructor () {\n    // 存储事件\n    this.events = this.events || new Map()\n  }\n  // 监听事件\n  addListener (type, fn) {\n    if (!this.events.get(type)) {\n      this.events.set(type, fn)\n    }\n  }\n  // 触发事件\n  emit (type) {\n    let handle = this.events.get(type)\n    handle.apply(this, [...arguments].slice(1))\n  }\n}\n```\n\n2.手写Promise\n```javascript\n// 未添加异步处理等其他边界情况\n// ①自动执行函数，②三个状态，③then\nclass Promise {\n  constructor (fn) {\n    // 三个状态\n    this.state = 'pending'\n    this.value = undefined\n    this.reason = undefined\n    let resolve = value => {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled'\n        this.value = value\n      }\n    }\n    let reject = value => {\n      if (this.state === 'pending') {\n        this.state = 'rejected'\n        this.reason = value\n      }\n    }\n    // 自动执行函数\n    try {\n      fn(resolve, reject)\n    } catch (e) {\n      reject(e)\n    }\n  }\n  // then\n  then(onFulfilled, onRejected) {\n    switch (this.state) {\n      case 'fulfilled':\n        onFulfilled()\n        break\n      case 'rejected':\n        onRejected()\n        break\n      default:\n    }\n  }\n}\n```\n\n4.下面代码中a在什么情况下会打印1\n```javascript\nvar a = ?;\nif (a == 1 && a == 2 && a == 3) {\n  console.log(1)\n}\n// answer1\na = console.log(1)\n// answer2\nvar a = { num: 0 }\na.valueOf = () => ++a.num\nif (a == 1 && a == 2 && a == 3) {\n  console.log(1)\n}\n// answer3\nObject.defineProperty(window, 'a', {\n  get() { \n    return this.value = this.value ? ++this.value : 1\n  }\n})\nif (a == 1 && a == 2 && a == 3) {\n  console.log(1)\n}\n```\n\n5.实现一个 sleep 函数，比如 sleep(1000),意味着等等1000毫秒，可从Promise、Generator、Async/Await等角度实现\n```javascript\n// answer1\nfunction sleep(time) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, time)\n  })\n}\nlet start = Date.now()\nsleep(3000).then(() => {\n  console.log(Date.now() - start)\n})\n```\n\n6.实现(5).add(3).minus(2)功能\n```javascript\nNumber.prototype.add = function (i = 0) { return this.valueOf() + i }\nNumber.prototype.minus = function (i = 0) { return this.valueOf() - i }\nvar result = (5).add(3).minus(2)\nconsole.log(result)\n```\n\n7.实现加法运算，解决浮点数问题\n```javascript\nfunction digitLength(a, b) {\n  var as = a.toString()\n  var bs = b.toString()\n\n  var t1 = as.split('.')\n  var t2 = bs.split('.')\n  var len1 = t1[1] ? t1[1].length : 0\n  var len2 = t2[1] ? t2[1].length : 0\n\n  return Math.pow(10, len1 > len2 ? len1 : len2)\n}\n\nfunction add(a = 0, b = 0) {\n  var max = digitLength(a, b)\n  return (a * max + b * max) / max\n}\nfunction minus(a = 0, b = 0) {\n  var max = digitLength(a, b)\n  return (a * max - b * max) / max\n}\nfunction multiply(a = 0, b = 0) {\n  var max = digitLength(a, b)\n  return ((a * max) * (b * max)) / (max*max)\n}\nfunction devide(a = 0, b = 0) {\n  var max = digitLength(a, b)\n  return (a * max) / (b * max)\n}\nadd(0.1, 0.2) // 0.3\nminus(0.3, 0.2) // 0.1\nmultiply(0.7, 0.2) // 0.14\ndevide(0.7, 0.2) // 3.5\n```\n\n\n8.如何把一个字符串大小写取反，如 Abc => aBC\n```javascript\nvar str = 'aBcDefGhij'\nfunction capitalReverse1(str) {\n  var arr = str.split('').map(s => s === s.toUpperCase() ? s.toLowerCase() : s.toUpperCase())\n  return arr.join('')\n}\nfunction capitalReverse2(str) {\n  return str.replace(/./ig, (a) => a === a.toUpperCase() ? a.toLowerCase() : a.toUpperCase())\n}\nvar newStr = capitalReverse2(str)\nconsole.log(newStr)\n```\n\n9.实现一个字符串匹配算法，从长度为n的字符串S中，查找是否存在字符串T，T的长度是m，若存在则返回所在位置\n```javascript\nvar S = 'abcdefghijklmnopqrstuvwxyz'\nvar T = 'cdef'\nfunction findStr(t, s) {\n  try {\n    return new RegExp(t).exec(s).index\n  } catch(e) {\n    return -1\n  }\n}\nvar index = findStr(T, S)\nconsole.log(index) // 2\n```\n\n\n10、请用闭包定义一个函数,实现每隔1秒,输出从1到500\n```javascript\nfunction interval(num) {\n  let i = 0\n  const timer = setInterval(function() {\n    if (i >= num) return clearInterval(timer)\n    console.log(++i)\n  }, 1000)\n}\ninterval(10)\n```\n\n\n11、改造下面代码，使之输出0-9\n```javascript\n// question code\nfor (var i = 0; i < 10; i++) {\n  setTimeout(() => {\n    console.log(i)\n  }, 1000)\n}\n// answer1\nfor (let i = 0; i<10;i++) {\n  setTimeout(() => {\n    console.log(i)\n  }, 1000)\n}\n// answer2\nfor (var i = 0; i < 10; i++) {\n  setTimeout(((i) => {\n    console.log(i)\n  })(i), 1000)\n}\n// answer3\nfor (var i = 0; i < 10; i++) {\n  setTimeout((i) => {\n    console.log(i)\n  }, 1000, i)\n}\n// answer4\nfor (var i = 0; i < 10; i++) {\n  setTimeout(console.log, 1000, i)\n}\n```\n\n\n12.打印出1-10000之间的所有对称数，例如：121、1331等\n```javascript\n// answer1\nfunction printNum(min, max) { // 1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,...,9999\n  for ( var i = min; i <= max; i++) {\n    var stri = i.toString()\n    if (stri.length % 2 === 0) { // 偶数\n      var halfStri1 = stri.slice(0, stri.length / 2)\n      var halfStri2 = stri.slice(stri.length / 2).split('').reverse().join('')\n      if (halfStri1 === halfStri2) {\n        console.log(i)\n      }\n    } else { // 奇数\n      var c = Math.floor(stri.length / 2)\n      var halfStri1 = stri.slice(0, c)\n      var halfStri2 = stri.slice(c+1).split('').reverse().join('')\n      if (halfStri1 === halfStri2) {\n        console.log(i)\n      }\n    }\n  }\n}\n// answer2\nfunction printNum(min, max) {\n  for (var i = min; i <= max; i++) {\n    var stri = i.toString()\n    var reverseI = stri.split('').reverse().join('')\n    if (stri === reverseI) {\n      console.log(i)\n    }\n  }\n}\n// answer3\nfunction printNum(min, max) {\n  for (var i = 1; i < 10 ; i++) {\n    console.log(i) // 1, ..., 9\n    console.log(i * 11) // 11, 22, 33, ..., 99\n    for (var j = 0; j < 10; j++) {\n      console.log(i * 101 + j * 10) // 101, 111, ..., 191, 202, 212, ... ,999\n      console.log(i * 1001 + j * 110) // 1001, 1111, ..., 9999\n    }\n  }\n}\n\nprintNum(1, 100000)\n```\n\n13.请实现一个add函数，满足以下功能\n```javascript\nadd(1) // 1\nadd(1)(2) // 3\nadd(1)(2)(3) // 6\nadd(1)(2, 3) // 6\nadd(1, 2)(3) // 6\n```\n```javascript\nfunction add() {\n  let args = [...arguments]\n  let fn = function() {\n    args = args.concat([...arguments])\n    return fn\n  }\n  fn.toString = () => args.reduce((acc, item) => acc + item)\n  return fn\n}\nadd(1,2)(3)(4, 5)\n```\n\n14.算法题之【两数之和】\n给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。\n你可以假设每个输入值对应一种答案，且相同的元素不能重复利用。\n示例：\n```html\n给定 nums = [2, 7, 11, 5], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n```\n```javascript\n// answer1\nfunction calc1(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j]\n      }\n    }\n  }\n}\n// answer2\nfunction calc2(nums, target) {\n  let map = {}\n  for (let [i, n] of nums.entries()) {\n    map[n] = i\n  }\n  for (let i = 0; i < nums.length; i++) {\n    let k = target - nums[i]\n    if (map[k]) {\n      return [i, map[k]]\n    }\n  }\n}\n\nvar nums = [2, 7, 11, 5]\nvar target = 9\ncalc2(nums, target)\n```\n","slug":"qa7","published":1,"updated":"2021-03-30T01:32:00.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug7001ka0vz6lv5195y","content":"<p>1.关于事件监听<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> event = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;events&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> emitter = <span class=\"keyword\">new</span> event.EventEmitter()</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">   emitter.emit(<span class=\"string\">&#x27;some_event&#x27;</span>, <span class=\"number\">123</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">3000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">emitter.on(<span class=\"string\">&#x27;some_event&#x27;</span>, <span class=\"function\">(<span class=\"params\">evt</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;receive:&#x27;</span>,evt)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件通信，一个触发与监听的过程</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventEmitter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"title\">constructor</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储事件</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.events = <span class=\"built_in\">this</span>.events || <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 监听事件</span></span><br><span class=\"line\">  addListener (type, fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.events.get(type)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.events.set(type, fn)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">  emit (type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> handle = <span class=\"built_in\">this</span>.events.get(type)</span><br><span class=\"line\">    handle.apply(<span class=\"built_in\">this</span>, [...arguments].slice(<span class=\"number\">1</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.手写Promise<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 未添加异步处理等其他边界情况</span></span><br><span class=\"line\"><span class=\"comment\">// ①自动执行函数，②三个状态，③then</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Promise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"title\">constructor</span> (<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 三个状态</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.state = <span class=\"string\">&#x27;pending&#x27;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value = <span class=\"literal\">undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.reason = <span class=\"literal\">undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> resolve = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.state === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.state = <span class=\"string\">&#x27;fulfilled&#x27;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> reject = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.state === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.state = <span class=\"string\">&#x27;rejected&#x27;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.reason = value</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 自动执行函数</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      fn(resolve, reject)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      reject(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// then</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">then</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"built_in\">this</span>.state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;fulfilled&#x27;</span>:</span><br><span class=\"line\">        onFulfilled()</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;rejected&#x27;</span>:</span><br><span class=\"line\">        onRejected()</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.下面代码中a在什么情况下会打印1<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = ?;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">1</span> &amp;&amp; a == <span class=\"number\">2</span> &amp;&amp; a == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer1</span></span><br><span class=\"line\">a = <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// answer2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123; <span class=\"attr\">num</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">a.valueOf = <span class=\"function\">() =&gt;</span> ++a.num</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">1</span> &amp;&amp; a == <span class=\"number\">2</span> &amp;&amp; a == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer3</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">window</span>, <span class=\"string\">&#x27;a&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.value = <span class=\"built_in\">this</span>.value ? ++<span class=\"built_in\">this</span>.value : <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">1</span> &amp;&amp; a == <span class=\"number\">2</span> &amp;&amp; a == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>5.实现一个 sleep 函数，比如 sleep(1000),意味着等等1000毫秒，可从Promise、Generator、Async/Await等角度实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// answer1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(resolve, time)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> start = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">sleep(<span class=\"number\">3000</span>).then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Date</span>.now() - start)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>6.实现(5).add(3).minus(2)功能<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.prototype.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i = <span class=\"number\">0</span></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.valueOf() + i &#125;</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.prototype.minus = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i = <span class=\"number\">0</span></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.valueOf() - i &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = (<span class=\"number\">5</span>).add(<span class=\"number\">3</span>).minus(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result)</span><br></pre></td></tr></table></figure></p>\n<p>7.实现加法运算，解决浮点数问题<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">digitLength</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> <span class=\"keyword\">as</span> = a.toString()</span><br><span class=\"line\">  <span class=\"keyword\">var</span> bs = b.toString()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> t1 = <span class=\"keyword\">as</span>.split(<span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t2 = bs.split(<span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> len1 = t1[<span class=\"number\">1</span>] ? t1[<span class=\"number\">1</span>].length : <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> len2 = t2[<span class=\"number\">1</span>] ? t2[<span class=\"number\">1</span>].length : <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, len1 &gt; len2 ? len1 : len2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> max = digitLength(a, b)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (a * max + b * max) / max</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minus</span>(<span class=\"params\">a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> max = digitLength(a, b)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (a * max - b * max) / max</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multiply</span>(<span class=\"params\">a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> max = digitLength(a, b)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ((a * max) * (b * max)) / (max*max)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">devide</span>(<span class=\"params\">a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> max = digitLength(a, b)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (a * max) / (b * max)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(<span class=\"number\">0.1</span>, <span class=\"number\">0.2</span>) <span class=\"comment\">// 0.3</span></span><br><span class=\"line\">minus(<span class=\"number\">0.3</span>, <span class=\"number\">0.2</span>) <span class=\"comment\">// 0.1</span></span><br><span class=\"line\">multiply(<span class=\"number\">0.7</span>, <span class=\"number\">0.2</span>) <span class=\"comment\">// 0.14</span></span><br><span class=\"line\">devide(<span class=\"number\">0.7</span>, <span class=\"number\">0.2</span>) <span class=\"comment\">// 3.5</span></span><br></pre></td></tr></table></figure></p>\n<p>8.如何把一个字符串大小写取反，如 Abc =&gt; aBC<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;aBcDefGhij&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">capitalReverse1</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = str.split(<span class=\"string\">&#x27;&#x27;</span>).map(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> s === s.toUpperCase() ? s.toLowerCase() : s.toUpperCase())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.join(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">capitalReverse2</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.replace(<span class=\"regexp\">/./ig</span>, <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> a === a.toUpperCase() ? a.toLowerCase() : a.toUpperCase())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newStr = capitalReverse2(str)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newStr)</span><br></pre></td></tr></table></figure></p>\n<p>9.实现一个字符串匹配算法，从长度为n的字符串S中，查找是否存在字符串T，T的长度是m，若存在则返回所在位置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> S = <span class=\"string\">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> T = <span class=\"string\">&#x27;cdef&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findStr</span>(<span class=\"params\">t, s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(t).exec(s).index</span><br><span class=\"line\">  &#125; <span class=\"function\"><span class=\"title\">catch</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> index = findStr(T, S)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(index) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>10、请用闭包定义一个函数,实现每隔1秒,输出从1到500<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">interval</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> timer = <span class=\"built_in\">setInterval</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= num) <span class=\"keyword\">return</span> <span class=\"built_in\">clearInterval</span>(timer)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(++i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interval(<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure></p>\n<p>11、改造下面代码，使之输出0-9<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// question code</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>;i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer2</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>((<span class=\"function\">(<span class=\"params\">i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;)(i), <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer3</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">(<span class=\"params\">i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer4</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"built_in\">console</span>.log, <span class=\"number\">1000</span>, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>12.打印出1-10000之间的所有对称数，例如：121、1331等<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// answer1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printNum</span>(<span class=\"params\">min, max</span>) </span>&#123; <span class=\"comment\">// 1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,...,9999</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( <span class=\"keyword\">var</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stri = i.toString()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stri.length % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 偶数</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> halfStri1 = stri.slice(<span class=\"number\">0</span>, stri.length / <span class=\"number\">2</span>)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> halfStri2 = stri.slice(stri.length / <span class=\"number\">2</span>).split(<span class=\"string\">&#x27;&#x27;</span>).reverse().join(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (halfStri1 === halfStri2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 奇数</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> c = <span class=\"built_in\">Math</span>.floor(stri.length / <span class=\"number\">2</span>)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> halfStri1 = stri.slice(<span class=\"number\">0</span>, c)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> halfStri2 = stri.slice(c+<span class=\"number\">1</span>).split(<span class=\"string\">&#x27;&#x27;</span>).reverse().join(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (halfStri1 === halfStri2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printNum</span>(<span class=\"params\">min, max</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stri = i.toString()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> reverseI = stri.split(<span class=\"string\">&#x27;&#x27;</span>).reverse().join(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stri === reverseI) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer3</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printNum</span>(<span class=\"params\">min, max</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 1, ..., 9</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i * <span class=\"number\">11</span>) <span class=\"comment\">// 11, 22, 33, ..., 99</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i * <span class=\"number\">101</span> + j * <span class=\"number\">10</span>) <span class=\"comment\">// 101, 111, ..., 191, 202, 212, ... ,999</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i * <span class=\"number\">1001</span> + j * <span class=\"number\">110</span>) <span class=\"comment\">// 1001, 1111, ..., 9999</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printNum(<span class=\"number\">1</span>, <span class=\"number\">100000</span>)</span><br></pre></td></tr></table></figure></p>\n<p>13.请实现一个add函数，满足以下功能<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(<span class=\"number\">1</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>)(<span class=\"number\">2</span>) <span class=\"comment\">// 3</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>) <span class=\"comment\">// 6</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>)(<span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 6</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>)(<span class=\"number\">3</span>) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> args = [...arguments]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    args = args.concat([...arguments])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fn.toString = <span class=\"function\">() =&gt;</span> args.reduce(<span class=\"function\">(<span class=\"params\">acc, item</span>) =&gt;</span> acc + item)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">2</span>)(<span class=\"number\">3</span>)(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<p>14.算法题之【两数之和】<br>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br>你可以假设每个输入值对应一种答案，且相同的元素不能重复利用。<br>示例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 nums = [2, 7, 11, 5], target = 9</span><br><span class=\"line\">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class=\"line\">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// answer1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calc1</span>(<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nums[i] + nums[j] === target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [i, j]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calc2</span>(<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [i, n] <span class=\"keyword\">of</span> nums.entries()) &#123;</span><br><span class=\"line\">    map[n] = i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> k = target - nums[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map[k]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [i, map[k]]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> target = <span class=\"number\">9</span></span><br><span class=\"line\">calc2(nums, target)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.关于事件监听<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> event = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;events&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> emitter = <span class=\"keyword\">new</span> event.EventEmitter()</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">   emitter.emit(<span class=\"string\">&#x27;some_event&#x27;</span>, <span class=\"number\">123</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">3000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">emitter.on(<span class=\"string\">&#x27;some_event&#x27;</span>, <span class=\"function\">(<span class=\"params\">evt</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;receive:&#x27;</span>,evt)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件通信，一个触发与监听的过程</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventEmitter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"title\">constructor</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储事件</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.events = <span class=\"built_in\">this</span>.events || <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 监听事件</span></span><br><span class=\"line\">  addListener (type, fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.events.get(type)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.events.set(type, fn)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">  emit (type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> handle = <span class=\"built_in\">this</span>.events.get(type)</span><br><span class=\"line\">    handle.apply(<span class=\"built_in\">this</span>, [...arguments].slice(<span class=\"number\">1</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.手写Promise<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 未添加异步处理等其他边界情况</span></span><br><span class=\"line\"><span class=\"comment\">// ①自动执行函数，②三个状态，③then</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Promise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"title\">constructor</span> (<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 三个状态</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.state = <span class=\"string\">&#x27;pending&#x27;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value = <span class=\"literal\">undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.reason = <span class=\"literal\">undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> resolve = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.state === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.state = <span class=\"string\">&#x27;fulfilled&#x27;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> reject = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.state === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.state = <span class=\"string\">&#x27;rejected&#x27;</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.reason = value</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 自动执行函数</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      fn(resolve, reject)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      reject(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// then</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">then</span>(<span class=\"params\">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"built_in\">this</span>.state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;fulfilled&#x27;</span>:</span><br><span class=\"line\">        onFulfilled()</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;rejected&#x27;</span>:</span><br><span class=\"line\">        onRejected()</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.下面代码中a在什么情况下会打印1<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = ?;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">1</span> &amp;&amp; a == <span class=\"number\">2</span> &amp;&amp; a == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer1</span></span><br><span class=\"line\">a = <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// answer2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123; <span class=\"attr\">num</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">a.valueOf = <span class=\"function\">() =&gt;</span> ++a.num</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">1</span> &amp;&amp; a == <span class=\"number\">2</span> &amp;&amp; a == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer3</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">window</span>, <span class=\"string\">&#x27;a&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.value = <span class=\"built_in\">this</span>.value ? ++<span class=\"built_in\">this</span>.value : <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">1</span> &amp;&amp; a == <span class=\"number\">2</span> &amp;&amp; a == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>5.实现一个 sleep 函数，比如 sleep(1000),意味着等等1000毫秒，可从Promise、Generator、Async/Await等角度实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// answer1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(resolve, time)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> start = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">sleep(<span class=\"number\">3000</span>).then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Date</span>.now() - start)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>6.实现(5).add(3).minus(2)功能<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.prototype.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i = <span class=\"number\">0</span></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.valueOf() + i &#125;</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.prototype.minus = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i = <span class=\"number\">0</span></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.valueOf() - i &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = (<span class=\"number\">5</span>).add(<span class=\"number\">3</span>).minus(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result)</span><br></pre></td></tr></table></figure></p>\n<p>7.实现加法运算，解决浮点数问题<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">digitLength</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> <span class=\"keyword\">as</span> = a.toString()</span><br><span class=\"line\">  <span class=\"keyword\">var</span> bs = b.toString()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> t1 = <span class=\"keyword\">as</span>.split(<span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t2 = bs.split(<span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> len1 = t1[<span class=\"number\">1</span>] ? t1[<span class=\"number\">1</span>].length : <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> len2 = t2[<span class=\"number\">1</span>] ? t2[<span class=\"number\">1</span>].length : <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, len1 &gt; len2 ? len1 : len2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> max = digitLength(a, b)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (a * max + b * max) / max</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minus</span>(<span class=\"params\">a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> max = digitLength(a, b)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (a * max - b * max) / max</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multiply</span>(<span class=\"params\">a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> max = digitLength(a, b)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ((a * max) * (b * max)) / (max*max)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">devide</span>(<span class=\"params\">a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> max = digitLength(a, b)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (a * max) / (b * max)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(<span class=\"number\">0.1</span>, <span class=\"number\">0.2</span>) <span class=\"comment\">// 0.3</span></span><br><span class=\"line\">minus(<span class=\"number\">0.3</span>, <span class=\"number\">0.2</span>) <span class=\"comment\">// 0.1</span></span><br><span class=\"line\">multiply(<span class=\"number\">0.7</span>, <span class=\"number\">0.2</span>) <span class=\"comment\">// 0.14</span></span><br><span class=\"line\">devide(<span class=\"number\">0.7</span>, <span class=\"number\">0.2</span>) <span class=\"comment\">// 3.5</span></span><br></pre></td></tr></table></figure></p>\n<p>8.如何把一个字符串大小写取反，如 Abc =&gt; aBC<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;aBcDefGhij&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">capitalReverse1</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = str.split(<span class=\"string\">&#x27;&#x27;</span>).map(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> s === s.toUpperCase() ? s.toLowerCase() : s.toUpperCase())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.join(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">capitalReverse2</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.replace(<span class=\"regexp\">/./ig</span>, <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> a === a.toUpperCase() ? a.toLowerCase() : a.toUpperCase())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newStr = capitalReverse2(str)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newStr)</span><br></pre></td></tr></table></figure></p>\n<p>9.实现一个字符串匹配算法，从长度为n的字符串S中，查找是否存在字符串T，T的长度是m，若存在则返回所在位置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> S = <span class=\"string\">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> T = <span class=\"string\">&#x27;cdef&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findStr</span>(<span class=\"params\">t, s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(t).exec(s).index</span><br><span class=\"line\">  &#125; <span class=\"function\"><span class=\"title\">catch</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> index = findStr(T, S)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(index) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>10、请用闭包定义一个函数,实现每隔1秒,输出从1到500<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">interval</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> timer = <span class=\"built_in\">setInterval</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= num) <span class=\"keyword\">return</span> <span class=\"built_in\">clearInterval</span>(timer)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(++i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interval(<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure></p>\n<p>11、改造下面代码，使之输出0-9<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// question code</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>;i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer2</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>((<span class=\"function\">(<span class=\"params\">i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;)(i), <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer3</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">(<span class=\"params\">i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer4</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"built_in\">console</span>.log, <span class=\"number\">1000</span>, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>12.打印出1-10000之间的所有对称数，例如：121、1331等<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// answer1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printNum</span>(<span class=\"params\">min, max</span>) </span>&#123; <span class=\"comment\">// 1,2,3,4,5,6,7,8,9,11,22,33,44,55,66,77,88,99,101,111,121,131,...,9999</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( <span class=\"keyword\">var</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stri = i.toString()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stri.length % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 偶数</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> halfStri1 = stri.slice(<span class=\"number\">0</span>, stri.length / <span class=\"number\">2</span>)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> halfStri2 = stri.slice(stri.length / <span class=\"number\">2</span>).split(<span class=\"string\">&#x27;&#x27;</span>).reverse().join(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (halfStri1 === halfStri2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 奇数</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> c = <span class=\"built_in\">Math</span>.floor(stri.length / <span class=\"number\">2</span>)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> halfStri1 = stri.slice(<span class=\"number\">0</span>, c)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> halfStri2 = stri.slice(c+<span class=\"number\">1</span>).split(<span class=\"string\">&#x27;&#x27;</span>).reverse().join(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (halfStri1 === halfStri2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printNum</span>(<span class=\"params\">min, max</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stri = i.toString()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> reverseI = stri.split(<span class=\"string\">&#x27;&#x27;</span>).reverse().join(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stri === reverseI) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer3</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printNum</span>(<span class=\"params\">min, max</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 1, ..., 9</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i * <span class=\"number\">11</span>) <span class=\"comment\">// 11, 22, 33, ..., 99</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i * <span class=\"number\">101</span> + j * <span class=\"number\">10</span>) <span class=\"comment\">// 101, 111, ..., 191, 202, 212, ... ,999</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i * <span class=\"number\">1001</span> + j * <span class=\"number\">110</span>) <span class=\"comment\">// 1001, 1111, ..., 9999</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printNum(<span class=\"number\">1</span>, <span class=\"number\">100000</span>)</span><br></pre></td></tr></table></figure></p>\n<p>13.请实现一个add函数，满足以下功能<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(<span class=\"number\">1</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>)(<span class=\"number\">2</span>) <span class=\"comment\">// 3</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>) <span class=\"comment\">// 6</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>)(<span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 6</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>)(<span class=\"number\">3</span>) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> args = [...arguments]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    args = args.concat([...arguments])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fn.toString = <span class=\"function\">() =&gt;</span> args.reduce(<span class=\"function\">(<span class=\"params\">acc, item</span>) =&gt;</span> acc + item)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">2</span>)(<span class=\"number\">3</span>)(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<p>14.算法题之【两数之和】<br>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br>你可以假设每个输入值对应一种答案，且相同的元素不能重复利用。<br>示例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 nums = [2, 7, 11, 5], target = 9</span><br><span class=\"line\">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class=\"line\">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// answer1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calc1</span>(<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nums[i] + nums[j] === target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [i, j]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// answer2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calc2</span>(<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [i, n] <span class=\"keyword\">of</span> nums.entries()) &#123;</span><br><span class=\"line\">    map[n] = i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> k = target - nums[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map[k]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [i, map[k]]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nums = [<span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> target = <span class=\"number\">9</span></span><br><span class=\"line\">calc2(nums, target)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"React、Flux以及Redux小结","date":"2018-04-09T16:00:00.000Z","_content":"\nReact和Vue是当下前端最流行的Javascript框架。作为一名现代化前端工程师，学习这两个框架已经成为了标配。\n本人学习这两个框架已经有很长一段时间了，当下对其做一些基本概念梳理总结，利人利己。\n\n\n### Flux\n\n##### Flux是什么\n\nFlux是一种架构思想，专门解决软件结构问题，它和MVC是同一种东西。\n\n##### facebook flux官网描述\n```html\nFlux is the application architecture that Facebook uses for building client-side web applications. \nIt complements React's composable view components by utilizing a unidirectional data flow. \nIt's more of a pattern rather than a formal framework, and you can start using Flux immediately without a lot of new code.\n\n（Flux是Facebook用来构建客户端应用程序的web应用程序架构。它是React单向数据流view组件的补充。它更向是一种模式，而不是一种框架，你只需要使用一点点代码就能立即使用它）\n```\n\n##### Flux结构组成\n```html\nView 视图层\n\nAction 动作 比如视图层发出的消息（比如mouseClick）\n\nDispatcher 派发器 接受Actions，执行回调函数\n\nStore 数据层 用来存放应用状态 Store变动的时候，会触发View更新\n```\n\n##### Flux最大的特点就是“数据的单向流动”\n\n```html\n1.用户访问View\n\n2.用户触发View发起Action\n\n3.Dispather接收到用户的Action，要求Store进行相应更新\n\n4.Store更新之后通知view更新\n```\n如图所示：（图片来源:http://www.ruanyifeng.com/）\n\n![avatar](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016011503.png)\n\n##### Flux的应用\nFlux是一种架构思想，使用flux就是使用flux的这种思想模式构建程序代码。\n使用flux模式构建的代码能够更容易阅读，修改维护更为简单。\n当然，通其它结构思想一样（如MVC）引入flux模式必然会需要引入一些其它的代码，一定程度上提升了代码的复杂度。\n因此，如果不是项目到达一定的规模，如果不是觉得不用框架开发起来很艰难，那就不需要使用flux框架。\n\n\n---\n\n### React\nReact是一个View层框架，用来渲染视图，不直接操作View，想要操作view只能通过修改state来实现\nstate的改变主要来自两个方面，一个是服务端，另一个是用户行为，其中用户行为占很大一部分。\nReact每个组件都有一个setState方法用来修改当前的state，所以一般把修改state操作都放在各自的组件中。\n但是，随着项目的扩大，业务逻辑越来越复杂，一个state的变化往往对应着多个组件，这样很可能导致混乱。\n此时，我们需要一个对state进行统一管理，这也就是Flux出现的原因了。\n\n\n##### React使用Flux\nFlux在React中主要用来集中管理引起state变化的情况，Flux维护着一个或多个Store，（MVC中的Model），Store中存储着应用用到的所有数据。\n当Action触发的时候，Flux根据Action在对应Store中经过一系列逻辑处理，更新Store。\n当Store发生变化的时候，通常根组件（也可以不是根组件）会去获取新的store，然后更新state，然后利用React的单项数据流的特点一层层的向下传递state以更新view。\n\n\n##### Redux\nRedux的作用和Flux相同，可以看作是Flux的一种实现\n\n当然，Redux既然独立存在，肯定是有其独特之处，同Flux相比，Redux有以下不同。\n```html\n1.Redux没有 Dispatcher，只有Reducer，Reducer是一个纯函数，它接受两个参数(previousState、action)，返回一个新的state；\n  Redux中含有多个reducer，多个reducer通过combineReducers方法合并为一个根reducer，这个根reducer负责维护完整的state；\n  当action发起的时候，store会调用dispatch方法，向某个特定的reducer纯函数传递该action，以更新state。\n\n2.Flux有多个store；在store中完成新的state的推导；每一个store都只对对应的view，每次更新都只通知对应的view\n  Redux只有一个store；Redux的更新逻辑也不在store中执行，而是放在reducer中；Redux中所有reducer都由根Reducer统一管理，对应一个根View。\n```\n\n##### Redux Store 以及 Redux State\nStore保存所有的数据，可以将其看做是一个容器。整个应用只能有一个Store\n``` javascript\nimport {createStore} from \"redux\";\n\nconst store = createStore(fn);\n```\n\n如果想得到某个时点的数据，就要对Store生成快照。这种时点的数据集合就叫做State\n``` javascript\nimport {createStore} from \"redux\";\n\nconst store = createStore(fn);\n\nconst state = store.getState();\n```\n\nRedux规定，一个State对应一个View。只要State相同，View就相同。\n知道State就能知道View是什么样，反之亦然。\n\n##### Redux Action\nAction为View发出的通知，表示State将要发生变化\nAction描述当前发生的事情。改变State的唯一办法就是通过Action将数据运送到Store\n``` javascript\nconst action = {\n  type: \"ADD_TODO\", // Action的名称\n  payload: \"LEARN Redux\" // Action携带的字符串信息\n};\n```\n\n#### Redux Action Creater\n定义一个函数，用来自动生成Action，这个函数就叫做Action Creator\n\n``` javascript\nconst ADD_TODO = \"添加 TODO\";\n\nfunction addToDo(text) {\n    return {\n        type: ADD_TODO,\n        text\n    }\n}\n\nconst action = addToDo(Learn Redux);\n```\n\n#### Redux store.dispatch()\nstore.dispatch()是View唯一发出Action的方法\n\n``` javascript\nimport {createStore} form \"redux\";\n\nconst store = createStore(fn);\n\nstore.dispatch({\n  type: \"ADD_TODO\",\n  payload: \"Learn Redux\",\n});\n```\nstore.dispatch接受一个Action对象作为参数，将它发送出去\n\n结合Action Creater\n\n``` javascript\nstore.dispatch(addToDo(\"Learn Redux\"));\n```\n\n##### Redux Reducer\nStore收到一个Action之后必须给出一个新的State，这样View才会发生变化。\n这种State的计算过程就叫做Reducer，Reducer是一个纯函数，它接受Action和当前的State作为参数，返回一个新的State\n``` javascript\nconst Reducer = function(state, action){\n  //...\n  return new_state;\n}\n```\n\n##### Redux subscribe()\nStore允许使用Store.subscribe方法设置监听函数，一旦State发生变化就自动执行这个函数\n\n``` javascript\nimport {createStore} from \"redux\";\nconst store = createStore(reducer);\n\nstore.subscribe(listener);\n```\n\n解除监听，store.subscribe方法返回一个函数，调用这个函数即可解除监听\n\n``` javascript\nconst unsubscribe = store.subscribe(() => \n    console.log(store.getState());\n);\nunsubscribe();\n```\n\n##### Redux Store的实现\nStore提供了三个方法\n\n``` javascript\nstore.getState();\n\nstore.dispatch();\n\nstore.subscribe();\n```\n\n``` javascript\nimport {createStore} from \"redux\";\nlet {subscribe, dispatch, getState} = createStore(reducer);\n```\n\n##### Reducer拆分\nReducer负责生成State，由于一个项目只有一个State，导致这个State会非常庞大。\n所以，Redux提供了解决方案，那就是将其拆分开来，同时Redux又提供了一个combineReducers方法\n用这个方法可以将各个子Reducer合并成一个大的Reducer。\n\n``` javascript\nimport {combineReducers} form \"redux\";\n\nconst chatReducer = combineReducers(){\n    chatLog,\n    statusMessage,\n    userName\n};\n\nexport default todoApp;\n```\n\n可以将所有的子Reducer放在一个文件里面，然后统一引入\n\n``` javascript\nimport {combineReducers} form \"redux\";\nimport * as reducers from \"./reducers\";\n\nconst reducer = combineReducers(reducers); \n```\n\n\n##### Reducer工作流程\n1.用户发出action\n``` javascript\nstore.dispatch(actioin);\n```\n\n2.Store自动调用Reducer，并传入两个参数（当前State和Action）。Reducer会返回新的State\n``` javascript\nlet nextState = todoApp(previousState, action);\n```\n\n3.State出现变化之后，Store调用监听函数\n``` javascript\nstore.subscribe(listener);\n```\nlistener可以通过store.getState()获取当前状态。\n\n``` javascript\nfunction listener() {\n  let newState = store.getState();\n  component.setState(newState);\n}\n```\n\n\n---------------------------------------\n\n### 传送门\n\n#### babel官网\n<a href=\"https://babeljs.io/\" target=\"_blank\">https://babeljs.io/</a>\n\n\n#### react官网\n<a href=\"https://facebook.github.io/react/\" target=\"_blank\">https://facebook.github.io/react/</a>\n\n\n#### redux中文文档\n<a href=\"http://cn.redux.js.org/\" target=\"_blank\">http://cn.redux.js.org/</a>\n\n\n#### redux介绍（segmentfault）\n<a href=\"https://segmentfault.com/a/1190000003503338?_ea=323420\" target=\"_blank\">https://segmentfault.com/a/1190000003503338?_ea=323420</a>\n\n\n#### react入门实践\n<a href=\"http://www.jianshu.com/p/808bb43b3744\" target=\"_blank\">http://www.jianshu.com/p/808bb43b3744</a>\n\n\n#### 阮一峰react系列教程\n<a href=\"http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html\" target=\"_blank\" >http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html</a>\n\n#### imwebRedux文章\n<a href=\"http://imweb.io/topic/57711e37f0a5487b05f325b5\" target=\"_blank\">http://imweb.io/topic/57711e37f0a5487b05f325b5</a>\n\n\n\n","source":"_posts/react.md","raw":"---\ntitle: React、Flux以及Redux小结\ndate: 2018/04/10\ntag: [js, react, flux, redux]\ncategory: 技术\n---\n\nReact和Vue是当下前端最流行的Javascript框架。作为一名现代化前端工程师，学习这两个框架已经成为了标配。\n本人学习这两个框架已经有很长一段时间了，当下对其做一些基本概念梳理总结，利人利己。\n\n\n### Flux\n\n##### Flux是什么\n\nFlux是一种架构思想，专门解决软件结构问题，它和MVC是同一种东西。\n\n##### facebook flux官网描述\n```html\nFlux is the application architecture that Facebook uses for building client-side web applications. \nIt complements React's composable view components by utilizing a unidirectional data flow. \nIt's more of a pattern rather than a formal framework, and you can start using Flux immediately without a lot of new code.\n\n（Flux是Facebook用来构建客户端应用程序的web应用程序架构。它是React单向数据流view组件的补充。它更向是一种模式，而不是一种框架，你只需要使用一点点代码就能立即使用它）\n```\n\n##### Flux结构组成\n```html\nView 视图层\n\nAction 动作 比如视图层发出的消息（比如mouseClick）\n\nDispatcher 派发器 接受Actions，执行回调函数\n\nStore 数据层 用来存放应用状态 Store变动的时候，会触发View更新\n```\n\n##### Flux最大的特点就是“数据的单向流动”\n\n```html\n1.用户访问View\n\n2.用户触发View发起Action\n\n3.Dispather接收到用户的Action，要求Store进行相应更新\n\n4.Store更新之后通知view更新\n```\n如图所示：（图片来源:http://www.ruanyifeng.com/）\n\n![avatar](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016011503.png)\n\n##### Flux的应用\nFlux是一种架构思想，使用flux就是使用flux的这种思想模式构建程序代码。\n使用flux模式构建的代码能够更容易阅读，修改维护更为简单。\n当然，通其它结构思想一样（如MVC）引入flux模式必然会需要引入一些其它的代码，一定程度上提升了代码的复杂度。\n因此，如果不是项目到达一定的规模，如果不是觉得不用框架开发起来很艰难，那就不需要使用flux框架。\n\n\n---\n\n### React\nReact是一个View层框架，用来渲染视图，不直接操作View，想要操作view只能通过修改state来实现\nstate的改变主要来自两个方面，一个是服务端，另一个是用户行为，其中用户行为占很大一部分。\nReact每个组件都有一个setState方法用来修改当前的state，所以一般把修改state操作都放在各自的组件中。\n但是，随着项目的扩大，业务逻辑越来越复杂，一个state的变化往往对应着多个组件，这样很可能导致混乱。\n此时，我们需要一个对state进行统一管理，这也就是Flux出现的原因了。\n\n\n##### React使用Flux\nFlux在React中主要用来集中管理引起state变化的情况，Flux维护着一个或多个Store，（MVC中的Model），Store中存储着应用用到的所有数据。\n当Action触发的时候，Flux根据Action在对应Store中经过一系列逻辑处理，更新Store。\n当Store发生变化的时候，通常根组件（也可以不是根组件）会去获取新的store，然后更新state，然后利用React的单项数据流的特点一层层的向下传递state以更新view。\n\n\n##### Redux\nRedux的作用和Flux相同，可以看作是Flux的一种实现\n\n当然，Redux既然独立存在，肯定是有其独特之处，同Flux相比，Redux有以下不同。\n```html\n1.Redux没有 Dispatcher，只有Reducer，Reducer是一个纯函数，它接受两个参数(previousState、action)，返回一个新的state；\n  Redux中含有多个reducer，多个reducer通过combineReducers方法合并为一个根reducer，这个根reducer负责维护完整的state；\n  当action发起的时候，store会调用dispatch方法，向某个特定的reducer纯函数传递该action，以更新state。\n\n2.Flux有多个store；在store中完成新的state的推导；每一个store都只对对应的view，每次更新都只通知对应的view\n  Redux只有一个store；Redux的更新逻辑也不在store中执行，而是放在reducer中；Redux中所有reducer都由根Reducer统一管理，对应一个根View。\n```\n\n##### Redux Store 以及 Redux State\nStore保存所有的数据，可以将其看做是一个容器。整个应用只能有一个Store\n``` javascript\nimport {createStore} from \"redux\";\n\nconst store = createStore(fn);\n```\n\n如果想得到某个时点的数据，就要对Store生成快照。这种时点的数据集合就叫做State\n``` javascript\nimport {createStore} from \"redux\";\n\nconst store = createStore(fn);\n\nconst state = store.getState();\n```\n\nRedux规定，一个State对应一个View。只要State相同，View就相同。\n知道State就能知道View是什么样，反之亦然。\n\n##### Redux Action\nAction为View发出的通知，表示State将要发生变化\nAction描述当前发生的事情。改变State的唯一办法就是通过Action将数据运送到Store\n``` javascript\nconst action = {\n  type: \"ADD_TODO\", // Action的名称\n  payload: \"LEARN Redux\" // Action携带的字符串信息\n};\n```\n\n#### Redux Action Creater\n定义一个函数，用来自动生成Action，这个函数就叫做Action Creator\n\n``` javascript\nconst ADD_TODO = \"添加 TODO\";\n\nfunction addToDo(text) {\n    return {\n        type: ADD_TODO,\n        text\n    }\n}\n\nconst action = addToDo(Learn Redux);\n```\n\n#### Redux store.dispatch()\nstore.dispatch()是View唯一发出Action的方法\n\n``` javascript\nimport {createStore} form \"redux\";\n\nconst store = createStore(fn);\n\nstore.dispatch({\n  type: \"ADD_TODO\",\n  payload: \"Learn Redux\",\n});\n```\nstore.dispatch接受一个Action对象作为参数，将它发送出去\n\n结合Action Creater\n\n``` javascript\nstore.dispatch(addToDo(\"Learn Redux\"));\n```\n\n##### Redux Reducer\nStore收到一个Action之后必须给出一个新的State，这样View才会发生变化。\n这种State的计算过程就叫做Reducer，Reducer是一个纯函数，它接受Action和当前的State作为参数，返回一个新的State\n``` javascript\nconst Reducer = function(state, action){\n  //...\n  return new_state;\n}\n```\n\n##### Redux subscribe()\nStore允许使用Store.subscribe方法设置监听函数，一旦State发生变化就自动执行这个函数\n\n``` javascript\nimport {createStore} from \"redux\";\nconst store = createStore(reducer);\n\nstore.subscribe(listener);\n```\n\n解除监听，store.subscribe方法返回一个函数，调用这个函数即可解除监听\n\n``` javascript\nconst unsubscribe = store.subscribe(() => \n    console.log(store.getState());\n);\nunsubscribe();\n```\n\n##### Redux Store的实现\nStore提供了三个方法\n\n``` javascript\nstore.getState();\n\nstore.dispatch();\n\nstore.subscribe();\n```\n\n``` javascript\nimport {createStore} from \"redux\";\nlet {subscribe, dispatch, getState} = createStore(reducer);\n```\n\n##### Reducer拆分\nReducer负责生成State，由于一个项目只有一个State，导致这个State会非常庞大。\n所以，Redux提供了解决方案，那就是将其拆分开来，同时Redux又提供了一个combineReducers方法\n用这个方法可以将各个子Reducer合并成一个大的Reducer。\n\n``` javascript\nimport {combineReducers} form \"redux\";\n\nconst chatReducer = combineReducers(){\n    chatLog,\n    statusMessage,\n    userName\n};\n\nexport default todoApp;\n```\n\n可以将所有的子Reducer放在一个文件里面，然后统一引入\n\n``` javascript\nimport {combineReducers} form \"redux\";\nimport * as reducers from \"./reducers\";\n\nconst reducer = combineReducers(reducers); \n```\n\n\n##### Reducer工作流程\n1.用户发出action\n``` javascript\nstore.dispatch(actioin);\n```\n\n2.Store自动调用Reducer，并传入两个参数（当前State和Action）。Reducer会返回新的State\n``` javascript\nlet nextState = todoApp(previousState, action);\n```\n\n3.State出现变化之后，Store调用监听函数\n``` javascript\nstore.subscribe(listener);\n```\nlistener可以通过store.getState()获取当前状态。\n\n``` javascript\nfunction listener() {\n  let newState = store.getState();\n  component.setState(newState);\n}\n```\n\n\n---------------------------------------\n\n### 传送门\n\n#### babel官网\n<a href=\"https://babeljs.io/\" target=\"_blank\">https://babeljs.io/</a>\n\n\n#### react官网\n<a href=\"https://facebook.github.io/react/\" target=\"_blank\">https://facebook.github.io/react/</a>\n\n\n#### redux中文文档\n<a href=\"http://cn.redux.js.org/\" target=\"_blank\">http://cn.redux.js.org/</a>\n\n\n#### redux介绍（segmentfault）\n<a href=\"https://segmentfault.com/a/1190000003503338?_ea=323420\" target=\"_blank\">https://segmentfault.com/a/1190000003503338?_ea=323420</a>\n\n\n#### react入门实践\n<a href=\"http://www.jianshu.com/p/808bb43b3744\" target=\"_blank\">http://www.jianshu.com/p/808bb43b3744</a>\n\n\n#### 阮一峰react系列教程\n<a href=\"http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html\" target=\"_blank\" >http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html</a>\n\n#### imwebRedux文章\n<a href=\"http://imweb.io/topic/57711e37f0a5487b05f325b5\" target=\"_blank\">http://imweb.io/topic/57711e37f0a5487b05f325b5</a>\n\n\n\n","slug":"react","published":1,"updated":"2021-03-30T01:32:00.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug8001la0vzak459zwm","content":"<p>React和Vue是当下前端最流行的Javascript框架。作为一名现代化前端工程师，学习这两个框架已经成为了标配。<br>本人学习这两个框架已经有很长一段时间了，当下对其做一些基本概念梳理总结，利人利己。</p>\n<h3 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h3><h5 id=\"Flux是什么\"><a href=\"#Flux是什么\" class=\"headerlink\" title=\"Flux是什么\"></a>Flux是什么</h5><p>Flux是一种架构思想，专门解决软件结构问题，它和MVC是同一种东西。</p>\n<h5 id=\"facebook-flux官网描述\"><a href=\"#facebook-flux官网描述\" class=\"headerlink\" title=\"facebook flux官网描述\"></a>facebook flux官网描述</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flux is the application architecture that Facebook uses for building client-side web applications. </span><br><span class=\"line\">It complements React&#x27;s composable view components by utilizing a unidirectional data flow. </span><br><span class=\"line\">It&#x27;s more of a pattern rather than a formal framework, and you can start using Flux immediately without a lot of new code.</span><br><span class=\"line\"></span><br><span class=\"line\">（Flux是Facebook用来构建客户端应用程序的web应用程序架构。它是React单向数据流view组件的补充。它更向是一种模式，而不是一种框架，你只需要使用一点点代码就能立即使用它）</span><br></pre></td></tr></table></figure>\n<h5 id=\"Flux结构组成\"><a href=\"#Flux结构组成\" class=\"headerlink\" title=\"Flux结构组成\"></a>Flux结构组成</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View 视图层</span><br><span class=\"line\"></span><br><span class=\"line\">Action 动作 比如视图层发出的消息（比如mouseClick）</span><br><span class=\"line\"></span><br><span class=\"line\">Dispatcher 派发器 接受Actions，执行回调函数</span><br><span class=\"line\"></span><br><span class=\"line\">Store 数据层 用来存放应用状态 Store变动的时候，会触发View更新</span><br></pre></td></tr></table></figure>\n<h5 id=\"Flux最大的特点就是“数据的单向流动”\"><a href=\"#Flux最大的特点就是“数据的单向流动”\" class=\"headerlink\" title=\"Flux最大的特点就是“数据的单向流动”\"></a>Flux最大的特点就是“数据的单向流动”</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.用户访问View</span><br><span class=\"line\"></span><br><span class=\"line\">2.用户触发View发起Action</span><br><span class=\"line\"></span><br><span class=\"line\">3.Dispather接收到用户的Action，要求Store进行相应更新</span><br><span class=\"line\"></span><br><span class=\"line\">4.Store更新之后通知view更新</span><br></pre></td></tr></table></figure>\n<p>如图所示：（图片来源:<a href=\"http://www.ruanyifeng.com/）\">http://www.ruanyifeng.com/）</a></p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016011503.png\" alt=\"avatar\"></p>\n<h5 id=\"Flux的应用\"><a href=\"#Flux的应用\" class=\"headerlink\" title=\"Flux的应用\"></a>Flux的应用</h5><p>Flux是一种架构思想，使用flux就是使用flux的这种思想模式构建程序代码。<br>使用flux模式构建的代码能够更容易阅读，修改维护更为简单。<br>当然，通其它结构思想一样（如MVC）引入flux模式必然会需要引入一些其它的代码，一定程度上提升了代码的复杂度。<br>因此，如果不是项目到达一定的规模，如果不是觉得不用框架开发起来很艰难，那就不需要使用flux框架。</p>\n<hr>\n<h3 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h3><p>React是一个View层框架，用来渲染视图，不直接操作View，想要操作view只能通过修改state来实现<br>state的改变主要来自两个方面，一个是服务端，另一个是用户行为，其中用户行为占很大一部分。<br>React每个组件都有一个setState方法用来修改当前的state，所以一般把修改state操作都放在各自的组件中。<br>但是，随着项目的扩大，业务逻辑越来越复杂，一个state的变化往往对应着多个组件，这样很可能导致混乱。<br>此时，我们需要一个对state进行统一管理，这也就是Flux出现的原因了。</p>\n<h5 id=\"React使用Flux\"><a href=\"#React使用Flux\" class=\"headerlink\" title=\"React使用Flux\"></a>React使用Flux</h5><p>Flux在React中主要用来集中管理引起state变化的情况，Flux维护着一个或多个Store，（MVC中的Model），Store中存储着应用用到的所有数据。<br>当Action触发的时候，Flux根据Action在对应Store中经过一系列逻辑处理，更新Store。<br>当Store发生变化的时候，通常根组件（也可以不是根组件）会去获取新的store，然后更新state，然后利用React的单项数据流的特点一层层的向下传递state以更新view。</p>\n<h5 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h5><p>Redux的作用和Flux相同，可以看作是Flux的一种实现</p>\n<p>当然，Redux既然独立存在，肯定是有其独特之处，同Flux相比，Redux有以下不同。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.Redux没有 Dispatcher，只有Reducer，Reducer是一个纯函数，它接受两个参数(previousState、action)，返回一个新的state；</span><br><span class=\"line\">  Redux中含有多个reducer，多个reducer通过combineReducers方法合并为一个根reducer，这个根reducer负责维护完整的state；</span><br><span class=\"line\">  当action发起的时候，store会调用dispatch方法，向某个特定的reducer纯函数传递该action，以更新state。</span><br><span class=\"line\"></span><br><span class=\"line\">2.Flux有多个store；在store中完成新的state的推导；每一个store都只对对应的view，每次更新都只通知对应的view</span><br><span class=\"line\">  Redux只有一个store；Redux的更新逻辑也不在store中执行，而是放在reducer中；Redux中所有reducer都由根Reducer统一管理，对应一个根View。</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Redux-Store-以及-Redux-State\"><a href=\"#Redux-Store-以及-Redux-State\" class=\"headerlink\" title=\"Redux Store 以及 Redux State\"></a>Redux Store 以及 Redux State</h5><p>Store保存所有的数据，可以将其看做是一个容器。整个应用只能有一个Store<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(fn);</span><br></pre></td></tr></table></figure></p>\n<p>如果想得到某个时点的数据，就要对Store生成快照。这种时点的数据集合就叫做State<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(fn);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = store.getState();</span><br></pre></td></tr></table></figure></p>\n<p>Redux规定，一个State对应一个View。只要State相同，View就相同。<br>知道State就能知道View是什么样，反之亦然。</p>\n<h5 id=\"Redux-Action\"><a href=\"#Redux-Action\" class=\"headerlink\" title=\"Redux Action\"></a>Redux Action</h5><p>Action为View发出的通知，表示State将要发生变化<br>Action描述当前发生的事情。改变State的唯一办法就是通过Action将数据运送到Store<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> action = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">&quot;ADD_TODO&quot;</span>, <span class=\"comment\">// Action的名称</span></span><br><span class=\"line\">  payload: <span class=\"string\">&quot;LEARN Redux&quot;</span> <span class=\"comment\">// Action携带的字符串信息</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Redux-Action-Creater\"><a href=\"#Redux-Action-Creater\" class=\"headerlink\" title=\"Redux Action Creater\"></a>Redux Action Creater</h4><p>定义一个函数，用来自动生成Action，这个函数就叫做Action Creator</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ADD_TODO = <span class=\"string\">&quot;添加 TODO&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addToDo</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        type: ADD_TODO,</span><br><span class=\"line\">        text</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> action = addToDo(Learn Redux);</span><br></pre></td></tr></table></figure>\n<h4 id=\"Redux-store-dispatch\"><a href=\"#Redux-store-dispatch\" class=\"headerlink\" title=\"Redux store.dispatch()\"></a>Redux store.dispatch()</h4><p>store.dispatch()是View唯一发出Action的方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; form <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(fn);</span><br><span class=\"line\"></span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">&quot;ADD_TODO&quot;</span>,</span><br><span class=\"line\">  payload: <span class=\"string\">&quot;Learn Redux&quot;</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>store.dispatch接受一个Action对象作为参数，将它发送出去</p>\n<p>结合Action Creater</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(addToDo(<span class=\"string\">&quot;Learn Redux&quot;</span>));</span><br></pre></td></tr></table></figure>\n<h5 id=\"Redux-Reducer\"><a href=\"#Redux-Reducer\" class=\"headerlink\" title=\"Redux Reducer\"></a>Redux Reducer</h5><p>Store收到一个Action之后必须给出一个新的State，这样View才会发生变化。<br>这种State的计算过程就叫做Reducer，Reducer是一个纯函数，它接受Action和当前的State作为参数，返回一个新的State<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Reducer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">state, action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> new_state;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Redux-subscribe\"><a href=\"#Redux-subscribe\" class=\"headerlink\" title=\"Redux subscribe()\"></a>Redux subscribe()</h5><p>Store允许使用Store.subscribe方法设置监听函数，一旦State发生变化就自动执行这个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer);</span><br><span class=\"line\"></span><br><span class=\"line\">store.subscribe(listener);</span><br></pre></td></tr></table></figure>\n<p>解除监听，store.subscribe方法返回一个函数，调用这个函数即可解除监听</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unsubscribe = store.subscribe(<span class=\"function\">() =&gt;</span> </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(store.getState());</span><br><span class=\"line\">);</span><br><span class=\"line\">unsubscribe();</span><br></pre></td></tr></table></figure>\n<h5 id=\"Redux-Store的实现\"><a href=\"#Redux-Store的实现\" class=\"headerlink\" title=\"Redux Store的实现\"></a>Redux Store的实现</h5><p>Store提供了三个方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.getState();</span><br><span class=\"line\"></span><br><span class=\"line\">store.dispatch();</span><br><span class=\"line\"></span><br><span class=\"line\">store.subscribe();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;subscribe, dispatch, getState&#125; = createStore(reducer);</span><br></pre></td></tr></table></figure>\n<h5 id=\"Reducer拆分\"><a href=\"#Reducer拆分\" class=\"headerlink\" title=\"Reducer拆分\"></a>Reducer拆分</h5><p>Reducer负责生成State，由于一个项目只有一个State，导致这个State会非常庞大。<br>所以，Redux提供了解决方案，那就是将其拆分开来，同时Redux又提供了一个combineReducers方法<br>用这个方法可以将各个子Reducer合并成一个大的Reducer。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;combineReducers&#125; form <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> chatReducer = <span class=\"function\"><span class=\"title\">combineReducers</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    chatLog,</span><br><span class=\"line\">    statusMessage,</span><br><span class=\"line\">    userName</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todoApp;</span><br></pre></td></tr></table></figure>\n<p>可以将所有的子Reducer放在一个文件里面，然后统一引入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;combineReducers&#125; form <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> reducers <span class=\"keyword\">from</span> <span class=\"string\">&quot;./reducers&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> reducer = combineReducers(reducers); </span><br></pre></td></tr></table></figure>\n<h5 id=\"Reducer工作流程\"><a href=\"#Reducer工作流程\" class=\"headerlink\" title=\"Reducer工作流程\"></a>Reducer工作流程</h5><p>1.用户发出action<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(actioin);</span><br></pre></td></tr></table></figure></p>\n<p>2.Store自动调用Reducer，并传入两个参数（当前State和Action）。Reducer会返回新的State<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nextState = todoApp(previousState, action);</span><br></pre></td></tr></table></figure></p>\n<p>3.State出现变化之后，Store调用监听函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.subscribe(listener);</span><br></pre></td></tr></table></figure><br>listener可以通过store.getState()获取当前状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listener</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newState = store.getState();</span><br><span class=\"line\">  component.setState(newState);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><h4 id=\"babel官网\"><a href=\"#babel官网\" class=\"headerlink\" title=\"babel官网\"></a>babel官网</h4><p><a href=\"https://babeljs.io/\" target=\"_blank\">https://babeljs.io/</a></p>\n<h4 id=\"react官网\"><a href=\"#react官网\" class=\"headerlink\" title=\"react官网\"></a>react官网</h4><p><a href=\"https://facebook.github.io/react/\" target=\"_blank\">https://facebook.github.io/react/</a></p>\n<h4 id=\"redux中文文档\"><a href=\"#redux中文文档\" class=\"headerlink\" title=\"redux中文文档\"></a>redux中文文档</h4><p><a href=\"http://cn.redux.js.org/\" target=\"_blank\">http://cn.redux.js.org/</a></p>\n<h4 id=\"redux介绍（segmentfault）\"><a href=\"#redux介绍（segmentfault）\" class=\"headerlink\" title=\"redux介绍（segmentfault）\"></a>redux介绍（segmentfault）</h4><p><a href=\"https://segmentfault.com/a/1190000003503338?_ea=323420\" target=\"_blank\">https://segmentfault.com/a/1190000003503338?_ea=323420</a></p>\n<h4 id=\"react入门实践\"><a href=\"#react入门实践\" class=\"headerlink\" title=\"react入门实践\"></a>react入门实践</h4><p><a href=\"http://www.jianshu.com/p/808bb43b3744\" target=\"_blank\">http://www.jianshu.com/p/808bb43b3744</a></p>\n<h4 id=\"阮一峰react系列教程\"><a href=\"#阮一峰react系列教程\" class=\"headerlink\" title=\"阮一峰react系列教程\"></a>阮一峰react系列教程</h4><p><a href=\"http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html\" target=\"_blank\" >http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html</a></p>\n<h4 id=\"imwebRedux文章\"><a href=\"#imwebRedux文章\" class=\"headerlink\" title=\"imwebRedux文章\"></a>imwebRedux文章</h4><p><a href=\"http://imweb.io/topic/57711e37f0a5487b05f325b5\" target=\"_blank\">http://imweb.io/topic/57711e37f0a5487b05f325b5</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>React和Vue是当下前端最流行的Javascript框架。作为一名现代化前端工程师，学习这两个框架已经成为了标配。<br>本人学习这两个框架已经有很长一段时间了，当下对其做一些基本概念梳理总结，利人利己。</p>\n<h3 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h3><h5 id=\"Flux是什么\"><a href=\"#Flux是什么\" class=\"headerlink\" title=\"Flux是什么\"></a>Flux是什么</h5><p>Flux是一种架构思想，专门解决软件结构问题，它和MVC是同一种东西。</p>\n<h5 id=\"facebook-flux官网描述\"><a href=\"#facebook-flux官网描述\" class=\"headerlink\" title=\"facebook flux官网描述\"></a>facebook flux官网描述</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flux is the application architecture that Facebook uses for building client-side web applications. </span><br><span class=\"line\">It complements React&#x27;s composable view components by utilizing a unidirectional data flow. </span><br><span class=\"line\">It&#x27;s more of a pattern rather than a formal framework, and you can start using Flux immediately without a lot of new code.</span><br><span class=\"line\"></span><br><span class=\"line\">（Flux是Facebook用来构建客户端应用程序的web应用程序架构。它是React单向数据流view组件的补充。它更向是一种模式，而不是一种框架，你只需要使用一点点代码就能立即使用它）</span><br></pre></td></tr></table></figure>\n<h5 id=\"Flux结构组成\"><a href=\"#Flux结构组成\" class=\"headerlink\" title=\"Flux结构组成\"></a>Flux结构组成</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View 视图层</span><br><span class=\"line\"></span><br><span class=\"line\">Action 动作 比如视图层发出的消息（比如mouseClick）</span><br><span class=\"line\"></span><br><span class=\"line\">Dispatcher 派发器 接受Actions，执行回调函数</span><br><span class=\"line\"></span><br><span class=\"line\">Store 数据层 用来存放应用状态 Store变动的时候，会触发View更新</span><br></pre></td></tr></table></figure>\n<h5 id=\"Flux最大的特点就是“数据的单向流动”\"><a href=\"#Flux最大的特点就是“数据的单向流动”\" class=\"headerlink\" title=\"Flux最大的特点就是“数据的单向流动”\"></a>Flux最大的特点就是“数据的单向流动”</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.用户访问View</span><br><span class=\"line\"></span><br><span class=\"line\">2.用户触发View发起Action</span><br><span class=\"line\"></span><br><span class=\"line\">3.Dispather接收到用户的Action，要求Store进行相应更新</span><br><span class=\"line\"></span><br><span class=\"line\">4.Store更新之后通知view更新</span><br></pre></td></tr></table></figure>\n<p>如图所示：（图片来源:<a href=\"http://www.ruanyifeng.com/）\">http://www.ruanyifeng.com/）</a></p>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016011503.png\" alt=\"avatar\"></p>\n<h5 id=\"Flux的应用\"><a href=\"#Flux的应用\" class=\"headerlink\" title=\"Flux的应用\"></a>Flux的应用</h5><p>Flux是一种架构思想，使用flux就是使用flux的这种思想模式构建程序代码。<br>使用flux模式构建的代码能够更容易阅读，修改维护更为简单。<br>当然，通其它结构思想一样（如MVC）引入flux模式必然会需要引入一些其它的代码，一定程度上提升了代码的复杂度。<br>因此，如果不是项目到达一定的规模，如果不是觉得不用框架开发起来很艰难，那就不需要使用flux框架。</p>\n<hr>\n<h3 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h3><p>React是一个View层框架，用来渲染视图，不直接操作View，想要操作view只能通过修改state来实现<br>state的改变主要来自两个方面，一个是服务端，另一个是用户行为，其中用户行为占很大一部分。<br>React每个组件都有一个setState方法用来修改当前的state，所以一般把修改state操作都放在各自的组件中。<br>但是，随着项目的扩大，业务逻辑越来越复杂，一个state的变化往往对应着多个组件，这样很可能导致混乱。<br>此时，我们需要一个对state进行统一管理，这也就是Flux出现的原因了。</p>\n<h5 id=\"React使用Flux\"><a href=\"#React使用Flux\" class=\"headerlink\" title=\"React使用Flux\"></a>React使用Flux</h5><p>Flux在React中主要用来集中管理引起state变化的情况，Flux维护着一个或多个Store，（MVC中的Model），Store中存储着应用用到的所有数据。<br>当Action触发的时候，Flux根据Action在对应Store中经过一系列逻辑处理，更新Store。<br>当Store发生变化的时候，通常根组件（也可以不是根组件）会去获取新的store，然后更新state，然后利用React的单项数据流的特点一层层的向下传递state以更新view。</p>\n<h5 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h5><p>Redux的作用和Flux相同，可以看作是Flux的一种实现</p>\n<p>当然，Redux既然独立存在，肯定是有其独特之处，同Flux相比，Redux有以下不同。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.Redux没有 Dispatcher，只有Reducer，Reducer是一个纯函数，它接受两个参数(previousState、action)，返回一个新的state；</span><br><span class=\"line\">  Redux中含有多个reducer，多个reducer通过combineReducers方法合并为一个根reducer，这个根reducer负责维护完整的state；</span><br><span class=\"line\">  当action发起的时候，store会调用dispatch方法，向某个特定的reducer纯函数传递该action，以更新state。</span><br><span class=\"line\"></span><br><span class=\"line\">2.Flux有多个store；在store中完成新的state的推导；每一个store都只对对应的view，每次更新都只通知对应的view</span><br><span class=\"line\">  Redux只有一个store；Redux的更新逻辑也不在store中执行，而是放在reducer中；Redux中所有reducer都由根Reducer统一管理，对应一个根View。</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Redux-Store-以及-Redux-State\"><a href=\"#Redux-Store-以及-Redux-State\" class=\"headerlink\" title=\"Redux Store 以及 Redux State\"></a>Redux Store 以及 Redux State</h5><p>Store保存所有的数据，可以将其看做是一个容器。整个应用只能有一个Store<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(fn);</span><br></pre></td></tr></table></figure></p>\n<p>如果想得到某个时点的数据，就要对Store生成快照。这种时点的数据集合就叫做State<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(fn);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = store.getState();</span><br></pre></td></tr></table></figure></p>\n<p>Redux规定，一个State对应一个View。只要State相同，View就相同。<br>知道State就能知道View是什么样，反之亦然。</p>\n<h5 id=\"Redux-Action\"><a href=\"#Redux-Action\" class=\"headerlink\" title=\"Redux Action\"></a>Redux Action</h5><p>Action为View发出的通知，表示State将要发生变化<br>Action描述当前发生的事情。改变State的唯一办法就是通过Action将数据运送到Store<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> action = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">&quot;ADD_TODO&quot;</span>, <span class=\"comment\">// Action的名称</span></span><br><span class=\"line\">  payload: <span class=\"string\">&quot;LEARN Redux&quot;</span> <span class=\"comment\">// Action携带的字符串信息</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Redux-Action-Creater\"><a href=\"#Redux-Action-Creater\" class=\"headerlink\" title=\"Redux Action Creater\"></a>Redux Action Creater</h4><p>定义一个函数，用来自动生成Action，这个函数就叫做Action Creator</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ADD_TODO = <span class=\"string\">&quot;添加 TODO&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addToDo</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        type: ADD_TODO,</span><br><span class=\"line\">        text</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> action = addToDo(Learn Redux);</span><br></pre></td></tr></table></figure>\n<h4 id=\"Redux-store-dispatch\"><a href=\"#Redux-store-dispatch\" class=\"headerlink\" title=\"Redux store.dispatch()\"></a>Redux store.dispatch()</h4><p>store.dispatch()是View唯一发出Action的方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; form <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(fn);</span><br><span class=\"line\"></span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">&quot;ADD_TODO&quot;</span>,</span><br><span class=\"line\">  payload: <span class=\"string\">&quot;Learn Redux&quot;</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>store.dispatch接受一个Action对象作为参数，将它发送出去</p>\n<p>结合Action Creater</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(addToDo(<span class=\"string\">&quot;Learn Redux&quot;</span>));</span><br></pre></td></tr></table></figure>\n<h5 id=\"Redux-Reducer\"><a href=\"#Redux-Reducer\" class=\"headerlink\" title=\"Redux Reducer\"></a>Redux Reducer</h5><p>Store收到一个Action之后必须给出一个新的State，这样View才会发生变化。<br>这种State的计算过程就叫做Reducer，Reducer是一个纯函数，它接受Action和当前的State作为参数，返回一个新的State<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Reducer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">state, action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> new_state;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Redux-subscribe\"><a href=\"#Redux-subscribe\" class=\"headerlink\" title=\"Redux subscribe()\"></a>Redux subscribe()</h5><p>Store允许使用Store.subscribe方法设置监听函数，一旦State发生变化就自动执行这个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer);</span><br><span class=\"line\"></span><br><span class=\"line\">store.subscribe(listener);</span><br></pre></td></tr></table></figure>\n<p>解除监听，store.subscribe方法返回一个函数，调用这个函数即可解除监听</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unsubscribe = store.subscribe(<span class=\"function\">() =&gt;</span> </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(store.getState());</span><br><span class=\"line\">);</span><br><span class=\"line\">unsubscribe();</span><br></pre></td></tr></table></figure>\n<h5 id=\"Redux-Store的实现\"><a href=\"#Redux-Store的实现\" class=\"headerlink\" title=\"Redux Store的实现\"></a>Redux Store的实现</h5><p>Store提供了三个方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.getState();</span><br><span class=\"line\"></span><br><span class=\"line\">store.dispatch();</span><br><span class=\"line\"></span><br><span class=\"line\">store.subscribe();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;subscribe, dispatch, getState&#125; = createStore(reducer);</span><br></pre></td></tr></table></figure>\n<h5 id=\"Reducer拆分\"><a href=\"#Reducer拆分\" class=\"headerlink\" title=\"Reducer拆分\"></a>Reducer拆分</h5><p>Reducer负责生成State，由于一个项目只有一个State，导致这个State会非常庞大。<br>所以，Redux提供了解决方案，那就是将其拆分开来，同时Redux又提供了一个combineReducers方法<br>用这个方法可以将各个子Reducer合并成一个大的Reducer。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;combineReducers&#125; form <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> chatReducer = <span class=\"function\"><span class=\"title\">combineReducers</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    chatLog,</span><br><span class=\"line\">    statusMessage,</span><br><span class=\"line\">    userName</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todoApp;</span><br></pre></td></tr></table></figure>\n<p>可以将所有的子Reducer放在一个文件里面，然后统一引入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;combineReducers&#125; form <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> reducers <span class=\"keyword\">from</span> <span class=\"string\">&quot;./reducers&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> reducer = combineReducers(reducers); </span><br></pre></td></tr></table></figure>\n<h5 id=\"Reducer工作流程\"><a href=\"#Reducer工作流程\" class=\"headerlink\" title=\"Reducer工作流程\"></a>Reducer工作流程</h5><p>1.用户发出action<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(actioin);</span><br></pre></td></tr></table></figure></p>\n<p>2.Store自动调用Reducer，并传入两个参数（当前State和Action）。Reducer会返回新的State<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nextState = todoApp(previousState, action);</span><br></pre></td></tr></table></figure></p>\n<p>3.State出现变化之后，Store调用监听函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.subscribe(listener);</span><br></pre></td></tr></table></figure><br>listener可以通过store.getState()获取当前状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listener</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newState = store.getState();</span><br><span class=\"line\">  component.setState(newState);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><h4 id=\"babel官网\"><a href=\"#babel官网\" class=\"headerlink\" title=\"babel官网\"></a>babel官网</h4><p><a href=\"https://babeljs.io/\" target=\"_blank\">https://babeljs.io/</a></p>\n<h4 id=\"react官网\"><a href=\"#react官网\" class=\"headerlink\" title=\"react官网\"></a>react官网</h4><p><a href=\"https://facebook.github.io/react/\" target=\"_blank\">https://facebook.github.io/react/</a></p>\n<h4 id=\"redux中文文档\"><a href=\"#redux中文文档\" class=\"headerlink\" title=\"redux中文文档\"></a>redux中文文档</h4><p><a href=\"http://cn.redux.js.org/\" target=\"_blank\">http://cn.redux.js.org/</a></p>\n<h4 id=\"redux介绍（segmentfault）\"><a href=\"#redux介绍（segmentfault）\" class=\"headerlink\" title=\"redux介绍（segmentfault）\"></a>redux介绍（segmentfault）</h4><p><a href=\"https://segmentfault.com/a/1190000003503338?_ea=323420\" target=\"_blank\">https://segmentfault.com/a/1190000003503338?_ea=323420</a></p>\n<h4 id=\"react入门实践\"><a href=\"#react入门实践\" class=\"headerlink\" title=\"react入门实践\"></a>react入门实践</h4><p><a href=\"http://www.jianshu.com/p/808bb43b3744\" target=\"_blank\">http://www.jianshu.com/p/808bb43b3744</a></p>\n<h4 id=\"阮一峰react系列教程\"><a href=\"#阮一峰react系列教程\" class=\"headerlink\" title=\"阮一峰react系列教程\"></a>阮一峰react系列教程</h4><p><a href=\"http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html\" target=\"_blank\" >http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html</a></p>\n<h4 id=\"imwebRedux文章\"><a href=\"#imwebRedux文章\" class=\"headerlink\" title=\"imwebRedux文章\"></a>imwebRedux文章</h4><p><a href=\"http://imweb.io/topic/57711e37f0a5487b05f325b5\" target=\"_blank\">http://imweb.io/topic/57711e37f0a5487b05f325b5</a></p>\n"},{"title":"react 学习笔记","date":"2021-02-07T16:00:00.000Z","_content":"\n影响 App 应用 ***快速响应***的因素主要有两个\n```html\n1.网络请求响应慢\n2.js中含有大量计算，导致设备性能不足，导致卡顿（CPU瓶颈）\n```\n对于网络请求作为前端开发能做的无非就是做缓存、懒加载等。\n\n对于 javascript 中含有必要的大量计算的情况，如果是异步计算可以使用 WebWorker另外开一个进程来解决。\n对于同步计算，WebWorker就力不从心了。\n\n对于大量计算导致设备性能不足，页面卡顿的情况，升级设备才是最好的办法。\n当然，在设备有限的情况下我们只能从我们的代码入手，尽可能的优化代码，减少设备资源的消耗了。\n\n主流浏览器的刷新频率是 60HZ，每16.66毫秒刷新一次，js可以操作DOM，GUI渲染界面\n所以JS线程和 GUI 渲染线程如果同时执行，会导致混乱，因此，浏览器的这两个线程被设计成互斥的。\n因此，如果 js 每次执行时间过长，超过了16.66毫秒则会导致 GUI 渲染不连贯，让用户感知到卡顿。\n\n#### 如何保证 js 的执行不影响 GUI 的渲染呢？\nReact 给出了一个解决方案 ***“时间切片”***。\n在浏览器每一帧中预留出一部分时间给 js 线程，React 在这部分时间来做组件更新。\n当预留时间消耗完毕之后，中断js线程的执行，将剩余时间进行GUI渲染，待下一帧来临的时候继续被中断的js线程工作。\n而如果想做到上面的工作，必须要做到的是：将同步的更新变为可中断的异步更新。\n\n#### React\nReact 官网对它理念介绍是：\n```html\nReact 是用 Javascript 构建能够快速响应的大型 Web 应用程序的首选方式。\n```\n\n#### React16\nReact16 三层架构\n```html\nScheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler (React16 新增)\nReconciler（协调器）—— 负责找出变化的组件\nRenderer（渲染器）—— 负责将变化的组件渲染到页面上，根据不同的平台有不同的Renderer，如 reactDom、ReactNative\n```\n\n##### Scheduler 调度器\nReact16 做到了时间切片，以浏览器是否有剩余时间作为任务中断的标准。\n它实现了一种机制，当浏览器有剩余时间时通知我们。\n```html\n其实部分浏览器已经实现了这个API，这就是requestIdleCallback (opens new window)。但是由于以下因素，React放弃使用\n比如：触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的 requestIdleCallback 触发的频率会变得很低\n```\n基于以上原因，React实现了功能更完备的 requestIdleCallbackpolyfill，这就是Scheduler。\n除了在空闲时触发回调的功能外，Scheduler 还提供了多种调度优先级供任务设置。\n\n调度器会按照任务的优先级来进行任务分配，任务分配分为有六种：\n```html\nsynchronous，与之前的Stack Reconciler操作一样，同步执行\ntask，在next tick之前执行\nanimation，下一帧之前执行\nhigh，在不久的将来立即执行\nlow，稍微延迟执行也没关系\noffscreen，下一次render时或scroll时才执行\n```\n优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。\n\n\n##### Reconciler 协调器\n协调器的作用是调用函数组件、或 class 组件的 render 方法，将返回的 JSX 转化为虚拟 DOM\n首先将虚拟 DOM 和上次更新时的虚拟 DOM 对比，通过对比找出本次更新中变化的虚拟 DOM\n然后通知 Renderer 将变化的虚拟DOM渲染到页面上。\n\nReact 团队给 Reconciler 层起了个新的名字，叫 ***Fiber Reconciler***。\n为了加以区分，React16 以前的原 Reconciler 被命名为 Stack Reconciler。\nStack Reconciler 和 Fiber Reconciler 的区别在于前者的运作的过程是不能被打断的，后者每执行一段时间，都会将控制权交回给浏览器，可以实现分段执行。\n\n##### Renderer 渲染器\n由于React支持跨平台，所以不同平台有不同的Renderer。\n我们前端最熟悉的是负责在浏览器环境渲染的 Renderer —— ReactDOM\n除此之外，还有：\nReactNative 渲染器，渲染App原生组件\nReactTest 渲染器，渲染出纯Js对象用于测试\nReactArt 渲染器，渲染到Canvas, SVG 或 VML (IE8)\n\n在每次更新发生时，Renderer 会接到 Reconciler 通知，然后将变化的组件渲染在当前宿主环境。\n\n#### Fiber\nFiber 并不是计算机术语中的新名词，他的中文翻译叫做纤程\n与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。\n\nFiber 的主要目标是实现虚拟 DOM 的增量渲染，能够将渲染工作拆分成块并将其分散到多个帧的能力。\n在新的更新到来时，能够暂停、中止和复用工作，能为不同类型的更新分配优先级顺序的能力。\n\nReact Fiber 是 React 内部实现的一套状态更新机制，***其实际上就是 React16版本的 的虚拟 DOM***。\n作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。\n作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。\n\nReact Fiber 支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。\n其中每个任务更新单元为 React Element 对应的 Fiber 节点。\n\n在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。\n如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。\nReact16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。\n于是，全新的 Fiber 架构应运而生。\n\n##### Fiber 工作原理\nFiber 保存的就是对应的虚拟DOM，Fiber 构成的 Fiber 树就是对应的 DOM树。\n对于 Fiber DOM树的更新，用到了“双缓存”的技术。\n双缓存是一种在内存中构建并直接替换的技术，类似 Canvas 绘图过程中事先在内存中绘制了完整的新图层，然后用新图层直接替换旧图层的操作。\n在 React 视图更新的时候，最多会存在两颗 Fiber 树， 状态变化的时候产生内存树，绘制完成之后直接替换 UI树。\n\n\n### 附录\n#### requestIdleCallback\nrequestIdleCallback 的作用是是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务，它的 FPS 只有 20\n同步的调用多次 requestIdleCallback，该方法的回调执行可能会分布在不同的帧上，每执行完一次回调，浏览器会检查是否还有剩余的空闲时间\n如果没有，会将执行控制权交还 event loop\n如果有才会继续执行下一个回调\n和 react fiber 的调度很像（事实上，React Fiber就是 ReqeustIdleCallback 的 polyfill）。\n\n其特点是：不占用单独帧，只在帧空闲的时间执行\nwindow.requestIdleCallback()会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务\n而且不会对像动画和用户交互这些延迟触发但关键的事件产生影响\n\n#### requestAnimationFrame\n其作用就是让浏览器流畅的执行动画效果\n告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画\n该方法的回调将会在浏览器的下一次绘制前\nrequestAnimationFrame()已经解决了浏览器不知道 JavaScript 动画何时开始的问题， 以及最佳间隔是多少的问题\nrequestAnimationFrame 方法会告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用回调函数来更新动画。\nrequestAnimationFrame的基本思想是 让页面重绘的频率和刷新频率保持同步\n通过 requestAnimationFrame 调用回调函数引起的页面重绘或回流的时间间隔和显示器的刷新时间间隔相同。\n\n\n#### jsx\nReact DOM 在渲染所有输入内容之前，默认会进行转义，可以有效地防止 xss 攻击\nBabel 会把 JSX 转译成一个名为 React.createElement() 函数调用。\n\n```javascript\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n)\n```\n等效\n```javascript\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n)\n```\nReact.createElement() 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象：\n```javascript\n// 注意：这是简化过的结构\nconst element = {\n  type: 'h1',\n  props: {\n    className: 'greeting',\n    children: 'Hello, world!'\n  }\n}\n```\n\n\n仅使用 React 构建的应用通常只有单一的根 DOM 节点。\n想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()：\n```javascript\nconst element = <h1>Hello, world</h1>\nReactDOM.render(element, document.getElementById('root'))\n```\n\n#### 函数组件\n```javascript\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\n该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。\n这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。\n\n也可以使用 es6 的类定义的方式定义 class 组件\n```javascript\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```\n\n#### state\nState 与 props 类似，但是 state 是私有的，并且完全受控于当前组件\n\n#### key\nkey 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。\n当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key\n如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。\n如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。\n元素的 key 只有放在就近的数组上下文中才有意义。\n```javascript\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    // 错误！元素的 key 应该在这里指定：\n    <ListItem value={number} />\n  );\n  return (\n    <ul>\n      {listItems}\n    </ul>\n  );\n}\n```\n一个好的经验法则是：在 map() 方法中的元素需要设置 key 属性。\n数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。\n然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值\nPost 组件可以读出 props.xx，但是不能读出 props.key (key的值应该使用其他属性名来传递)\n\n#### 受控组件\n表单元素依赖于状态，表单元素需要默认值实时映射到状态的时候，就是受控组件，这个和双向绑定相似.\n受控组件，表单元素的修改会实时映射到状态值上，此时就可以对输入的内容进行校验.\n受控组件只有继承React.Component才会有状态.\n受控组件必须要在表单上使用onChange事件来绑定对应的事件.\nReact 最棒的部分之一是引导我们思考如何构建一个应用。一个组件原则上只能负责一个功能\n\n#### 状态提升\n通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去\n\n#### state 和 props 之间的区别是什么？\nprops（“properties” 的缩写）和 state 都是普通的 JavaScript 对象。\n它们都是用来保存信息的，这些信息可以控制组件的渲染输出\n而它们的一个重要的不同点就是：props 是传递给组件的（类似于函数的形参）\n而 state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。\n\n#### 给 setState 传递一个对象与传递一个函数的区别是什么\n传递一个函数可以让你在函数内访问到当前的 state 的值\n因为 setState 的调用是分批的，所以你可以链式地进行更新，并确保它们是一个建立在另一个之上的，这样才不会发生冲突\n在事件处理函数内部的 setState 是异步的。\n\n### 传送门\n为什么 React 中 Key 是必须的\nhttps://zh-hans.reactjs.org/docs/reconciliation.html#recursing-on-children\n\n受控组件和非受控组件\nhttps://juejin.cn/post/6858276396968951822\n\nReact 和 vue的区别\nhttps://juejin.cn/post/6844903668446134286\n\nReact Fiber 原理\nhttps://segmentfault.com/a/1190000018250127\n\nFiber 介绍\nhttps://musicfe.dev/react-fiber/","source":"_posts/react16.md","raw":"---\ntitle: react 学习笔记\ndate: 2021/02/08\ntag: [react,fiber]\ncategory: 笔记\n---\n\n影响 App 应用 ***快速响应***的因素主要有两个\n```html\n1.网络请求响应慢\n2.js中含有大量计算，导致设备性能不足，导致卡顿（CPU瓶颈）\n```\n对于网络请求作为前端开发能做的无非就是做缓存、懒加载等。\n\n对于 javascript 中含有必要的大量计算的情况，如果是异步计算可以使用 WebWorker另外开一个进程来解决。\n对于同步计算，WebWorker就力不从心了。\n\n对于大量计算导致设备性能不足，页面卡顿的情况，升级设备才是最好的办法。\n当然，在设备有限的情况下我们只能从我们的代码入手，尽可能的优化代码，减少设备资源的消耗了。\n\n主流浏览器的刷新频率是 60HZ，每16.66毫秒刷新一次，js可以操作DOM，GUI渲染界面\n所以JS线程和 GUI 渲染线程如果同时执行，会导致混乱，因此，浏览器的这两个线程被设计成互斥的。\n因此，如果 js 每次执行时间过长，超过了16.66毫秒则会导致 GUI 渲染不连贯，让用户感知到卡顿。\n\n#### 如何保证 js 的执行不影响 GUI 的渲染呢？\nReact 给出了一个解决方案 ***“时间切片”***。\n在浏览器每一帧中预留出一部分时间给 js 线程，React 在这部分时间来做组件更新。\n当预留时间消耗完毕之后，中断js线程的执行，将剩余时间进行GUI渲染，待下一帧来临的时候继续被中断的js线程工作。\n而如果想做到上面的工作，必须要做到的是：将同步的更新变为可中断的异步更新。\n\n#### React\nReact 官网对它理念介绍是：\n```html\nReact 是用 Javascript 构建能够快速响应的大型 Web 应用程序的首选方式。\n```\n\n#### React16\nReact16 三层架构\n```html\nScheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler (React16 新增)\nReconciler（协调器）—— 负责找出变化的组件\nRenderer（渲染器）—— 负责将变化的组件渲染到页面上，根据不同的平台有不同的Renderer，如 reactDom、ReactNative\n```\n\n##### Scheduler 调度器\nReact16 做到了时间切片，以浏览器是否有剩余时间作为任务中断的标准。\n它实现了一种机制，当浏览器有剩余时间时通知我们。\n```html\n其实部分浏览器已经实现了这个API，这就是requestIdleCallback (opens new window)。但是由于以下因素，React放弃使用\n比如：触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的 requestIdleCallback 触发的频率会变得很低\n```\n基于以上原因，React实现了功能更完备的 requestIdleCallbackpolyfill，这就是Scheduler。\n除了在空闲时触发回调的功能外，Scheduler 还提供了多种调度优先级供任务设置。\n\n调度器会按照任务的优先级来进行任务分配，任务分配分为有六种：\n```html\nsynchronous，与之前的Stack Reconciler操作一样，同步执行\ntask，在next tick之前执行\nanimation，下一帧之前执行\nhigh，在不久的将来立即执行\nlow，稍微延迟执行也没关系\noffscreen，下一次render时或scroll时才执行\n```\n优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。\n\n\n##### Reconciler 协调器\n协调器的作用是调用函数组件、或 class 组件的 render 方法，将返回的 JSX 转化为虚拟 DOM\n首先将虚拟 DOM 和上次更新时的虚拟 DOM 对比，通过对比找出本次更新中变化的虚拟 DOM\n然后通知 Renderer 将变化的虚拟DOM渲染到页面上。\n\nReact 团队给 Reconciler 层起了个新的名字，叫 ***Fiber Reconciler***。\n为了加以区分，React16 以前的原 Reconciler 被命名为 Stack Reconciler。\nStack Reconciler 和 Fiber Reconciler 的区别在于前者的运作的过程是不能被打断的，后者每执行一段时间，都会将控制权交回给浏览器，可以实现分段执行。\n\n##### Renderer 渲染器\n由于React支持跨平台，所以不同平台有不同的Renderer。\n我们前端最熟悉的是负责在浏览器环境渲染的 Renderer —— ReactDOM\n除此之外，还有：\nReactNative 渲染器，渲染App原生组件\nReactTest 渲染器，渲染出纯Js对象用于测试\nReactArt 渲染器，渲染到Canvas, SVG 或 VML (IE8)\n\n在每次更新发生时，Renderer 会接到 Reconciler 通知，然后将变化的组件渲染在当前宿主环境。\n\n#### Fiber\nFiber 并不是计算机术语中的新名词，他的中文翻译叫做纤程\n与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。\n\nFiber 的主要目标是实现虚拟 DOM 的增量渲染，能够将渲染工作拆分成块并将其分散到多个帧的能力。\n在新的更新到来时，能够暂停、中止和复用工作，能为不同类型的更新分配优先级顺序的能力。\n\nReact Fiber 是 React 内部实现的一套状态更新机制，***其实际上就是 React16版本的 的虚拟 DOM***。\n作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。\n作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。\n\nReact Fiber 支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。\n其中每个任务更新单元为 React Element 对应的 Fiber 节点。\n\n在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。\n如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。\nReact16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。\n于是，全新的 Fiber 架构应运而生。\n\n##### Fiber 工作原理\nFiber 保存的就是对应的虚拟DOM，Fiber 构成的 Fiber 树就是对应的 DOM树。\n对于 Fiber DOM树的更新，用到了“双缓存”的技术。\n双缓存是一种在内存中构建并直接替换的技术，类似 Canvas 绘图过程中事先在内存中绘制了完整的新图层，然后用新图层直接替换旧图层的操作。\n在 React 视图更新的时候，最多会存在两颗 Fiber 树， 状态变化的时候产生内存树，绘制完成之后直接替换 UI树。\n\n\n### 附录\n#### requestIdleCallback\nrequestIdleCallback 的作用是是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务，它的 FPS 只有 20\n同步的调用多次 requestIdleCallback，该方法的回调执行可能会分布在不同的帧上，每执行完一次回调，浏览器会检查是否还有剩余的空闲时间\n如果没有，会将执行控制权交还 event loop\n如果有才会继续执行下一个回调\n和 react fiber 的调度很像（事实上，React Fiber就是 ReqeustIdleCallback 的 polyfill）。\n\n其特点是：不占用单独帧，只在帧空闲的时间执行\nwindow.requestIdleCallback()会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务\n而且不会对像动画和用户交互这些延迟触发但关键的事件产生影响\n\n#### requestAnimationFrame\n其作用就是让浏览器流畅的执行动画效果\n告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画\n该方法的回调将会在浏览器的下一次绘制前\nrequestAnimationFrame()已经解决了浏览器不知道 JavaScript 动画何时开始的问题， 以及最佳间隔是多少的问题\nrequestAnimationFrame 方法会告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用回调函数来更新动画。\nrequestAnimationFrame的基本思想是 让页面重绘的频率和刷新频率保持同步\n通过 requestAnimationFrame 调用回调函数引起的页面重绘或回流的时间间隔和显示器的刷新时间间隔相同。\n\n\n#### jsx\nReact DOM 在渲染所有输入内容之前，默认会进行转义，可以有效地防止 xss 攻击\nBabel 会把 JSX 转译成一个名为 React.createElement() 函数调用。\n\n```javascript\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n)\n```\n等效\n```javascript\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n)\n```\nReact.createElement() 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象：\n```javascript\n// 注意：这是简化过的结构\nconst element = {\n  type: 'h1',\n  props: {\n    className: 'greeting',\n    children: 'Hello, world!'\n  }\n}\n```\n\n\n仅使用 React 构建的应用通常只有单一的根 DOM 节点。\n想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()：\n```javascript\nconst element = <h1>Hello, world</h1>\nReactDOM.render(element, document.getElementById('root'))\n```\n\n#### 函数组件\n```javascript\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\n该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。\n这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。\n\n也可以使用 es6 的类定义的方式定义 class 组件\n```javascript\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n```\n\n#### state\nState 与 props 类似，但是 state 是私有的，并且完全受控于当前组件\n\n#### key\nkey 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。\n当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key\n如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。\n如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。\n元素的 key 只有放在就近的数组上下文中才有意义。\n```javascript\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    // 错误！元素的 key 应该在这里指定：\n    <ListItem value={number} />\n  );\n  return (\n    <ul>\n      {listItems}\n    </ul>\n  );\n}\n```\n一个好的经验法则是：在 map() 方法中的元素需要设置 key 属性。\n数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。\n然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值\nPost 组件可以读出 props.xx，但是不能读出 props.key (key的值应该使用其他属性名来传递)\n\n#### 受控组件\n表单元素依赖于状态，表单元素需要默认值实时映射到状态的时候，就是受控组件，这个和双向绑定相似.\n受控组件，表单元素的修改会实时映射到状态值上，此时就可以对输入的内容进行校验.\n受控组件只有继承React.Component才会有状态.\n受控组件必须要在表单上使用onChange事件来绑定对应的事件.\nReact 最棒的部分之一是引导我们思考如何构建一个应用。一个组件原则上只能负责一个功能\n\n#### 状态提升\n通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去\n\n#### state 和 props 之间的区别是什么？\nprops（“properties” 的缩写）和 state 都是普通的 JavaScript 对象。\n它们都是用来保存信息的，这些信息可以控制组件的渲染输出\n而它们的一个重要的不同点就是：props 是传递给组件的（类似于函数的形参）\n而 state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。\n\n#### 给 setState 传递一个对象与传递一个函数的区别是什么\n传递一个函数可以让你在函数内访问到当前的 state 的值\n因为 setState 的调用是分批的，所以你可以链式地进行更新，并确保它们是一个建立在另一个之上的，这样才不会发生冲突\n在事件处理函数内部的 setState 是异步的。\n\n### 传送门\n为什么 React 中 Key 是必须的\nhttps://zh-hans.reactjs.org/docs/reconciliation.html#recursing-on-children\n\n受控组件和非受控组件\nhttps://juejin.cn/post/6858276396968951822\n\nReact 和 vue的区别\nhttps://juejin.cn/post/6844903668446134286\n\nReact Fiber 原理\nhttps://segmentfault.com/a/1190000018250127\n\nFiber 介绍\nhttps://musicfe.dev/react-fiber/","slug":"react16","published":1,"updated":"2021-03-30T01:32:00.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug8001ma0vz6gymgppb","content":"<p>影响 App 应用 <strong><em>快速响应</em></strong>的因素主要有两个<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.网络请求响应慢</span><br><span class=\"line\">2.js中含有大量计算，导致设备性能不足，导致卡顿（CPU瓶颈）</span><br></pre></td></tr></table></figure><br>对于网络请求作为前端开发能做的无非就是做缓存、懒加载等。</p>\n<p>对于 javascript 中含有必要的大量计算的情况，如果是异步计算可以使用 WebWorker另外开一个进程来解决。<br>对于同步计算，WebWorker就力不从心了。</p>\n<p>对于大量计算导致设备性能不足，页面卡顿的情况，升级设备才是最好的办法。<br>当然，在设备有限的情况下我们只能从我们的代码入手，尽可能的优化代码，减少设备资源的消耗了。</p>\n<p>主流浏览器的刷新频率是 60HZ，每16.66毫秒刷新一次，js可以操作DOM，GUI渲染界面<br>所以JS线程和 GUI 渲染线程如果同时执行，会导致混乱，因此，浏览器的这两个线程被设计成互斥的。<br>因此，如果 js 每次执行时间过长，超过了16.66毫秒则会导致 GUI 渲染不连贯，让用户感知到卡顿。</p>\n<h4 id=\"如何保证-js-的执行不影响-GUI-的渲染呢？\"><a href=\"#如何保证-js-的执行不影响-GUI-的渲染呢？\" class=\"headerlink\" title=\"如何保证 js 的执行不影响 GUI 的渲染呢？\"></a>如何保证 js 的执行不影响 GUI 的渲染呢？</h4><p>React 给出了一个解决方案 <strong><em>“时间切片”</em></strong>。<br>在浏览器每一帧中预留出一部分时间给 js 线程，React 在这部分时间来做组件更新。<br>当预留时间消耗完毕之后，中断js线程的执行，将剩余时间进行GUI渲染，待下一帧来临的时候继续被中断的js线程工作。<br>而如果想做到上面的工作，必须要做到的是：将同步的更新变为可中断的异步更新。</p>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><p>React 官网对它理念介绍是：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React 是用 Javascript 构建能够快速响应的大型 Web 应用程序的首选方式。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"React16\"><a href=\"#React16\" class=\"headerlink\" title=\"React16\"></a>React16</h4><p>React16 三层架构<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler (React16 新增)</span><br><span class=\"line\">Reconciler（协调器）—— 负责找出变化的组件</span><br><span class=\"line\">Renderer（渲染器）—— 负责将变化的组件渲染到页面上，根据不同的平台有不同的Renderer，如 reactDom、ReactNative</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Scheduler-调度器\"><a href=\"#Scheduler-调度器\" class=\"headerlink\" title=\"Scheduler 调度器\"></a>Scheduler 调度器</h5><p>React16 做到了时间切片，以浏览器是否有剩余时间作为任务中断的标准。<br>它实现了一种机制，当浏览器有剩余时间时通知我们。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其实部分浏览器已经实现了这个API，这就是requestIdleCallback (opens new window)。但是由于以下因素，React放弃使用</span><br><span class=\"line\">比如：触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的 requestIdleCallback 触发的频率会变得很低</span><br></pre></td></tr></table></figure><br>基于以上原因，React实现了功能更完备的 requestIdleCallbackpolyfill，这就是Scheduler。<br>除了在空闲时触发回调的功能外，Scheduler 还提供了多种调度优先级供任务设置。</p>\n<p>调度器会按照任务的优先级来进行任务分配，任务分配分为有六种：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronous，与之前的Stack Reconciler操作一样，同步执行</span><br><span class=\"line\">task，在next tick之前执行</span><br><span class=\"line\">animation，下一帧之前执行</span><br><span class=\"line\">high，在不久的将来立即执行</span><br><span class=\"line\">low，稍微延迟执行也没关系</span><br><span class=\"line\">offscreen，下一次render时或scroll时才执行</span><br></pre></td></tr></table></figure><br>优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。</p>\n<h5 id=\"Reconciler-协调器\"><a href=\"#Reconciler-协调器\" class=\"headerlink\" title=\"Reconciler 协调器\"></a>Reconciler 协调器</h5><p>协调器的作用是调用函数组件、或 class 组件的 render 方法，将返回的 JSX 转化为虚拟 DOM<br>首先将虚拟 DOM 和上次更新时的虚拟 DOM 对比，通过对比找出本次更新中变化的虚拟 DOM<br>然后通知 Renderer 将变化的虚拟DOM渲染到页面上。</p>\n<p>React 团队给 Reconciler 层起了个新的名字，叫 <strong><em>Fiber Reconciler</em></strong>。<br>为了加以区分，React16 以前的原 Reconciler 被命名为 Stack Reconciler。<br>Stack Reconciler 和 Fiber Reconciler 的区别在于前者的运作的过程是不能被打断的，后者每执行一段时间，都会将控制权交回给浏览器，可以实现分段执行。</p>\n<h5 id=\"Renderer-渲染器\"><a href=\"#Renderer-渲染器\" class=\"headerlink\" title=\"Renderer 渲染器\"></a>Renderer 渲染器</h5><p>由于React支持跨平台，所以不同平台有不同的Renderer。<br>我们前端最熟悉的是负责在浏览器环境渲染的 Renderer —— ReactDOM<br>除此之外，还有：<br>ReactNative 渲染器，渲染App原生组件<br>ReactTest 渲染器，渲染出纯Js对象用于测试<br>ReactArt 渲染器，渲染到Canvas, SVG 或 VML (IE8)</p>\n<p>在每次更新发生时，Renderer 会接到 Reconciler 通知，然后将变化的组件渲染在当前宿主环境。</p>\n<h4 id=\"Fiber\"><a href=\"#Fiber\" class=\"headerlink\" title=\"Fiber\"></a>Fiber</h4><p>Fiber 并不是计算机术语中的新名词，他的中文翻译叫做纤程<br>与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。</p>\n<p>Fiber 的主要目标是实现虚拟 DOM 的增量渲染，能够将渲染工作拆分成块并将其分散到多个帧的能力。<br>在新的更新到来时，能够暂停、中止和复用工作，能为不同类型的更新分配优先级顺序的能力。</p>\n<p>React Fiber 是 React 内部实现的一套状态更新机制，<strong><em>其实际上就是 React16版本的 的虚拟 DOM</em></strong>。<br>作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的DOM节点等信息。<br>作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。</p>\n<p>React Fiber 支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。<br>其中每个任务更新单元为 React Element 对应的 Fiber 节点。</p>\n<p>在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。<br>如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。<br>React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。<br>于是，全新的 Fiber 架构应运而生。</p>\n<h5 id=\"Fiber-工作原理\"><a href=\"#Fiber-工作原理\" class=\"headerlink\" title=\"Fiber 工作原理\"></a>Fiber 工作原理</h5><p>Fiber 保存的就是对应的虚拟DOM，Fiber 构成的 Fiber 树就是对应的 DOM树。<br>对于 Fiber DOM树的更新，用到了“双缓存”的技术。<br>双缓存是一种在内存中构建并直接替换的技术，类似 Canvas 绘图过程中事先在内存中绘制了完整的新图层，然后用新图层直接替换旧图层的操作。<br>在 React 视图更新的时候，最多会存在两颗 Fiber 树， 状态变化的时候产生内存树，绘制完成之后直接替换 UI树。</p>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><h4 id=\"requestIdleCallback\"><a href=\"#requestIdleCallback\" class=\"headerlink\" title=\"requestIdleCallback\"></a>requestIdleCallback</h4><p>requestIdleCallback 的作用是是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务，它的 FPS 只有 20<br>同步的调用多次 requestIdleCallback，该方法的回调执行可能会分布在不同的帧上，每执行完一次回调，浏览器会检查是否还有剩余的空闲时间<br>如果没有，会将执行控制权交还 event loop<br>如果有才会继续执行下一个回调<br>和 react fiber 的调度很像（事实上，React Fiber就是 ReqeustIdleCallback 的 polyfill）。</p>\n<p>其特点是：不占用单独帧，只在帧空闲的时间执行<br>window.requestIdleCallback()会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务<br>而且不会对像动画和用户交互这些延迟触发但关键的事件产生影响</p>\n<h4 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h4><p>其作用就是让浏览器流畅的执行动画效果<br>告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画<br>该方法的回调将会在浏览器的下一次绘制前<br>requestAnimationFrame()已经解决了浏览器不知道 JavaScript 动画何时开始的问题， 以及最佳间隔是多少的问题<br>requestAnimationFrame 方法会告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用回调函数来更新动画。<br>requestAnimationFrame的基本思想是 让页面重绘的频率和刷新频率保持同步<br>通过 requestAnimationFrame 调用回调函数引起的页面重绘或回流的时间间隔和显示器的刷新时间间隔相同。</p>\n<h4 id=\"jsx\"><a href=\"#jsx\" class=\"headerlink\" title=\"jsx\"></a>jsx</h4><p>React DOM 在渲染所有输入内容之前，默认会进行转义，可以有效地防止 xss 攻击<br>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;h1 className=<span class=\"string\">&quot;greeting&quot;</span>&gt;</span><br><span class=\"line\">    Hello, world!</span><br><span class=\"line\">  &lt;/h1&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>等效<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = React.createElement(</span><br><span class=\"line\">  <span class=\"string\">&#x27;h1&#x27;</span>,</span><br><span class=\"line\">  &#123;<span class=\"attr\">className</span>: <span class=\"string\">&#x27;greeting&#x27;</span>&#125;,</span><br><span class=\"line\">  <span class=\"string\">&#x27;Hello, world!&#x27;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure><br>React.createElement() 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意：这是简化过的结构</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;h1&#x27;</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    className: <span class=\"string\">&#x27;greeting&#x27;</span>,</span><br><span class=\"line\">    children: <span class=\"string\">&#x27;Hello, world!&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>仅使用 React 构建的应用通常只有单一的根 DOM 节点。<br>想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">ReactDOM.render(element, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"函数组件\"><a href=\"#函数组件\" class=\"headerlink\" title=\"函数组件\"></a>函数组件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。<br>这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p>\n<p>也可以使用 es6 的类定义的方式定义 class 组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h4><p>State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件</p>\n<h4 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h4><p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。<br>当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key<br>如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。<br>如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。<br>元素的 key 只有放在就近的数组上下文中才有意义。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">NumberList</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numbers = props.numbers;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = numbers.map(<span class=\"function\">(<span class=\"params\">number</span>) =&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">// 错误！元素的 key 应该在这里指定：</span></span><br><span class=\"line\">    &lt;ListItem value=&#123;number&#125; /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &#123;listItems&#125;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>一个好的经验法则是：在 map() 方法中的元素需要设置 key 属性。<br>数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。<br>然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值<br>Post 组件可以读出 props.xx，但是不能读出 props.key (key的值应该使用其他属性名来传递)</p>\n<h4 id=\"受控组件\"><a href=\"#受控组件\" class=\"headerlink\" title=\"受控组件\"></a>受控组件</h4><p>表单元素依赖于状态，表单元素需要默认值实时映射到状态的时候，就是受控组件，这个和双向绑定相似.<br>受控组件，表单元素的修改会实时映射到状态值上，此时就可以对输入的内容进行校验.<br>受控组件只有继承React.Component才会有状态.<br>受控组件必须要在表单上使用onChange事件来绑定对应的事件.<br>React 最棒的部分之一是引导我们思考如何构建一个应用。一个组件原则上只能负责一个功能</p>\n<h4 id=\"状态提升\"><a href=\"#状态提升\" class=\"headerlink\" title=\"状态提升\"></a>状态提升</h4><p>通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去</p>\n<h4 id=\"state-和-props-之间的区别是什么？\"><a href=\"#state-和-props-之间的区别是什么？\" class=\"headerlink\" title=\"state 和 props 之间的区别是什么？\"></a>state 和 props 之间的区别是什么？</h4><p>props（“properties” 的缩写）和 state 都是普通的 JavaScript 对象。<br>它们都是用来保存信息的，这些信息可以控制组件的渲染输出<br>而它们的一个重要的不同点就是：props 是传递给组件的（类似于函数的形参）<br>而 state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</p>\n<h4 id=\"给-setState-传递一个对象与传递一个函数的区别是什么\"><a href=\"#给-setState-传递一个对象与传递一个函数的区别是什么\" class=\"headerlink\" title=\"给 setState 传递一个对象与传递一个函数的区别是什么\"></a>给 setState 传递一个对象与传递一个函数的区别是什么</h4><p>传递一个函数可以让你在函数内访问到当前的 state 的值<br>因为 setState 的调用是分批的，所以你可以链式地进行更新，并确保它们是一个建立在另一个之上的，这样才不会发生冲突<br>在事件处理函数内部的 setState 是异步的。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>为什么 React 中 Key 是必须的<br><a href=\"https://zh-hans.reactjs.org/docs/reconciliation.html#recursing-on-children\">https://zh-hans.reactjs.org/docs/reconciliation.html#recursing-on-children</a></p>\n<p>受控组件和非受控组件<br><a href=\"https://juejin.cn/post/6858276396968951822\">https://juejin.cn/post/6858276396968951822</a></p>\n<p>React 和 vue的区别<br><a href=\"https://juejin.cn/post/6844903668446134286\">https://juejin.cn/post/6844903668446134286</a></p>\n<p>React Fiber 原理<br><a href=\"https://segmentfault.com/a/1190000018250127\">https://segmentfault.com/a/1190000018250127</a></p>\n<p>Fiber 介绍<br><a href=\"https://musicfe.dev/react-fiber/\">https://musicfe.dev/react-fiber/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>影响 App 应用 <strong><em>快速响应</em></strong>的因素主要有两个<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.网络请求响应慢</span><br><span class=\"line\">2.js中含有大量计算，导致设备性能不足，导致卡顿（CPU瓶颈）</span><br></pre></td></tr></table></figure><br>对于网络请求作为前端开发能做的无非就是做缓存、懒加载等。</p>\n<p>对于 javascript 中含有必要的大量计算的情况，如果是异步计算可以使用 WebWorker另外开一个进程来解决。<br>对于同步计算，WebWorker就力不从心了。</p>\n<p>对于大量计算导致设备性能不足，页面卡顿的情况，升级设备才是最好的办法。<br>当然，在设备有限的情况下我们只能从我们的代码入手，尽可能的优化代码，减少设备资源的消耗了。</p>\n<p>主流浏览器的刷新频率是 60HZ，每16.66毫秒刷新一次，js可以操作DOM，GUI渲染界面<br>所以JS线程和 GUI 渲染线程如果同时执行，会导致混乱，因此，浏览器的这两个线程被设计成互斥的。<br>因此，如果 js 每次执行时间过长，超过了16.66毫秒则会导致 GUI 渲染不连贯，让用户感知到卡顿。</p>\n<h4 id=\"如何保证-js-的执行不影响-GUI-的渲染呢？\"><a href=\"#如何保证-js-的执行不影响-GUI-的渲染呢？\" class=\"headerlink\" title=\"如何保证 js 的执行不影响 GUI 的渲染呢？\"></a>如何保证 js 的执行不影响 GUI 的渲染呢？</h4><p>React 给出了一个解决方案 <strong><em>“时间切片”</em></strong>。<br>在浏览器每一帧中预留出一部分时间给 js 线程，React 在这部分时间来做组件更新。<br>当预留时间消耗完毕之后，中断js线程的执行，将剩余时间进行GUI渲染，待下一帧来临的时候继续被中断的js线程工作。<br>而如果想做到上面的工作，必须要做到的是：将同步的更新变为可中断的异步更新。</p>\n<h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><p>React 官网对它理念介绍是：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React 是用 Javascript 构建能够快速响应的大型 Web 应用程序的首选方式。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"React16\"><a href=\"#React16\" class=\"headerlink\" title=\"React16\"></a>React16</h4><p>React16 三层架构<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler (React16 新增)</span><br><span class=\"line\">Reconciler（协调器）—— 负责找出变化的组件</span><br><span class=\"line\">Renderer（渲染器）—— 负责将变化的组件渲染到页面上，根据不同的平台有不同的Renderer，如 reactDom、ReactNative</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"Scheduler-调度器\"><a href=\"#Scheduler-调度器\" class=\"headerlink\" title=\"Scheduler 调度器\"></a>Scheduler 调度器</h5><p>React16 做到了时间切片，以浏览器是否有剩余时间作为任务中断的标准。<br>它实现了一种机制，当浏览器有剩余时间时通知我们。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其实部分浏览器已经实现了这个API，这就是requestIdleCallback (opens new window)。但是由于以下因素，React放弃使用</span><br><span class=\"line\">比如：触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的 requestIdleCallback 触发的频率会变得很低</span><br></pre></td></tr></table></figure><br>基于以上原因，React实现了功能更完备的 requestIdleCallbackpolyfill，这就是Scheduler。<br>除了在空闲时触发回调的功能外，Scheduler 还提供了多种调度优先级供任务设置。</p>\n<p>调度器会按照任务的优先级来进行任务分配，任务分配分为有六种：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronous，与之前的Stack Reconciler操作一样，同步执行</span><br><span class=\"line\">task，在next tick之前执行</span><br><span class=\"line\">animation，下一帧之前执行</span><br><span class=\"line\">high，在不久的将来立即执行</span><br><span class=\"line\">low，稍微延迟执行也没关系</span><br><span class=\"line\">offscreen，下一次render时或scroll时才执行</span><br></pre></td></tr></table></figure><br>优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。</p>\n<h5 id=\"Reconciler-协调器\"><a href=\"#Reconciler-协调器\" class=\"headerlink\" title=\"Reconciler 协调器\"></a>Reconciler 协调器</h5><p>协调器的作用是调用函数组件、或 class 组件的 render 方法，将返回的 JSX 转化为虚拟 DOM<br>首先将虚拟 DOM 和上次更新时的虚拟 DOM 对比，通过对比找出本次更新中变化的虚拟 DOM<br>然后通知 Renderer 将变化的虚拟DOM渲染到页面上。</p>\n<p>React 团队给 Reconciler 层起了个新的名字，叫 <strong><em>Fiber Reconciler</em></strong>。<br>为了加以区分，React16 以前的原 Reconciler 被命名为 Stack Reconciler。<br>Stack Reconciler 和 Fiber Reconciler 的区别在于前者的运作的过程是不能被打断的，后者每执行一段时间，都会将控制权交回给浏览器，可以实现分段执行。</p>\n<h5 id=\"Renderer-渲染器\"><a href=\"#Renderer-渲染器\" class=\"headerlink\" title=\"Renderer 渲染器\"></a>Renderer 渲染器</h5><p>由于React支持跨平台，所以不同平台有不同的Renderer。<br>我们前端最熟悉的是负责在浏览器环境渲染的 Renderer —— ReactDOM<br>除此之外，还有：<br>ReactNative 渲染器，渲染App原生组件<br>ReactTest 渲染器，渲染出纯Js对象用于测试<br>ReactArt 渲染器，渲染到Canvas, SVG 或 VML (IE8)</p>\n<p>在每次更新发生时，Renderer 会接到 Reconciler 通知，然后将变化的组件渲染在当前宿主环境。</p>\n<h4 id=\"Fiber\"><a href=\"#Fiber\" class=\"headerlink\" title=\"Fiber\"></a>Fiber</h4><p>Fiber 并不是计算机术语中的新名词，他的中文翻译叫做纤程<br>与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。</p>\n<p>Fiber 的主要目标是实现虚拟 DOM 的增量渲染，能够将渲染工作拆分成块并将其分散到多个帧的能力。<br>在新的更新到来时，能够暂停、中止和复用工作，能为不同类型的更新分配优先级顺序的能力。</p>\n<p>React Fiber 是 React 内部实现的一套状态更新机制，<strong><em>其实际上就是 React16版本的 的虚拟 DOM</em></strong>。<br>作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的DOM节点等信息。<br>作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。</p>\n<p>React Fiber 支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。<br>其中每个任务更新单元为 React Element 对应的 Fiber 节点。</p>\n<p>在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。<br>如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。<br>React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。<br>于是，全新的 Fiber 架构应运而生。</p>\n<h5 id=\"Fiber-工作原理\"><a href=\"#Fiber-工作原理\" class=\"headerlink\" title=\"Fiber 工作原理\"></a>Fiber 工作原理</h5><p>Fiber 保存的就是对应的虚拟DOM，Fiber 构成的 Fiber 树就是对应的 DOM树。<br>对于 Fiber DOM树的更新，用到了“双缓存”的技术。<br>双缓存是一种在内存中构建并直接替换的技术，类似 Canvas 绘图过程中事先在内存中绘制了完整的新图层，然后用新图层直接替换旧图层的操作。<br>在 React 视图更新的时候，最多会存在两颗 Fiber 树， 状态变化的时候产生内存树，绘制完成之后直接替换 UI树。</p>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><h4 id=\"requestIdleCallback\"><a href=\"#requestIdleCallback\" class=\"headerlink\" title=\"requestIdleCallback\"></a>requestIdleCallback</h4><p>requestIdleCallback 的作用是是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务，它的 FPS 只有 20<br>同步的调用多次 requestIdleCallback，该方法的回调执行可能会分布在不同的帧上，每执行完一次回调，浏览器会检查是否还有剩余的空闲时间<br>如果没有，会将执行控制权交还 event loop<br>如果有才会继续执行下一个回调<br>和 react fiber 的调度很像（事实上，React Fiber就是 ReqeustIdleCallback 的 polyfill）。</p>\n<p>其特点是：不占用单独帧，只在帧空闲的时间执行<br>window.requestIdleCallback()会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务<br>而且不会对像动画和用户交互这些延迟触发但关键的事件产生影响</p>\n<h4 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h4><p>其作用就是让浏览器流畅的执行动画效果<br>告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画<br>该方法的回调将会在浏览器的下一次绘制前<br>requestAnimationFrame()已经解决了浏览器不知道 JavaScript 动画何时开始的问题， 以及最佳间隔是多少的问题<br>requestAnimationFrame 方法会告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用回调函数来更新动画。<br>requestAnimationFrame的基本思想是 让页面重绘的频率和刷新频率保持同步<br>通过 requestAnimationFrame 调用回调函数引起的页面重绘或回流的时间间隔和显示器的刷新时间间隔相同。</p>\n<h4 id=\"jsx\"><a href=\"#jsx\" class=\"headerlink\" title=\"jsx\"></a>jsx</h4><p>React DOM 在渲染所有输入内容之前，默认会进行转义，可以有效地防止 xss 攻击<br>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;h1 className=<span class=\"string\">&quot;greeting&quot;</span>&gt;</span><br><span class=\"line\">    Hello, world!</span><br><span class=\"line\">  &lt;/h1&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>等效<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = React.createElement(</span><br><span class=\"line\">  <span class=\"string\">&#x27;h1&#x27;</span>,</span><br><span class=\"line\">  &#123;<span class=\"attr\">className</span>: <span class=\"string\">&#x27;greeting&#x27;</span>&#125;,</span><br><span class=\"line\">  <span class=\"string\">&#x27;Hello, world!&#x27;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure><br>React.createElement() 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意：这是简化过的结构</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;h1&#x27;</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    className: <span class=\"string\">&#x27;greeting&#x27;</span>,</span><br><span class=\"line\">    children: <span class=\"string\">&#x27;Hello, world!&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>仅使用 React 构建的应用通常只有单一的根 DOM 节点。<br>想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, world<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">ReactDOM.render(element, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"函数组件\"><a href=\"#函数组件\" class=\"headerlink\" title=\"函数组件\"></a>函数组件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。<br>这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p>\n<p>也可以使用 es6 的类定义的方式定义 class 组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Welcome</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h4><p>State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件</p>\n<h4 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h4><p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。<br>当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key<br>如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。<br>如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。<br>元素的 key 只有放在就近的数组上下文中才有意义。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">NumberList</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numbers = props.numbers;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = numbers.map(<span class=\"function\">(<span class=\"params\">number</span>) =&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">// 错误！元素的 key 应该在这里指定：</span></span><br><span class=\"line\">    &lt;ListItem value=&#123;number&#125; /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &#123;listItems&#125;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>一个好的经验法则是：在 map() 方法中的元素需要设置 key 属性。<br>数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。<br>然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值<br>Post 组件可以读出 props.xx，但是不能读出 props.key (key的值应该使用其他属性名来传递)</p>\n<h4 id=\"受控组件\"><a href=\"#受控组件\" class=\"headerlink\" title=\"受控组件\"></a>受控组件</h4><p>表单元素依赖于状态，表单元素需要默认值实时映射到状态的时候，就是受控组件，这个和双向绑定相似.<br>受控组件，表单元素的修改会实时映射到状态值上，此时就可以对输入的内容进行校验.<br>受控组件只有继承React.Component才会有状态.<br>受控组件必须要在表单上使用onChange事件来绑定对应的事件.<br>React 最棒的部分之一是引导我们思考如何构建一个应用。一个组件原则上只能负责一个功能</p>\n<h4 id=\"状态提升\"><a href=\"#状态提升\" class=\"headerlink\" title=\"状态提升\"></a>状态提升</h4><p>通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去</p>\n<h4 id=\"state-和-props-之间的区别是什么？\"><a href=\"#state-和-props-之间的区别是什么？\" class=\"headerlink\" title=\"state 和 props 之间的区别是什么？\"></a>state 和 props 之间的区别是什么？</h4><p>props（“properties” 的缩写）和 state 都是普通的 JavaScript 对象。<br>它们都是用来保存信息的，这些信息可以控制组件的渲染输出<br>而它们的一个重要的不同点就是：props 是传递给组件的（类似于函数的形参）<br>而 state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</p>\n<h4 id=\"给-setState-传递一个对象与传递一个函数的区别是什么\"><a href=\"#给-setState-传递一个对象与传递一个函数的区别是什么\" class=\"headerlink\" title=\"给 setState 传递一个对象与传递一个函数的区别是什么\"></a>给 setState 传递一个对象与传递一个函数的区别是什么</h4><p>传递一个函数可以让你在函数内访问到当前的 state 的值<br>因为 setState 的调用是分批的，所以你可以链式地进行更新，并确保它们是一个建立在另一个之上的，这样才不会发生冲突<br>在事件处理函数内部的 setState 是异步的。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>为什么 React 中 Key 是必须的<br><a href=\"https://zh-hans.reactjs.org/docs/reconciliation.html#recursing-on-children\">https://zh-hans.reactjs.org/docs/reconciliation.html#recursing-on-children</a></p>\n<p>受控组件和非受控组件<br><a href=\"https://juejin.cn/post/6858276396968951822\">https://juejin.cn/post/6858276396968951822</a></p>\n<p>React 和 vue的区别<br><a href=\"https://juejin.cn/post/6844903668446134286\">https://juejin.cn/post/6844903668446134286</a></p>\n<p>React Fiber 原理<br><a href=\"https://segmentfault.com/a/1190000018250127\">https://segmentfault.com/a/1190000018250127</a></p>\n<p>Fiber 介绍<br><a href=\"https://musicfe.dev/react-fiber/\">https://musicfe.dev/react-fiber/</a></p>\n"},{"title":"redis入门","date":"2018-10-31T16:00:00.000Z","_content":"\nRedis是一个内存高速缓存数据库，redis全称 Remote Dictionary Server（远程数据服务）\nRedis是一个key-value存储系统，它支持很多数据类型：string、list、set、zset、hash\nRedis以内存作为存储介质，读写数据效率高，远超过数据库。\nRedis也支持持久化存储，即将数据定时存储备份到硬盘，当遭遇停电或者宕机的情况下数据不至于丢失。\n\n### ubuntu安装redis\n```shell\nsudo apt-get install redis-server\n```\n\n### 关闭、启动、重启 redis-server\n```shell\n# ubuntu 这里有点问题，通过杀进程的方式关闭不了redis，得用下面的这种方式\n/etc/init.d/redis-server stop\n/etc/init.d/redis-server start\n/etc/init.d/redis-server restart\n```\n\n### 查看redis进程\n```shell\nps -ef|grep redis\n```\n\n### 进入redis-cli\n```shell\nredis-cli # 本地连接\nredis-cli -h REDIS_HOST_IP_ADDR -p 6379 -a 123456 # 通过IP地址 \n```\n\n\n### redis常用命令\n\n```shell\nset age 25 # 设置一个 redis 数据 age\nkeys * # 查看 redis 数据\nget age # 查看 redis 数据 age\n```\n\n### 如果设置了密码\n如果设置了密码可能回报错\n```shell\n(error) NOAUTH Authentication required.\n```\n解决办法：\n```shell\nredis-cli\nauth 'yourpassword'\nkeys *\n# is ok, will show all keys!\n```\n\n\n### redis-cluster\nRedis支持集群模式，能够更稳定的存储数据\n\n\n### redis-sentinel\nRedis 的 Sentinel 系统用于管理多个 Redis 服务器\nsentinel配置实践如下，包括两个配置文件，一个是redis服务配置，另一个是sentinel配置\n\n#### redis配置文件\n```shell\nport 6379\ndaemonize yes\n#logfile \"log/6379.log\"\nslave-read-only no\nrequirepass \"123456\"\ndbfilename \"dump-6379.rdb\"\n# dir \"/Users/zsr/learn/redis/data/\"\n```\n\n#### sentinel配置文件\n```shell\nport 26379\n# dir \"/Users/zsr/learn/redis/data\"\n# logfile \"26379.log\"\nsentinel myid c83c4d372c28916980ac2eca754b13cc794359fd\nsentinel monitor mymaster 10.242.22.138 6379 2\n#sentinel auth-pass mymaster 123456a\nsentinel config-epoch mymaster 0\nsentinel leader-epoch mymaster 0\n# Generated by CONFIG REWRITE\nsentinel known-slave mymaster 10.242.22.138 6380\nsentinel known-slave mymaster 10.242.22.138 6381\nsentinel current-epoch 0\nprotected-mode no\n```\n\n配置完毕之后，直接运用redis-server启动sentinel服务：\n```shell\nredis-server sentinel-26379.conf --sentinel &;\n```\n\n配置完毕之后，直接运用redis-server启动redis服务：\n```shell\nredis-server redis-6379.conf\n```\n\n### 利用ioredis nodejs连接sentinel方式\n\n```javascript\nconst Redis = require('ioredis')\nlet redisConfig = {\n  sentinels: [{\n    host: '10.242.22.138',\n    port: 26379\n  }],\n  password: '123456',\n  name: 'mymaster'\n}\nconst client = new Redis(redisConfig)\nlet redisIsOk = false\nclient.on('ready', () => {\n  redisIsOk = true\n  global.logger.server('redis is ready!')\n})\nclient.on('error', (err) => {\n  redisIsOk = false\n  global.logger.server('redis is on error! errmsg:' + err.toString(), 'ERROR')\n})\n\nmodule.exports = {\n  /**\n   * 存入redis\n   * expire (单位：s)\n   */\n  set: (key, value, expire) => {\n    return new Promise((resolve, reject) => {\n      if (!redisIsOk) {\n        reject(false)\n      }\n      client.set(key, value).then((res) => {\n        resolve(true)\n      })\n      expire = expire || 24*3600\n      // 过期时间默认1天\n      client.expire(key, expire)\n    })\n  },\n  /**\n   * return false || value\n   */\n  get: (key) => {\n    return new Promise((resolve, reject) => {\n      if (!redisIsOk) {\n        reject(false)\n      }\n      client.get(key).then((value) => {\n        resolve(value)\n      })\n    })\n  },\n  del: (key) => {\n    if (!redisIsOk) {\n      reject(false)\n    }\n    return new Promise((resolve, reject) => {\n      client.del(key).then((value) => {\n        resolve(value)\n      })\n    })\n  }\n}\n```\n\n\n### 传送门\n\nnodejs 连接sentinel开源库\nhttps://github.com/luin/ioredis\n\nredis持久化存储\nhttps://segmentfault.com/a/1190000002906345\n\nredis看云文档\nhttps://www.kancloud.cn/digest/redis330/162452\n","source":"_posts/redis.md","raw":"---\ntitle: redis入门\ndate: 2018/11/01\ntag: [redis, sentinel]\n---\n\nRedis是一个内存高速缓存数据库，redis全称 Remote Dictionary Server（远程数据服务）\nRedis是一个key-value存储系统，它支持很多数据类型：string、list、set、zset、hash\nRedis以内存作为存储介质，读写数据效率高，远超过数据库。\nRedis也支持持久化存储，即将数据定时存储备份到硬盘，当遭遇停电或者宕机的情况下数据不至于丢失。\n\n### ubuntu安装redis\n```shell\nsudo apt-get install redis-server\n```\n\n### 关闭、启动、重启 redis-server\n```shell\n# ubuntu 这里有点问题，通过杀进程的方式关闭不了redis，得用下面的这种方式\n/etc/init.d/redis-server stop\n/etc/init.d/redis-server start\n/etc/init.d/redis-server restart\n```\n\n### 查看redis进程\n```shell\nps -ef|grep redis\n```\n\n### 进入redis-cli\n```shell\nredis-cli # 本地连接\nredis-cli -h REDIS_HOST_IP_ADDR -p 6379 -a 123456 # 通过IP地址 \n```\n\n\n### redis常用命令\n\n```shell\nset age 25 # 设置一个 redis 数据 age\nkeys * # 查看 redis 数据\nget age # 查看 redis 数据 age\n```\n\n### 如果设置了密码\n如果设置了密码可能回报错\n```shell\n(error) NOAUTH Authentication required.\n```\n解决办法：\n```shell\nredis-cli\nauth 'yourpassword'\nkeys *\n# is ok, will show all keys!\n```\n\n\n### redis-cluster\nRedis支持集群模式，能够更稳定的存储数据\n\n\n### redis-sentinel\nRedis 的 Sentinel 系统用于管理多个 Redis 服务器\nsentinel配置实践如下，包括两个配置文件，一个是redis服务配置，另一个是sentinel配置\n\n#### redis配置文件\n```shell\nport 6379\ndaemonize yes\n#logfile \"log/6379.log\"\nslave-read-only no\nrequirepass \"123456\"\ndbfilename \"dump-6379.rdb\"\n# dir \"/Users/zsr/learn/redis/data/\"\n```\n\n#### sentinel配置文件\n```shell\nport 26379\n# dir \"/Users/zsr/learn/redis/data\"\n# logfile \"26379.log\"\nsentinel myid c83c4d372c28916980ac2eca754b13cc794359fd\nsentinel monitor mymaster 10.242.22.138 6379 2\n#sentinel auth-pass mymaster 123456a\nsentinel config-epoch mymaster 0\nsentinel leader-epoch mymaster 0\n# Generated by CONFIG REWRITE\nsentinel known-slave mymaster 10.242.22.138 6380\nsentinel known-slave mymaster 10.242.22.138 6381\nsentinel current-epoch 0\nprotected-mode no\n```\n\n配置完毕之后，直接运用redis-server启动sentinel服务：\n```shell\nredis-server sentinel-26379.conf --sentinel &;\n```\n\n配置完毕之后，直接运用redis-server启动redis服务：\n```shell\nredis-server redis-6379.conf\n```\n\n### 利用ioredis nodejs连接sentinel方式\n\n```javascript\nconst Redis = require('ioredis')\nlet redisConfig = {\n  sentinels: [{\n    host: '10.242.22.138',\n    port: 26379\n  }],\n  password: '123456',\n  name: 'mymaster'\n}\nconst client = new Redis(redisConfig)\nlet redisIsOk = false\nclient.on('ready', () => {\n  redisIsOk = true\n  global.logger.server('redis is ready!')\n})\nclient.on('error', (err) => {\n  redisIsOk = false\n  global.logger.server('redis is on error! errmsg:' + err.toString(), 'ERROR')\n})\n\nmodule.exports = {\n  /**\n   * 存入redis\n   * expire (单位：s)\n   */\n  set: (key, value, expire) => {\n    return new Promise((resolve, reject) => {\n      if (!redisIsOk) {\n        reject(false)\n      }\n      client.set(key, value).then((res) => {\n        resolve(true)\n      })\n      expire = expire || 24*3600\n      // 过期时间默认1天\n      client.expire(key, expire)\n    })\n  },\n  /**\n   * return false || value\n   */\n  get: (key) => {\n    return new Promise((resolve, reject) => {\n      if (!redisIsOk) {\n        reject(false)\n      }\n      client.get(key).then((value) => {\n        resolve(value)\n      })\n    })\n  },\n  del: (key) => {\n    if (!redisIsOk) {\n      reject(false)\n    }\n    return new Promise((resolve, reject) => {\n      client.del(key).then((value) => {\n        resolve(value)\n      })\n    })\n  }\n}\n```\n\n\n### 传送门\n\nnodejs 连接sentinel开源库\nhttps://github.com/luin/ioredis\n\nredis持久化存储\nhttps://segmentfault.com/a/1190000002906345\n\nredis看云文档\nhttps://www.kancloud.cn/digest/redis330/162452\n","slug":"redis","published":1,"updated":"2021-03-30T01:32:00.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug9001na0vz2uspgfp3","content":"<p>Redis是一个内存高速缓存数据库，redis全称 Remote Dictionary Server（远程数据服务）<br>Redis是一个key-value存储系统，它支持很多数据类型：string、list、set、zset、hash<br>Redis以内存作为存储介质，读写数据效率高，远超过数据库。<br>Redis也支持持久化存储，即将数据定时存储备份到硬盘，当遭遇停电或者宕机的情况下数据不至于丢失。</p>\n<h3 id=\"ubuntu安装redis\"><a href=\"#ubuntu安装redis\" class=\"headerlink\" title=\"ubuntu安装redis\"></a>ubuntu安装redis</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install redis-server</span><br></pre></td></tr></table></figure>\n<h3 id=\"关闭、启动、重启-redis-server\"><a href=\"#关闭、启动、重启-redis-server\" class=\"headerlink\" title=\"关闭、启动、重启 redis-server\"></a>关闭、启动、重启 redis-server</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ubuntu 这里有点问题，通过杀进程的方式关闭不了redis，得用下面的这种方式</span></span><br><span class=\"line\">/etc/init.d/redis-server stop</span><br><span class=\"line\">/etc/init.d/redis-server start</span><br><span class=\"line\">/etc/init.d/redis-server restart</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看redis进程\"><a href=\"#查看redis进程\" class=\"headerlink\" title=\"查看redis进程\"></a>查看redis进程</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef|grep redis</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入redis-cli\"><a href=\"#进入redis-cli\" class=\"headerlink\" title=\"进入redis-cli\"></a>进入redis-cli</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli # 本地连接</span><br><span class=\"line\">redis-cli -h REDIS_HOST_IP_ADDR -p 6379 -a 123456 # 通过IP地址 </span><br></pre></td></tr></table></figure>\n<h3 id=\"redis常用命令\"><a href=\"#redis常用命令\" class=\"headerlink\" title=\"redis常用命令\"></a>redis常用命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set age 25 # 设置一个 redis 数据 age</span><br><span class=\"line\">keys * # 查看 redis 数据</span><br><span class=\"line\">get age # 查看 redis 数据 age</span><br></pre></td></tr></table></figure>\n<h3 id=\"如果设置了密码\"><a href=\"#如果设置了密码\" class=\"headerlink\" title=\"如果设置了密码\"></a>如果设置了密码</h3><p>如果设置了密码可能回报错<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(error) NOAUTH Authentication required.</span><br></pre></td></tr></table></figure><br>解决办法：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli</span><br><span class=\"line\">auth &#x27;yourpassword&#x27;</span><br><span class=\"line\">keys *</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> is ok, will show all keys!</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"redis-cluster\"><a href=\"#redis-cluster\" class=\"headerlink\" title=\"redis-cluster\"></a>redis-cluster</h3><p>Redis支持集群模式，能够更稳定的存储数据</p>\n<h3 id=\"redis-sentinel\"><a href=\"#redis-sentinel\" class=\"headerlink\" title=\"redis-sentinel\"></a>redis-sentinel</h3><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器<br>sentinel配置实践如下，包括两个配置文件，一个是redis服务配置，另一个是sentinel配置</p>\n<h4 id=\"redis配置文件\"><a href=\"#redis配置文件\" class=\"headerlink\" title=\"redis配置文件\"></a>redis配置文件</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port 6379</span><br><span class=\"line\">daemonize yes</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">logfile <span class=\"string\">&quot;log/6379.log&quot;</span></span></span><br><span class=\"line\">slave-read-only no</span><br><span class=\"line\">requirepass &quot;123456&quot;</span><br><span class=\"line\">dbfilename &quot;dump-6379.rdb&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> dir <span class=\"string\">&quot;/Users/zsr/learn/redis/data/&quot;</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"sentinel配置文件\"><a href=\"#sentinel配置文件\" class=\"headerlink\" title=\"sentinel配置文件\"></a>sentinel配置文件</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port 26379</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> dir <span class=\"string\">&quot;/Users/zsr/learn/redis/data&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> logfile <span class=\"string\">&quot;26379.log&quot;</span></span></span><br><span class=\"line\">sentinel myid c83c4d372c28916980ac2eca754b13cc794359fd</span><br><span class=\"line\">sentinel monitor mymaster 10.242.22.138 6379 2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">sentinel auth-pass mymaster 123456a</span></span><br><span class=\"line\">sentinel config-epoch mymaster 0</span><br><span class=\"line\">sentinel leader-epoch mymaster 0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Generated by CONFIG REWRITE</span></span><br><span class=\"line\">sentinel known-slave mymaster 10.242.22.138 6380</span><br><span class=\"line\">sentinel known-slave mymaster 10.242.22.138 6381</span><br><span class=\"line\">sentinel current-epoch 0</span><br><span class=\"line\">protected-mode no</span><br></pre></td></tr></table></figure>\n<p>配置完毕之后，直接运用redis-server启动sentinel服务：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-server sentinel-26379.conf --sentinel &amp;;</span><br></pre></td></tr></table></figure></p>\n<p>配置完毕之后，直接运用redis-server启动redis服务：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-server redis-6379.conf</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"利用ioredis-nodejs连接sentinel方式\"><a href=\"#利用ioredis-nodejs连接sentinel方式\" class=\"headerlink\" title=\"利用ioredis nodejs连接sentinel方式\"></a>利用ioredis nodejs连接sentinel方式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Redis = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;ioredis&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> redisConfig = &#123;</span><br><span class=\"line\">  sentinels: [&#123;</span><br><span class=\"line\">    host: <span class=\"string\">&#x27;10.242.22.138&#x27;</span>,</span><br><span class=\"line\">    port: <span class=\"number\">26379</span></span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">  password: <span class=\"string\">&#x27;123456&#x27;</span>,</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;mymaster&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> client = <span class=\"keyword\">new</span> Redis(redisConfig)</span><br><span class=\"line\"><span class=\"keyword\">let</span> redisIsOk = <span class=\"literal\">false</span></span><br><span class=\"line\">client.on(<span class=\"string\">&#x27;ready&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  redisIsOk = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"built_in\">global</span>.logger.server(<span class=\"string\">&#x27;redis is ready!&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">client.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  redisIsOk = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"built_in\">global</span>.logger.server(<span class=\"string\">&#x27;redis is on error! errmsg:&#x27;</span> + err.toString(), <span class=\"string\">&#x27;ERROR&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 存入redis</span></span><br><span class=\"line\"><span class=\"comment\">   * expire (单位：s)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  set: <span class=\"function\">(<span class=\"params\">key, value, expire</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!redisIsOk) &#123;</span><br><span class=\"line\">        reject(<span class=\"literal\">false</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      client.set(key, value).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(<span class=\"literal\">true</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      expire = expire || <span class=\"number\">24</span>*<span class=\"number\">3600</span></span><br><span class=\"line\">      <span class=\"comment\">// 过期时间默认1天</span></span><br><span class=\"line\">      client.expire(key, expire)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * return false || value</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  get: <span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!redisIsOk) &#123;</span><br><span class=\"line\">        reject(<span class=\"literal\">false</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      client.get(key).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  del: <span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!redisIsOk) &#123;</span><br><span class=\"line\">      reject(<span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      client.del(key).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>nodejs 连接sentinel开源库<br><a href=\"https://github.com/luin/ioredis\">https://github.com/luin/ioredis</a></p>\n<p>redis持久化存储<br><a href=\"https://segmentfault.com/a/1190000002906345\">https://segmentfault.com/a/1190000002906345</a></p>\n<p>redis看云文档<br><a href=\"https://www.kancloud.cn/digest/redis330/162452\">https://www.kancloud.cn/digest/redis330/162452</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Redis是一个内存高速缓存数据库，redis全称 Remote Dictionary Server（远程数据服务）<br>Redis是一个key-value存储系统，它支持很多数据类型：string、list、set、zset、hash<br>Redis以内存作为存储介质，读写数据效率高，远超过数据库。<br>Redis也支持持久化存储，即将数据定时存储备份到硬盘，当遭遇停电或者宕机的情况下数据不至于丢失。</p>\n<h3 id=\"ubuntu安装redis\"><a href=\"#ubuntu安装redis\" class=\"headerlink\" title=\"ubuntu安装redis\"></a>ubuntu安装redis</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install redis-server</span><br></pre></td></tr></table></figure>\n<h3 id=\"关闭、启动、重启-redis-server\"><a href=\"#关闭、启动、重启-redis-server\" class=\"headerlink\" title=\"关闭、启动、重启 redis-server\"></a>关闭、启动、重启 redis-server</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ubuntu 这里有点问题，通过杀进程的方式关闭不了redis，得用下面的这种方式</span></span><br><span class=\"line\">/etc/init.d/redis-server stop</span><br><span class=\"line\">/etc/init.d/redis-server start</span><br><span class=\"line\">/etc/init.d/redis-server restart</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看redis进程\"><a href=\"#查看redis进程\" class=\"headerlink\" title=\"查看redis进程\"></a>查看redis进程</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef|grep redis</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入redis-cli\"><a href=\"#进入redis-cli\" class=\"headerlink\" title=\"进入redis-cli\"></a>进入redis-cli</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli # 本地连接</span><br><span class=\"line\">redis-cli -h REDIS_HOST_IP_ADDR -p 6379 -a 123456 # 通过IP地址 </span><br></pre></td></tr></table></figure>\n<h3 id=\"redis常用命令\"><a href=\"#redis常用命令\" class=\"headerlink\" title=\"redis常用命令\"></a>redis常用命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set age 25 # 设置一个 redis 数据 age</span><br><span class=\"line\">keys * # 查看 redis 数据</span><br><span class=\"line\">get age # 查看 redis 数据 age</span><br></pre></td></tr></table></figure>\n<h3 id=\"如果设置了密码\"><a href=\"#如果设置了密码\" class=\"headerlink\" title=\"如果设置了密码\"></a>如果设置了密码</h3><p>如果设置了密码可能回报错<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(error) NOAUTH Authentication required.</span><br></pre></td></tr></table></figure><br>解决办法：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli</span><br><span class=\"line\">auth &#x27;yourpassword&#x27;</span><br><span class=\"line\">keys *</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> is ok, will show all keys!</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"redis-cluster\"><a href=\"#redis-cluster\" class=\"headerlink\" title=\"redis-cluster\"></a>redis-cluster</h3><p>Redis支持集群模式，能够更稳定的存储数据</p>\n<h3 id=\"redis-sentinel\"><a href=\"#redis-sentinel\" class=\"headerlink\" title=\"redis-sentinel\"></a>redis-sentinel</h3><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器<br>sentinel配置实践如下，包括两个配置文件，一个是redis服务配置，另一个是sentinel配置</p>\n<h4 id=\"redis配置文件\"><a href=\"#redis配置文件\" class=\"headerlink\" title=\"redis配置文件\"></a>redis配置文件</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port 6379</span><br><span class=\"line\">daemonize yes</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">logfile <span class=\"string\">&quot;log/6379.log&quot;</span></span></span><br><span class=\"line\">slave-read-only no</span><br><span class=\"line\">requirepass &quot;123456&quot;</span><br><span class=\"line\">dbfilename &quot;dump-6379.rdb&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> dir <span class=\"string\">&quot;/Users/zsr/learn/redis/data/&quot;</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"sentinel配置文件\"><a href=\"#sentinel配置文件\" class=\"headerlink\" title=\"sentinel配置文件\"></a>sentinel配置文件</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port 26379</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> dir <span class=\"string\">&quot;/Users/zsr/learn/redis/data&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> logfile <span class=\"string\">&quot;26379.log&quot;</span></span></span><br><span class=\"line\">sentinel myid c83c4d372c28916980ac2eca754b13cc794359fd</span><br><span class=\"line\">sentinel monitor mymaster 10.242.22.138 6379 2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">sentinel auth-pass mymaster 123456a</span></span><br><span class=\"line\">sentinel config-epoch mymaster 0</span><br><span class=\"line\">sentinel leader-epoch mymaster 0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Generated by CONFIG REWRITE</span></span><br><span class=\"line\">sentinel known-slave mymaster 10.242.22.138 6380</span><br><span class=\"line\">sentinel known-slave mymaster 10.242.22.138 6381</span><br><span class=\"line\">sentinel current-epoch 0</span><br><span class=\"line\">protected-mode no</span><br></pre></td></tr></table></figure>\n<p>配置完毕之后，直接运用redis-server启动sentinel服务：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-server sentinel-26379.conf --sentinel &amp;;</span><br></pre></td></tr></table></figure></p>\n<p>配置完毕之后，直接运用redis-server启动redis服务：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-server redis-6379.conf</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"利用ioredis-nodejs连接sentinel方式\"><a href=\"#利用ioredis-nodejs连接sentinel方式\" class=\"headerlink\" title=\"利用ioredis nodejs连接sentinel方式\"></a>利用ioredis nodejs连接sentinel方式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Redis = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;ioredis&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> redisConfig = &#123;</span><br><span class=\"line\">  sentinels: [&#123;</span><br><span class=\"line\">    host: <span class=\"string\">&#x27;10.242.22.138&#x27;</span>,</span><br><span class=\"line\">    port: <span class=\"number\">26379</span></span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">  password: <span class=\"string\">&#x27;123456&#x27;</span>,</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;mymaster&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> client = <span class=\"keyword\">new</span> Redis(redisConfig)</span><br><span class=\"line\"><span class=\"keyword\">let</span> redisIsOk = <span class=\"literal\">false</span></span><br><span class=\"line\">client.on(<span class=\"string\">&#x27;ready&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  redisIsOk = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"built_in\">global</span>.logger.server(<span class=\"string\">&#x27;redis is ready!&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">client.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  redisIsOk = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"built_in\">global</span>.logger.server(<span class=\"string\">&#x27;redis is on error! errmsg:&#x27;</span> + err.toString(), <span class=\"string\">&#x27;ERROR&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 存入redis</span></span><br><span class=\"line\"><span class=\"comment\">   * expire (单位：s)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  set: <span class=\"function\">(<span class=\"params\">key, value, expire</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!redisIsOk) &#123;</span><br><span class=\"line\">        reject(<span class=\"literal\">false</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      client.set(key, value).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(<span class=\"literal\">true</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      expire = expire || <span class=\"number\">24</span>*<span class=\"number\">3600</span></span><br><span class=\"line\">      <span class=\"comment\">// 过期时间默认1天</span></span><br><span class=\"line\">      client.expire(key, expire)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * return false || value</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  get: <span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!redisIsOk) &#123;</span><br><span class=\"line\">        reject(<span class=\"literal\">false</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      client.get(key).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  del: <span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!redisIsOk) &#123;</span><br><span class=\"line\">      reject(<span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      client.del(key).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>nodejs 连接sentinel开源库<br><a href=\"https://github.com/luin/ioredis\">https://github.com/luin/ioredis</a></p>\n<p>redis持久化存储<br><a href=\"https://segmentfault.com/a/1190000002906345\">https://segmentfault.com/a/1190000002906345</a></p>\n<p>redis看云文档<br><a href=\"https://www.kancloud.cn/digest/redis330/162452\">https://www.kancloud.cn/digest/redis330/162452</a></p>\n"},{"title":"rpc与thrift简介","date":"2018-07-30T16:00:00.000Z","_content":"\n现如今都流行大前端开发，所谓的大前端就是，将后端的传统的MVC（model、view、controler）中的view和controler给接过来。\n将view接过来这个没什么问题，最近的vue、react等框架，以前的静态html页面，ftl模板等都是干这种事情的，没什么好说。\n但是，如果要将controler给接过来，就有些麻烦了。\n最直接的问题就是需要搞定服务器内部服务之间的通讯\n\n对于Jser来说，就是需要搞定nodejs和其它语言（如java）之间的通讯。\n\n### 通讯方式\n对于Jser来说，最简单，最熟悉，最好用的莫过于直接通过http请求调用接口了。\n这种方式最实用，也最好实现，这个也是我之前公司用的方式。（中小型公司首选）\n\n但是，http协议设计最初是为了实现web与服务器之间的通讯。\n而http请求是基于http协议的，因此存在有很多web浏览器定制的信息。这对于服务器之间的通讯来说这些信息就是冗余信息了。\n除此之外，http通讯对于大规模的后端服务器之间数据交互还是存在一定的性能问题的。\n\nhttp协议并不是服务器之间通讯的最理想协议。\n\n那么，除了http协议，还有其他的方式来做服务器之间的通讯吗？\n当然有，而且目前在后端开发领域还很常见，那就是RPC。\n而作为JS开发者，要想搞定controler层，RPC就是必须得啃的骨头了。\n\n\n### rpc是什么？\n```html\nrpc(remote procedure call)远程过程调用，是一个计算机通信协议。\n该协议允许运行在一台计算机的程序调用另一台计算机的子程序。\n如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。\n```\n其实可以看做是一个系统内部调用通道。\n\n### IDL是什么？\n```html\nIDL（Interface Description Language）接口描述语言。\n是一个描述软件组件接口的语言“规范”。\n为了不同服务器能够访问服务器，需要定制一些标准化的RPC，大部分采用的接口描述语言。\nIDL采用一种中立的方式来描述接口，使得不同平台上运行的对象和用不同语言编写的程序可以相互通信交流。\n```\n\n### rpc框架？\nrpc框架有很多，目前用的比较多的有：gRPC、Thrift、Dubbo\n```html\nDubbo是阿里开源的一款rpc框架\ngRPC是google开源的一款rpc框架\nThrift是facebook开源的rpc框架\n```\n\n其中，阿里巴巴开源的Dubbo在国内是最流行的RPC框架（我厂java后端就是用的这个）。\n当然，据我了解，目前阿里内部都用HSF，据说是继Dubbo之后的下一代RPC框架。\n只是，目前HSF并没有开源。\n\n---\n\n*当然，thrift也是用的挺多的，至少我之前在网上搜索node-java通讯，搜出来的很多结果都是说用thrift进行通讯，于是顺便了解了一下thrift。*\n\n### thrift 是什么？\n```html\nthrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。\n它被当做一个远程过程调用（RPC）框架使用。\n早期由Facebook“为大规模跨语言服务”而开发的。现在是Apache软件基金会的开源项目。\n```\n\n### thrift与IDL\n```html\nthrift采用IDL来定义通用的服务接口，然后通过thrift提供的编译器，可以将服务接口编译成不同语言编写的代码，通过这种方式来实现跨语言通信。\nthrift是一个基于IDL生成跨语言的RPC clients and services。\n```\n\n### thrift使用？\n```html\n1.安装\nhttps://thrift.apache.org/docs/install/os_x\n```\n\n####  安装遇到问题：\n```html\nCouldn't find libtoolize!\n```\n解决：\n```shell\nbrew reinstall libtool;\n```\n\n问题：\n```html\nconfigure: error: Bison version 2.5 or higher must be installed on the system!\n```\n解决：\n```shell\nbrew install bison # 缺什么安装什么\nexport PATH=/usr/local/Cellar/bison/3.0.5/bin:$PATH # 安装完成之后设置环境变量\n```\n\n问题：make报错\n```html\n'boost/tokenizer.hpp' file not found\n```\n解决：\n```shell\nbrew install boost\n```\n\n问题：make报错\n```html\nmake[3]: /usr/local/bin/bundle: No such file or directory\n```\n解决：\n```html\n好烦，有完没完。。。\n```\n\n这条路没完没了了，搜一下还有什么其他的方式吧，要不回去用brew安装一下试试？\n\n```shell\nbrew install thrift\n```\n解决\n```html\n好吧，安装成功了。\n明明记得之前安装会报错的，在源码安装之前其实我有试过brew安装，但是也报了一个什么环境错误。\n但是现在却能够安装成功。\n唯一的解释是，上面的安装的那些环境包还是有用的。\n理论上来说安装方式有多种：一种是通过源码一步一步编译、构建；另一种就是通过brew直接安装。\n```\n\n安装的过程中或多或少都会遇到一些环境问题，但是，只要一步一步去解决最终还是能搞定的。\n\n至此，整个thrift安装就已经结束了。\n\n---\n\n作为程序员，不论学了什么，如果没有跑一个hello world！总觉得少了些什么。\n要跑thrift的hello world，首先得有一个thrift服务端、一个thrift客户端。\n既然我们是要做nodejs跟java的通讯，这个demo最好当然是用nodejs和java来互相通讯了。\n\n但是，我不懂java...\n\n好吧，其实thrift是rpc框架，不仅仅是跨语言通讯，更主要功能还是做服务器各个子服务之间的通讯。\n（妥协）那就做一个nodejs跟nodejs之间的一个通讯吧。\n\n### 使用thrift协议作为NODEJS之间的通讯实例。\n\n第一步：\n要创建一个thrift服务，必须写一些thrift文件来描述它，为目标语言生成代码，并且写一些代码来启动服务器及从客户端调用它。\n下面是我从thrift上官网上扒下来的NODEJS版本的thrift例子的简化版。\n\ntutorial.thrift文件，遵循IDL语法规则。\n```thrift\n// 命名空间\nnamespace js tutorial\n// 定义接口方法\nservice Ping {\n  void ping(),\n}\n```\n\n通过thrift生成nodejs版本的代码\n\n```shell\nthrift --gen <language> <Thrift filename> # eg：thrift -r --gen js:node tutorial.thrift\n```\n通过上面的命令，会生成如下结构的两个文件（这两个文件不要手动修改）\n\n```html\n-gen-nodejs\n  -Ping.js\n  -tutorial_types.js\n```\n\n之后，用nodejs 分别写服务端和客户端文件，并引入上面thrift生成的文件。\n\n```javascript\n// 文件：./server.js\n\nvar thrift = require(\"thrift\");\nvar Ping = require(\"./gen-nodejs/Ping\");\n\nvar server = thrift.createServer(Ping, {\n\t// 接收到客户端的ping之后，打印一个ping()\n  ping: function() {\n    console.log(\"ping()\");\n    result(null);\n  }\n});\n\nserver.listen(9090);\n```\n\n```javascript\n// 文件：./client.js\nvar thrift = require('thrift');\nvar Ping = require('./gen-nodejs/Ping');\nconst assert = require('assert');\n\nvar transport = thrift.TBufferedTransport;\nvar protocol = thrift.TBinaryProtocol;\n\nvar connection = thrift.createConnection(\"localhost\", 9090, {\n  transport : transport,\n  protocol : protocol\n});\n\nconnection.on('error', function(err) {\n  assert(false, err);\n});\n\n// Create a Ping client with the connection\nvar client = thrift.createClient(Ping, connection);\n\nfunction ping() {\n  client.ping(function(err, response) {\n    console.log('ping...');\n  });\n}\n\n// 每一秒ping一次\nsetInterval(function() {\n  ping()\n}, 1000)\n```\n\n运行：\n```shell\n# 先运行服务端\nnode ./server.js\n# 再运行客户端\nnode ./client.js\n```\n\n客户端控制台结果：\n```html\nping...\nping...\nping...\n...\n```\n\n服务端控制台结果：\n```html\nping()\nping()\nping()\n...\n```\n\n---\n\n至此，我们就完成了一个完整的通过thrift协议进行nodejs之间的通讯了。\n当然，上面只是一个最简单的例子。\n要想做一个完整而复杂的thrift通讯还有很多事情要做。\n\n得了解更多的IDL语法，动态生成获取thrift生成文件，服务的稳定性，容错性等。\n几乎是需要搭建一整套thrift服务应用程序了。这个过程其实就是开发一个新的基础服务系统。\n总算明白了为什么得大厂的jser才会玩rpc服务了。\n\n\n \n### 传送门：\n\nthrift的IDL\nhttp://thrift.apache.org/docs/idl\n\nNODEJS实例传送门：\nhttps://thrift.apache.org/tutorial/nodejs\n\ndubbo传送门\nhttps://github.com/dubbo/dubbo2.js\n\n","source":"_posts/rpc.md","raw":"---\ntitle: rpc与thrift简介\ndate: 2018/07/31\ntag: [rpc, thrift, nodejs]\n---\n\n现如今都流行大前端开发，所谓的大前端就是，将后端的传统的MVC（model、view、controler）中的view和controler给接过来。\n将view接过来这个没什么问题，最近的vue、react等框架，以前的静态html页面，ftl模板等都是干这种事情的，没什么好说。\n但是，如果要将controler给接过来，就有些麻烦了。\n最直接的问题就是需要搞定服务器内部服务之间的通讯\n\n对于Jser来说，就是需要搞定nodejs和其它语言（如java）之间的通讯。\n\n### 通讯方式\n对于Jser来说，最简单，最熟悉，最好用的莫过于直接通过http请求调用接口了。\n这种方式最实用，也最好实现，这个也是我之前公司用的方式。（中小型公司首选）\n\n但是，http协议设计最初是为了实现web与服务器之间的通讯。\n而http请求是基于http协议的，因此存在有很多web浏览器定制的信息。这对于服务器之间的通讯来说这些信息就是冗余信息了。\n除此之外，http通讯对于大规模的后端服务器之间数据交互还是存在一定的性能问题的。\n\nhttp协议并不是服务器之间通讯的最理想协议。\n\n那么，除了http协议，还有其他的方式来做服务器之间的通讯吗？\n当然有，而且目前在后端开发领域还很常见，那就是RPC。\n而作为JS开发者，要想搞定controler层，RPC就是必须得啃的骨头了。\n\n\n### rpc是什么？\n```html\nrpc(remote procedure call)远程过程调用，是一个计算机通信协议。\n该协议允许运行在一台计算机的程序调用另一台计算机的子程序。\n如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。\n```\n其实可以看做是一个系统内部调用通道。\n\n### IDL是什么？\n```html\nIDL（Interface Description Language）接口描述语言。\n是一个描述软件组件接口的语言“规范”。\n为了不同服务器能够访问服务器，需要定制一些标准化的RPC，大部分采用的接口描述语言。\nIDL采用一种中立的方式来描述接口，使得不同平台上运行的对象和用不同语言编写的程序可以相互通信交流。\n```\n\n### rpc框架？\nrpc框架有很多，目前用的比较多的有：gRPC、Thrift、Dubbo\n```html\nDubbo是阿里开源的一款rpc框架\ngRPC是google开源的一款rpc框架\nThrift是facebook开源的rpc框架\n```\n\n其中，阿里巴巴开源的Dubbo在国内是最流行的RPC框架（我厂java后端就是用的这个）。\n当然，据我了解，目前阿里内部都用HSF，据说是继Dubbo之后的下一代RPC框架。\n只是，目前HSF并没有开源。\n\n---\n\n*当然，thrift也是用的挺多的，至少我之前在网上搜索node-java通讯，搜出来的很多结果都是说用thrift进行通讯，于是顺便了解了一下thrift。*\n\n### thrift 是什么？\n```html\nthrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。\n它被当做一个远程过程调用（RPC）框架使用。\n早期由Facebook“为大规模跨语言服务”而开发的。现在是Apache软件基金会的开源项目。\n```\n\n### thrift与IDL\n```html\nthrift采用IDL来定义通用的服务接口，然后通过thrift提供的编译器，可以将服务接口编译成不同语言编写的代码，通过这种方式来实现跨语言通信。\nthrift是一个基于IDL生成跨语言的RPC clients and services。\n```\n\n### thrift使用？\n```html\n1.安装\nhttps://thrift.apache.org/docs/install/os_x\n```\n\n####  安装遇到问题：\n```html\nCouldn't find libtoolize!\n```\n解决：\n```shell\nbrew reinstall libtool;\n```\n\n问题：\n```html\nconfigure: error: Bison version 2.5 or higher must be installed on the system!\n```\n解决：\n```shell\nbrew install bison # 缺什么安装什么\nexport PATH=/usr/local/Cellar/bison/3.0.5/bin:$PATH # 安装完成之后设置环境变量\n```\n\n问题：make报错\n```html\n'boost/tokenizer.hpp' file not found\n```\n解决：\n```shell\nbrew install boost\n```\n\n问题：make报错\n```html\nmake[3]: /usr/local/bin/bundle: No such file or directory\n```\n解决：\n```html\n好烦，有完没完。。。\n```\n\n这条路没完没了了，搜一下还有什么其他的方式吧，要不回去用brew安装一下试试？\n\n```shell\nbrew install thrift\n```\n解决\n```html\n好吧，安装成功了。\n明明记得之前安装会报错的，在源码安装之前其实我有试过brew安装，但是也报了一个什么环境错误。\n但是现在却能够安装成功。\n唯一的解释是，上面的安装的那些环境包还是有用的。\n理论上来说安装方式有多种：一种是通过源码一步一步编译、构建；另一种就是通过brew直接安装。\n```\n\n安装的过程中或多或少都会遇到一些环境问题，但是，只要一步一步去解决最终还是能搞定的。\n\n至此，整个thrift安装就已经结束了。\n\n---\n\n作为程序员，不论学了什么，如果没有跑一个hello world！总觉得少了些什么。\n要跑thrift的hello world，首先得有一个thrift服务端、一个thrift客户端。\n既然我们是要做nodejs跟java的通讯，这个demo最好当然是用nodejs和java来互相通讯了。\n\n但是，我不懂java...\n\n好吧，其实thrift是rpc框架，不仅仅是跨语言通讯，更主要功能还是做服务器各个子服务之间的通讯。\n（妥协）那就做一个nodejs跟nodejs之间的一个通讯吧。\n\n### 使用thrift协议作为NODEJS之间的通讯实例。\n\n第一步：\n要创建一个thrift服务，必须写一些thrift文件来描述它，为目标语言生成代码，并且写一些代码来启动服务器及从客户端调用它。\n下面是我从thrift上官网上扒下来的NODEJS版本的thrift例子的简化版。\n\ntutorial.thrift文件，遵循IDL语法规则。\n```thrift\n// 命名空间\nnamespace js tutorial\n// 定义接口方法\nservice Ping {\n  void ping(),\n}\n```\n\n通过thrift生成nodejs版本的代码\n\n```shell\nthrift --gen <language> <Thrift filename> # eg：thrift -r --gen js:node tutorial.thrift\n```\n通过上面的命令，会生成如下结构的两个文件（这两个文件不要手动修改）\n\n```html\n-gen-nodejs\n  -Ping.js\n  -tutorial_types.js\n```\n\n之后，用nodejs 分别写服务端和客户端文件，并引入上面thrift生成的文件。\n\n```javascript\n// 文件：./server.js\n\nvar thrift = require(\"thrift\");\nvar Ping = require(\"./gen-nodejs/Ping\");\n\nvar server = thrift.createServer(Ping, {\n\t// 接收到客户端的ping之后，打印一个ping()\n  ping: function() {\n    console.log(\"ping()\");\n    result(null);\n  }\n});\n\nserver.listen(9090);\n```\n\n```javascript\n// 文件：./client.js\nvar thrift = require('thrift');\nvar Ping = require('./gen-nodejs/Ping');\nconst assert = require('assert');\n\nvar transport = thrift.TBufferedTransport;\nvar protocol = thrift.TBinaryProtocol;\n\nvar connection = thrift.createConnection(\"localhost\", 9090, {\n  transport : transport,\n  protocol : protocol\n});\n\nconnection.on('error', function(err) {\n  assert(false, err);\n});\n\n// Create a Ping client with the connection\nvar client = thrift.createClient(Ping, connection);\n\nfunction ping() {\n  client.ping(function(err, response) {\n    console.log('ping...');\n  });\n}\n\n// 每一秒ping一次\nsetInterval(function() {\n  ping()\n}, 1000)\n```\n\n运行：\n```shell\n# 先运行服务端\nnode ./server.js\n# 再运行客户端\nnode ./client.js\n```\n\n客户端控制台结果：\n```html\nping...\nping...\nping...\n...\n```\n\n服务端控制台结果：\n```html\nping()\nping()\nping()\n...\n```\n\n---\n\n至此，我们就完成了一个完整的通过thrift协议进行nodejs之间的通讯了。\n当然，上面只是一个最简单的例子。\n要想做一个完整而复杂的thrift通讯还有很多事情要做。\n\n得了解更多的IDL语法，动态生成获取thrift生成文件，服务的稳定性，容错性等。\n几乎是需要搭建一整套thrift服务应用程序了。这个过程其实就是开发一个新的基础服务系统。\n总算明白了为什么得大厂的jser才会玩rpc服务了。\n\n\n \n### 传送门：\n\nthrift的IDL\nhttp://thrift.apache.org/docs/idl\n\nNODEJS实例传送门：\nhttps://thrift.apache.org/tutorial/nodejs\n\ndubbo传送门\nhttps://github.com/dubbo/dubbo2.js\n\n","slug":"rpc","published":1,"updated":"2021-03-30T01:32:00.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ug9001oa0vzgtb7h3v6","content":"<p>现如今都流行大前端开发，所谓的大前端就是，将后端的传统的MVC（model、view、controler）中的view和controler给接过来。<br>将view接过来这个没什么问题，最近的vue、react等框架，以前的静态html页面，ftl模板等都是干这种事情的，没什么好说。<br>但是，如果要将controler给接过来，就有些麻烦了。<br>最直接的问题就是需要搞定服务器内部服务之间的通讯</p>\n<p>对于Jser来说，就是需要搞定nodejs和其它语言（如java）之间的通讯。</p>\n<h3 id=\"通讯方式\"><a href=\"#通讯方式\" class=\"headerlink\" title=\"通讯方式\"></a>通讯方式</h3><p>对于Jser来说，最简单，最熟悉，最好用的莫过于直接通过http请求调用接口了。<br>这种方式最实用，也最好实现，这个也是我之前公司用的方式。（中小型公司首选）</p>\n<p>但是，http协议设计最初是为了实现web与服务器之间的通讯。<br>而http请求是基于http协议的，因此存在有很多web浏览器定制的信息。这对于服务器之间的通讯来说这些信息就是冗余信息了。<br>除此之外，http通讯对于大规模的后端服务器之间数据交互还是存在一定的性能问题的。</p>\n<p>http协议并不是服务器之间通讯的最理想协议。</p>\n<p>那么，除了http协议，还有其他的方式来做服务器之间的通讯吗？<br>当然有，而且目前在后端开发领域还很常见，那就是RPC。<br>而作为JS开发者，要想搞定controler层，RPC就是必须得啃的骨头了。</p>\n<h3 id=\"rpc是什么？\"><a href=\"#rpc是什么？\" class=\"headerlink\" title=\"rpc是什么？\"></a>rpc是什么？</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpc(remote procedure call)远程过程调用，是一个计算机通信协议。</span><br><span class=\"line\">该协议允许运行在一台计算机的程序调用另一台计算机的子程序。</span><br><span class=\"line\">如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。</span><br></pre></td></tr></table></figure>\n<p>其实可以看做是一个系统内部调用通道。</p>\n<h3 id=\"IDL是什么？\"><a href=\"#IDL是什么？\" class=\"headerlink\" title=\"IDL是什么？\"></a>IDL是什么？</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IDL（Interface Description Language）接口描述语言。</span><br><span class=\"line\">是一个描述软件组件接口的语言“规范”。</span><br><span class=\"line\">为了不同服务器能够访问服务器，需要定制一些标准化的RPC，大部分采用的接口描述语言。</span><br><span class=\"line\">IDL采用一种中立的方式来描述接口，使得不同平台上运行的对象和用不同语言编写的程序可以相互通信交流。</span><br></pre></td></tr></table></figure>\n<h3 id=\"rpc框架？\"><a href=\"#rpc框架？\" class=\"headerlink\" title=\"rpc框架？\"></a>rpc框架？</h3><p>rpc框架有很多，目前用的比较多的有：gRPC、Thrift、Dubbo<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dubbo是阿里开源的一款rpc框架</span><br><span class=\"line\">gRPC是google开源的一款rpc框架</span><br><span class=\"line\">Thrift是facebook开源的rpc框架</span><br></pre></td></tr></table></figure></p>\n<p>其中，阿里巴巴开源的Dubbo在国内是最流行的RPC框架（我厂java后端就是用的这个）。<br>当然，据我了解，目前阿里内部都用HSF，据说是继Dubbo之后的下一代RPC框架。<br>只是，目前HSF并没有开源。</p>\n<hr>\n<p><em>当然，thrift也是用的挺多的，至少我之前在网上搜索node-java通讯，搜出来的很多结果都是说用thrift进行通讯，于是顺便了解了一下thrift。</em></p>\n<h3 id=\"thrift-是什么？\"><a href=\"#thrift-是什么？\" class=\"headerlink\" title=\"thrift 是什么？\"></a>thrift 是什么？</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。</span><br><span class=\"line\">它被当做一个远程过程调用（RPC）框架使用。</span><br><span class=\"line\">早期由Facebook“为大规模跨语言服务”而开发的。现在是Apache软件基金会的开源项目。</span><br></pre></td></tr></table></figure>\n<h3 id=\"thrift与IDL\"><a href=\"#thrift与IDL\" class=\"headerlink\" title=\"thrift与IDL\"></a>thrift与IDL</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thrift采用IDL来定义通用的服务接口，然后通过thrift提供的编译器，可以将服务接口编译成不同语言编写的代码，通过这种方式来实现跨语言通信。</span><br><span class=\"line\">thrift是一个基于IDL生成跨语言的RPC clients and services。</span><br></pre></td></tr></table></figure>\n<h3 id=\"thrift使用？\"><a href=\"#thrift使用？\" class=\"headerlink\" title=\"thrift使用？\"></a>thrift使用？</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.安装</span><br><span class=\"line\">https://thrift.apache.org/docs/install/os_x</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装遇到问题：\"><a href=\"#安装遇到问题：\" class=\"headerlink\" title=\"安装遇到问题：\"></a>安装遇到问题：</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Couldn&#x27;t find libtoolize!</span><br></pre></td></tr></table></figure>\n<p>解决：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew reinstall libtool;</span><br></pre></td></tr></table></figure></p>\n<p>问题：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configure: error: Bison version 2.5 or higher must be installed on the system!</span><br></pre></td></tr></table></figure><br>解决：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install bison # 缺什么安装什么</span><br><span class=\"line\">export PATH=/usr/local/Cellar/bison/3.0.5/bin:$PATH # 安装完成之后设置环境变量</span><br></pre></td></tr></table></figure></p>\n<p>问题：make报错<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x27;boost/tokenizer.hpp&#x27; file not found</span><br></pre></td></tr></table></figure><br>解决：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install boost</span><br></pre></td></tr></table></figure></p>\n<p>问题：make报错<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make[3]: /usr/local/bin/bundle: No such file or directory</span><br></pre></td></tr></table></figure><br>解决：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">好烦，有完没完。。。</span><br></pre></td></tr></table></figure></p>\n<p>这条路没完没了了，搜一下还有什么其他的方式吧，要不回去用brew安装一下试试？</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install thrift</span><br></pre></td></tr></table></figure>\n<p>解决<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">好吧，安装成功了。</span><br><span class=\"line\">明明记得之前安装会报错的，在源码安装之前其实我有试过brew安装，但是也报了一个什么环境错误。</span><br><span class=\"line\">但是现在却能够安装成功。</span><br><span class=\"line\">唯一的解释是，上面的安装的那些环境包还是有用的。</span><br><span class=\"line\">理论上来说安装方式有多种：一种是通过源码一步一步编译、构建；另一种就是通过brew直接安装。</span><br></pre></td></tr></table></figure></p>\n<p>安装的过程中或多或少都会遇到一些环境问题，但是，只要一步一步去解决最终还是能搞定的。</p>\n<p>至此，整个thrift安装就已经结束了。</p>\n<hr>\n<p>作为程序员，不论学了什么，如果没有跑一个hello world！总觉得少了些什么。<br>要跑thrift的hello world，首先得有一个thrift服务端、一个thrift客户端。<br>既然我们是要做nodejs跟java的通讯，这个demo最好当然是用nodejs和java来互相通讯了。</p>\n<p>但是，我不懂java…</p>\n<p>好吧，其实thrift是rpc框架，不仅仅是跨语言通讯，更主要功能还是做服务器各个子服务之间的通讯。<br>（妥协）那就做一个nodejs跟nodejs之间的一个通讯吧。</p>\n<h3 id=\"使用thrift协议作为NODEJS之间的通讯实例。\"><a href=\"#使用thrift协议作为NODEJS之间的通讯实例。\" class=\"headerlink\" title=\"使用thrift协议作为NODEJS之间的通讯实例。\"></a>使用thrift协议作为NODEJS之间的通讯实例。</h3><p>第一步：<br>要创建一个thrift服务，必须写一些thrift文件来描述它，为目标语言生成代码，并且写一些代码来启动服务器及从客户端调用它。<br>下面是我从thrift上官网上扒下来的NODEJS版本的thrift例子的简化版。</p>\n<p>tutorial.thrift文件，遵循IDL语法规则。<br><figure class=\"highlight thrift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> js tutorial</span><br><span class=\"line\"><span class=\"comment\">// 定义接口方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">Ping</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> ping(),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过thrift生成nodejs版本的代码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thrift --gen &lt;language&gt; &lt;Thrift filename&gt; # eg：thrift -r --gen js:node tutorial.thrift</span><br></pre></td></tr></table></figure>\n<p>通过上面的命令，会生成如下结构的两个文件（这两个文件不要手动修改）</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-gen-nodejs</span><br><span class=\"line\">  -Ping.js</span><br><span class=\"line\">  -tutorial_types.js</span><br></pre></td></tr></table></figure>\n<p>之后，用nodejs 分别写服务端和客户端文件，并引入上面thrift生成的文件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 文件：./server.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> thrift = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;thrift&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> Ping = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./gen-nodejs/Ping&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> server = thrift.createServer(Ping, &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 接收到客户端的ping之后，打印一个ping()</span></span><br><span class=\"line\">  ping: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;ping()&quot;</span>);</span><br><span class=\"line\">    result(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9090</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 文件：./client.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> thrift = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;thrift&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> Ping = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./gen-nodejs/Ping&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> assert = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;assert&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> transport = thrift.TBufferedTransport;</span><br><span class=\"line\"><span class=\"keyword\">var</span> protocol = thrift.TBinaryProtocol;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> connection = thrift.createConnection(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">9090</span>, &#123;</span><br><span class=\"line\">  transport : transport,</span><br><span class=\"line\">  protocol : protocol</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  assert(<span class=\"literal\">false</span>, err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Create a Ping client with the connection</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> client = thrift.createClient(Ping, connection);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ping</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  client.ping(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, response</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;ping...&#x27;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每一秒ping一次</span></span><br><span class=\"line\"><span class=\"built_in\">setInterval</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ping()</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n<p>运行：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先运行服务端</span></span><br><span class=\"line\">node ./server.js</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 再运行客户端</span></span><br><span class=\"line\">node ./client.js</span><br></pre></td></tr></table></figure></p>\n<p>客户端控制台结果：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping...</span><br><span class=\"line\">ping...</span><br><span class=\"line\">ping...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>服务端控制台结果：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping()</span><br><span class=\"line\">ping()</span><br><span class=\"line\">ping()</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>至此，我们就完成了一个完整的通过thrift协议进行nodejs之间的通讯了。<br>当然，上面只是一个最简单的例子。<br>要想做一个完整而复杂的thrift通讯还有很多事情要做。</p>\n<p>得了解更多的IDL语法，动态生成获取thrift生成文件，服务的稳定性，容错性等。<br>几乎是需要搭建一整套thrift服务应用程序了。这个过程其实就是开发一个新的基础服务系统。<br>总算明白了为什么得大厂的jser才会玩rpc服务了。</p>\n<h3 id=\"传送门：\"><a href=\"#传送门：\" class=\"headerlink\" title=\"传送门：\"></a>传送门：</h3><p>thrift的IDL<br><a href=\"http://thrift.apache.org/docs/idl\">http://thrift.apache.org/docs/idl</a></p>\n<p>NODEJS实例传送门：<br><a href=\"https://thrift.apache.org/tutorial/nodejs\">https://thrift.apache.org/tutorial/nodejs</a></p>\n<p>dubbo传送门<br><a href=\"https://github.com/dubbo/dubbo2.js\">https://github.com/dubbo/dubbo2.js</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>现如今都流行大前端开发，所谓的大前端就是，将后端的传统的MVC（model、view、controler）中的view和controler给接过来。<br>将view接过来这个没什么问题，最近的vue、react等框架，以前的静态html页面，ftl模板等都是干这种事情的，没什么好说。<br>但是，如果要将controler给接过来，就有些麻烦了。<br>最直接的问题就是需要搞定服务器内部服务之间的通讯</p>\n<p>对于Jser来说，就是需要搞定nodejs和其它语言（如java）之间的通讯。</p>\n<h3 id=\"通讯方式\"><a href=\"#通讯方式\" class=\"headerlink\" title=\"通讯方式\"></a>通讯方式</h3><p>对于Jser来说，最简单，最熟悉，最好用的莫过于直接通过http请求调用接口了。<br>这种方式最实用，也最好实现，这个也是我之前公司用的方式。（中小型公司首选）</p>\n<p>但是，http协议设计最初是为了实现web与服务器之间的通讯。<br>而http请求是基于http协议的，因此存在有很多web浏览器定制的信息。这对于服务器之间的通讯来说这些信息就是冗余信息了。<br>除此之外，http通讯对于大规模的后端服务器之间数据交互还是存在一定的性能问题的。</p>\n<p>http协议并不是服务器之间通讯的最理想协议。</p>\n<p>那么，除了http协议，还有其他的方式来做服务器之间的通讯吗？<br>当然有，而且目前在后端开发领域还很常见，那就是RPC。<br>而作为JS开发者，要想搞定controler层，RPC就是必须得啃的骨头了。</p>\n<h3 id=\"rpc是什么？\"><a href=\"#rpc是什么？\" class=\"headerlink\" title=\"rpc是什么？\"></a>rpc是什么？</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpc(remote procedure call)远程过程调用，是一个计算机通信协议。</span><br><span class=\"line\">该协议允许运行在一台计算机的程序调用另一台计算机的子程序。</span><br><span class=\"line\">如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。</span><br></pre></td></tr></table></figure>\n<p>其实可以看做是一个系统内部调用通道。</p>\n<h3 id=\"IDL是什么？\"><a href=\"#IDL是什么？\" class=\"headerlink\" title=\"IDL是什么？\"></a>IDL是什么？</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IDL（Interface Description Language）接口描述语言。</span><br><span class=\"line\">是一个描述软件组件接口的语言“规范”。</span><br><span class=\"line\">为了不同服务器能够访问服务器，需要定制一些标准化的RPC，大部分采用的接口描述语言。</span><br><span class=\"line\">IDL采用一种中立的方式来描述接口，使得不同平台上运行的对象和用不同语言编写的程序可以相互通信交流。</span><br></pre></td></tr></table></figure>\n<h3 id=\"rpc框架？\"><a href=\"#rpc框架？\" class=\"headerlink\" title=\"rpc框架？\"></a>rpc框架？</h3><p>rpc框架有很多，目前用的比较多的有：gRPC、Thrift、Dubbo<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dubbo是阿里开源的一款rpc框架</span><br><span class=\"line\">gRPC是google开源的一款rpc框架</span><br><span class=\"line\">Thrift是facebook开源的rpc框架</span><br></pre></td></tr></table></figure></p>\n<p>其中，阿里巴巴开源的Dubbo在国内是最流行的RPC框架（我厂java后端就是用的这个）。<br>当然，据我了解，目前阿里内部都用HSF，据说是继Dubbo之后的下一代RPC框架。<br>只是，目前HSF并没有开源。</p>\n<hr>\n<p><em>当然，thrift也是用的挺多的，至少我之前在网上搜索node-java通讯，搜出来的很多结果都是说用thrift进行通讯，于是顺便了解了一下thrift。</em></p>\n<h3 id=\"thrift-是什么？\"><a href=\"#thrift-是什么？\" class=\"headerlink\" title=\"thrift 是什么？\"></a>thrift 是什么？</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。</span><br><span class=\"line\">它被当做一个远程过程调用（RPC）框架使用。</span><br><span class=\"line\">早期由Facebook“为大规模跨语言服务”而开发的。现在是Apache软件基金会的开源项目。</span><br></pre></td></tr></table></figure>\n<h3 id=\"thrift与IDL\"><a href=\"#thrift与IDL\" class=\"headerlink\" title=\"thrift与IDL\"></a>thrift与IDL</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thrift采用IDL来定义通用的服务接口，然后通过thrift提供的编译器，可以将服务接口编译成不同语言编写的代码，通过这种方式来实现跨语言通信。</span><br><span class=\"line\">thrift是一个基于IDL生成跨语言的RPC clients and services。</span><br></pre></td></tr></table></figure>\n<h3 id=\"thrift使用？\"><a href=\"#thrift使用？\" class=\"headerlink\" title=\"thrift使用？\"></a>thrift使用？</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.安装</span><br><span class=\"line\">https://thrift.apache.org/docs/install/os_x</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装遇到问题：\"><a href=\"#安装遇到问题：\" class=\"headerlink\" title=\"安装遇到问题：\"></a>安装遇到问题：</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Couldn&#x27;t find libtoolize!</span><br></pre></td></tr></table></figure>\n<p>解决：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew reinstall libtool;</span><br></pre></td></tr></table></figure></p>\n<p>问题：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configure: error: Bison version 2.5 or higher must be installed on the system!</span><br></pre></td></tr></table></figure><br>解决：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install bison # 缺什么安装什么</span><br><span class=\"line\">export PATH=/usr/local/Cellar/bison/3.0.5/bin:$PATH # 安装完成之后设置环境变量</span><br></pre></td></tr></table></figure></p>\n<p>问题：make报错<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x27;boost/tokenizer.hpp&#x27; file not found</span><br></pre></td></tr></table></figure><br>解决：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install boost</span><br></pre></td></tr></table></figure></p>\n<p>问题：make报错<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make[3]: /usr/local/bin/bundle: No such file or directory</span><br></pre></td></tr></table></figure><br>解决：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">好烦，有完没完。。。</span><br></pre></td></tr></table></figure></p>\n<p>这条路没完没了了，搜一下还有什么其他的方式吧，要不回去用brew安装一下试试？</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install thrift</span><br></pre></td></tr></table></figure>\n<p>解决<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">好吧，安装成功了。</span><br><span class=\"line\">明明记得之前安装会报错的，在源码安装之前其实我有试过brew安装，但是也报了一个什么环境错误。</span><br><span class=\"line\">但是现在却能够安装成功。</span><br><span class=\"line\">唯一的解释是，上面的安装的那些环境包还是有用的。</span><br><span class=\"line\">理论上来说安装方式有多种：一种是通过源码一步一步编译、构建；另一种就是通过brew直接安装。</span><br></pre></td></tr></table></figure></p>\n<p>安装的过程中或多或少都会遇到一些环境问题，但是，只要一步一步去解决最终还是能搞定的。</p>\n<p>至此，整个thrift安装就已经结束了。</p>\n<hr>\n<p>作为程序员，不论学了什么，如果没有跑一个hello world！总觉得少了些什么。<br>要跑thrift的hello world，首先得有一个thrift服务端、一个thrift客户端。<br>既然我们是要做nodejs跟java的通讯，这个demo最好当然是用nodejs和java来互相通讯了。</p>\n<p>但是，我不懂java…</p>\n<p>好吧，其实thrift是rpc框架，不仅仅是跨语言通讯，更主要功能还是做服务器各个子服务之间的通讯。<br>（妥协）那就做一个nodejs跟nodejs之间的一个通讯吧。</p>\n<h3 id=\"使用thrift协议作为NODEJS之间的通讯实例。\"><a href=\"#使用thrift协议作为NODEJS之间的通讯实例。\" class=\"headerlink\" title=\"使用thrift协议作为NODEJS之间的通讯实例。\"></a>使用thrift协议作为NODEJS之间的通讯实例。</h3><p>第一步：<br>要创建一个thrift服务，必须写一些thrift文件来描述它，为目标语言生成代码，并且写一些代码来启动服务器及从客户端调用它。<br>下面是我从thrift上官网上扒下来的NODEJS版本的thrift例子的简化版。</p>\n<p>tutorial.thrift文件，遵循IDL语法规则。<br><figure class=\"highlight thrift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> js tutorial</span><br><span class=\"line\"><span class=\"comment\">// 定义接口方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">Ping</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> ping(),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过thrift生成nodejs版本的代码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thrift --gen &lt;language&gt; &lt;Thrift filename&gt; # eg：thrift -r --gen js:node tutorial.thrift</span><br></pre></td></tr></table></figure>\n<p>通过上面的命令，会生成如下结构的两个文件（这两个文件不要手动修改）</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-gen-nodejs</span><br><span class=\"line\">  -Ping.js</span><br><span class=\"line\">  -tutorial_types.js</span><br></pre></td></tr></table></figure>\n<p>之后，用nodejs 分别写服务端和客户端文件，并引入上面thrift生成的文件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 文件：./server.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> thrift = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;thrift&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> Ping = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./gen-nodejs/Ping&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> server = thrift.createServer(Ping, &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 接收到客户端的ping之后，打印一个ping()</span></span><br><span class=\"line\">  ping: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;ping()&quot;</span>);</span><br><span class=\"line\">    result(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9090</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 文件：./client.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> thrift = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;thrift&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> Ping = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./gen-nodejs/Ping&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> assert = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;assert&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> transport = thrift.TBufferedTransport;</span><br><span class=\"line\"><span class=\"keyword\">var</span> protocol = thrift.TBinaryProtocol;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> connection = thrift.createConnection(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">9090</span>, &#123;</span><br><span class=\"line\">  transport : transport,</span><br><span class=\"line\">  protocol : protocol</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  assert(<span class=\"literal\">false</span>, err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Create a Ping client with the connection</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> client = thrift.createClient(Ping, connection);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ping</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  client.ping(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, response</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;ping...&#x27;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每一秒ping一次</span></span><br><span class=\"line\"><span class=\"built_in\">setInterval</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ping()</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n<p>运行：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先运行服务端</span></span><br><span class=\"line\">node ./server.js</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 再运行客户端</span></span><br><span class=\"line\">node ./client.js</span><br></pre></td></tr></table></figure></p>\n<p>客户端控制台结果：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping...</span><br><span class=\"line\">ping...</span><br><span class=\"line\">ping...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>服务端控制台结果：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping()</span><br><span class=\"line\">ping()</span><br><span class=\"line\">ping()</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>至此，我们就完成了一个完整的通过thrift协议进行nodejs之间的通讯了。<br>当然，上面只是一个最简单的例子。<br>要想做一个完整而复杂的thrift通讯还有很多事情要做。</p>\n<p>得了解更多的IDL语法，动态生成获取thrift生成文件，服务的稳定性，容错性等。<br>几乎是需要搭建一整套thrift服务应用程序了。这个过程其实就是开发一个新的基础服务系统。<br>总算明白了为什么得大厂的jser才会玩rpc服务了。</p>\n<h3 id=\"传送门：\"><a href=\"#传送门：\" class=\"headerlink\" title=\"传送门：\"></a>传送门：</h3><p>thrift的IDL<br><a href=\"http://thrift.apache.org/docs/idl\">http://thrift.apache.org/docs/idl</a></p>\n<p>NODEJS实例传送门：<br><a href=\"https://thrift.apache.org/tutorial/nodejs\">https://thrift.apache.org/tutorial/nodejs</a></p>\n<p>dubbo传送门<br><a href=\"https://github.com/dubbo/dubbo2.js\">https://github.com/dubbo/dubbo2.js</a></p>\n"},{"layout":"default","title":"Linux 软件的安装","date":"2018-11-04T16:00:00.000Z","_content":"\n### linux系统的软件安装\n在GNU/Linux操作系统中，rpm和dpkg是 *最为常见的两类* 软件包管理工具。\n他们分别应用于 RPM 软件包的Linux发行版本和 DEB 软件包的Linux发行版本。\n\nRPM全称 Redhat Package Manager，最早由Red Hat公司制定实施，后被GNU开源操作系统接受，成为很多 Linux 系统的既定软件标准。\nDEB是与RPM进行竞争的基于Debian操作系统(Ubuntu)的 DEB 软件包管理工具 - DPKG(Debian Package)\n\n\n#### yum\nyum 基于 rpm 软件包管理工具，是一个shell前端软件包管理器，能够自动安装、更新 RMP 包以及其依赖。\n\n\n#### apt\napt 是与 yum 对应的，是debian(ubuntu) Linux发行版本中的APT软件包管理工具。\n所有基于debian的发行都使用这个包管理系统。\nAPT 的主要包管理工具为 APT-GET，通过此工具可满足和上述 YUM 相似的功能要求\n\n### Mac OSX系统的软件安装\nMac OSX系统是基于linux的，绝大多数特性和功能都喝linux相似。\n但是也有很多不一样的地方，比如软件的安装。\n\n#### brew\nbrew 全称homebrew，是mac osx系统下的包管理器。\n\n### 源码安装\n除了用上面的包管理工具安装软件外，还可以直接下载源码然后解压编译安装。\n\n#### wget\nwget 是Linux系统中一个下载文件工具。\n很多时候我们都需要用到这个命令去下载文件，比如下载软件源码。\n源码包发布格式一般都是.tar.gz和.tar.bz2的。\n\n具体源码包的安装过程\n```shell\n# 第一步：解压文件（两种解压命令分别对应两种压缩格式）\ntar -zxvf ×××.tar.gz\ntar -jxvf ×××.tar.bz2\n# 第二步：执行配置文件，检测目标平台特征，一般会生成makefile文件。\n./configure\n# 第三步：make编译，将源码编译为二进制可执行程序\nmake\n# 第四步： make install，安装，这一步需要root权限，因为要向系统写入文件\nmake install\n```\n\n\n\n\n\n\n","source":"_posts/shell1.md","raw":"---\nlayout: default\ntitle: Linux 软件的安装\ndate: 2018-11-05\ntag: [linux, shell, 软件安装]\ncategory: 笔记\n---\n\n### linux系统的软件安装\n在GNU/Linux操作系统中，rpm和dpkg是 *最为常见的两类* 软件包管理工具。\n他们分别应用于 RPM 软件包的Linux发行版本和 DEB 软件包的Linux发行版本。\n\nRPM全称 Redhat Package Manager，最早由Red Hat公司制定实施，后被GNU开源操作系统接受，成为很多 Linux 系统的既定软件标准。\nDEB是与RPM进行竞争的基于Debian操作系统(Ubuntu)的 DEB 软件包管理工具 - DPKG(Debian Package)\n\n\n#### yum\nyum 基于 rpm 软件包管理工具，是一个shell前端软件包管理器，能够自动安装、更新 RMP 包以及其依赖。\n\n\n#### apt\napt 是与 yum 对应的，是debian(ubuntu) Linux发行版本中的APT软件包管理工具。\n所有基于debian的发行都使用这个包管理系统。\nAPT 的主要包管理工具为 APT-GET，通过此工具可满足和上述 YUM 相似的功能要求\n\n### Mac OSX系统的软件安装\nMac OSX系统是基于linux的，绝大多数特性和功能都喝linux相似。\n但是也有很多不一样的地方，比如软件的安装。\n\n#### brew\nbrew 全称homebrew，是mac osx系统下的包管理器。\n\n### 源码安装\n除了用上面的包管理工具安装软件外，还可以直接下载源码然后解压编译安装。\n\n#### wget\nwget 是Linux系统中一个下载文件工具。\n很多时候我们都需要用到这个命令去下载文件，比如下载软件源码。\n源码包发布格式一般都是.tar.gz和.tar.bz2的。\n\n具体源码包的安装过程\n```shell\n# 第一步：解压文件（两种解压命令分别对应两种压缩格式）\ntar -zxvf ×××.tar.gz\ntar -jxvf ×××.tar.bz2\n# 第二步：执行配置文件，检测目标平台特征，一般会生成makefile文件。\n./configure\n# 第三步：make编译，将源码编译为二进制可执行程序\nmake\n# 第四步： make install，安装，这一步需要root权限，因为要向系统写入文件\nmake install\n```\n\n\n\n\n\n\n","slug":"shell1","published":1,"updated":"2021-03-30T01:32:00.326Z","comments":1,"photos":[],"link":"","_id":"ckn2g7uga001pa0vzb5rq1ot4","content":"<h3 id=\"linux系统的软件安装\"><a href=\"#linux系统的软件安装\" class=\"headerlink\" title=\"linux系统的软件安装\"></a>linux系统的软件安装</h3><p>在GNU/Linux操作系统中，rpm和dpkg是 <em>最为常见的两类</em> 软件包管理工具。<br>他们分别应用于 RPM 软件包的Linux发行版本和 DEB 软件包的Linux发行版本。</p>\n<p>RPM全称 Redhat Package Manager，最早由Red Hat公司制定实施，后被GNU开源操作系统接受，成为很多 Linux 系统的既定软件标准。<br>DEB是与RPM进行竞争的基于Debian操作系统(Ubuntu)的 DEB 软件包管理工具 - DPKG(Debian Package)</p>\n<h4 id=\"yum\"><a href=\"#yum\" class=\"headerlink\" title=\"yum\"></a>yum</h4><p>yum 基于 rpm 软件包管理工具，是一个shell前端软件包管理器，能够自动安装、更新 RMP 包以及其依赖。</p>\n<h4 id=\"apt\"><a href=\"#apt\" class=\"headerlink\" title=\"apt\"></a>apt</h4><p>apt 是与 yum 对应的，是debian(ubuntu) Linux发行版本中的APT软件包管理工具。<br>所有基于debian的发行都使用这个包管理系统。<br>APT 的主要包管理工具为 APT-GET，通过此工具可满足和上述 YUM 相似的功能要求</p>\n<h3 id=\"Mac-OSX系统的软件安装\"><a href=\"#Mac-OSX系统的软件安装\" class=\"headerlink\" title=\"Mac OSX系统的软件安装\"></a>Mac OSX系统的软件安装</h3><p>Mac OSX系统是基于linux的，绝大多数特性和功能都喝linux相似。<br>但是也有很多不一样的地方，比如软件的安装。</p>\n<h4 id=\"brew\"><a href=\"#brew\" class=\"headerlink\" title=\"brew\"></a>brew</h4><p>brew 全称homebrew，是mac osx系统下的包管理器。</p>\n<h3 id=\"源码安装\"><a href=\"#源码安装\" class=\"headerlink\" title=\"源码安装\"></a>源码安装</h3><p>除了用上面的包管理工具安装软件外，还可以直接下载源码然后解压编译安装。</p>\n<h4 id=\"wget\"><a href=\"#wget\" class=\"headerlink\" title=\"wget\"></a>wget</h4><p>wget 是Linux系统中一个下载文件工具。<br>很多时候我们都需要用到这个命令去下载文件，比如下载软件源码。<br>源码包发布格式一般都是.tar.gz和.tar.bz2的。</p>\n<p>具体源码包的安装过程<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 第一步：解压文件（两种解压命令分别对应两种压缩格式）</span></span><br><span class=\"line\">tar -zxvf ×××.tar.gz</span><br><span class=\"line\">tar -jxvf ×××.tar.bz2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 第二步：执行配置文件，检测目标平台特征，一般会生成makefile文件。</span></span><br><span class=\"line\">./configure</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 第三步：make编译，将源码编译为二进制可执行程序</span></span><br><span class=\"line\">make</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 第四步： make install，安装，这一步需要root权限，因为要向系统写入文件</span></span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"linux系统的软件安装\"><a href=\"#linux系统的软件安装\" class=\"headerlink\" title=\"linux系统的软件安装\"></a>linux系统的软件安装</h3><p>在GNU/Linux操作系统中，rpm和dpkg是 <em>最为常见的两类</em> 软件包管理工具。<br>他们分别应用于 RPM 软件包的Linux发行版本和 DEB 软件包的Linux发行版本。</p>\n<p>RPM全称 Redhat Package Manager，最早由Red Hat公司制定实施，后被GNU开源操作系统接受，成为很多 Linux 系统的既定软件标准。<br>DEB是与RPM进行竞争的基于Debian操作系统(Ubuntu)的 DEB 软件包管理工具 - DPKG(Debian Package)</p>\n<h4 id=\"yum\"><a href=\"#yum\" class=\"headerlink\" title=\"yum\"></a>yum</h4><p>yum 基于 rpm 软件包管理工具，是一个shell前端软件包管理器，能够自动安装、更新 RMP 包以及其依赖。</p>\n<h4 id=\"apt\"><a href=\"#apt\" class=\"headerlink\" title=\"apt\"></a>apt</h4><p>apt 是与 yum 对应的，是debian(ubuntu) Linux发行版本中的APT软件包管理工具。<br>所有基于debian的发行都使用这个包管理系统。<br>APT 的主要包管理工具为 APT-GET，通过此工具可满足和上述 YUM 相似的功能要求</p>\n<h3 id=\"Mac-OSX系统的软件安装\"><a href=\"#Mac-OSX系统的软件安装\" class=\"headerlink\" title=\"Mac OSX系统的软件安装\"></a>Mac OSX系统的软件安装</h3><p>Mac OSX系统是基于linux的，绝大多数特性和功能都喝linux相似。<br>但是也有很多不一样的地方，比如软件的安装。</p>\n<h4 id=\"brew\"><a href=\"#brew\" class=\"headerlink\" title=\"brew\"></a>brew</h4><p>brew 全称homebrew，是mac osx系统下的包管理器。</p>\n<h3 id=\"源码安装\"><a href=\"#源码安装\" class=\"headerlink\" title=\"源码安装\"></a>源码安装</h3><p>除了用上面的包管理工具安装软件外，还可以直接下载源码然后解压编译安装。</p>\n<h4 id=\"wget\"><a href=\"#wget\" class=\"headerlink\" title=\"wget\"></a>wget</h4><p>wget 是Linux系统中一个下载文件工具。<br>很多时候我们都需要用到这个命令去下载文件，比如下载软件源码。<br>源码包发布格式一般都是.tar.gz和.tar.bz2的。</p>\n<p>具体源码包的安装过程<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 第一步：解压文件（两种解压命令分别对应两种压缩格式）</span></span><br><span class=\"line\">tar -zxvf ×××.tar.gz</span><br><span class=\"line\">tar -jxvf ×××.tar.bz2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 第二步：执行配置文件，检测目标平台特征，一般会生成makefile文件。</span></span><br><span class=\"line\">./configure</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 第三步：make编译，将源码编译为二进制可执行程序</span></span><br><span class=\"line\">make</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 第四步： make install，安装，这一步需要root权限，因为要向系统写入文件</span></span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure></p>\n"},{"layout":"default","title":"ssh命令笔记","date":"2020-10-10T16:00:00.000Z","_content":"\n#### ssh 简介\nssh命令是，secure shell 的缩写。\n是一种网络协议，用于机密两台计算机之前的通信，支持各种身份验证机制，主要用与保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。\n\n#### ssh 架构\nSSH 的软件架构是服务器-客户端模式（Server - Client）。在这个架构中，SSH 软件分成两个部分：\n向服务器发出请求的部分，称为客户端（client），OpenSSH 的实现为 ssh；\n接收客户端发出的请求的部分，称为服务器（server），OpenSSH 的实现为 sshd\n\n补充：\nOpenSSH（OpenBSD Secure Shell）是使用 SSH 透过计算机网络加密通信的实现，是一种实现方式。\n\n\n#### ssh 基本用法\n1.ssh 命令\nssh命令可用来登录远程机器，如：\n```shell\nssh user@hostname -p 端口 # ssh root@111.222.333 -p 8821 || ssh root@epoos.com -p 8821\nssh -l user hostname -p 端口 # ssh -l root 111.222.333 -p 8821\n```\nssh 在远程机器上执行命令\n```shell\nssh user@hostname ls # 在远程机器上执行 ls 命令\n```\n\n2.ssh -L命令\nssh -L 命令可以用来做本地转发，端口代理，将本地ip和端口通过跳板机代理到目标机器\n\n在本人日常工作中经常会遇到这样的场景，本地机器需要与测试服务器的某个*纯IP加端口的 http服务*进行直连，以便调试。\n但是，由于安全考虑，测试服务器往往不能与本地进行直连，哪怕是连了vpn也不行，唯一的办法就是通过跳板机转发，如图：\n<img src=\"http://zhoushirong.github.io/img/ssh-l.png\" alt=\"ssh-l图片\" width=\"350\" height=\"250\">\n此时，ssh -L命令就能派上用场了，如下命令\n```shell\n# ssh -L 本地IP:本地端口:目标机器ip:目标机器端口 跳板机用户名@跳板机IP -N(可选，加了之后不会登陆到跳板机，仅仅做转发功能)\n  ssh -L 127.0.0.1:8877:10.113.133.786:8877 root@10.101.111.122 -N\n```\n\n如果本地配置了跳板机的别名，则可直接使用别名\n```shell\nssh -L 127.0.0.1:8877:10.113.133.78:8877 tbj\n```\n跳板机本地别名配置如下（将此配置写在本地.ssh目录下的config文件，没有config文件则创建一个）\n```shell\nHost tbj\nHostName 10.101.111.122\nPort 1233\nUser root\nIdentityFile ~/.ssh/unamekey\n```\n如上示例，使用ssh -L 命令之后，在本地访问 127.0.0.1:8877 服务的时候，就会被跳板机代理到目标机器 10.113.133.786:8877 服务上了，此时本地即可访问到目标服务器的服务了。\n\n#### scp 命令\nscp 命令是 SSH 提供的一个客户端程序，用来在两台主机之间加密传送文件，可实现文件的上传和下载（可以利用此命令实现简单的应用程序发布）\nscp 命令相当于 ssh + cp，先登录到远程机器，然后再复制文件。\n\n```html\n本地复制到远程。\n远程复制到本地。\n两个远程系统之间的复制。\n```\n基本命令\n```shell\nscp source destination # source 是源文件，destination是目标文件，两个都可以带上host\n\n# 例：scp 远端的目标文件foo.txt 本地文件bar.txt\nscp user@host:foo.txt bar.txt\n\nscp -r documents username@serverhost:remote_path_dir # 将本机的 documents 目录拷贝到远程主机\nscp -r username@serverhost:remote_path_dir local_documents # 将远程的的 documents 目录拷贝到本地\n```\n\n#### rsync 命令\nrsync（remote sync）远程同步命令，是一个常用的 Linux 应用程序。\n可以用于本地计算机的两个目录之间的同步（能够很方便的实现应用程序发布，比scp更好用）。\n也可以在两台远程计算机直接进行文件同步（比如多点备份？）\nrsync 不是 SSH 工具集的一部分，需要手动安装此命令。\n\n```shell\n# 命令执行以后，目标目录下就会出现 destination/source 这个子目录\nrsync -r source destination # -r 命令表示递归，即包含子目录\nrsync -r source1 source2 destination # 多文件同步\nrsync -a source1 source2 destination # -a参数可以替代-r，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）\n\n#如果只想同步源目录source里面的内容到目标目录destination，则需要在源目录后面加上斜杠。\n# 命令执行后，source目录里面的内容，就都被复制到了destination目录里面，并不会在destination下面创建一个source子目录\nrsync -a source1/ source2/ destination\n```\n\n如果不确定 rsync 执行后会产生什么结果，可以先用 ***-n***或 --dry-run 参数模拟执行的结果。\n-n 参数模拟命令执行的结果，并不真的执行命令。***-v***参数则是将结果输出到终端，这样就可以看到哪些内容会被同步。\n```shell\nrsync -anv source/ destination\n```\n\n默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。\n如果要使得目标目录成为源目录的镜像副本，则必须使用 ***--delete*** 参数，这将删除只存在于目标目录、不存在于源目录的文件。\n```shell\nrsync -av --delete source/ destination\n```\n\n补充：\nrsync 的最大特点就是它可以完成增量备份，也就是默认只复制有变动的文件，能够极大地减少文件同步的时间。\n\n### 传送门\nhttps://wangdoc.com/ssh/basic.html","source":"_posts/ssh.md","raw":"---\nlayout: default\ntitle: ssh命令笔记\ndate: 2020/10/11\ntag: [ssh, scp, rsync]\ncategory: 笔记\n---\n\n#### ssh 简介\nssh命令是，secure shell 的缩写。\n是一种网络协议，用于机密两台计算机之前的通信，支持各种身份验证机制，主要用与保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。\n\n#### ssh 架构\nSSH 的软件架构是服务器-客户端模式（Server - Client）。在这个架构中，SSH 软件分成两个部分：\n向服务器发出请求的部分，称为客户端（client），OpenSSH 的实现为 ssh；\n接收客户端发出的请求的部分，称为服务器（server），OpenSSH 的实现为 sshd\n\n补充：\nOpenSSH（OpenBSD Secure Shell）是使用 SSH 透过计算机网络加密通信的实现，是一种实现方式。\n\n\n#### ssh 基本用法\n1.ssh 命令\nssh命令可用来登录远程机器，如：\n```shell\nssh user@hostname -p 端口 # ssh root@111.222.333 -p 8821 || ssh root@epoos.com -p 8821\nssh -l user hostname -p 端口 # ssh -l root 111.222.333 -p 8821\n```\nssh 在远程机器上执行命令\n```shell\nssh user@hostname ls # 在远程机器上执行 ls 命令\n```\n\n2.ssh -L命令\nssh -L 命令可以用来做本地转发，端口代理，将本地ip和端口通过跳板机代理到目标机器\n\n在本人日常工作中经常会遇到这样的场景，本地机器需要与测试服务器的某个*纯IP加端口的 http服务*进行直连，以便调试。\n但是，由于安全考虑，测试服务器往往不能与本地进行直连，哪怕是连了vpn也不行，唯一的办法就是通过跳板机转发，如图：\n<img src=\"http://zhoushirong.github.io/img/ssh-l.png\" alt=\"ssh-l图片\" width=\"350\" height=\"250\">\n此时，ssh -L命令就能派上用场了，如下命令\n```shell\n# ssh -L 本地IP:本地端口:目标机器ip:目标机器端口 跳板机用户名@跳板机IP -N(可选，加了之后不会登陆到跳板机，仅仅做转发功能)\n  ssh -L 127.0.0.1:8877:10.113.133.786:8877 root@10.101.111.122 -N\n```\n\n如果本地配置了跳板机的别名，则可直接使用别名\n```shell\nssh -L 127.0.0.1:8877:10.113.133.78:8877 tbj\n```\n跳板机本地别名配置如下（将此配置写在本地.ssh目录下的config文件，没有config文件则创建一个）\n```shell\nHost tbj\nHostName 10.101.111.122\nPort 1233\nUser root\nIdentityFile ~/.ssh/unamekey\n```\n如上示例，使用ssh -L 命令之后，在本地访问 127.0.0.1:8877 服务的时候，就会被跳板机代理到目标机器 10.113.133.786:8877 服务上了，此时本地即可访问到目标服务器的服务了。\n\n#### scp 命令\nscp 命令是 SSH 提供的一个客户端程序，用来在两台主机之间加密传送文件，可实现文件的上传和下载（可以利用此命令实现简单的应用程序发布）\nscp 命令相当于 ssh + cp，先登录到远程机器，然后再复制文件。\n\n```html\n本地复制到远程。\n远程复制到本地。\n两个远程系统之间的复制。\n```\n基本命令\n```shell\nscp source destination # source 是源文件，destination是目标文件，两个都可以带上host\n\n# 例：scp 远端的目标文件foo.txt 本地文件bar.txt\nscp user@host:foo.txt bar.txt\n\nscp -r documents username@serverhost:remote_path_dir # 将本机的 documents 目录拷贝到远程主机\nscp -r username@serverhost:remote_path_dir local_documents # 将远程的的 documents 目录拷贝到本地\n```\n\n#### rsync 命令\nrsync（remote sync）远程同步命令，是一个常用的 Linux 应用程序。\n可以用于本地计算机的两个目录之间的同步（能够很方便的实现应用程序发布，比scp更好用）。\n也可以在两台远程计算机直接进行文件同步（比如多点备份？）\nrsync 不是 SSH 工具集的一部分，需要手动安装此命令。\n\n```shell\n# 命令执行以后，目标目录下就会出现 destination/source 这个子目录\nrsync -r source destination # -r 命令表示递归，即包含子目录\nrsync -r source1 source2 destination # 多文件同步\nrsync -a source1 source2 destination # -a参数可以替代-r，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）\n\n#如果只想同步源目录source里面的内容到目标目录destination，则需要在源目录后面加上斜杠。\n# 命令执行后，source目录里面的内容，就都被复制到了destination目录里面，并不会在destination下面创建一个source子目录\nrsync -a source1/ source2/ destination\n```\n\n如果不确定 rsync 执行后会产生什么结果，可以先用 ***-n***或 --dry-run 参数模拟执行的结果。\n-n 参数模拟命令执行的结果，并不真的执行命令。***-v***参数则是将结果输出到终端，这样就可以看到哪些内容会被同步。\n```shell\nrsync -anv source/ destination\n```\n\n默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。\n如果要使得目标目录成为源目录的镜像副本，则必须使用 ***--delete*** 参数，这将删除只存在于目标目录、不存在于源目录的文件。\n```shell\nrsync -av --delete source/ destination\n```\n\n补充：\nrsync 的最大特点就是它可以完成增量备份，也就是默认只复制有变动的文件，能够极大地减少文件同步的时间。\n\n### 传送门\nhttps://wangdoc.com/ssh/basic.html","slug":"ssh","published":1,"updated":"2021-03-30T01:32:00.326Z","comments":1,"photos":[],"link":"","_id":"ckn2g7uga001qa0vzbldo7h9s","content":"<h4 id=\"ssh-简介\"><a href=\"#ssh-简介\" class=\"headerlink\" title=\"ssh 简介\"></a>ssh 简介</h4><p>ssh命令是，secure shell 的缩写。<br>是一种网络协议，用于机密两台计算机之前的通信，支持各种身份验证机制，主要用与保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。</p>\n<h4 id=\"ssh-架构\"><a href=\"#ssh-架构\" class=\"headerlink\" title=\"ssh 架构\"></a>ssh 架构</h4><p>SSH 的软件架构是服务器-客户端模式（Server - Client）。在这个架构中，SSH 软件分成两个部分：<br>向服务器发出请求的部分，称为客户端（client），OpenSSH 的实现为 ssh；<br>接收客户端发出的请求的部分，称为服务器（server），OpenSSH 的实现为 sshd</p>\n<p>补充：<br>OpenSSH（OpenBSD Secure Shell）是使用 SSH 透过计算机网络加密通信的实现，是一种实现方式。</p>\n<h4 id=\"ssh-基本用法\"><a href=\"#ssh-基本用法\" class=\"headerlink\" title=\"ssh 基本用法\"></a>ssh 基本用法</h4><p>1.ssh 命令<br>ssh命令可用来登录远程机器，如：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh user@hostname -p 端口 # ssh root@111.222.333 -p 8821 || ssh root@epoos.com -p 8821</span><br><span class=\"line\">ssh -l user hostname -p 端口 # ssh -l root 111.222.333 -p 8821</span><br></pre></td></tr></table></figure><br>ssh 在远程机器上执行命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh user@hostname ls # 在远程机器上执行 ls 命令</span><br></pre></td></tr></table></figure></p>\n<p>2.ssh -L命令<br>ssh -L 命令可以用来做本地转发，端口代理，将本地ip和端口通过跳板机代理到目标机器</p>\n<p>在本人日常工作中经常会遇到这样的场景，本地机器需要与测试服务器的某个<em>纯IP加端口的 http服务</em>进行直连，以便调试。<br>但是，由于安全考虑，测试服务器往往不能与本地进行直连，哪怕是连了vpn也不行，唯一的办法就是通过跳板机转发，如图：<br><img src=\"http://zhoushirong.github.io/img/ssh-l.png\" alt=\"ssh-l图片\" width=\"350\" height=\"250\"><br>此时，ssh -L命令就能派上用场了，如下命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ssh -L 本地IP:本地端口:目标机器ip:目标机器端口 跳板机用户名@跳板机IP -N(可选，加了之后不会登陆到跳板机，仅仅做转发功能)</span></span><br><span class=\"line\">  ssh -L 127.0.0.1:8877:10.113.133.786:8877 root@10.101.111.122 -N</span><br></pre></td></tr></table></figure></p>\n<p>如果本地配置了跳板机的别名，则可直接使用别名<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -L 127.0.0.1:8877:10.113.133.78:8877 tbj</span><br></pre></td></tr></table></figure><br>跳板机本地别名配置如下（将此配置写在本地.ssh目录下的config文件，没有config文件则创建一个）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host tbj</span><br><span class=\"line\">HostName 10.101.111.122</span><br><span class=\"line\">Port 1233</span><br><span class=\"line\">User root</span><br><span class=\"line\">IdentityFile ~/.ssh/unamekey</span><br></pre></td></tr></table></figure><br>如上示例，使用ssh -L 命令之后，在本地访问 127.0.0.1:8877 服务的时候，就会被跳板机代理到目标机器 10.113.133.786:8877 服务上了，此时本地即可访问到目标服务器的服务了。</p>\n<h4 id=\"scp-命令\"><a href=\"#scp-命令\" class=\"headerlink\" title=\"scp 命令\"></a>scp 命令</h4><p>scp 命令是 SSH 提供的一个客户端程序，用来在两台主机之间加密传送文件，可实现文件的上传和下载（可以利用此命令实现简单的应用程序发布）<br>scp 命令相当于 ssh + cp，先登录到远程机器，然后再复制文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地复制到远程。</span><br><span class=\"line\">远程复制到本地。</span><br><span class=\"line\">两个远程系统之间的复制。</span><br></pre></td></tr></table></figure>\n<p>基本命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp source destination # source 是源文件，destination是目标文件，两个都可以带上host</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例：scp 远端的目标文件foo.txt 本地文件bar.txt</span></span><br><span class=\"line\">scp user@host:foo.txt bar.txt</span><br><span class=\"line\"></span><br><span class=\"line\">scp -r documents username@serverhost:remote_path_dir # 将本机的 documents 目录拷贝到远程主机</span><br><span class=\"line\">scp -r username@serverhost:remote_path_dir local_documents # 将远程的的 documents 目录拷贝到本地</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"rsync-命令\"><a href=\"#rsync-命令\" class=\"headerlink\" title=\"rsync 命令\"></a>rsync 命令</h4><p>rsync（remote sync）远程同步命令，是一个常用的 Linux 应用程序。<br>可以用于本地计算机的两个目录之间的同步（能够很方便的实现应用程序发布，比scp更好用）。<br>也可以在两台远程计算机直接进行文件同步（比如多点备份？）<br>rsync 不是 SSH 工具集的一部分，需要手动安装此命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 命令执行以后，目标目录下就会出现 destination/<span class=\"built_in\">source</span> 这个子目录</span></span><br><span class=\"line\">rsync -r source destination # -r 命令表示递归，即包含子目录</span><br><span class=\"line\">rsync -r source1 source2 destination # 多文件同步</span><br><span class=\"line\">rsync -a source1 source2 destination # -a参数可以替代-r，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">如果只想同步源目录<span class=\"built_in\">source</span>里面的内容到目标目录destination，则需要在源目录后面加上斜杠。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 命令执行后，<span class=\"built_in\">source</span>目录里面的内容，就都被复制到了destination目录里面，并不会在destination下面创建一个<span class=\"built_in\">source</span>子目录</span></span><br><span class=\"line\">rsync -a source1/ source2/ destination</span><br></pre></td></tr></table></figure>\n<p>如果不确定 rsync 执行后会产生什么结果，可以先用 <strong><em>-n</em></strong>或 –dry-run 参数模拟执行的结果。<br>-n 参数模拟命令执行的结果，并不真的执行命令。<strong><em>-v</em></strong>参数则是将结果输出到终端，这样就可以看到哪些内容会被同步。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync -anv source/ destination</span><br></pre></td></tr></table></figure></p>\n<p>默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。<br>如果要使得目标目录成为源目录的镜像副本，则必须使用 <strong><em>–delete</em></strong> 参数，这将删除只存在于目标目录、不存在于源目录的文件。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync -av --delete source/ destination</span><br></pre></td></tr></table></figure></p>\n<p>补充：<br>rsync 的最大特点就是它可以完成增量备份，也就是默认只复制有变动的文件，能够极大地减少文件同步的时间。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://wangdoc.com/ssh/basic.html\">https://wangdoc.com/ssh/basic.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"ssh-简介\"><a href=\"#ssh-简介\" class=\"headerlink\" title=\"ssh 简介\"></a>ssh 简介</h4><p>ssh命令是，secure shell 的缩写。<br>是一种网络协议，用于机密两台计算机之前的通信，支持各种身份验证机制，主要用与保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。</p>\n<h4 id=\"ssh-架构\"><a href=\"#ssh-架构\" class=\"headerlink\" title=\"ssh 架构\"></a>ssh 架构</h4><p>SSH 的软件架构是服务器-客户端模式（Server - Client）。在这个架构中，SSH 软件分成两个部分：<br>向服务器发出请求的部分，称为客户端（client），OpenSSH 的实现为 ssh；<br>接收客户端发出的请求的部分，称为服务器（server），OpenSSH 的实现为 sshd</p>\n<p>补充：<br>OpenSSH（OpenBSD Secure Shell）是使用 SSH 透过计算机网络加密通信的实现，是一种实现方式。</p>\n<h4 id=\"ssh-基本用法\"><a href=\"#ssh-基本用法\" class=\"headerlink\" title=\"ssh 基本用法\"></a>ssh 基本用法</h4><p>1.ssh 命令<br>ssh命令可用来登录远程机器，如：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh user@hostname -p 端口 # ssh root@111.222.333 -p 8821 || ssh root@epoos.com -p 8821</span><br><span class=\"line\">ssh -l user hostname -p 端口 # ssh -l root 111.222.333 -p 8821</span><br></pre></td></tr></table></figure><br>ssh 在远程机器上执行命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh user@hostname ls # 在远程机器上执行 ls 命令</span><br></pre></td></tr></table></figure></p>\n<p>2.ssh -L命令<br>ssh -L 命令可以用来做本地转发，端口代理，将本地ip和端口通过跳板机代理到目标机器</p>\n<p>在本人日常工作中经常会遇到这样的场景，本地机器需要与测试服务器的某个<em>纯IP加端口的 http服务</em>进行直连，以便调试。<br>但是，由于安全考虑，测试服务器往往不能与本地进行直连，哪怕是连了vpn也不行，唯一的办法就是通过跳板机转发，如图：<br><img src=\"http://zhoushirong.github.io/img/ssh-l.png\" alt=\"ssh-l图片\" width=\"350\" height=\"250\"><br>此时，ssh -L命令就能派上用场了，如下命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ssh -L 本地IP:本地端口:目标机器ip:目标机器端口 跳板机用户名@跳板机IP -N(可选，加了之后不会登陆到跳板机，仅仅做转发功能)</span></span><br><span class=\"line\">  ssh -L 127.0.0.1:8877:10.113.133.786:8877 root@10.101.111.122 -N</span><br></pre></td></tr></table></figure></p>\n<p>如果本地配置了跳板机的别名，则可直接使用别名<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -L 127.0.0.1:8877:10.113.133.78:8877 tbj</span><br></pre></td></tr></table></figure><br>跳板机本地别名配置如下（将此配置写在本地.ssh目录下的config文件，没有config文件则创建一个）<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host tbj</span><br><span class=\"line\">HostName 10.101.111.122</span><br><span class=\"line\">Port 1233</span><br><span class=\"line\">User root</span><br><span class=\"line\">IdentityFile ~/.ssh/unamekey</span><br></pre></td></tr></table></figure><br>如上示例，使用ssh -L 命令之后，在本地访问 127.0.0.1:8877 服务的时候，就会被跳板机代理到目标机器 10.113.133.786:8877 服务上了，此时本地即可访问到目标服务器的服务了。</p>\n<h4 id=\"scp-命令\"><a href=\"#scp-命令\" class=\"headerlink\" title=\"scp 命令\"></a>scp 命令</h4><p>scp 命令是 SSH 提供的一个客户端程序，用来在两台主机之间加密传送文件，可实现文件的上传和下载（可以利用此命令实现简单的应用程序发布）<br>scp 命令相当于 ssh + cp，先登录到远程机器，然后再复制文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地复制到远程。</span><br><span class=\"line\">远程复制到本地。</span><br><span class=\"line\">两个远程系统之间的复制。</span><br></pre></td></tr></table></figure>\n<p>基本命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp source destination # source 是源文件，destination是目标文件，两个都可以带上host</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例：scp 远端的目标文件foo.txt 本地文件bar.txt</span></span><br><span class=\"line\">scp user@host:foo.txt bar.txt</span><br><span class=\"line\"></span><br><span class=\"line\">scp -r documents username@serverhost:remote_path_dir # 将本机的 documents 目录拷贝到远程主机</span><br><span class=\"line\">scp -r username@serverhost:remote_path_dir local_documents # 将远程的的 documents 目录拷贝到本地</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"rsync-命令\"><a href=\"#rsync-命令\" class=\"headerlink\" title=\"rsync 命令\"></a>rsync 命令</h4><p>rsync（remote sync）远程同步命令，是一个常用的 Linux 应用程序。<br>可以用于本地计算机的两个目录之间的同步（能够很方便的实现应用程序发布，比scp更好用）。<br>也可以在两台远程计算机直接进行文件同步（比如多点备份？）<br>rsync 不是 SSH 工具集的一部分，需要手动安装此命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 命令执行以后，目标目录下就会出现 destination/<span class=\"built_in\">source</span> 这个子目录</span></span><br><span class=\"line\">rsync -r source destination # -r 命令表示递归，即包含子目录</span><br><span class=\"line\">rsync -r source1 source2 destination # 多文件同步</span><br><span class=\"line\">rsync -a source1 source2 destination # -a参数可以替代-r，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">如果只想同步源目录<span class=\"built_in\">source</span>里面的内容到目标目录destination，则需要在源目录后面加上斜杠。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 命令执行后，<span class=\"built_in\">source</span>目录里面的内容，就都被复制到了destination目录里面，并不会在destination下面创建一个<span class=\"built_in\">source</span>子目录</span></span><br><span class=\"line\">rsync -a source1/ source2/ destination</span><br></pre></td></tr></table></figure>\n<p>如果不确定 rsync 执行后会产生什么结果，可以先用 <strong><em>-n</em></strong>或 –dry-run 参数模拟执行的结果。<br>-n 参数模拟命令执行的结果，并不真的执行命令。<strong><em>-v</em></strong>参数则是将结果输出到终端，这样就可以看到哪些内容会被同步。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync -anv source/ destination</span><br></pre></td></tr></table></figure></p>\n<p>默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。<br>如果要使得目标目录成为源目录的镜像副本，则必须使用 <strong><em>–delete</em></strong> 参数，这将删除只存在于目标目录、不存在于源目录的文件。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync -av --delete source/ destination</span><br></pre></td></tr></table></figure></p>\n<p>补充：<br>rsync 的最大特点就是它可以完成增量备份，也就是默认只复制有变动的文件，能够极大地减少文件同步的时间。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://wangdoc.com/ssh/basic.html\">https://wangdoc.com/ssh/basic.html</a></p>\n"},{"title":"svn入门","date":"2017-04-10T16:00:00.000Z","_content":"\n\nsvn\n\n### Mac上用命令行使用svn\n\n``` shell\nsvn checkout：将服务器代码完整的下载到本地\n\nsvn commit：将本地修改的内容提交到服务器\n\nsvn update：将服务器最新代码下载到本地\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/svn.md","raw":"---\ntitle: svn入门\ntag: svn\ndate: 2017/04/11\ncategory: 技术\n---\n\n\nsvn\n\n### Mac上用命令行使用svn\n\n``` shell\nsvn checkout：将服务器代码完整的下载到本地\n\nsvn commit：将本地修改的内容提交到服务器\n\nsvn update：将服务器最新代码下载到本地\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"svn","published":1,"updated":"2021-03-30T01:32:00.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ugb001ra0vzh59wfqtf","content":"<p>svn</p>\n<h3 id=\"Mac上用命令行使用svn\"><a href=\"#Mac上用命令行使用svn\" class=\"headerlink\" title=\"Mac上用命令行使用svn\"></a>Mac上用命令行使用svn</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn checkout：将服务器代码完整的下载到本地</span><br><span class=\"line\"></span><br><span class=\"line\">svn commit：将本地修改的内容提交到服务器</span><br><span class=\"line\"></span><br><span class=\"line\">svn update：将服务器最新代码下载到本地</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>svn</p>\n<h3 id=\"Mac上用命令行使用svn\"><a href=\"#Mac上用命令行使用svn\" class=\"headerlink\" title=\"Mac上用命令行使用svn\"></a>Mac上用命令行使用svn</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn checkout：将服务器代码完整的下载到本地</span><br><span class=\"line\"></span><br><span class=\"line\">svn commit：将本地修改的内容提交到服务器</span><br><span class=\"line\"></span><br><span class=\"line\">svn update：将服务器最新代码下载到本地</span><br></pre></td></tr></table></figure>\n"},{"title":"Vim入门","date":"2016-12-30T16:00:00.000Z","_content":"\nVim是从vi发展出来的一个文本编辑器,在程序员中尤其受欢迎，虽然一般人（包括一般的程序员）都不一定能够熟练、经常使用它们，但是这并不影响的地位，至少目前为止还没有人能够替代它成为人们的‘信仰’，毕竟编辑器之神的称号不是白叫的。\n早就对它仰慕已久，只不过迟迟未能正式与它见面。作为一名前端开发工程师，因为Nodejs的大火而开始接触到服务端的知识，这也就不可避免的需要在非可视化界面以及无鼠标环境进行操作了，这时候vim的价值就更加凸显了，下面记录一下学习vim的一些笔记。\n\n\n#### 普通模式(Normal Mode)\n\n在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。\n这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。\n\n``` shell\ngg 回到最前一行\n\nG 回到最后一行\n\nnG 跳到第n行 （n为int数值）\n\nctl+b 向上滚动一页\n\nctl+f 向下滚动一页\n\ndd 删除一行\n\nx 删除游标所在的字符\n\nX 删除游标所在字符的前一个字符\n\nd^ 删除至行首\n\n2dd 删除2行\n\nu 撤销修改\n\n全局替换命令为：:%s/源字符串/目的字符串/g\n```\n\n在普通模式有如下方位键\n\n``` shell\nh   左\nl   右（小写L）\nj   下\nk   上\nw   移动到下一个单词\nb   移动到上一个单词\n```\n\n### 命令行模式（Command-Line）\n\n在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（\":\"键），搜索（\"/\"和\"?\"键）或者过滤命令（\"!\"键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。\n\n``` shell\n:q! 强制保存\n\n:q 退出\n\n:wq 保存并退出\n\n:x 保存并退出\n\n:wq! 强制保存并退出\n\n```\n\n命令模式对vim编辑器进行设置\n\n``` shell\nsyntax on                   \" 自动语法高亮\n\ncolorscheme torte           \"配置颜色方案\n\nset number                  \" 显示行号\n\nset cursorline              \" 突出显示当前行\n\nset wildmenu                \"Turn on WiLd menu 在末行命令行敲tab键时会在状态栏显示选项\n\nset whichwrap+=h,           \"Bbackspace and cursor keys wrap to 使指定的左右移动光标的键在行首或行尾可以移到前一行或者后一行\n\nset shiftwidth=4            \" 设定 << 和 >> 命令移动时的宽度为 4\n\nset softtabstop=4           \" 使得按退格键时可以一次删掉 4 个空格\n\nset tabstop=4               \" 设定 tab 长度为 4\n\nset nobackup                \" 覆盖文件时不备份\n\nset autochdir               \" 自动切换当前目录为当前文件所在的目录\n```\n\n\n### 插入模式（Insert Mode）\n\n进入vim编辑之后，默认为普通模式，普通模式下，可以按i\\I，a\\A，o\\O进入，这几个进入插入模式后位置不同。\n在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。在插入模式中，可以按ESC键回到普通模式。\n\n\n\n### 可视模式（Visual Mode）\n\n这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的\"文本对象\"也能和移动命令一样用在这个模式中。\n\n\n### 选择模式（Select Mode）\n\n这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。\n\n\n\n### 格式化代码\n\n``` shell\ngg=G\n```\n\n\n### Ex模式（Ex Mode）\n\n普通模式下键入Q进入该模式\n\n这和命令行模式比较相似，在使用\":visual\"命令离开Ex模式前，可以一次执行多条命令。\n\n上面的都是vim的基本模式，其次还有派生模式，这个模式包含：操作符等待模式、插入普通模式、插入可视模式、插入选择模式、替换模式、其他\n\n### item\n```shell\ncommand+option+方向键 #切换item屏幕\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/vim.md","raw":"---\ntitle: Vim入门\ntag: vim\ndate: 2016/12/31\ncategory: 技术\n---\n\nVim是从vi发展出来的一个文本编辑器,在程序员中尤其受欢迎，虽然一般人（包括一般的程序员）都不一定能够熟练、经常使用它们，但是这并不影响的地位，至少目前为止还没有人能够替代它成为人们的‘信仰’，毕竟编辑器之神的称号不是白叫的。\n早就对它仰慕已久，只不过迟迟未能正式与它见面。作为一名前端开发工程师，因为Nodejs的大火而开始接触到服务端的知识，这也就不可避免的需要在非可视化界面以及无鼠标环境进行操作了，这时候vim的价值就更加凸显了，下面记录一下学习vim的一些笔记。\n\n\n#### 普通模式(Normal Mode)\n\n在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。\n这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。\n\n``` shell\ngg 回到最前一行\n\nG 回到最后一行\n\nnG 跳到第n行 （n为int数值）\n\nctl+b 向上滚动一页\n\nctl+f 向下滚动一页\n\ndd 删除一行\n\nx 删除游标所在的字符\n\nX 删除游标所在字符的前一个字符\n\nd^ 删除至行首\n\n2dd 删除2行\n\nu 撤销修改\n\n全局替换命令为：:%s/源字符串/目的字符串/g\n```\n\n在普通模式有如下方位键\n\n``` shell\nh   左\nl   右（小写L）\nj   下\nk   上\nw   移动到下一个单词\nb   移动到上一个单词\n```\n\n### 命令行模式（Command-Line）\n\n在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（\":\"键），搜索（\"/\"和\"?\"键）或者过滤命令（\"!\"键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。\n\n``` shell\n:q! 强制保存\n\n:q 退出\n\n:wq 保存并退出\n\n:x 保存并退出\n\n:wq! 强制保存并退出\n\n```\n\n命令模式对vim编辑器进行设置\n\n``` shell\nsyntax on                   \" 自动语法高亮\n\ncolorscheme torte           \"配置颜色方案\n\nset number                  \" 显示行号\n\nset cursorline              \" 突出显示当前行\n\nset wildmenu                \"Turn on WiLd menu 在末行命令行敲tab键时会在状态栏显示选项\n\nset whichwrap+=h,           \"Bbackspace and cursor keys wrap to 使指定的左右移动光标的键在行首或行尾可以移到前一行或者后一行\n\nset shiftwidth=4            \" 设定 << 和 >> 命令移动时的宽度为 4\n\nset softtabstop=4           \" 使得按退格键时可以一次删掉 4 个空格\n\nset tabstop=4               \" 设定 tab 长度为 4\n\nset nobackup                \" 覆盖文件时不备份\n\nset autochdir               \" 自动切换当前目录为当前文件所在的目录\n```\n\n\n### 插入模式（Insert Mode）\n\n进入vim编辑之后，默认为普通模式，普通模式下，可以按i\\I，a\\A，o\\O进入，这几个进入插入模式后位置不同。\n在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。在插入模式中，可以按ESC键回到普通模式。\n\n\n\n### 可视模式（Visual Mode）\n\n这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的\"文本对象\"也能和移动命令一样用在这个模式中。\n\n\n### 选择模式（Select Mode）\n\n这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。\n\n\n\n### 格式化代码\n\n``` shell\ngg=G\n```\n\n\n### Ex模式（Ex Mode）\n\n普通模式下键入Q进入该模式\n\n这和命令行模式比较相似，在使用\":visual\"命令离开Ex模式前，可以一次执行多条命令。\n\n上面的都是vim的基本模式，其次还有派生模式，这个模式包含：操作符等待模式、插入普通模式、插入可视模式、插入选择模式、替换模式、其他\n\n### item\n```shell\ncommand+option+方向键 #切换item屏幕\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"vim","published":1,"updated":"2021-03-30T01:32:00.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ugb001sa0vz1g5r2q3q","content":"<p>Vim是从vi发展出来的一个文本编辑器,在程序员中尤其受欢迎，虽然一般人（包括一般的程序员）都不一定能够熟练、经常使用它们，但是这并不影响的地位，至少目前为止还没有人能够替代它成为人们的‘信仰’，毕竟编辑器之神的称号不是白叫的。<br>早就对它仰慕已久，只不过迟迟未能正式与它见面。作为一名前端开发工程师，因为Nodejs的大火而开始接触到服务端的知识，这也就不可避免的需要在非可视化界面以及无鼠标环境进行操作了，这时候vim的价值就更加凸显了，下面记录一下学习vim的一些笔记。</p>\n<h4 id=\"普通模式-Normal-Mode\"><a href=\"#普通模式-Normal-Mode\" class=\"headerlink\" title=\"普通模式(Normal Mode)\"></a>普通模式(Normal Mode)</h4><p>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。<br>这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gg 回到最前一行</span><br><span class=\"line\"></span><br><span class=\"line\">G 回到最后一行</span><br><span class=\"line\"></span><br><span class=\"line\">nG 跳到第n行 （n为int数值）</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+b 向上滚动一页</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+f 向下滚动一页</span><br><span class=\"line\"></span><br><span class=\"line\">dd 删除一行</span><br><span class=\"line\"></span><br><span class=\"line\">x 删除游标所在的字符</span><br><span class=\"line\"></span><br><span class=\"line\">X 删除游标所在字符的前一个字符</span><br><span class=\"line\"></span><br><span class=\"line\">d^ 删除至行首</span><br><span class=\"line\"></span><br><span class=\"line\">2dd 删除2行</span><br><span class=\"line\"></span><br><span class=\"line\">u 撤销修改</span><br><span class=\"line\"></span><br><span class=\"line\">全局替换命令为：:%s/源字符串/目的字符串/g</span><br></pre></td></tr></table></figure>\n<p>在普通模式有如下方位键</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h   左</span><br><span class=\"line\">l   右（小写L）</span><br><span class=\"line\">j   下</span><br><span class=\"line\">k   上</span><br><span class=\"line\">w   移动到下一个单词</span><br><span class=\"line\">b   移动到上一个单词</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令行模式（Command-Line）\"><a href=\"#命令行模式（Command-Line）\" class=\"headerlink\" title=\"命令行模式（Command-Line）\"></a>命令行模式（Command-Line）</h3><p>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（”:”键），搜索（”/“和”?”键）或者过滤命令（”!”键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:q! 强制保存</span><br><span class=\"line\"></span><br><span class=\"line\">:q 退出</span><br><span class=\"line\"></span><br><span class=\"line\">:wq 保存并退出</span><br><span class=\"line\"></span><br><span class=\"line\">:x 保存并退出</span><br><span class=\"line\"></span><br><span class=\"line\">:wq! 强制保存并退出</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>命令模式对vim编辑器进行设置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax on                   &quot; 自动语法高亮</span><br><span class=\"line\"></span><br><span class=\"line\">colorscheme torte           &quot;配置颜色方案</span><br><span class=\"line\"></span><br><span class=\"line\">set number                  &quot; 显示行号</span><br><span class=\"line\"></span><br><span class=\"line\">set cursorline              &quot; 突出显示当前行</span><br><span class=\"line\"></span><br><span class=\"line\">set wildmenu                &quot;Turn on WiLd menu 在末行命令行敲tab键时会在状态栏显示选项</span><br><span class=\"line\"></span><br><span class=\"line\">set whichwrap+=h,           &quot;Bbackspace and cursor keys wrap to 使指定的左右移动光标的键在行首或行尾可以移到前一行或者后一行</span><br><span class=\"line\"></span><br><span class=\"line\">set shiftwidth=4            &quot; 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4</span><br><span class=\"line\"></span><br><span class=\"line\">set softtabstop=4           &quot; 使得按退格键时可以一次删掉 4 个空格</span><br><span class=\"line\"></span><br><span class=\"line\">set tabstop=4               &quot; 设定 tab 长度为 4</span><br><span class=\"line\"></span><br><span class=\"line\">set nobackup                &quot; 覆盖文件时不备份</span><br><span class=\"line\"></span><br><span class=\"line\">set autochdir               &quot; 自动切换当前目录为当前文件所在的目录</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入模式（Insert-Mode）\"><a href=\"#插入模式（Insert-Mode）\" class=\"headerlink\" title=\"插入模式（Insert Mode）\"></a>插入模式（Insert Mode）</h3><p>进入vim编辑之后，默认为普通模式，普通模式下，可以按i\\I，a\\A，o\\O进入，这几个进入插入模式后位置不同。<br>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。在插入模式中，可以按ESC键回到普通模式。</p>\n<h3 id=\"可视模式（Visual-Mode）\"><a href=\"#可视模式（Visual-Mode）\" class=\"headerlink\" title=\"可视模式（Visual Mode）\"></a>可视模式（Visual Mode）</h3><p>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。</p>\n<h3 id=\"选择模式（Select-Mode）\"><a href=\"#选择模式（Select-Mode）\" class=\"headerlink\" title=\"选择模式（Select Mode）\"></a>选择模式（Select Mode）</h3><p>这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p>\n<h3 id=\"格式化代码\"><a href=\"#格式化代码\" class=\"headerlink\" title=\"格式化代码\"></a>格式化代码</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gg=G</span><br></pre></td></tr></table></figure>\n<h3 id=\"Ex模式（Ex-Mode）\"><a href=\"#Ex模式（Ex-Mode）\" class=\"headerlink\" title=\"Ex模式（Ex Mode）\"></a>Ex模式（Ex Mode）</h3><p>普通模式下键入Q进入该模式</p>\n<p>这和命令行模式比较相似，在使用”:visual”命令离开Ex模式前，可以一次执行多条命令。</p>\n<p>上面的都是vim的基本模式，其次还有派生模式，这个模式包含：操作符等待模式、插入普通模式、插入可视模式、插入选择模式、替换模式、其他</p>\n<h3 id=\"item\"><a href=\"#item\" class=\"headerlink\" title=\"item\"></a>item</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command+option+方向键 #切换item屏幕</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Vim是从vi发展出来的一个文本编辑器,在程序员中尤其受欢迎，虽然一般人（包括一般的程序员）都不一定能够熟练、经常使用它们，但是这并不影响的地位，至少目前为止还没有人能够替代它成为人们的‘信仰’，毕竟编辑器之神的称号不是白叫的。<br>早就对它仰慕已久，只不过迟迟未能正式与它见面。作为一名前端开发工程师，因为Nodejs的大火而开始接触到服务端的知识，这也就不可避免的需要在非可视化界面以及无鼠标环境进行操作了，这时候vim的价值就更加凸显了，下面记录一下学习vim的一些笔记。</p>\n<h4 id=\"普通模式-Normal-Mode\"><a href=\"#普通模式-Normal-Mode\" class=\"headerlink\" title=\"普通模式(Normal Mode)\"></a>普通模式(Normal Mode)</h4><p>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。<br>这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gg 回到最前一行</span><br><span class=\"line\"></span><br><span class=\"line\">G 回到最后一行</span><br><span class=\"line\"></span><br><span class=\"line\">nG 跳到第n行 （n为int数值）</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+b 向上滚动一页</span><br><span class=\"line\"></span><br><span class=\"line\">ctl+f 向下滚动一页</span><br><span class=\"line\"></span><br><span class=\"line\">dd 删除一行</span><br><span class=\"line\"></span><br><span class=\"line\">x 删除游标所在的字符</span><br><span class=\"line\"></span><br><span class=\"line\">X 删除游标所在字符的前一个字符</span><br><span class=\"line\"></span><br><span class=\"line\">d^ 删除至行首</span><br><span class=\"line\"></span><br><span class=\"line\">2dd 删除2行</span><br><span class=\"line\"></span><br><span class=\"line\">u 撤销修改</span><br><span class=\"line\"></span><br><span class=\"line\">全局替换命令为：:%s/源字符串/目的字符串/g</span><br></pre></td></tr></table></figure>\n<p>在普通模式有如下方位键</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h   左</span><br><span class=\"line\">l   右（小写L）</span><br><span class=\"line\">j   下</span><br><span class=\"line\">k   上</span><br><span class=\"line\">w   移动到下一个单词</span><br><span class=\"line\">b   移动到上一个单词</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令行模式（Command-Line）\"><a href=\"#命令行模式（Command-Line）\" class=\"headerlink\" title=\"命令行模式（Command-Line）\"></a>命令行模式（Command-Line）</h3><p>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（”:”键），搜索（”/“和”?”键）或者过滤命令（”!”键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:q! 强制保存</span><br><span class=\"line\"></span><br><span class=\"line\">:q 退出</span><br><span class=\"line\"></span><br><span class=\"line\">:wq 保存并退出</span><br><span class=\"line\"></span><br><span class=\"line\">:x 保存并退出</span><br><span class=\"line\"></span><br><span class=\"line\">:wq! 强制保存并退出</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>命令模式对vim编辑器进行设置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax on                   &quot; 自动语法高亮</span><br><span class=\"line\"></span><br><span class=\"line\">colorscheme torte           &quot;配置颜色方案</span><br><span class=\"line\"></span><br><span class=\"line\">set number                  &quot; 显示行号</span><br><span class=\"line\"></span><br><span class=\"line\">set cursorline              &quot; 突出显示当前行</span><br><span class=\"line\"></span><br><span class=\"line\">set wildmenu                &quot;Turn on WiLd menu 在末行命令行敲tab键时会在状态栏显示选项</span><br><span class=\"line\"></span><br><span class=\"line\">set whichwrap+=h,           &quot;Bbackspace and cursor keys wrap to 使指定的左右移动光标的键在行首或行尾可以移到前一行或者后一行</span><br><span class=\"line\"></span><br><span class=\"line\">set shiftwidth=4            &quot; 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4</span><br><span class=\"line\"></span><br><span class=\"line\">set softtabstop=4           &quot; 使得按退格键时可以一次删掉 4 个空格</span><br><span class=\"line\"></span><br><span class=\"line\">set tabstop=4               &quot; 设定 tab 长度为 4</span><br><span class=\"line\"></span><br><span class=\"line\">set nobackup                &quot; 覆盖文件时不备份</span><br><span class=\"line\"></span><br><span class=\"line\">set autochdir               &quot; 自动切换当前目录为当前文件所在的目录</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入模式（Insert-Mode）\"><a href=\"#插入模式（Insert-Mode）\" class=\"headerlink\" title=\"插入模式（Insert Mode）\"></a>插入模式（Insert Mode）</h3><p>进入vim编辑之后，默认为普通模式，普通模式下，可以按i\\I，a\\A，o\\O进入，这几个进入插入模式后位置不同。<br>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。在插入模式中，可以按ESC键回到普通模式。</p>\n<h3 id=\"可视模式（Visual-Mode）\"><a href=\"#可视模式（Visual-Mode）\" class=\"headerlink\" title=\"可视模式（Visual Mode）\"></a>可视模式（Visual Mode）</h3><p>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。</p>\n<h3 id=\"选择模式（Select-Mode）\"><a href=\"#选择模式（Select-Mode）\" class=\"headerlink\" title=\"选择模式（Select Mode）\"></a>选择模式（Select Mode）</h3><p>这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p>\n<h3 id=\"格式化代码\"><a href=\"#格式化代码\" class=\"headerlink\" title=\"格式化代码\"></a>格式化代码</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gg=G</span><br></pre></td></tr></table></figure>\n<h3 id=\"Ex模式（Ex-Mode）\"><a href=\"#Ex模式（Ex-Mode）\" class=\"headerlink\" title=\"Ex模式（Ex Mode）\"></a>Ex模式（Ex Mode）</h3><p>普通模式下键入Q进入该模式</p>\n<p>这和命令行模式比较相似，在使用”:visual”命令离开Ex模式前，可以一次执行多条命令。</p>\n<p>上面的都是vim的基本模式，其次还有派生模式，这个模式包含：操作符等待模式、插入普通模式、插入可视模式、插入选择模式、替换模式、其他</p>\n<h3 id=\"item\"><a href=\"#item\" class=\"headerlink\" title=\"item\"></a>item</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command+option+方向键 #切换item屏幕</span><br></pre></td></tr></table></figure>\n"},{"title":"Vue的虚拟DOM","date":"2021-01-03T16:00:00.000Z","_content":"\n#### 什么是虚拟 DOM\n虚拟DOM是对DOM的一层抽象，以Javascript对象（VNode节点）作为基础的树。\n用对象的属性描述节点，最后通过一些方法将其映射为真实的环境上，因此可实现跨平台。\n当前主流前端框架React、Vue以及各种小程序的界面渲染都是用到的虚拟DOM技术。\n\n```html\n<div id=\"app\">\n  <p class=\"text\">hello world!!!</p>\n</div>\n```\n```javascript\nconst vNode = {\n  tag: 'div',\n  props: { id: 'app' },\n  chidren: [{\n    tag: 'p',\n    props: { className: 'text' },\n    chidren: [ 'hello world!!!' ]\n  }]\n}\n```\n该js对象就是虚拟 DOM 了，它以js对象的形式描述了 DOM 节点。后续如果有 DOM 操作，不会直接操作 DOM，而是先变更 js 对象，然后 使用 diff 算法计算出新老对象之间的差异。最后最小范围的直接替换掉有变化的节点。\n\n#### 虚拟 DOM 的优势\n原生 DOM 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 div 也要付出昂贵的代价。\n```javascript\nvar arr = []\nvar div = document.createElement('div')\nfor (let i in div){ arr.push(i) }\nconsole.log(arr.length) // 314\n```\n上面代码输出可以看出，即使创建一个简单的DIV，就需要为其添加314个属性，如果之后直接操作该 DIV，应该会消耗掉不少的资源。\n\n而对于虚拟DOM，我们只需要创建和维护几个我们用得上的必要属性，之后无论是增删查改还是通过diff算法计算出差异点，都是能够大大提高其效率的。\n因此使用虚拟DOM，我们能够以最小代价的预处理DOM，最后一步到位渲染成真实的DOM。\n\n当然这并不是虚拟DOM的主要优势，因为即使是原生的DOM操作也可以人为的控制批量操作DOM，通过减少DOM操作能够最大限度的解决这个效能问题。\n\n虚拟DOM的**最大的优势**在于它可以接受 Parser 解析转化，这意味着其实相当多的东西我们都可以在编译阶段解决，比如：xss 攻击过滤。\n除此之外，因为虚拟DOM是一个用 js 对象描述的DOM抽象，所以只要为这个抽象实现一个与之对应的UI层的映射，那么就可以将其应用到相应的UI处理，这也是为什么虚拟DOM能够实现跨平台的原因了。\n\n#### Vue使用虚拟DOM渲染页面的完整过程\n1.挂载，通过调用Vue.prototype.$mount()方法实现Vue页面的挂载\n2.通过编译器来解析Template模板之后，生成render函数\n3.调用vm._render()，将render函数转换为虚拟DOM\n4.调用vm._update()，将虚拟DOM渲染为真实DOM\n\nVue是通过修改数据来更新视图的，当某个数据被修改的时候，set方法会让闭包中的Dep调用notify通知所有订阅者Watcher\nWatcher通过get方法执行_update\n```javascript\n// _update 的调用时机有两个，一个是发生在初次渲染阶段，另一个发生数据更新阶段。\n// _update 第一个参数是 vNode对象，update内部会先执行patch方法，该方法使用 diff算法 计算出最小的视图修改。\nVNode = vm._render()\nvm._update(VNode)\n```\n\n#### diff算法\ndiff算法通过同层的树节点比较，时间复杂度只有O(n)\n只有Vnode节点相同（是同一个节点）的时候才会进行节点比较（patchVnode），否则直接删除旧节点，添加新节点。\n##### 判断是否同一个节点的标准\n```html\nkey相同\ntag标签名相同\n是否同为注释节点\n是否都有data\n当为input标签的时候，type是否相同\n```\n\n##### 新老节点 patchVnode 过程\n```html\n若 都是静态节点判断key是否相同（相同表示为同一节点），且新VNode是clone或是标记了once，则直接替换elm以及componentInstance。\n若 均有children子节点，则对子节点进行diff操作，调用 updateChildren（diff算法的核心）。\n若 老节点无子节点，新节点有子节点，先清空老节点DOM的文本内容，再为改DOM加入新子节点。\n若 新节点无子节点，老节点有子节点，移除该DOM节点的所有子节点。\n若 新老节点都无子节点的时候，仅进行文本的替换。\n```\n\n##### updateChildren过程\n```html\n新老节点的左右两边 子节点 各起一个变量标记（oldStartVnode, newStartVnode, oldEndVnode, oldEndVnode），遍历的过程两边的标记向中间靠拢，直到全部遍历完成。\n要点：oldStartVnode、oldEndVnode与newStartVnode、newEndVnode 两两比较一共会有 2*2=4 种比较方法\n\n遍历过程中：\n如 存在key，且为相同节点，则复用节点\n如 sameVnode(oldStartVnode, newStartVnode) 或 sameVnode(oldEndVnode, newEndVnode)，则直接对该节点进行 pathVnode\n如 sameVnode(oldStartVnode, newEndVnode)，则进行 patchVnode 的同时还需要将真实DOM节点移动到 oldEndVnode 的后面\n如 sameVnode(oldEndVnode, newStartVnode)，则进行 patchVnode 的同时还需要将真实DOM节点移动到 oldStartVnode 的前面\n非上述情况，则创建 oldKeyToIdx: { [旧的VNode]: index }，从中刚找到含有与 newStartVnode 的key一致的节点X，\n  1）如sameVnode(x, newStartVnode) ，则进行 patchVnode 的同时将这个真实DOM移动到 oldStartVnode 对应的真实DOM的前面。\n  2）如notSameVnode(x, newStartVnode) ，则调用 createElm 创建一个新的节点。\n\n结束时\n如 新节点 多余 老节点，则将多余VNode节点插入到真实DOM中去\n如 新节点 少于 老节点，则删除多余的DOM节点\n```\nupdateChildren源码\n```javascript\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n  let oldStartIdx = 0\n  let newStartIdx = 0\n  let oldEndIdx = oldCh.length - 1\n  let oldStartVnode = oldCh[0]\n  let oldEndVnode = oldCh[oldEndIdx]\n  let newEndIdx = newCh.length - 1\n  let newStartVnode = newCh[0]\n  let newEndVnode = newCh[newEndIdx]\n  let oldKeyToIdx, idxInOld, elmToMove, refElm\n\n  // removeOnly is a special flag used only by <transition-group>\n  // to ensure removed elements stay in correct relative positions\n  // during leaving transitions\n  const canMove = !removeOnly\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (isUndef(oldStartVnode)) {\n      oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n    } else if (isUndef(oldEndVnode)) {\n      oldEndVnode = oldCh[--oldEndIdx]\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      /*前四种情况其实是指定key的时候，判定为同一个VNode，则直接patchVnode即可，分别比较oldCh以及newCh的两头节点2*2=4种情况*/\n      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n      oldStartVnode = oldCh[++oldStartIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n      canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n      oldStartVnode = oldCh[++oldStartIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n      canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else {\n      /*\n        生成一个key与旧VNode的key对应的哈希表（只有第一次进来undefined的时候会生成，也为后面检测重复的key值做铺垫）\n        比如childre是这样的 [{xx: xx, key: 'key0'}, {xx: xx, key: 'key1'}, {xx: xx, key: 'key2'}]  beginIdx = 0   endIdx = 2  \n        结果生成{key0: 0, key1: 1, key2: 2}\n      */\n      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n      /*如果newStartVnode新的VNode节点存在key并且这个key在oldVnode中能找到则返回这个节点的idxInOld（即第几个节点，下标）*/\n      idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null\n      if (isUndef(idxInOld)) { // New element\n        /*newStartVnode没有key或者是该key没有在老节点中找到则创建一个新的节点*/\n        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n        /*获取同key的老节点*/\n        elmToMove = oldCh[idxInOld]\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n          /*如果elmToMove不存在说明之前已经有新节点放入过这个key的DOM中，提示可能存在重复的key，确保v-for的时候item有唯一的key值*/\n          warn(\n            'It seems there are duplicate keys that is causing an update error. ' +\n            'Make sure each v-for item has a unique key.'\n          )\n        }\n        if (sameVnode(elmToMove, newStartVnode)) {\n          /*Github:https://github.com/answershuto*/\n          /*如果新VNode与得到的有相同key的节点是同一个VNode则进行patchVnode*/\n          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)\n          /*因为已经patchVnode进去了，所以将这个老节点赋值undefined，之后如果还有新节点与该节点key相同可以检测出来提示已有重复的key*/\n          oldCh[idxInOld] = undefined\n          /*当有标识位canMove实可以直接插入oldStartVnode对应的真实DOM节点前面*/\n          canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)\n          newStartVnode = newCh[++newStartIdx]\n        } else {\n          // same key but different element. treat as new element\n          /*当新的VNode与找到的同样key的VNode不是sameVNode的时候（比如说tag不一样或者是有不一样type的input标签），创建一个新的节点*/\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n          newStartVnode = newCh[++newStartIdx]\n        }\n      }\n    }\n  }\n  if (oldStartIdx > oldEndIdx) {\n    /*全部比较完成以后，发现oldStartIdx > oldEndIdx的话，说明老节点已经遍历完了，新节点比老节点多，所以这时候多出来的新节点需要一个一个创建出来加入到真实DOM中*/\n    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n  } else if (newStartIdx > newEndIdx) {\n    /*如果全部比较完成以后发现newStartIdx > newEndIdx，则说明新节点已经遍历完了，老节点多余新节点，这个时候需要将多余的老节点从真实DOM中移除*/\n    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n  }\n}\n```\n\n\n\n### 传送门\n\nVue虚拟DOM的diff实现\nhttps://github.com/answershuto/learnVue/blob/master/docs/VirtualDOM与diff(Vue实现).MarkDown\n\n剖析Vue实现原理 - 如何实现双向绑定mvvm\nhttps://github.com/DMQ/mvvm\n\n一个虚拟DOM库\nhttps://github.com/Matt-Esch/virtual-dom\n\nVue2 的虚拟DOM\nhttps://juejin.cn/post/6844903895467032589","source":"_posts/virtual-dom.md","raw":"---\ntitle: Vue的虚拟DOM\ndate: 2021/01/04\ntag: [virtualDom,虚拟DOM,Vue]\ncategory: 技术\n---\n\n#### 什么是虚拟 DOM\n虚拟DOM是对DOM的一层抽象，以Javascript对象（VNode节点）作为基础的树。\n用对象的属性描述节点，最后通过一些方法将其映射为真实的环境上，因此可实现跨平台。\n当前主流前端框架React、Vue以及各种小程序的界面渲染都是用到的虚拟DOM技术。\n\n```html\n<div id=\"app\">\n  <p class=\"text\">hello world!!!</p>\n</div>\n```\n```javascript\nconst vNode = {\n  tag: 'div',\n  props: { id: 'app' },\n  chidren: [{\n    tag: 'p',\n    props: { className: 'text' },\n    chidren: [ 'hello world!!!' ]\n  }]\n}\n```\n该js对象就是虚拟 DOM 了，它以js对象的形式描述了 DOM 节点。后续如果有 DOM 操作，不会直接操作 DOM，而是先变更 js 对象，然后 使用 diff 算法计算出新老对象之间的差异。最后最小范围的直接替换掉有变化的节点。\n\n#### 虚拟 DOM 的优势\n原生 DOM 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 div 也要付出昂贵的代价。\n```javascript\nvar arr = []\nvar div = document.createElement('div')\nfor (let i in div){ arr.push(i) }\nconsole.log(arr.length) // 314\n```\n上面代码输出可以看出，即使创建一个简单的DIV，就需要为其添加314个属性，如果之后直接操作该 DIV，应该会消耗掉不少的资源。\n\n而对于虚拟DOM，我们只需要创建和维护几个我们用得上的必要属性，之后无论是增删查改还是通过diff算法计算出差异点，都是能够大大提高其效率的。\n因此使用虚拟DOM，我们能够以最小代价的预处理DOM，最后一步到位渲染成真实的DOM。\n\n当然这并不是虚拟DOM的主要优势，因为即使是原生的DOM操作也可以人为的控制批量操作DOM，通过减少DOM操作能够最大限度的解决这个效能问题。\n\n虚拟DOM的**最大的优势**在于它可以接受 Parser 解析转化，这意味着其实相当多的东西我们都可以在编译阶段解决，比如：xss 攻击过滤。\n除此之外，因为虚拟DOM是一个用 js 对象描述的DOM抽象，所以只要为这个抽象实现一个与之对应的UI层的映射，那么就可以将其应用到相应的UI处理，这也是为什么虚拟DOM能够实现跨平台的原因了。\n\n#### Vue使用虚拟DOM渲染页面的完整过程\n1.挂载，通过调用Vue.prototype.$mount()方法实现Vue页面的挂载\n2.通过编译器来解析Template模板之后，生成render函数\n3.调用vm._render()，将render函数转换为虚拟DOM\n4.调用vm._update()，将虚拟DOM渲染为真实DOM\n\nVue是通过修改数据来更新视图的，当某个数据被修改的时候，set方法会让闭包中的Dep调用notify通知所有订阅者Watcher\nWatcher通过get方法执行_update\n```javascript\n// _update 的调用时机有两个，一个是发生在初次渲染阶段，另一个发生数据更新阶段。\n// _update 第一个参数是 vNode对象，update内部会先执行patch方法，该方法使用 diff算法 计算出最小的视图修改。\nVNode = vm._render()\nvm._update(VNode)\n```\n\n#### diff算法\ndiff算法通过同层的树节点比较，时间复杂度只有O(n)\n只有Vnode节点相同（是同一个节点）的时候才会进行节点比较（patchVnode），否则直接删除旧节点，添加新节点。\n##### 判断是否同一个节点的标准\n```html\nkey相同\ntag标签名相同\n是否同为注释节点\n是否都有data\n当为input标签的时候，type是否相同\n```\n\n##### 新老节点 patchVnode 过程\n```html\n若 都是静态节点判断key是否相同（相同表示为同一节点），且新VNode是clone或是标记了once，则直接替换elm以及componentInstance。\n若 均有children子节点，则对子节点进行diff操作，调用 updateChildren（diff算法的核心）。\n若 老节点无子节点，新节点有子节点，先清空老节点DOM的文本内容，再为改DOM加入新子节点。\n若 新节点无子节点，老节点有子节点，移除该DOM节点的所有子节点。\n若 新老节点都无子节点的时候，仅进行文本的替换。\n```\n\n##### updateChildren过程\n```html\n新老节点的左右两边 子节点 各起一个变量标记（oldStartVnode, newStartVnode, oldEndVnode, oldEndVnode），遍历的过程两边的标记向中间靠拢，直到全部遍历完成。\n要点：oldStartVnode、oldEndVnode与newStartVnode、newEndVnode 两两比较一共会有 2*2=4 种比较方法\n\n遍历过程中：\n如 存在key，且为相同节点，则复用节点\n如 sameVnode(oldStartVnode, newStartVnode) 或 sameVnode(oldEndVnode, newEndVnode)，则直接对该节点进行 pathVnode\n如 sameVnode(oldStartVnode, newEndVnode)，则进行 patchVnode 的同时还需要将真实DOM节点移动到 oldEndVnode 的后面\n如 sameVnode(oldEndVnode, newStartVnode)，则进行 patchVnode 的同时还需要将真实DOM节点移动到 oldStartVnode 的前面\n非上述情况，则创建 oldKeyToIdx: { [旧的VNode]: index }，从中刚找到含有与 newStartVnode 的key一致的节点X，\n  1）如sameVnode(x, newStartVnode) ，则进行 patchVnode 的同时将这个真实DOM移动到 oldStartVnode 对应的真实DOM的前面。\n  2）如notSameVnode(x, newStartVnode) ，则调用 createElm 创建一个新的节点。\n\n结束时\n如 新节点 多余 老节点，则将多余VNode节点插入到真实DOM中去\n如 新节点 少于 老节点，则删除多余的DOM节点\n```\nupdateChildren源码\n```javascript\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n  let oldStartIdx = 0\n  let newStartIdx = 0\n  let oldEndIdx = oldCh.length - 1\n  let oldStartVnode = oldCh[0]\n  let oldEndVnode = oldCh[oldEndIdx]\n  let newEndIdx = newCh.length - 1\n  let newStartVnode = newCh[0]\n  let newEndVnode = newCh[newEndIdx]\n  let oldKeyToIdx, idxInOld, elmToMove, refElm\n\n  // removeOnly is a special flag used only by <transition-group>\n  // to ensure removed elements stay in correct relative positions\n  // during leaving transitions\n  const canMove = !removeOnly\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (isUndef(oldStartVnode)) {\n      oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n    } else if (isUndef(oldEndVnode)) {\n      oldEndVnode = oldCh[--oldEndIdx]\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      /*前四种情况其实是指定key的时候，判定为同一个VNode，则直接patchVnode即可，分别比较oldCh以及newCh的两头节点2*2=4种情况*/\n      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n      oldStartVnode = oldCh[++oldStartIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n      canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n      oldStartVnode = oldCh[++oldStartIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n      canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else {\n      /*\n        生成一个key与旧VNode的key对应的哈希表（只有第一次进来undefined的时候会生成，也为后面检测重复的key值做铺垫）\n        比如childre是这样的 [{xx: xx, key: 'key0'}, {xx: xx, key: 'key1'}, {xx: xx, key: 'key2'}]  beginIdx = 0   endIdx = 2  \n        结果生成{key0: 0, key1: 1, key2: 2}\n      */\n      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n      /*如果newStartVnode新的VNode节点存在key并且这个key在oldVnode中能找到则返回这个节点的idxInOld（即第几个节点，下标）*/\n      idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null\n      if (isUndef(idxInOld)) { // New element\n        /*newStartVnode没有key或者是该key没有在老节点中找到则创建一个新的节点*/\n        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n        /*获取同key的老节点*/\n        elmToMove = oldCh[idxInOld]\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n          /*如果elmToMove不存在说明之前已经有新节点放入过这个key的DOM中，提示可能存在重复的key，确保v-for的时候item有唯一的key值*/\n          warn(\n            'It seems there are duplicate keys that is causing an update error. ' +\n            'Make sure each v-for item has a unique key.'\n          )\n        }\n        if (sameVnode(elmToMove, newStartVnode)) {\n          /*Github:https://github.com/answershuto*/\n          /*如果新VNode与得到的有相同key的节点是同一个VNode则进行patchVnode*/\n          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)\n          /*因为已经patchVnode进去了，所以将这个老节点赋值undefined，之后如果还有新节点与该节点key相同可以检测出来提示已有重复的key*/\n          oldCh[idxInOld] = undefined\n          /*当有标识位canMove实可以直接插入oldStartVnode对应的真实DOM节点前面*/\n          canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)\n          newStartVnode = newCh[++newStartIdx]\n        } else {\n          // same key but different element. treat as new element\n          /*当新的VNode与找到的同样key的VNode不是sameVNode的时候（比如说tag不一样或者是有不一样type的input标签），创建一个新的节点*/\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n          newStartVnode = newCh[++newStartIdx]\n        }\n      }\n    }\n  }\n  if (oldStartIdx > oldEndIdx) {\n    /*全部比较完成以后，发现oldStartIdx > oldEndIdx的话，说明老节点已经遍历完了，新节点比老节点多，所以这时候多出来的新节点需要一个一个创建出来加入到真实DOM中*/\n    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n  } else if (newStartIdx > newEndIdx) {\n    /*如果全部比较完成以后发现newStartIdx > newEndIdx，则说明新节点已经遍历完了，老节点多余新节点，这个时候需要将多余的老节点从真实DOM中移除*/\n    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n  }\n}\n```\n\n\n\n### 传送门\n\nVue虚拟DOM的diff实现\nhttps://github.com/answershuto/learnVue/blob/master/docs/VirtualDOM与diff(Vue实现).MarkDown\n\n剖析Vue实现原理 - 如何实现双向绑定mvvm\nhttps://github.com/DMQ/mvvm\n\n一个虚拟DOM库\nhttps://github.com/Matt-Esch/virtual-dom\n\nVue2 的虚拟DOM\nhttps://juejin.cn/post/6844903895467032589","slug":"virtual-dom","published":1,"updated":"2021-03-30T01:32:00.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ugc001ta0vzdwkl3jfq","content":"<h4 id=\"什么是虚拟-DOM\"><a href=\"#什么是虚拟-DOM\" class=\"headerlink\" title=\"什么是虚拟 DOM\"></a>什么是虚拟 DOM</h4><p>虚拟DOM是对DOM的一层抽象，以Javascript对象（VNode节点）作为基础的树。<br>用对象的属性描述节点，最后通过一些方法将其映射为真实的环境上，因此可实现跨平台。<br>当前主流前端框架React、Vue以及各种小程序的界面渲染都是用到的虚拟DOM技术。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span>hello world!!!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> vNode = &#123;</span><br><span class=\"line\">  tag: <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">  props: &#123; <span class=\"attr\">id</span>: <span class=\"string\">&#x27;app&#x27;</span> &#125;,</span><br><span class=\"line\">  chidren: [&#123;</span><br><span class=\"line\">    tag: <span class=\"string\">&#x27;p&#x27;</span>,</span><br><span class=\"line\">    props: &#123; <span class=\"attr\">className</span>: <span class=\"string\">&#x27;text&#x27;</span> &#125;,</span><br><span class=\"line\">    chidren: [ <span class=\"string\">&#x27;hello world!!!&#x27;</span> ]</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该js对象就是虚拟 DOM 了，它以js对象的形式描述了 DOM 节点。后续如果有 DOM 操作，不会直接操作 DOM，而是先变更 js 对象，然后 使用 diff 算法计算出新老对象之间的差异。最后最小范围的直接替换掉有变化的节点。</p>\n<h4 id=\"虚拟-DOM-的优势\"><a href=\"#虚拟-DOM-的优势\" class=\"headerlink\" title=\"虚拟 DOM 的优势\"></a>虚拟 DOM 的优势</h4><p>原生 DOM 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 div 也要付出昂贵的代价。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\"><span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;div&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> div)&#123; arr.push(i) &#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.length) <span class=\"comment\">// 314</span></span><br></pre></td></tr></table></figure><br>上面代码输出可以看出，即使创建一个简单的DIV，就需要为其添加314个属性，如果之后直接操作该 DIV，应该会消耗掉不少的资源。</p>\n<p>而对于虚拟DOM，我们只需要创建和维护几个我们用得上的必要属性，之后无论是增删查改还是通过diff算法计算出差异点，都是能够大大提高其效率的。<br>因此使用虚拟DOM，我们能够以最小代价的预处理DOM，最后一步到位渲染成真实的DOM。</p>\n<p>当然这并不是虚拟DOM的主要优势，因为即使是原生的DOM操作也可以人为的控制批量操作DOM，通过减少DOM操作能够最大限度的解决这个效能问题。</p>\n<p>虚拟DOM的<strong>最大的优势</strong>在于它可以接受 Parser 解析转化，这意味着其实相当多的东西我们都可以在编译阶段解决，比如：xss 攻击过滤。<br>除此之外，因为虚拟DOM是一个用 js 对象描述的DOM抽象，所以只要为这个抽象实现一个与之对应的UI层的映射，那么就可以将其应用到相应的UI处理，这也是为什么虚拟DOM能够实现跨平台的原因了。</p>\n<h4 id=\"Vue使用虚拟DOM渲染页面的完整过程\"><a href=\"#Vue使用虚拟DOM渲染页面的完整过程\" class=\"headerlink\" title=\"Vue使用虚拟DOM渲染页面的完整过程\"></a>Vue使用虚拟DOM渲染页面的完整过程</h4><p>1.挂载，通过调用Vue.prototype.$mount()方法实现Vue页面的挂载<br>2.通过编译器来解析Template模板之后，生成render函数<br>3.调用vm._render()，将render函数转换为虚拟DOM<br>4.调用vm._update()，将虚拟DOM渲染为真实DOM</p>\n<p>Vue是通过修改数据来更新视图的，当某个数据被修改的时候，set方法会让闭包中的Dep调用notify通知所有订阅者Watcher<br>Watcher通过get方法执行_update<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// _update 的调用时机有两个，一个是发生在初次渲染阶段，另一个发生数据更新阶段。</span></span><br><span class=\"line\"><span class=\"comment\">// _update 第一个参数是 vNode对象，update内部会先执行patch方法，该方法使用 diff算法 计算出最小的视图修改。</span></span><br><span class=\"line\">VNode = vm._render()</span><br><span class=\"line\">vm._update(VNode)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"diff算法\"><a href=\"#diff算法\" class=\"headerlink\" title=\"diff算法\"></a>diff算法</h4><p>diff算法通过同层的树节点比较，时间复杂度只有O(n)<br>只有Vnode节点相同（是同一个节点）的时候才会进行节点比较（patchVnode），否则直接删除旧节点，添加新节点。</p>\n<h5 id=\"判断是否同一个节点的标准\"><a href=\"#判断是否同一个节点的标准\" class=\"headerlink\" title=\"判断是否同一个节点的标准\"></a>判断是否同一个节点的标准</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key相同</span><br><span class=\"line\">tag标签名相同</span><br><span class=\"line\">是否同为注释节点</span><br><span class=\"line\">是否都有data</span><br><span class=\"line\">当为input标签的时候，type是否相同</span><br></pre></td></tr></table></figure>\n<h5 id=\"新老节点-patchVnode-过程\"><a href=\"#新老节点-patchVnode-过程\" class=\"headerlink\" title=\"新老节点 patchVnode 过程\"></a>新老节点 patchVnode 过程</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">若 都是静态节点判断key是否相同（相同表示为同一节点），且新VNode是clone或是标记了once，则直接替换elm以及componentInstance。</span><br><span class=\"line\">若 均有children子节点，则对子节点进行diff操作，调用 updateChildren（diff算法的核心）。</span><br><span class=\"line\">若 老节点无子节点，新节点有子节点，先清空老节点DOM的文本内容，再为改DOM加入新子节点。</span><br><span class=\"line\">若 新节点无子节点，老节点有子节点，移除该DOM节点的所有子节点。</span><br><span class=\"line\">若 新老节点都无子节点的时候，仅进行文本的替换。</span><br></pre></td></tr></table></figure>\n<h5 id=\"updateChildren过程\"><a href=\"#updateChildren过程\" class=\"headerlink\" title=\"updateChildren过程\"></a>updateChildren过程</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">新老节点的左右两边 子节点 各起一个变量标记（oldStartVnode, newStartVnode, oldEndVnode, oldEndVnode），遍历的过程两边的标记向中间靠拢，直到全部遍历完成。</span><br><span class=\"line\">要点：oldStartVnode、oldEndVnode与newStartVnode、newEndVnode 两两比较一共会有 2*2=4 种比较方法</span><br><span class=\"line\"></span><br><span class=\"line\">遍历过程中：</span><br><span class=\"line\">如 存在key，且为相同节点，则复用节点</span><br><span class=\"line\">如 sameVnode(oldStartVnode, newStartVnode) 或 sameVnode(oldEndVnode, newEndVnode)，则直接对该节点进行 pathVnode</span><br><span class=\"line\">如 sameVnode(oldStartVnode, newEndVnode)，则进行 patchVnode 的同时还需要将真实DOM节点移动到 oldEndVnode 的后面</span><br><span class=\"line\">如 sameVnode(oldEndVnode, newStartVnode)，则进行 patchVnode 的同时还需要将真实DOM节点移动到 oldStartVnode 的前面</span><br><span class=\"line\">非上述情况，则创建 oldKeyToIdx: &#123; [旧的VNode]: index &#125;，从中刚找到含有与 newStartVnode 的key一致的节点X，</span><br><span class=\"line\">  1）如sameVnode(x, newStartVnode) ，则进行 patchVnode 的同时将这个真实DOM移动到 oldStartVnode 对应的真实DOM的前面。</span><br><span class=\"line\">  2）如notSameVnode(x, newStartVnode) ，则调用 createElm 创建一个新的节点。</span><br><span class=\"line\"></span><br><span class=\"line\">结束时</span><br><span class=\"line\">如 新节点 多余 老节点，则将多余VNode节点插入到真实DOM中去</span><br><span class=\"line\">如 新节点 少于 老节点，则删除多余的DOM节点</span><br></pre></td></tr></table></figure>\n<p>updateChildren源码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateChildren</span> (<span class=\"params\">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldStartIdx = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> newStartIdx = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldEndIdx = oldCh.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldStartVnode = oldCh[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newEndIdx = newCh.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> newStartVnode = newCh[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldKeyToIdx, idxInOld, elmToMove, refElm</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">// to ensure removed elements stay in correct relative positions</span></span><br><span class=\"line\">  <span class=\"comment\">// during leaving transitions</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> canMove = !removeOnly</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class=\"line\">      oldStartVnode = oldCh[++oldStartIdx] <span class=\"comment\">// Vnode has been moved left</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class=\"line\">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/*前四种情况其实是指定key的时候，判定为同一个VNode，则直接patchVnode即可，分别比较oldCh以及newCh的两头节点2*2=4种情况*/</span></span><br><span class=\"line\">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">      newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class=\"line\">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class=\"line\">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">      newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class=\"comment\">// Vnode moved right</span></span><br><span class=\"line\">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class=\"line\">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class=\"line\">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">      newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class=\"comment\">// Vnode moved left</span></span><br><span class=\"line\">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class=\"line\">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">      newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        生成一个key与旧VNode的key对应的哈希表（只有第一次进来undefined的时候会生成，也为后面检测重复的key值做铺垫）</span></span><br><span class=\"line\"><span class=\"comment\">        比如childre是这样的 [&#123;xx: xx, key: &#x27;key0&#x27;&#125;, &#123;xx: xx, key: &#x27;key1&#x27;&#125;, &#123;xx: xx, key: &#x27;key2&#x27;&#125;]  beginIdx = 0   endIdx = 2  </span></span><br><span class=\"line\"><span class=\"comment\">        结果生成&#123;key0: 0, key1: 1, key2: 2&#125;</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">      <span class=\"comment\">/*如果newStartVnode新的VNode节点存在key并且这个key在oldVnode中能找到则返回这个节点的idxInOld（即第几个节点，下标）*/</span></span><br><span class=\"line\">      idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : <span class=\"literal\">null</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isUndef(idxInOld)) &#123; <span class=\"comment\">// New element</span></span><br><span class=\"line\">        <span class=\"comment\">/*newStartVnode没有key或者是该key没有在老节点中找到则创建一个新的节点*/</span></span><br><span class=\"line\">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*获取同key的老节点*/</span></span><br><span class=\"line\">        elmToMove = oldCh[idxInOld]</span><br><span class=\"line\">        <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; !elmToMove) &#123;</span><br><span class=\"line\">          <span class=\"comment\">/*如果elmToMove不存在说明之前已经有新节点放入过这个key的DOM中，提示可能存在重复的key，确保v-for的时候item有唯一的key值*/</span></span><br><span class=\"line\">          warn(</span><br><span class=\"line\">            <span class=\"string\">&#x27;It seems there are duplicate keys that is causing an update error. &#x27;</span> +</span><br><span class=\"line\">            <span class=\"string\">&#x27;Make sure each v-for item has a unique key.&#x27;</span></span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class=\"line\">          <span class=\"comment\">/*Github:https://github.com/answershuto*/</span></span><br><span class=\"line\">          <span class=\"comment\">/*如果新VNode与得到的有相同key的节点是同一个VNode则进行patchVnode*/</span></span><br><span class=\"line\">          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">          <span class=\"comment\">/*因为已经patchVnode进去了，所以将这个老节点赋值undefined，之后如果还有新节点与该节点key相同可以检测出来提示已有重复的key*/</span></span><br><span class=\"line\">          oldCh[idxInOld] = <span class=\"literal\">undefined</span></span><br><span class=\"line\">          <span class=\"comment\">/*当有标识位canMove实可以直接插入oldStartVnode对应的真实DOM节点前面*/</span></span><br><span class=\"line\">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)</span><br><span class=\"line\">          newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// same key but different element. treat as new element</span></span><br><span class=\"line\">          <span class=\"comment\">/*当新的VNode与找到的同样key的VNode不是sameVNode的时候（比如说tag不一样或者是有不一样type的input标签），创建一个新的节点*/</span></span><br><span class=\"line\">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</span><br><span class=\"line\">          newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*全部比较完成以后，发现oldStartIdx &gt; oldEndIdx的话，说明老节点已经遍历完了，新节点比老节点多，所以这时候多出来的新节点需要一个一个创建出来加入到真实DOM中*/</span></span><br><span class=\"line\">    refElm = isUndef(newCh[newEndIdx + <span class=\"number\">1</span>]) ? <span class=\"literal\">null</span> : newCh[newEndIdx + <span class=\"number\">1</span>].elm</span><br><span class=\"line\">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*如果全部比较完成以后发现newStartIdx &gt; newEndIdx，则说明新节点已经遍历完了，老节点多余新节点，这个时候需要将多余的老节点从真实DOM中移除*/</span></span><br><span class=\"line\">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>Vue虚拟DOM的diff实现<br><a href=\"https://github.com/answershuto/learnVue/blob/master/docs/VirtualDOM与diff(Vue实现).MarkDown\">https://github.com/answershuto/learnVue/blob/master/docs/VirtualDOM与diff(Vue实现).MarkDown</a></p>\n<p>剖析Vue实现原理 - 如何实现双向绑定mvvm<br><a href=\"https://github.com/DMQ/mvvm\">https://github.com/DMQ/mvvm</a></p>\n<p>一个虚拟DOM库<br><a href=\"https://github.com/Matt-Esch/virtual-dom\">https://github.com/Matt-Esch/virtual-dom</a></p>\n<p>Vue2 的虚拟DOM<br><a href=\"https://juejin.cn/post/6844903895467032589\">https://juejin.cn/post/6844903895467032589</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是虚拟-DOM\"><a href=\"#什么是虚拟-DOM\" class=\"headerlink\" title=\"什么是虚拟 DOM\"></a>什么是虚拟 DOM</h4><p>虚拟DOM是对DOM的一层抽象，以Javascript对象（VNode节点）作为基础的树。<br>用对象的属性描述节点，最后通过一些方法将其映射为真实的环境上，因此可实现跨平台。<br>当前主流前端框架React、Vue以及各种小程序的界面渲染都是用到的虚拟DOM技术。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span>hello world!!!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> vNode = &#123;</span><br><span class=\"line\">  tag: <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">  props: &#123; <span class=\"attr\">id</span>: <span class=\"string\">&#x27;app&#x27;</span> &#125;,</span><br><span class=\"line\">  chidren: [&#123;</span><br><span class=\"line\">    tag: <span class=\"string\">&#x27;p&#x27;</span>,</span><br><span class=\"line\">    props: &#123; <span class=\"attr\">className</span>: <span class=\"string\">&#x27;text&#x27;</span> &#125;,</span><br><span class=\"line\">    chidren: [ <span class=\"string\">&#x27;hello world!!!&#x27;</span> ]</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该js对象就是虚拟 DOM 了，它以js对象的形式描述了 DOM 节点。后续如果有 DOM 操作，不会直接操作 DOM，而是先变更 js 对象，然后 使用 diff 算法计算出新老对象之间的差异。最后最小范围的直接替换掉有变化的节点。</p>\n<h4 id=\"虚拟-DOM-的优势\"><a href=\"#虚拟-DOM-的优势\" class=\"headerlink\" title=\"虚拟 DOM 的优势\"></a>虚拟 DOM 的优势</h4><p>原生 DOM 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 div 也要付出昂贵的代价。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\"><span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;div&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> div)&#123; arr.push(i) &#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.length) <span class=\"comment\">// 314</span></span><br></pre></td></tr></table></figure><br>上面代码输出可以看出，即使创建一个简单的DIV，就需要为其添加314个属性，如果之后直接操作该 DIV，应该会消耗掉不少的资源。</p>\n<p>而对于虚拟DOM，我们只需要创建和维护几个我们用得上的必要属性，之后无论是增删查改还是通过diff算法计算出差异点，都是能够大大提高其效率的。<br>因此使用虚拟DOM，我们能够以最小代价的预处理DOM，最后一步到位渲染成真实的DOM。</p>\n<p>当然这并不是虚拟DOM的主要优势，因为即使是原生的DOM操作也可以人为的控制批量操作DOM，通过减少DOM操作能够最大限度的解决这个效能问题。</p>\n<p>虚拟DOM的<strong>最大的优势</strong>在于它可以接受 Parser 解析转化，这意味着其实相当多的东西我们都可以在编译阶段解决，比如：xss 攻击过滤。<br>除此之外，因为虚拟DOM是一个用 js 对象描述的DOM抽象，所以只要为这个抽象实现一个与之对应的UI层的映射，那么就可以将其应用到相应的UI处理，这也是为什么虚拟DOM能够实现跨平台的原因了。</p>\n<h4 id=\"Vue使用虚拟DOM渲染页面的完整过程\"><a href=\"#Vue使用虚拟DOM渲染页面的完整过程\" class=\"headerlink\" title=\"Vue使用虚拟DOM渲染页面的完整过程\"></a>Vue使用虚拟DOM渲染页面的完整过程</h4><p>1.挂载，通过调用Vue.prototype.$mount()方法实现Vue页面的挂载<br>2.通过编译器来解析Template模板之后，生成render函数<br>3.调用vm._render()，将render函数转换为虚拟DOM<br>4.调用vm._update()，将虚拟DOM渲染为真实DOM</p>\n<p>Vue是通过修改数据来更新视图的，当某个数据被修改的时候，set方法会让闭包中的Dep调用notify通知所有订阅者Watcher<br>Watcher通过get方法执行_update<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// _update 的调用时机有两个，一个是发生在初次渲染阶段，另一个发生数据更新阶段。</span></span><br><span class=\"line\"><span class=\"comment\">// _update 第一个参数是 vNode对象，update内部会先执行patch方法，该方法使用 diff算法 计算出最小的视图修改。</span></span><br><span class=\"line\">VNode = vm._render()</span><br><span class=\"line\">vm._update(VNode)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"diff算法\"><a href=\"#diff算法\" class=\"headerlink\" title=\"diff算法\"></a>diff算法</h4><p>diff算法通过同层的树节点比较，时间复杂度只有O(n)<br>只有Vnode节点相同（是同一个节点）的时候才会进行节点比较（patchVnode），否则直接删除旧节点，添加新节点。</p>\n<h5 id=\"判断是否同一个节点的标准\"><a href=\"#判断是否同一个节点的标准\" class=\"headerlink\" title=\"判断是否同一个节点的标准\"></a>判断是否同一个节点的标准</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key相同</span><br><span class=\"line\">tag标签名相同</span><br><span class=\"line\">是否同为注释节点</span><br><span class=\"line\">是否都有data</span><br><span class=\"line\">当为input标签的时候，type是否相同</span><br></pre></td></tr></table></figure>\n<h5 id=\"新老节点-patchVnode-过程\"><a href=\"#新老节点-patchVnode-过程\" class=\"headerlink\" title=\"新老节点 patchVnode 过程\"></a>新老节点 patchVnode 过程</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">若 都是静态节点判断key是否相同（相同表示为同一节点），且新VNode是clone或是标记了once，则直接替换elm以及componentInstance。</span><br><span class=\"line\">若 均有children子节点，则对子节点进行diff操作，调用 updateChildren（diff算法的核心）。</span><br><span class=\"line\">若 老节点无子节点，新节点有子节点，先清空老节点DOM的文本内容，再为改DOM加入新子节点。</span><br><span class=\"line\">若 新节点无子节点，老节点有子节点，移除该DOM节点的所有子节点。</span><br><span class=\"line\">若 新老节点都无子节点的时候，仅进行文本的替换。</span><br></pre></td></tr></table></figure>\n<h5 id=\"updateChildren过程\"><a href=\"#updateChildren过程\" class=\"headerlink\" title=\"updateChildren过程\"></a>updateChildren过程</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">新老节点的左右两边 子节点 各起一个变量标记（oldStartVnode, newStartVnode, oldEndVnode, oldEndVnode），遍历的过程两边的标记向中间靠拢，直到全部遍历完成。</span><br><span class=\"line\">要点：oldStartVnode、oldEndVnode与newStartVnode、newEndVnode 两两比较一共会有 2*2=4 种比较方法</span><br><span class=\"line\"></span><br><span class=\"line\">遍历过程中：</span><br><span class=\"line\">如 存在key，且为相同节点，则复用节点</span><br><span class=\"line\">如 sameVnode(oldStartVnode, newStartVnode) 或 sameVnode(oldEndVnode, newEndVnode)，则直接对该节点进行 pathVnode</span><br><span class=\"line\">如 sameVnode(oldStartVnode, newEndVnode)，则进行 patchVnode 的同时还需要将真实DOM节点移动到 oldEndVnode 的后面</span><br><span class=\"line\">如 sameVnode(oldEndVnode, newStartVnode)，则进行 patchVnode 的同时还需要将真实DOM节点移动到 oldStartVnode 的前面</span><br><span class=\"line\">非上述情况，则创建 oldKeyToIdx: &#123; [旧的VNode]: index &#125;，从中刚找到含有与 newStartVnode 的key一致的节点X，</span><br><span class=\"line\">  1）如sameVnode(x, newStartVnode) ，则进行 patchVnode 的同时将这个真实DOM移动到 oldStartVnode 对应的真实DOM的前面。</span><br><span class=\"line\">  2）如notSameVnode(x, newStartVnode) ，则调用 createElm 创建一个新的节点。</span><br><span class=\"line\"></span><br><span class=\"line\">结束时</span><br><span class=\"line\">如 新节点 多余 老节点，则将多余VNode节点插入到真实DOM中去</span><br><span class=\"line\">如 新节点 少于 老节点，则删除多余的DOM节点</span><br></pre></td></tr></table></figure>\n<p>updateChildren源码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateChildren</span> (<span class=\"params\">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldStartIdx = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> newStartIdx = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldEndIdx = oldCh.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldStartVnode = oldCh[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newEndIdx = newCh.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> newStartVnode = newCh[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldKeyToIdx, idxInOld, elmToMove, refElm</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">// to ensure removed elements stay in correct relative positions</span></span><br><span class=\"line\">  <span class=\"comment\">// during leaving transitions</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> canMove = !removeOnly</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class=\"line\">      oldStartVnode = oldCh[++oldStartIdx] <span class=\"comment\">// Vnode has been moved left</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class=\"line\">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/*前四种情况其实是指定key的时候，判定为同一个VNode，则直接patchVnode即可，分别比较oldCh以及newCh的两头节点2*2=4种情况*/</span></span><br><span class=\"line\">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">      newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class=\"line\">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class=\"line\">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">      newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class=\"comment\">// Vnode moved right</span></span><br><span class=\"line\">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class=\"line\">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class=\"line\">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">      newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class=\"comment\">// Vnode moved left</span></span><br><span class=\"line\">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class=\"line\">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">      newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        生成一个key与旧VNode的key对应的哈希表（只有第一次进来undefined的时候会生成，也为后面检测重复的key值做铺垫）</span></span><br><span class=\"line\"><span class=\"comment\">        比如childre是这样的 [&#123;xx: xx, key: &#x27;key0&#x27;&#125;, &#123;xx: xx, key: &#x27;key1&#x27;&#125;, &#123;xx: xx, key: &#x27;key2&#x27;&#125;]  beginIdx = 0   endIdx = 2  </span></span><br><span class=\"line\"><span class=\"comment\">        结果生成&#123;key0: 0, key1: 1, key2: 2&#125;</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">      <span class=\"comment\">/*如果newStartVnode新的VNode节点存在key并且这个key在oldVnode中能找到则返回这个节点的idxInOld（即第几个节点，下标）*/</span></span><br><span class=\"line\">      idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : <span class=\"literal\">null</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isUndef(idxInOld)) &#123; <span class=\"comment\">// New element</span></span><br><span class=\"line\">        <span class=\"comment\">/*newStartVnode没有key或者是该key没有在老节点中找到则创建一个新的节点*/</span></span><br><span class=\"line\">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*获取同key的老节点*/</span></span><br><span class=\"line\">        elmToMove = oldCh[idxInOld]</span><br><span class=\"line\">        <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; !elmToMove) &#123;</span><br><span class=\"line\">          <span class=\"comment\">/*如果elmToMove不存在说明之前已经有新节点放入过这个key的DOM中，提示可能存在重复的key，确保v-for的时候item有唯一的key值*/</span></span><br><span class=\"line\">          warn(</span><br><span class=\"line\">            <span class=\"string\">&#x27;It seems there are duplicate keys that is causing an update error. &#x27;</span> +</span><br><span class=\"line\">            <span class=\"string\">&#x27;Make sure each v-for item has a unique key.&#x27;</span></span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class=\"line\">          <span class=\"comment\">/*Github:https://github.com/answershuto*/</span></span><br><span class=\"line\">          <span class=\"comment\">/*如果新VNode与得到的有相同key的节点是同一个VNode则进行patchVnode*/</span></span><br><span class=\"line\">          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">          <span class=\"comment\">/*因为已经patchVnode进去了，所以将这个老节点赋值undefined，之后如果还有新节点与该节点key相同可以检测出来提示已有重复的key*/</span></span><br><span class=\"line\">          oldCh[idxInOld] = <span class=\"literal\">undefined</span></span><br><span class=\"line\">          <span class=\"comment\">/*当有标识位canMove实可以直接插入oldStartVnode对应的真实DOM节点前面*/</span></span><br><span class=\"line\">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)</span><br><span class=\"line\">          newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// same key but different element. treat as new element</span></span><br><span class=\"line\">          <span class=\"comment\">/*当新的VNode与找到的同样key的VNode不是sameVNode的时候（比如说tag不一样或者是有不一样type的input标签），创建一个新的节点*/</span></span><br><span class=\"line\">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</span><br><span class=\"line\">          newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*全部比较完成以后，发现oldStartIdx &gt; oldEndIdx的话，说明老节点已经遍历完了，新节点比老节点多，所以这时候多出来的新节点需要一个一个创建出来加入到真实DOM中*/</span></span><br><span class=\"line\">    refElm = isUndef(newCh[newEndIdx + <span class=\"number\">1</span>]) ? <span class=\"literal\">null</span> : newCh[newEndIdx + <span class=\"number\">1</span>].elm</span><br><span class=\"line\">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*如果全部比较完成以后发现newStartIdx &gt; newEndIdx，则说明新节点已经遍历完了，老节点多余新节点，这个时候需要将多余的老节点从真实DOM中移除*/</span></span><br><span class=\"line\">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>Vue虚拟DOM的diff实现<br><a href=\"https://github.com/answershuto/learnVue/blob/master/docs/VirtualDOM与diff(Vue实现).MarkDown\">https://github.com/answershuto/learnVue/blob/master/docs/VirtualDOM与diff(Vue实现).MarkDown</a></p>\n<p>剖析Vue实现原理 - 如何实现双向绑定mvvm<br><a href=\"https://github.com/DMQ/mvvm\">https://github.com/DMQ/mvvm</a></p>\n<p>一个虚拟DOM库<br><a href=\"https://github.com/Matt-Esch/virtual-dom\">https://github.com/Matt-Esch/virtual-dom</a></p>\n<p>Vue2 的虚拟DOM<br><a href=\"https://juejin.cn/post/6844903895467032589\">https://juejin.cn/post/6844903895467032589</a></p>\n"},{"title":"vue-ssr","date":"2019-04-02T16:00:00.000Z","_content":"\n### 什么是服务器端渲染 (SSR)？\n所谓的服务端渲染其实并不是上面新奇的东西，顾名思义，就是页面的生成是在服务端完成的。\n它自上古以来（很久很久以前）就已经存在了，传统的 jsp 页面、asp.net等页面都可以看做是服务端渲染的页面。\n既然如此，为什么会单独拿出来说事儿呢？\n\n### 单页应用（SPA single-page application）\n之所以单独拿服务端渲染说事，就是因为近几年兴起的“单页应用”。\n\n什么是单页应用呢？\n单页应用，是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。 —— 维基百科\n\n举例来说，最近几年兴起的，用 vue、react、Angular等技术开发的将传统的 html 开发转变为 js开发，然后在前端生成虚拟 DOM ，并在前端直接通过 js 绘制的页面，而且在前端自己维护的一套前端路由，通过前端路由切换页面的应用就是典型的单页应用。\n\n单页应用的好处多多，能够实现前端页面平滑无刷新切换，能够实现虚拟DOM快速响应用户交互等等\n但是，其缺点也有，那就是首次渲染页面相对 ssr 会慢一些，而且，因为其是在前端通过js绘制的页面，这就导致了它对搜索引擎抓取网站内容造成了一些阻碍，对 SEO 不友好。\n当然，随着近几年单页应用越来越火热，搜索引擎（如google）也对单页应用做了相应的优化。\n\n### 为什么使用服务器端渲染 (SSR)？\n所以，我们为什么要使用服务端渲染呢？\n1、页面首页渲染更快，减少白屏时长\n2、SEO 优化\n\n因此，对于某些业务场景，如果需要关注如上两点的，就需要作出相应的优化。\n而服务端渲染 SSR 就是为了解决这几个问题的。\n这里说的 SSR 相对于传统的 SSR 的优势就在于能够在使用最新技术（vue、react等）的同时做到SSR。\n\n\n### 服务端渲染脚手架\n这个是本人自己整理的 vue+koa+webpack4的服务端渲染脚手架\n[https://github.com/zhoushirong/vue-koa-ssr.git](https://github.com/zhoushirong/vue-koa-ssr.git)\n\n\n\n","source":"_posts/vue-ssr.md","raw":"---\ntitle: vue-ssr\ndate: 2019/04/03\ntag: [vue, ssr, 服务端渲染]\ncategory: 技术\n---\n\n### 什么是服务器端渲染 (SSR)？\n所谓的服务端渲染其实并不是上面新奇的东西，顾名思义，就是页面的生成是在服务端完成的。\n它自上古以来（很久很久以前）就已经存在了，传统的 jsp 页面、asp.net等页面都可以看做是服务端渲染的页面。\n既然如此，为什么会单独拿出来说事儿呢？\n\n### 单页应用（SPA single-page application）\n之所以单独拿服务端渲染说事，就是因为近几年兴起的“单页应用”。\n\n什么是单页应用呢？\n单页应用，是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。 —— 维基百科\n\n举例来说，最近几年兴起的，用 vue、react、Angular等技术开发的将传统的 html 开发转变为 js开发，然后在前端生成虚拟 DOM ，并在前端直接通过 js 绘制的页面，而且在前端自己维护的一套前端路由，通过前端路由切换页面的应用就是典型的单页应用。\n\n单页应用的好处多多，能够实现前端页面平滑无刷新切换，能够实现虚拟DOM快速响应用户交互等等\n但是，其缺点也有，那就是首次渲染页面相对 ssr 会慢一些，而且，因为其是在前端通过js绘制的页面，这就导致了它对搜索引擎抓取网站内容造成了一些阻碍，对 SEO 不友好。\n当然，随着近几年单页应用越来越火热，搜索引擎（如google）也对单页应用做了相应的优化。\n\n### 为什么使用服务器端渲染 (SSR)？\n所以，我们为什么要使用服务端渲染呢？\n1、页面首页渲染更快，减少白屏时长\n2、SEO 优化\n\n因此，对于某些业务场景，如果需要关注如上两点的，就需要作出相应的优化。\n而服务端渲染 SSR 就是为了解决这几个问题的。\n这里说的 SSR 相对于传统的 SSR 的优势就在于能够在使用最新技术（vue、react等）的同时做到SSR。\n\n\n### 服务端渲染脚手架\n这个是本人自己整理的 vue+koa+webpack4的服务端渲染脚手架\n[https://github.com/zhoushirong/vue-koa-ssr.git](https://github.com/zhoushirong/vue-koa-ssr.git)\n\n\n\n","slug":"vue-ssr","published":1,"updated":"2021-03-30T01:32:00.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ugc001ua0vzgsvlfpkr","content":"<h3 id=\"什么是服务器端渲染-SSR-？\"><a href=\"#什么是服务器端渲染-SSR-？\" class=\"headerlink\" title=\"什么是服务器端渲染 (SSR)？\"></a>什么是服务器端渲染 (SSR)？</h3><p>所谓的服务端渲染其实并不是上面新奇的东西，顾名思义，就是页面的生成是在服务端完成的。<br>它自上古以来（很久很久以前）就已经存在了，传统的 jsp 页面、asp.net等页面都可以看做是服务端渲染的页面。<br>既然如此，为什么会单独拿出来说事儿呢？</p>\n<h3 id=\"单页应用（SPA-single-page-application）\"><a href=\"#单页应用（SPA-single-page-application）\" class=\"headerlink\" title=\"单页应用（SPA single-page application）\"></a>单页应用（SPA single-page application）</h3><p>之所以单独拿服务端渲染说事，就是因为近几年兴起的“单页应用”。</p>\n<p>什么是单页应用呢？<br>单页应用，是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。 —— 维基百科</p>\n<p>举例来说，最近几年兴起的，用 vue、react、Angular等技术开发的将传统的 html 开发转变为 js开发，然后在前端生成虚拟 DOM ，并在前端直接通过 js 绘制的页面，而且在前端自己维护的一套前端路由，通过前端路由切换页面的应用就是典型的单页应用。</p>\n<p>单页应用的好处多多，能够实现前端页面平滑无刷新切换，能够实现虚拟DOM快速响应用户交互等等<br>但是，其缺点也有，那就是首次渲染页面相对 ssr 会慢一些，而且，因为其是在前端通过js绘制的页面，这就导致了它对搜索引擎抓取网站内容造成了一些阻碍，对 SEO 不友好。<br>当然，随着近几年单页应用越来越火热，搜索引擎（如google）也对单页应用做了相应的优化。</p>\n<h3 id=\"为什么使用服务器端渲染-SSR-？\"><a href=\"#为什么使用服务器端渲染-SSR-？\" class=\"headerlink\" title=\"为什么使用服务器端渲染 (SSR)？\"></a>为什么使用服务器端渲染 (SSR)？</h3><p>所以，我们为什么要使用服务端渲染呢？<br>1、页面首页渲染更快，减少白屏时长<br>2、SEO 优化</p>\n<p>因此，对于某些业务场景，如果需要关注如上两点的，就需要作出相应的优化。<br>而服务端渲染 SSR 就是为了解决这几个问题的。<br>这里说的 SSR 相对于传统的 SSR 的优势就在于能够在使用最新技术（vue、react等）的同时做到SSR。</p>\n<h3 id=\"服务端渲染脚手架\"><a href=\"#服务端渲染脚手架\" class=\"headerlink\" title=\"服务端渲染脚手架\"></a>服务端渲染脚手架</h3><p>这个是本人自己整理的 vue+koa+webpack4的服务端渲染脚手架<br><a href=\"https://github.com/zhoushirong/vue-koa-ssr.git\">https://github.com/zhoushirong/vue-koa-ssr.git</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是服务器端渲染-SSR-？\"><a href=\"#什么是服务器端渲染-SSR-？\" class=\"headerlink\" title=\"什么是服务器端渲染 (SSR)？\"></a>什么是服务器端渲染 (SSR)？</h3><p>所谓的服务端渲染其实并不是上面新奇的东西，顾名思义，就是页面的生成是在服务端完成的。<br>它自上古以来（很久很久以前）就已经存在了，传统的 jsp 页面、asp.net等页面都可以看做是服务端渲染的页面。<br>既然如此，为什么会单独拿出来说事儿呢？</p>\n<h3 id=\"单页应用（SPA-single-page-application）\"><a href=\"#单页应用（SPA-single-page-application）\" class=\"headerlink\" title=\"单页应用（SPA single-page application）\"></a>单页应用（SPA single-page application）</h3><p>之所以单独拿服务端渲染说事，就是因为近几年兴起的“单页应用”。</p>\n<p>什么是单页应用呢？<br>单页应用，是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。 —— 维基百科</p>\n<p>举例来说，最近几年兴起的，用 vue、react、Angular等技术开发的将传统的 html 开发转变为 js开发，然后在前端生成虚拟 DOM ，并在前端直接通过 js 绘制的页面，而且在前端自己维护的一套前端路由，通过前端路由切换页面的应用就是典型的单页应用。</p>\n<p>单页应用的好处多多，能够实现前端页面平滑无刷新切换，能够实现虚拟DOM快速响应用户交互等等<br>但是，其缺点也有，那就是首次渲染页面相对 ssr 会慢一些，而且，因为其是在前端通过js绘制的页面，这就导致了它对搜索引擎抓取网站内容造成了一些阻碍，对 SEO 不友好。<br>当然，随着近几年单页应用越来越火热，搜索引擎（如google）也对单页应用做了相应的优化。</p>\n<h3 id=\"为什么使用服务器端渲染-SSR-？\"><a href=\"#为什么使用服务器端渲染-SSR-？\" class=\"headerlink\" title=\"为什么使用服务器端渲染 (SSR)？\"></a>为什么使用服务器端渲染 (SSR)？</h3><p>所以，我们为什么要使用服务端渲染呢？<br>1、页面首页渲染更快，减少白屏时长<br>2、SEO 优化</p>\n<p>因此，对于某些业务场景，如果需要关注如上两点的，就需要作出相应的优化。<br>而服务端渲染 SSR 就是为了解决这几个问题的。<br>这里说的 SSR 相对于传统的 SSR 的优势就在于能够在使用最新技术（vue、react等）的同时做到SSR。</p>\n<h3 id=\"服务端渲染脚手架\"><a href=\"#服务端渲染脚手架\" class=\"headerlink\" title=\"服务端渲染脚手架\"></a>服务端渲染脚手架</h3><p>这个是本人自己整理的 vue+koa+webpack4的服务端渲染脚手架<br><a href=\"https://github.com/zhoushirong/vue-koa-ssr.git\">https://github.com/zhoushirong/vue-koa-ssr.git</a></p>\n"},{"title":"vue运行过程","date":"2018-08-01T16:00:00.000Z","_content":"\n#### 初始化 \n```javascript\nvar _v = new Vue()\n_v.init()\n```\n在new Vue()之后，Vue会调用init函数进行初始化。\n初始化包括：生命周期、事件、props、methods、data、computed、watch\n其中，*最重要的是*，通过Object.defineProperty设置 setter与getter函数，用来实现响应式以及依赖收集。\n\n#### mount()\n```javascript\n_v.$mount()\n```\n初始化之后调用 $mount 方法会挂载组件，如果是运行时编译（即不存在render function，但是存在template 的情况）需要进行编译步骤。\n\n\n#### compile()\n```javascript\ncompile() // 编译，包括三步\n- parse() // 解析，用正则等方式解析template模板中的指令（class、style等数据），形成AST。\n- optimize() // 优化，主要作用是标记静态节点，后面当update更新界面时，会有一个patch过程，此时，diff算法会直接跳过静态节点，优化patch性能\n- generate() // 生成，将AST转换为render function\n```\n\n#### 响应式\n```html\ninit的时候通过Object.defineProperty设置setter与getter函数。\nrender的时候，会触发getter函数，此时，进行依赖收集。\n在修改数据对象的时候，会触发setter函数，此时，通知依赖来更新视图。\nps:更新视图之前还有一个path的过程以及使用队列 \"异步更新\" 的策略。\n```\n\n#### vertual DOM\nrender function 会被转化为Javascript对象节点（VNode）。\nVirtual DOM其实就是一棵 VNode 作为基础的树，用对象属性来描述节点，实际上它只是一层对真实DOM的抽象。\n最终可以通过一系列操作使这棵树映射到真实环境上。\n由于Virtual DOM是以JavaScript对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。\n\n数据变化之后会触发setter，然后触发watcher，最后update更新视图。\n整个过程具体为：\n数据变化 ——> 执行render function得到新的VNode ——> 解析VNode ——> （diff 算法） ——> 更新必要的DOM\n\n\n### 独立构建与运行时构建\n传送门：https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释\n\n编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。\n\n*独立构建*，包括编译和支持 template 选项。 （同时，也依赖浏览器接口的存在，所以你不能使用它来为服务器端）\n*运行时构建*，不包括模板编译，不支持template选项。运行时构建，可以用render选项，但它只在单文件组件中起作用，因为单文件组件的模板是在构建时预编译到 render 函数中，运行时构建只有独立构建大小的 30%。\n\n完整版：同时包含编译器和运行时的版本。\n运行时版本：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。\n\n如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader预编译模板，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。\n\n\n\n\n### 传送门\n\nhttps://github.com/answershuto/learnVue\n\n","source":"_posts/vue1.md","raw":"---\ntitle: vue运行过程\ndate: 2018/08/02\ntag: [vue]\ncategory: 笔记\n---\n\n#### 初始化 \n```javascript\nvar _v = new Vue()\n_v.init()\n```\n在new Vue()之后，Vue会调用init函数进行初始化。\n初始化包括：生命周期、事件、props、methods、data、computed、watch\n其中，*最重要的是*，通过Object.defineProperty设置 setter与getter函数，用来实现响应式以及依赖收集。\n\n#### mount()\n```javascript\n_v.$mount()\n```\n初始化之后调用 $mount 方法会挂载组件，如果是运行时编译（即不存在render function，但是存在template 的情况）需要进行编译步骤。\n\n\n#### compile()\n```javascript\ncompile() // 编译，包括三步\n- parse() // 解析，用正则等方式解析template模板中的指令（class、style等数据），形成AST。\n- optimize() // 优化，主要作用是标记静态节点，后面当update更新界面时，会有一个patch过程，此时，diff算法会直接跳过静态节点，优化patch性能\n- generate() // 生成，将AST转换为render function\n```\n\n#### 响应式\n```html\ninit的时候通过Object.defineProperty设置setter与getter函数。\nrender的时候，会触发getter函数，此时，进行依赖收集。\n在修改数据对象的时候，会触发setter函数，此时，通知依赖来更新视图。\nps:更新视图之前还有一个path的过程以及使用队列 \"异步更新\" 的策略。\n```\n\n#### vertual DOM\nrender function 会被转化为Javascript对象节点（VNode）。\nVirtual DOM其实就是一棵 VNode 作为基础的树，用对象属性来描述节点，实际上它只是一层对真实DOM的抽象。\n最终可以通过一系列操作使这棵树映射到真实环境上。\n由于Virtual DOM是以JavaScript对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。\n\n数据变化之后会触发setter，然后触发watcher，最后update更新视图。\n整个过程具体为：\n数据变化 ——> 执行render function得到新的VNode ——> 解析VNode ——> （diff 算法） ——> 更新必要的DOM\n\n\n### 独立构建与运行时构建\n传送门：https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释\n\n编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。\n\n*独立构建*，包括编译和支持 template 选项。 （同时，也依赖浏览器接口的存在，所以你不能使用它来为服务器端）\n*运行时构建*，不包括模板编译，不支持template选项。运行时构建，可以用render选项，但它只在单文件组件中起作用，因为单文件组件的模板是在构建时预编译到 render 函数中，运行时构建只有独立构建大小的 30%。\n\n完整版：同时包含编译器和运行时的版本。\n运行时版本：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。\n\n如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader预编译模板，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。\n\n\n\n\n### 传送门\n\nhttps://github.com/answershuto/learnVue\n\n","slug":"vue1","published":1,"updated":"2021-03-30T01:32:00.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ugd001va0vz71ml8w0b","content":"<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _v = <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\">_v.init()</span><br></pre></td></tr></table></figure>\n<p>在new Vue()之后，Vue会调用init函数进行初始化。<br>初始化包括：生命周期、事件、props、methods、data、computed、watch<br>其中，<em>最重要的是</em>，通过Object.defineProperty设置 setter与getter函数，用来实现响应式以及依赖收集。</p>\n<h4 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount()\"></a>mount()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_v.$mount()</span><br></pre></td></tr></table></figure>\n<p>初始化之后调用 $mount 方法会挂载组件，如果是运行时编译（即不存在render function，但是存在template 的情况）需要进行编译步骤。</p>\n<h4 id=\"compile\"><a href=\"#compile\" class=\"headerlink\" title=\"compile()\"></a>compile()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile() <span class=\"comment\">// 编译，包括三步</span></span><br><span class=\"line\">- parse() <span class=\"comment\">// 解析，用正则等方式解析template模板中的指令（class、style等数据），形成AST。</span></span><br><span class=\"line\">- optimize() <span class=\"comment\">// 优化，主要作用是标记静态节点，后面当update更新界面时，会有一个patch过程，此时，diff算法会直接跳过静态节点，优化patch性能</span></span><br><span class=\"line\">- generate() <span class=\"comment\">// 生成，将AST转换为render function</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"响应式\"><a href=\"#响应式\" class=\"headerlink\" title=\"响应式\"></a>响应式</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init的时候通过Object.defineProperty设置setter与getter函数。</span><br><span class=\"line\">render的时候，会触发getter函数，此时，进行依赖收集。</span><br><span class=\"line\">在修改数据对象的时候，会触发setter函数，此时，通知依赖来更新视图。</span><br><span class=\"line\">ps:更新视图之前还有一个path的过程以及使用队列 &quot;异步更新&quot; 的策略。</span><br></pre></td></tr></table></figure>\n<h4 id=\"vertual-DOM\"><a href=\"#vertual-DOM\" class=\"headerlink\" title=\"vertual DOM\"></a>vertual DOM</h4><p>render function 会被转化为Javascript对象节点（VNode）。<br>Virtual DOM其实就是一棵 VNode 作为基础的树，用对象属性来描述节点，实际上它只是一层对真实DOM的抽象。<br>最终可以通过一系列操作使这棵树映射到真实环境上。<br>由于Virtual DOM是以JavaScript对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p>\n<p>数据变化之后会触发setter，然后触发watcher，最后update更新视图。<br>整个过程具体为：<br>数据变化 ——&gt; 执行render function得到新的VNode ——&gt; 解析VNode ——&gt; （diff 算法） ——&gt; 更新必要的DOM</p>\n<h3 id=\"独立构建与运行时构建\"><a href=\"#独立构建与运行时构建\" class=\"headerlink\" title=\"独立构建与运行时构建\"></a>独立构建与运行时构建</h3><p>传送门：<a href=\"https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释\">https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释</a></p>\n<p>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。</p>\n<p><em>独立构建</em>，包括编译和支持 template 选项。 （同时，也依赖浏览器接口的存在，所以你不能使用它来为服务器端）<br><em>运行时构建</em>，不包括模板编译，不支持template选项。运行时构建，可以用render选项，但它只在单文件组件中起作用，因为单文件组件的模板是在构建时预编译到 render 函数中，运行时构建只有独立构建大小的 30%。</p>\n<p>完整版：同时包含编译器和运行时的版本。<br>运行时版本：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</p>\n<p>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader预编译模板，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://github.com/answershuto/learnVue\">https://github.com/answershuto/learnVue</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _v = <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\">_v.init()</span><br></pre></td></tr></table></figure>\n<p>在new Vue()之后，Vue会调用init函数进行初始化。<br>初始化包括：生命周期、事件、props、methods、data、computed、watch<br>其中，<em>最重要的是</em>，通过Object.defineProperty设置 setter与getter函数，用来实现响应式以及依赖收集。</p>\n<h4 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount()\"></a>mount()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_v.$mount()</span><br></pre></td></tr></table></figure>\n<p>初始化之后调用 $mount 方法会挂载组件，如果是运行时编译（即不存在render function，但是存在template 的情况）需要进行编译步骤。</p>\n<h4 id=\"compile\"><a href=\"#compile\" class=\"headerlink\" title=\"compile()\"></a>compile()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile() <span class=\"comment\">// 编译，包括三步</span></span><br><span class=\"line\">- parse() <span class=\"comment\">// 解析，用正则等方式解析template模板中的指令（class、style等数据），形成AST。</span></span><br><span class=\"line\">- optimize() <span class=\"comment\">// 优化，主要作用是标记静态节点，后面当update更新界面时，会有一个patch过程，此时，diff算法会直接跳过静态节点，优化patch性能</span></span><br><span class=\"line\">- generate() <span class=\"comment\">// 生成，将AST转换为render function</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"响应式\"><a href=\"#响应式\" class=\"headerlink\" title=\"响应式\"></a>响应式</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init的时候通过Object.defineProperty设置setter与getter函数。</span><br><span class=\"line\">render的时候，会触发getter函数，此时，进行依赖收集。</span><br><span class=\"line\">在修改数据对象的时候，会触发setter函数，此时，通知依赖来更新视图。</span><br><span class=\"line\">ps:更新视图之前还有一个path的过程以及使用队列 &quot;异步更新&quot; 的策略。</span><br></pre></td></tr></table></figure>\n<h4 id=\"vertual-DOM\"><a href=\"#vertual-DOM\" class=\"headerlink\" title=\"vertual DOM\"></a>vertual DOM</h4><p>render function 会被转化为Javascript对象节点（VNode）。<br>Virtual DOM其实就是一棵 VNode 作为基础的树，用对象属性来描述节点，实际上它只是一层对真实DOM的抽象。<br>最终可以通过一系列操作使这棵树映射到真实环境上。<br>由于Virtual DOM是以JavaScript对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p>\n<p>数据变化之后会触发setter，然后触发watcher，最后update更新视图。<br>整个过程具体为：<br>数据变化 ——&gt; 执行render function得到新的VNode ——&gt; 解析VNode ——&gt; （diff 算法） ——&gt; 更新必要的DOM</p>\n<h3 id=\"独立构建与运行时构建\"><a href=\"#独立构建与运行时构建\" class=\"headerlink\" title=\"独立构建与运行时构建\"></a>独立构建与运行时构建</h3><p>传送门：<a href=\"https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释\">https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释</a></p>\n<p>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。</p>\n<p><em>独立构建</em>，包括编译和支持 template 选项。 （同时，也依赖浏览器接口的存在，所以你不能使用它来为服务器端）<br><em>运行时构建</em>，不包括模板编译，不支持template选项。运行时构建，可以用render选项，但它只在单文件组件中起作用，因为单文件组件的模板是在构建时预编译到 render 函数中，运行时构建只有独立构建大小的 30%。</p>\n<p>完整版：同时包含编译器和运行时的版本。<br>运行时版本：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</p>\n<p>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader预编译模板，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://github.com/answershuto/learnVue\">https://github.com/answershuto/learnVue</a></p>\n"},{"title":"vuex","date":"2018-08-06T16:00:00.000Z","_content":"\nVuex是一个专门为Vue.js应用程序开发的状态管理模式。\n它采用集中式存储管理应用的所有组件状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n状态管理包含以下几部分\n```html\n1.state 驱动应用的数据源\n2.view 以声明方式将state映射到视图\n3.action 相应在 view 上的用户输入导致的状态变化\n```\n\n这三个状态之间互相交互，就形成了vue的单向数据流\n\n<img src=\"https://vuex.vuejs.org/flow.png\" width=\"50%\" height=\"50%\">\n\n但是这个单项数据流模式是很容易被破坏的。\n如：\n```html\n1.多个视图依赖于同一状态。\n2.来自不同视图的行为需要变更同一状态。\n```\n\n对于第一种状态，可以通过传参的形式解决，但是对于兄弟节点之间的状态传递就很麻烦了。\n第二种状态，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。\n\n这些做法都有其局限性，那么有什么办法能解决这些问题呢？\n\n\n这就是vuex被设计出来的原因了。它的出现就是为了解决这些问题。\n\n<img src=\"https://vuex.vuejs.org/vuex.png\" width=\"50%\" height=\"50%\">\n\n### 核心概念\n\n```html\nstate：vuex使用单一状态树，一个对象包含了全部应用层级的状态，是唯一数据源。\n```\n由于vuex的状态是存储是响应式的，从store实例中读取状态，最简单的方法就是在计算属性中返回某个状态。\n\n\n除此之外，vue 还通过store选项，提供了一种机制，将状态从根组件 注入到每一个子组件。\n```javascript\n\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport * as actions from './actions'\nimport * as getters from './getters'\nimport state from './state'\nimport mutations from './mutations'\n\nVue.use(Vuex)\n\nconst debug = process.env.NODE_ENV !== 'production'\n\nlet store = new Vuex.Store({\n  actions,\n  getters,\n  state,\n  mutations,\n})\n\n\nconst app = new Vue({\n  el: '#app',\n  store, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\n  components: { Counter },\n  template: `\n    <div class=\"app\">\n      <counter></counter>\n    </div>\n  `\n})\n```\n通过在根实例中注册store选项，该store实例会注入到根组件下所有子组件中\n子组件能通过 this.$store 访问到。\n\n```html\ngetter： 通过getter获取属性，可以在获取state的时候对属性进行过滤或者计算。\n```\ngetter的返回值跟计算属性一样，会被缓存，只有当依赖属性变化的时候才会重新计算，可以看做是store的计算属性。\ngetter可以返回一个函数，来实现给getter传参。\n当getter返回的是一个函数的时候，通过方法访问的时候，每次都会去进行调用，不会缓存结果。\n\n\n```html\nmutation：更改vuex中store状态的唯一方法就是提交mutation\n```\nvuex中的mutation类似于事件\n每个mutation都有一个字符串 事件类型（type）和一个回调函数（handler）\n这个回调函数就是我们实际进行状态更改的地方，它接受一个state作为第一个参数。\n\n定义一个mutation\n```javascript\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state, n) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n```\n\n调用一个mutation\n```javascript\n// 字符串的方式调用\nstore.commit('increment', n)\n\n// 对象的方式调用cc\nstore.commit({\n  type: 'increment',\n  amount: 10\n  ... // 更多字段\n})\n```\n第二个参数‘n’叫做载荷，通常情况n是一个对象，这样方便传更多的参数。\n\n特别注意：mutation必须是同步函数。\n那么如果是异步请求怎么办呢？\n\n此时，就需要用到另一个核心概念Action了\n\n\n```html\naction：action和mutation类型，区别在于，action是提交一个mutation而直接变更状态。\n```\naction可以包含任意异步操作。\n\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象作为参数。\ncontext可以有commit、state、getters、\n因此，可以直接通过参数调用commit触发mutation。\n```javascript\n// 定义一个action\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n\n// 调用一个action action也支持荷载，支持对象和字符串的方式传参\n// 以载荷形式分发\nstore.dispatch('incrementAsync', {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n\nstore.dispatch可以处理被触发action的处理函数返回的Promise，并且 store.dispatch仍旧返回Promise\n```javascript\n// 定义异步的action\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  }\n}\n\n// dispatch一个promise\nstore.dispatch('actionA').then(() => {\n  // ...\n})\n```\n\n```html\nmodule：将store分割成模块，每个模块拥有自己的state、mutation、action、getter、嵌套子模块等。这个模块就是module\n```\n如果store非常大的时候，非常不好管理，这时候就可以将其分割为小的module了。\n\n\n```javascript\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。\n对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState\n对于模块内部的 getter，根节点状态会作为第三个参数暴露出来\n\n#### 模块命名空间\n默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。\n如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块\n```javascript\nconst store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true, // 待命名空间的模块，（命名空间控制属性会继承）\n    }\n  }\n})\n```\n\n### 传送门\nhttps://vuex.vuejs.org/zh/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/vue2.md","raw":"---\ntitle: vuex\ndate: 2018/08/07\ntag: [vue vuex]\ncategory: 笔记\n---\n\nVuex是一个专门为Vue.js应用程序开发的状态管理模式。\n它采用集中式存储管理应用的所有组件状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n状态管理包含以下几部分\n```html\n1.state 驱动应用的数据源\n2.view 以声明方式将state映射到视图\n3.action 相应在 view 上的用户输入导致的状态变化\n```\n\n这三个状态之间互相交互，就形成了vue的单向数据流\n\n<img src=\"https://vuex.vuejs.org/flow.png\" width=\"50%\" height=\"50%\">\n\n但是这个单项数据流模式是很容易被破坏的。\n如：\n```html\n1.多个视图依赖于同一状态。\n2.来自不同视图的行为需要变更同一状态。\n```\n\n对于第一种状态，可以通过传参的形式解决，但是对于兄弟节点之间的状态传递就很麻烦了。\n第二种状态，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。\n\n这些做法都有其局限性，那么有什么办法能解决这些问题呢？\n\n\n这就是vuex被设计出来的原因了。它的出现就是为了解决这些问题。\n\n<img src=\"https://vuex.vuejs.org/vuex.png\" width=\"50%\" height=\"50%\">\n\n### 核心概念\n\n```html\nstate：vuex使用单一状态树，一个对象包含了全部应用层级的状态，是唯一数据源。\n```\n由于vuex的状态是存储是响应式的，从store实例中读取状态，最简单的方法就是在计算属性中返回某个状态。\n\n\n除此之外，vue 还通过store选项，提供了一种机制，将状态从根组件 注入到每一个子组件。\n```javascript\n\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport * as actions from './actions'\nimport * as getters from './getters'\nimport state from './state'\nimport mutations from './mutations'\n\nVue.use(Vuex)\n\nconst debug = process.env.NODE_ENV !== 'production'\n\nlet store = new Vuex.Store({\n  actions,\n  getters,\n  state,\n  mutations,\n})\n\n\nconst app = new Vue({\n  el: '#app',\n  store, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\n  components: { Counter },\n  template: `\n    <div class=\"app\">\n      <counter></counter>\n    </div>\n  `\n})\n```\n通过在根实例中注册store选项，该store实例会注入到根组件下所有子组件中\n子组件能通过 this.$store 访问到。\n\n```html\ngetter： 通过getter获取属性，可以在获取state的时候对属性进行过滤或者计算。\n```\ngetter的返回值跟计算属性一样，会被缓存，只有当依赖属性变化的时候才会重新计算，可以看做是store的计算属性。\ngetter可以返回一个函数，来实现给getter传参。\n当getter返回的是一个函数的时候，通过方法访问的时候，每次都会去进行调用，不会缓存结果。\n\n\n```html\nmutation：更改vuex中store状态的唯一方法就是提交mutation\n```\nvuex中的mutation类似于事件\n每个mutation都有一个字符串 事件类型（type）和一个回调函数（handler）\n这个回调函数就是我们实际进行状态更改的地方，它接受一个state作为第一个参数。\n\n定义一个mutation\n```javascript\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state, n) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n```\n\n调用一个mutation\n```javascript\n// 字符串的方式调用\nstore.commit('increment', n)\n\n// 对象的方式调用cc\nstore.commit({\n  type: 'increment',\n  amount: 10\n  ... // 更多字段\n})\n```\n第二个参数‘n’叫做载荷，通常情况n是一个对象，这样方便传更多的参数。\n\n特别注意：mutation必须是同步函数。\n那么如果是异步请求怎么办呢？\n\n此时，就需要用到另一个核心概念Action了\n\n\n```html\naction：action和mutation类型，区别在于，action是提交一个mutation而直接变更状态。\n```\naction可以包含任意异步操作。\n\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象作为参数。\ncontext可以有commit、state、getters、\n因此，可以直接通过参数调用commit触发mutation。\n```javascript\n// 定义一个action\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n\n// 调用一个action action也支持荷载，支持对象和字符串的方式传参\n// 以载荷形式分发\nstore.dispatch('incrementAsync', {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n\nstore.dispatch可以处理被触发action的处理函数返回的Promise，并且 store.dispatch仍旧返回Promise\n```javascript\n// 定义异步的action\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  }\n}\n\n// dispatch一个promise\nstore.dispatch('actionA').then(() => {\n  // ...\n})\n```\n\n```html\nmodule：将store分割成模块，每个模块拥有自己的state、mutation、action、getter、嵌套子模块等。这个模块就是module\n```\n如果store非常大的时候，非常不好管理，这时候就可以将其分割为小的module了。\n\n\n```javascript\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。\n对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState\n对于模块内部的 getter，根节点状态会作为第三个参数暴露出来\n\n#### 模块命名空间\n默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。\n如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块\n```javascript\nconst store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true, // 待命名空间的模块，（命名空间控制属性会继承）\n    }\n  }\n})\n```\n\n### 传送门\nhttps://vuex.vuejs.org/zh/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"vue2","published":1,"updated":"2021-03-30T01:32:00.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ugd001wa0vzdeea4tem","content":"<p>Vuex是一个专门为Vue.js应用程序开发的状态管理模式。<br>它采用集中式存储管理应用的所有组件状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<p>状态管理包含以下几部分<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.state 驱动应用的数据源</span><br><span class=\"line\">2.view 以声明方式将state映射到视图</span><br><span class=\"line\">3.action 相应在 view 上的用户输入导致的状态变化</span><br></pre></td></tr></table></figure></p>\n<p>这三个状态之间互相交互，就形成了vue的单向数据流</p>\n<p><img src=\"https://vuex.vuejs.org/flow.png\" width=\"50%\" height=\"50%\"></p>\n<p>但是这个单项数据流模式是很容易被破坏的。<br>如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.多个视图依赖于同一状态。</span><br><span class=\"line\">2.来自不同视图的行为需要变更同一状态。</span><br></pre></td></tr></table></figure></p>\n<p>对于第一种状态，可以通过传参的形式解决，但是对于兄弟节点之间的状态传递就很麻烦了。<br>第二种状态，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。</p>\n<p>这些做法都有其局限性，那么有什么办法能解决这些问题呢？</p>\n<p>这就是vuex被设计出来的原因了。它的出现就是为了解决这些问题。</p>\n<p><img src=\"https://vuex.vuejs.org/vuex.png\" width=\"50%\" height=\"50%\"></p>\n<h3 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state：vuex使用单一状态树，一个对象包含了全部应用层级的状态，是唯一数据源。</span><br></pre></td></tr></table></figure>\n<p>由于vuex的状态是存储是响应式的，从store实例中读取状态，最简单的方法就是在计算属性中返回某个状态。</p>\n<p>除此之外，vue 还通过store选项，提供了一种机制，将状态从根组件 注入到每一个子组件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actions <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./actions&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> getters <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./getters&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> state <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./state&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> mutations <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./mutations&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> debug = process.env.NODE_ENV !== <span class=\"string\">&#x27;production&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  actions,</span><br><span class=\"line\">  getters,</span><br><span class=\"line\">  state,</span><br><span class=\"line\">  mutations,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">  store, <span class=\"comment\">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class=\"line\">  components: &#123; Counter &#125;,</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=&quot;app&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>通过在根实例中注册store选项，该store实例会注入到根组件下所有子组件中<br>子组件能通过 this.$store 访问到。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getter： 通过getter获取属性，可以在获取state的时候对属性进行过滤或者计算。</span><br></pre></td></tr></table></figure>\n<p>getter的返回值跟计算属性一样，会被缓存，只有当依赖属性变化的时候才会重新计算，可以看做是store的计算属性。<br>getter可以返回一个函数，来实现给getter传参。<br>当getter返回的是一个函数的时候，通过方法访问的时候，每次都会去进行调用，不会缓存结果。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutation：更改vuex中store状态的唯一方法就是提交mutation</span><br></pre></td></tr></table></figure>\n<p>vuex中的mutation类似于事件<br>每个mutation都有一个字符串 事件类型（type）和一个回调函数（handler）<br>这个回调函数就是我们实际进行状态更改的地方，它接受一个state作为第一个参数。</p>\n<p>定义一个mutation<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    increment (state, n) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 变更状态</span></span><br><span class=\"line\">      state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>调用一个mutation<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串的方式调用</span></span><br><span class=\"line\">store.commit(<span class=\"string\">&#x27;increment&#x27;</span>, n)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象的方式调用cc</span></span><br><span class=\"line\">store.commit(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;increment&#x27;</span>,</span><br><span class=\"line\">  amount: <span class=\"number\">10</span></span><br><span class=\"line\">  ... <span class=\"comment\">// 更多字段</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>第二个参数‘n’叫做载荷，通常情况n是一个对象，这样方便传更多的参数。</p>\n<p>特别注意：mutation必须是同步函数。<br>那么如果是异步请求怎么办呢？</p>\n<p>此时，就需要用到另一个核心概念Action了</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">action：action和mutation类型，区别在于，action是提交一个mutation而直接变更状态。</span><br></pre></td></tr></table></figure>\n<p>action可以包含任意异步操作。</p>\n<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象作为参数。<br>context可以有commit、state、getters、<br>因此，可以直接通过参数调用commit触发mutation。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个action</span></span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      commit(<span class=\"string\">&#x27;increment&#x27;</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用一个action action也支持荷载，支持对象和字符串的方式传参</span></span><br><span class=\"line\"><span class=\"comment\">// 以载荷形式分发</span></span><br><span class=\"line\">store.dispatch(<span class=\"string\">&#x27;incrementAsync&#x27;</span>, &#123;</span><br><span class=\"line\">  amount: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以对象形式分发</span></span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;incrementAsync&#x27;</span>,</span><br><span class=\"line\">  amount: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>store.dispatch可以处理被触发action的处理函数返回的Promise，并且 store.dispatch仍旧返回Promise<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义异步的action</span></span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        commit(<span class=\"string\">&#x27;someMutation&#x27;</span>)</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dispatch一个promise</span></span><br><span class=\"line\">store.dispatch(<span class=\"string\">&#x27;actionA&#x27;</span>).then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module：将store分割成模块，每个模块拥有自己的state、mutation、action、getter、嵌套子模块等。这个模块就是module</span><br></pre></td></tr></table></figure>\n<p>如果store非常大的时候，非常不好管理，这时候就可以将其分割为小的module了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a <span class=\"comment\">// -&gt; moduleA 的状态</span></span><br><span class=\"line\">store.state.b <span class=\"comment\">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>\n<p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。<br>对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState<br>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来</p>\n<h4 id=\"模块命名空间\"><a href=\"#模块命名空间\" class=\"headerlink\" title=\"模块命名空间\"></a>模块命名空间</h4><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。<br>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    account: &#123;</span><br><span class=\"line\">      namespaced: <span class=\"literal\">true</span>, <span class=\"comment\">// 待命名空间的模块，（命名空间控制属性会继承）</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://vuex.vuejs.org/zh/\">https://vuex.vuejs.org/zh/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Vuex是一个专门为Vue.js应用程序开发的状态管理模式。<br>它采用集中式存储管理应用的所有组件状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<p>状态管理包含以下几部分<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.state 驱动应用的数据源</span><br><span class=\"line\">2.view 以声明方式将state映射到视图</span><br><span class=\"line\">3.action 相应在 view 上的用户输入导致的状态变化</span><br></pre></td></tr></table></figure></p>\n<p>这三个状态之间互相交互，就形成了vue的单向数据流</p>\n<p><img src=\"https://vuex.vuejs.org/flow.png\" width=\"50%\" height=\"50%\"></p>\n<p>但是这个单项数据流模式是很容易被破坏的。<br>如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.多个视图依赖于同一状态。</span><br><span class=\"line\">2.来自不同视图的行为需要变更同一状态。</span><br></pre></td></tr></table></figure></p>\n<p>对于第一种状态，可以通过传参的形式解决，但是对于兄弟节点之间的状态传递就很麻烦了。<br>第二种状态，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。</p>\n<p>这些做法都有其局限性，那么有什么办法能解决这些问题呢？</p>\n<p>这就是vuex被设计出来的原因了。它的出现就是为了解决这些问题。</p>\n<p><img src=\"https://vuex.vuejs.org/vuex.png\" width=\"50%\" height=\"50%\"></p>\n<h3 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state：vuex使用单一状态树，一个对象包含了全部应用层级的状态，是唯一数据源。</span><br></pre></td></tr></table></figure>\n<p>由于vuex的状态是存储是响应式的，从store实例中读取状态，最简单的方法就是在计算属性中返回某个状态。</p>\n<p>除此之外，vue 还通过store选项，提供了一种机制，将状态从根组件 注入到每一个子组件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actions <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./actions&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> getters <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./getters&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> state <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./state&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> mutations <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./mutations&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> debug = process.env.NODE_ENV !== <span class=\"string\">&#x27;production&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  actions,</span><br><span class=\"line\">  getters,</span><br><span class=\"line\">  state,</span><br><span class=\"line\">  mutations,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">  store, <span class=\"comment\">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class=\"line\">  components: &#123; Counter &#125;,</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=&quot;app&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>通过在根实例中注册store选项，该store实例会注入到根组件下所有子组件中<br>子组件能通过 this.$store 访问到。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getter： 通过getter获取属性，可以在获取state的时候对属性进行过滤或者计算。</span><br></pre></td></tr></table></figure>\n<p>getter的返回值跟计算属性一样，会被缓存，只有当依赖属性变化的时候才会重新计算，可以看做是store的计算属性。<br>getter可以返回一个函数，来实现给getter传参。<br>当getter返回的是一个函数的时候，通过方法访问的时候，每次都会去进行调用，不会缓存结果。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutation：更改vuex中store状态的唯一方法就是提交mutation</span><br></pre></td></tr></table></figure>\n<p>vuex中的mutation类似于事件<br>每个mutation都有一个字符串 事件类型（type）和一个回调函数（handler）<br>这个回调函数就是我们实际进行状态更改的地方，它接受一个state作为第一个参数。</p>\n<p>定义一个mutation<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    increment (state, n) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 变更状态</span></span><br><span class=\"line\">      state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>调用一个mutation<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串的方式调用</span></span><br><span class=\"line\">store.commit(<span class=\"string\">&#x27;increment&#x27;</span>, n)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象的方式调用cc</span></span><br><span class=\"line\">store.commit(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;increment&#x27;</span>,</span><br><span class=\"line\">  amount: <span class=\"number\">10</span></span><br><span class=\"line\">  ... <span class=\"comment\">// 更多字段</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>第二个参数‘n’叫做载荷，通常情况n是一个对象，这样方便传更多的参数。</p>\n<p>特别注意：mutation必须是同步函数。<br>那么如果是异步请求怎么办呢？</p>\n<p>此时，就需要用到另一个核心概念Action了</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">action：action和mutation类型，区别在于，action是提交一个mutation而直接变更状态。</span><br></pre></td></tr></table></figure>\n<p>action可以包含任意异步操作。</p>\n<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象作为参数。<br>context可以有commit、state、getters、<br>因此，可以直接通过参数调用commit触发mutation。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个action</span></span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      commit(<span class=\"string\">&#x27;increment&#x27;</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用一个action action也支持荷载，支持对象和字符串的方式传参</span></span><br><span class=\"line\"><span class=\"comment\">// 以载荷形式分发</span></span><br><span class=\"line\">store.dispatch(<span class=\"string\">&#x27;incrementAsync&#x27;</span>, &#123;</span><br><span class=\"line\">  amount: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以对象形式分发</span></span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;incrementAsync&#x27;</span>,</span><br><span class=\"line\">  amount: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>store.dispatch可以处理被触发action的处理函数返回的Promise，并且 store.dispatch仍旧返回Promise<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义异步的action</span></span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        commit(<span class=\"string\">&#x27;someMutation&#x27;</span>)</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dispatch一个promise</span></span><br><span class=\"line\">store.dispatch(<span class=\"string\">&#x27;actionA&#x27;</span>).then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module：将store分割成模块，每个模块拥有自己的state、mutation、action、getter、嵌套子模块等。这个模块就是module</span><br></pre></td></tr></table></figure>\n<p>如果store非常大的时候，非常不好管理，这时候就可以将其分割为小的module了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a <span class=\"comment\">// -&gt; moduleA 的状态</span></span><br><span class=\"line\">store.state.b <span class=\"comment\">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>\n<p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。<br>对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState<br>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来</p>\n<h4 id=\"模块命名空间\"><a href=\"#模块命名空间\" class=\"headerlink\" title=\"模块命名空间\"></a>模块命名空间</h4><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。<br>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    account: &#123;</span><br><span class=\"line\">      namespaced: <span class=\"literal\">true</span>, <span class=\"comment\">// 待命名空间的模块，（命名空间控制属性会继承）</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://vuex.vuejs.org/zh/\">https://vuex.vuejs.org/zh/</a></p>\n"},{"title":"Vue3 初探","date":"2021-02-03T16:00:00.000Z","_content":"\nVue3 已经来了，详细文档见下方传送门\n这里记录一下比较重要的几个点。\n\n#### 总体概述\n\n优点都是比较比出来的，那么 Vue3 对比 Vue2 优势有\n```html\n更小、更快、更友好、优化方案\ntypeScript支持\nAPI 设计一致性\n自身可维护性\n开放更多底层功能\n```\n1.更小\n移除不常用功能，引入 tree-shaking ，打包体积更小\n\n2.更快\n优化 diff 算法、静态提升、事件监听缓存、ssr优化等\n\n3.更友好\n提出 composition Api，无论代码的编写还是查看都更加清晰方便\n\n4.优化方案\n1）源码优化 vue3 整个源码是通过 monorepo的方式维护的，根据功能将不同的模块拆分到 packages 目录下面不同的子目录中\nVue3是基于 typeScript 编写的，提供了更好的类型检查，能支持复杂的类型推导\n2）性能优化\n体积优化、编译优化、***数据劫持优化***\n在 vue2 中，数据劫持是通过 Object.defineProperty，这个 API 有一些缺陷，并不能检测对象属性的添加和删除\nvue3 是通过 proxy 监听整个对象，那么对于删除还是监听当然也能监听到\n\n#### 算法优化\nvue3 标记了动态节点，在patch阶段，只会比较动态节点，静态的直接略过了\n而 vue2中，还是会 patch 所有子节点去比对变更\n\n\n#### 关于生命周期函数\n1.Vue2 父子组件生命周期执行顺序\n```html\n父beforeCreate\n-> 父created\n->父beforeMount\n->子beforeCreate\n->子created\n->子beforeMount\n->子mounted\n->父mounted\n```\n\n2.Vue3 中生命周期函数变化\n```html\nbeforeCreated/cateated => setup\nbeforeMounted => onBeforeMounted\nmounted => onMounted\nbeforeUpdated => onBeforeUpdated\nupdated => onUpdated\nbeforeDestroyed => onBeforeUnmounted\ndestroyed => onUnmounted\nerrorCaptured => onErrorCaptured\n```\n#### setup 组件选项\nsetup 是Vue新增的选项， 组件选项在创建组件之前执行，没有 this 。\n```javascript\nsetup(props, context) {\n  // ...\n}\n```\n\n#### 组合式API（Composition API）\nVue3中生命周期函数的执行顺序大体上没有变化，但是生命周期函数被从全局抽离了出来，原来挂载在 this 下面的生命周期函数需要手动引入。\n也就是 Vue3 最大的改变 —— Composition API\n\n通过组合式API，我们可以将接口的可重复部分及其功能提取到可重用的代码段中，能够将与同一个逻辑关注点相关的代码配置在一起。\n为了使组合式 API 的特性与选项式 API 相比更加完整，我们还需要一种在 setup 中注册生命周期钩子的方法。\n```html\n<template>\n  <div>{{ readersNumber }} - {{ twiceTheCounter }}-{{ book.title }}-{{ author }}</div>\n</template>\n```\n```javascript\nimport { ref, onMounted, watch, computed, toRefs } from 'vue'\n/**\n* props 即 vue2 中的 props 属性，是响应式的\n* context 是一个普通的 js 对象，它暴露三个组件的 property（context.attrs/context.slots/context.emit）\n*/\nexport default {\n  setup(props, context) {\n    /*\n    * 使用 `toRefs` 创建对prop的 `author` property 的响应式引用\n    * 确保我们的侦听器能够对 author prop 所做的更改做出反应。\n    * 因为 props 是响应式的，不能使用 ES6 解构，因为它会消除 prop 的响应性\n    */\n    const { author } = toRefs(props)\n    const readersNumber = ref(0)\n    const book = reactive({ title: 'Vue 3 Guide' })\n    const twiceTheCounter = computed(() => readersNumber.value * 2)\n    watch(user, (newValue, oldValue) => {\n      console.log('user change', newValue, oldValue)\n    })\n    // 如何在 setup () 内部调用生命周期钩子\n    onMounted() {\n      console.log('Component is mounted!')\n    }\n    // expose to template\n    return {\n      readersNumber,\n      book,\n      author,\n      twiceTheCounter,\n    }\n  }\n}\n```\n\n\n### 传送门\n[Vue3官方文档&迁移指南](https://vue3js.cn/docs/zh/guide/migration/introduction.html)\n\nvue3.0 diff 算法优化细节：[https://juejin.cn/post/6844904136299773965](https://juejin.cn/post/6844904136299773965)","source":"_posts/vue3.md","raw":"---\ntitle: Vue3 初探\ndate: 2021/02/04\ntag: [vue, vue3]\ncategory: 笔记\n---\n\nVue3 已经来了，详细文档见下方传送门\n这里记录一下比较重要的几个点。\n\n#### 总体概述\n\n优点都是比较比出来的，那么 Vue3 对比 Vue2 优势有\n```html\n更小、更快、更友好、优化方案\ntypeScript支持\nAPI 设计一致性\n自身可维护性\n开放更多底层功能\n```\n1.更小\n移除不常用功能，引入 tree-shaking ，打包体积更小\n\n2.更快\n优化 diff 算法、静态提升、事件监听缓存、ssr优化等\n\n3.更友好\n提出 composition Api，无论代码的编写还是查看都更加清晰方便\n\n4.优化方案\n1）源码优化 vue3 整个源码是通过 monorepo的方式维护的，根据功能将不同的模块拆分到 packages 目录下面不同的子目录中\nVue3是基于 typeScript 编写的，提供了更好的类型检查，能支持复杂的类型推导\n2）性能优化\n体积优化、编译优化、***数据劫持优化***\n在 vue2 中，数据劫持是通过 Object.defineProperty，这个 API 有一些缺陷，并不能检测对象属性的添加和删除\nvue3 是通过 proxy 监听整个对象，那么对于删除还是监听当然也能监听到\n\n#### 算法优化\nvue3 标记了动态节点，在patch阶段，只会比较动态节点，静态的直接略过了\n而 vue2中，还是会 patch 所有子节点去比对变更\n\n\n#### 关于生命周期函数\n1.Vue2 父子组件生命周期执行顺序\n```html\n父beforeCreate\n-> 父created\n->父beforeMount\n->子beforeCreate\n->子created\n->子beforeMount\n->子mounted\n->父mounted\n```\n\n2.Vue3 中生命周期函数变化\n```html\nbeforeCreated/cateated => setup\nbeforeMounted => onBeforeMounted\nmounted => onMounted\nbeforeUpdated => onBeforeUpdated\nupdated => onUpdated\nbeforeDestroyed => onBeforeUnmounted\ndestroyed => onUnmounted\nerrorCaptured => onErrorCaptured\n```\n#### setup 组件选项\nsetup 是Vue新增的选项， 组件选项在创建组件之前执行，没有 this 。\n```javascript\nsetup(props, context) {\n  // ...\n}\n```\n\n#### 组合式API（Composition API）\nVue3中生命周期函数的执行顺序大体上没有变化，但是生命周期函数被从全局抽离了出来，原来挂载在 this 下面的生命周期函数需要手动引入。\n也就是 Vue3 最大的改变 —— Composition API\n\n通过组合式API，我们可以将接口的可重复部分及其功能提取到可重用的代码段中，能够将与同一个逻辑关注点相关的代码配置在一起。\n为了使组合式 API 的特性与选项式 API 相比更加完整，我们还需要一种在 setup 中注册生命周期钩子的方法。\n```html\n<template>\n  <div>{{ readersNumber }} - {{ twiceTheCounter }}-{{ book.title }}-{{ author }}</div>\n</template>\n```\n```javascript\nimport { ref, onMounted, watch, computed, toRefs } from 'vue'\n/**\n* props 即 vue2 中的 props 属性，是响应式的\n* context 是一个普通的 js 对象，它暴露三个组件的 property（context.attrs/context.slots/context.emit）\n*/\nexport default {\n  setup(props, context) {\n    /*\n    * 使用 `toRefs` 创建对prop的 `author` property 的响应式引用\n    * 确保我们的侦听器能够对 author prop 所做的更改做出反应。\n    * 因为 props 是响应式的，不能使用 ES6 解构，因为它会消除 prop 的响应性\n    */\n    const { author } = toRefs(props)\n    const readersNumber = ref(0)\n    const book = reactive({ title: 'Vue 3 Guide' })\n    const twiceTheCounter = computed(() => readersNumber.value * 2)\n    watch(user, (newValue, oldValue) => {\n      console.log('user change', newValue, oldValue)\n    })\n    // 如何在 setup () 内部调用生命周期钩子\n    onMounted() {\n      console.log('Component is mounted!')\n    }\n    // expose to template\n    return {\n      readersNumber,\n      book,\n      author,\n      twiceTheCounter,\n    }\n  }\n}\n```\n\n\n### 传送门\n[Vue3官方文档&迁移指南](https://vue3js.cn/docs/zh/guide/migration/introduction.html)\n\nvue3.0 diff 算法优化细节：[https://juejin.cn/post/6844904136299773965](https://juejin.cn/post/6844904136299773965)","slug":"vue3","published":1,"updated":"2021-03-30T01:32:00.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7uge001xa0vz4kfm0tcm","content":"<p>Vue3 已经来了，详细文档见下方传送门<br>这里记录一下比较重要的几个点。</p>\n<h4 id=\"总体概述\"><a href=\"#总体概述\" class=\"headerlink\" title=\"总体概述\"></a>总体概述</h4><p>优点都是比较比出来的，那么 Vue3 对比 Vue2 优势有<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">更小、更快、更友好、优化方案</span><br><span class=\"line\">typeScript支持</span><br><span class=\"line\">API 设计一致性</span><br><span class=\"line\">自身可维护性</span><br><span class=\"line\">开放更多底层功能</span><br></pre></td></tr></table></figure><br>1.更小<br>移除不常用功能，引入 tree-shaking ，打包体积更小</p>\n<p>2.更快<br>优化 diff 算法、静态提升、事件监听缓存、ssr优化等</p>\n<p>3.更友好<br>提出 composition Api，无论代码的编写还是查看都更加清晰方便</p>\n<p>4.优化方案<br>1）源码优化 vue3 整个源码是通过 monorepo的方式维护的，根据功能将不同的模块拆分到 packages 目录下面不同的子目录中<br>Vue3是基于 typeScript 编写的，提供了更好的类型检查，能支持复杂的类型推导<br>2）性能优化<br>体积优化、编译优化、<strong><em>数据劫持优化</em></strong><br>在 vue2 中，数据劫持是通过 Object.defineProperty，这个 API 有一些缺陷，并不能检测对象属性的添加和删除<br>vue3 是通过 proxy 监听整个对象，那么对于删除还是监听当然也能监听到</p>\n<h4 id=\"算法优化\"><a href=\"#算法优化\" class=\"headerlink\" title=\"算法优化\"></a>算法优化</h4><p>vue3 标记了动态节点，在patch阶段，只会比较动态节点，静态的直接略过了<br>而 vue2中，还是会 patch 所有子节点去比对变更</p>\n<h4 id=\"关于生命周期函数\"><a href=\"#关于生命周期函数\" class=\"headerlink\" title=\"关于生命周期函数\"></a>关于生命周期函数</h4><p>1.Vue2 父子组件生命周期执行顺序<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父beforeCreate</span><br><span class=\"line\">-&gt; 父created</span><br><span class=\"line\">-&gt;父beforeMount</span><br><span class=\"line\">-&gt;子beforeCreate</span><br><span class=\"line\">-&gt;子created</span><br><span class=\"line\">-&gt;子beforeMount</span><br><span class=\"line\">-&gt;子mounted</span><br><span class=\"line\">-&gt;父mounted</span><br></pre></td></tr></table></figure></p>\n<p>2.Vue3 中生命周期函数变化<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeCreated/cateated =&gt; setup</span><br><span class=\"line\">beforeMounted =&gt; onBeforeMounted</span><br><span class=\"line\">mounted =&gt; onMounted</span><br><span class=\"line\">beforeUpdated =&gt; onBeforeUpdated</span><br><span class=\"line\">updated =&gt; onUpdated</span><br><span class=\"line\">beforeDestroyed =&gt; onBeforeUnmounted</span><br><span class=\"line\">destroyed =&gt; onUnmounted</span><br><span class=\"line\">errorCaptured =&gt; onErrorCaptured</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"setup-组件选项\"><a href=\"#setup-组件选项\" class=\"headerlink\" title=\"setup 组件选项\"></a>setup 组件选项</h4><p>setup 是Vue新增的选项， 组件选项在创建组件之前执行，没有 this 。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">setup</span>(<span class=\"params\">props, context</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"组合式API（Composition-API）\"><a href=\"#组合式API（Composition-API）\" class=\"headerlink\" title=\"组合式API（Composition API）\"></a>组合式API（Composition API）</h4><p>Vue3中生命周期函数的执行顺序大体上没有变化，但是生命周期函数被从全局抽离了出来，原来挂载在 this 下面的生命周期函数需要手动引入。<br>也就是 Vue3 最大的改变 —— Composition API</p>\n<p>通过组合式API，我们可以将接口的可重复部分及其功能提取到可重用的代码段中，能够将与同一个逻辑关注点相关的代码配置在一起。<br>为了使组合式 API 的特性与选项式 API 相比更加完整，我们还需要一种在 setup 中注册生命周期钩子的方法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123; readersNumber &#125;&#125; - &#123;&#123; twiceTheCounter &#125;&#125;-&#123;&#123; book.title &#125;&#125;-&#123;&#123; author &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ref, onMounted, watch, computed, toRefs &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* props 即 vue2 中的 props 属性，是响应式的</span></span><br><span class=\"line\"><span class=\"comment\">* context 是一个普通的 js 对象，它暴露三个组件的 property（context.attrs/context.slots/context.emit）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">setup</span>(<span class=\"params\">props, context</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * 使用 `toRefs` 创建对prop的 `author` property 的响应式引用</span></span><br><span class=\"line\"><span class=\"comment\">    * 确保我们的侦听器能够对 author prop 所做的更改做出反应。</span></span><br><span class=\"line\"><span class=\"comment\">    * 因为 props 是响应式的，不能使用 ES6 解构，因为它会消除 prop 的响应性</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; author &#125; = toRefs(props)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> readersNumber = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> book = reactive(&#123; <span class=\"attr\">title</span>: <span class=\"string\">&#x27;Vue 3 Guide&#x27;</span> &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> twiceTheCounter = computed(<span class=\"function\">() =&gt;</span> readersNumber.value * <span class=\"number\">2</span>)</span><br><span class=\"line\">    watch(user, <span class=\"function\">(<span class=\"params\">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;user change&#x27;</span>, newValue, oldValue)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 如何在 setup () 内部调用生命周期钩子</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">onMounted</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Component is mounted!&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// expose to template</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      readersNumber,</span><br><span class=\"line\">      book,</span><br><span class=\"line\">      author,</span><br><span class=\"line\">      twiceTheCounter,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://vue3js.cn/docs/zh/guide/migration/introduction.html\">Vue3官方文档&amp;迁移指南</a></p>\n<p>vue3.0 diff 算法优化细节：<a href=\"https://juejin.cn/post/6844904136299773965\">https://juejin.cn/post/6844904136299773965</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Vue3 已经来了，详细文档见下方传送门<br>这里记录一下比较重要的几个点。</p>\n<h4 id=\"总体概述\"><a href=\"#总体概述\" class=\"headerlink\" title=\"总体概述\"></a>总体概述</h4><p>优点都是比较比出来的，那么 Vue3 对比 Vue2 优势有<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">更小、更快、更友好、优化方案</span><br><span class=\"line\">typeScript支持</span><br><span class=\"line\">API 设计一致性</span><br><span class=\"line\">自身可维护性</span><br><span class=\"line\">开放更多底层功能</span><br></pre></td></tr></table></figure><br>1.更小<br>移除不常用功能，引入 tree-shaking ，打包体积更小</p>\n<p>2.更快<br>优化 diff 算法、静态提升、事件监听缓存、ssr优化等</p>\n<p>3.更友好<br>提出 composition Api，无论代码的编写还是查看都更加清晰方便</p>\n<p>4.优化方案<br>1）源码优化 vue3 整个源码是通过 monorepo的方式维护的，根据功能将不同的模块拆分到 packages 目录下面不同的子目录中<br>Vue3是基于 typeScript 编写的，提供了更好的类型检查，能支持复杂的类型推导<br>2）性能优化<br>体积优化、编译优化、<strong><em>数据劫持优化</em></strong><br>在 vue2 中，数据劫持是通过 Object.defineProperty，这个 API 有一些缺陷，并不能检测对象属性的添加和删除<br>vue3 是通过 proxy 监听整个对象，那么对于删除还是监听当然也能监听到</p>\n<h4 id=\"算法优化\"><a href=\"#算法优化\" class=\"headerlink\" title=\"算法优化\"></a>算法优化</h4><p>vue3 标记了动态节点，在patch阶段，只会比较动态节点，静态的直接略过了<br>而 vue2中，还是会 patch 所有子节点去比对变更</p>\n<h4 id=\"关于生命周期函数\"><a href=\"#关于生命周期函数\" class=\"headerlink\" title=\"关于生命周期函数\"></a>关于生命周期函数</h4><p>1.Vue2 父子组件生命周期执行顺序<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父beforeCreate</span><br><span class=\"line\">-&gt; 父created</span><br><span class=\"line\">-&gt;父beforeMount</span><br><span class=\"line\">-&gt;子beforeCreate</span><br><span class=\"line\">-&gt;子created</span><br><span class=\"line\">-&gt;子beforeMount</span><br><span class=\"line\">-&gt;子mounted</span><br><span class=\"line\">-&gt;父mounted</span><br></pre></td></tr></table></figure></p>\n<p>2.Vue3 中生命周期函数变化<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeCreated/cateated =&gt; setup</span><br><span class=\"line\">beforeMounted =&gt; onBeforeMounted</span><br><span class=\"line\">mounted =&gt; onMounted</span><br><span class=\"line\">beforeUpdated =&gt; onBeforeUpdated</span><br><span class=\"line\">updated =&gt; onUpdated</span><br><span class=\"line\">beforeDestroyed =&gt; onBeforeUnmounted</span><br><span class=\"line\">destroyed =&gt; onUnmounted</span><br><span class=\"line\">errorCaptured =&gt; onErrorCaptured</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"setup-组件选项\"><a href=\"#setup-组件选项\" class=\"headerlink\" title=\"setup 组件选项\"></a>setup 组件选项</h4><p>setup 是Vue新增的选项， 组件选项在创建组件之前执行，没有 this 。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">setup</span>(<span class=\"params\">props, context</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"组合式API（Composition-API）\"><a href=\"#组合式API（Composition-API）\" class=\"headerlink\" title=\"组合式API（Composition API）\"></a>组合式API（Composition API）</h4><p>Vue3中生命周期函数的执行顺序大体上没有变化，但是生命周期函数被从全局抽离了出来，原来挂载在 this 下面的生命周期函数需要手动引入。<br>也就是 Vue3 最大的改变 —— Composition API</p>\n<p>通过组合式API，我们可以将接口的可重复部分及其功能提取到可重用的代码段中，能够将与同一个逻辑关注点相关的代码配置在一起。<br>为了使组合式 API 的特性与选项式 API 相比更加完整，我们还需要一种在 setup 中注册生命周期钩子的方法。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123; readersNumber &#125;&#125; - &#123;&#123; twiceTheCounter &#125;&#125;-&#123;&#123; book.title &#125;&#125;-&#123;&#123; author &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ref, onMounted, watch, computed, toRefs &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* props 即 vue2 中的 props 属性，是响应式的</span></span><br><span class=\"line\"><span class=\"comment\">* context 是一个普通的 js 对象，它暴露三个组件的 property（context.attrs/context.slots/context.emit）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">setup</span>(<span class=\"params\">props, context</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * 使用 `toRefs` 创建对prop的 `author` property 的响应式引用</span></span><br><span class=\"line\"><span class=\"comment\">    * 确保我们的侦听器能够对 author prop 所做的更改做出反应。</span></span><br><span class=\"line\"><span class=\"comment\">    * 因为 props 是响应式的，不能使用 ES6 解构，因为它会消除 prop 的响应性</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; author &#125; = toRefs(props)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> readersNumber = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> book = reactive(&#123; <span class=\"attr\">title</span>: <span class=\"string\">&#x27;Vue 3 Guide&#x27;</span> &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> twiceTheCounter = computed(<span class=\"function\">() =&gt;</span> readersNumber.value * <span class=\"number\">2</span>)</span><br><span class=\"line\">    watch(user, <span class=\"function\">(<span class=\"params\">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;user change&#x27;</span>, newValue, oldValue)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 如何在 setup () 内部调用生命周期钩子</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">onMounted</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Component is mounted!&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// expose to template</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      readersNumber,</span><br><span class=\"line\">      book,</span><br><span class=\"line\">      author,</span><br><span class=\"line\">      twiceTheCounter,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://vue3js.cn/docs/zh/guide/migration/introduction.html\">Vue3官方文档&amp;迁移指南</a></p>\n<p>vue3.0 diff 算法优化细节：<a href=\"https://juejin.cn/post/6844904136299773965\">https://juejin.cn/post/6844904136299773965</a></p>\n"},{"title":"weakSet与js内存回收","date":"2021-02-23T16:00:00.000Z","_content":"\n#### Map与WeakMap简单区别\n```html\nMap的键值可以是原始数据类型和引用类型，WeakMap的键值只能说引用类型（object）\nMap可以迭代遍历键，WeakMap不可迭代遍历键\n```\n#### Map 与 WeakMap 使用内存情况\n1.WeakMap 内存占用\n```javascript\n// index.js\n// 第一次手动清理垃圾以确保为最新状态，观察内存情况\nglobal.gc()\nconsole.log(`第一次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB`)\nconst wm = new WeakMap()\n\nlet key = {}\n// 给 WeakMap实例 赋值一个 占领内存足够大的 键值对\nwm.set(key, new Array(114514 * 19))\n// 手动清理一下垃圾 观察内存占用情况\nglobal.gc()\nconsole.log(`第二次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB`)\n\n// 此时把 key键 的引用进行断开，并观察内存占用情况\nkey = null\n// key = new Array()  \n// 这种改变引用地址写法也可以引起 弱映射，因为引用地址不再是同块内存地址 WeakMap内对应的value也会被垃圾回收\n\nglobal.gc()\nconsole.log(`第三次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB`)\n// $ node --expose-gc index.js\n// 第一次垃圾回收，当前内存使用情况：1.76MB\n// 第二次垃圾回收，当前内存使用情况：18.54MB\n// 第三次垃圾回收，当前内存使用情况：1.94MB\n```\n2.Map 内存占用\n同上，只不过是将\n```javascript\nconst wm = new WeakMap();\n```\n替换为\n```javascript\nconst wm = new Map();\n```\n结果为\n```javascript\n// 第一次垃圾回收，当前内存使用情况：1.77MB\n// 第二次垃圾回收，当前内存使用情况：18.54MB\n// 第三次垃圾回收，当前内存使用情况：18.54MB\n```\n比较1、2例子可以发现，当引用类型key的值指向为空的时候，使用WeakMap的时候会立即释放内存\n当使用Map的时候不会立即释放内存。\n\n当然，如果在 2例子里面起一个定时器，每隔100ms定时打印内存情况，会发现，即使使用Map，过一段时间内存也会被释放掉\n这是因为 javascript 引擎做了优化，会定期清理内存。\n```javascript\nsetInterval(() => {\n  console.log(`第N次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB`);\n}, 100)\n\n// 结果\n// 第一次垃圾回收，当前内存使用情况：1.77MB\n// 第二次垃圾回收，当前内存使用情况：18.54MB\n// 第三次垃圾回收，当前内存使用情况：18.54MB\n// 第N次垃圾回收，当前内存使用情况：18.55MB\n// ...\n// 第N次垃圾回收，当前内存使用情况：2.00MB\n// 第N次垃圾回收，当前内存使用情况：2.01MB\n```\n\n---\n\n虽然，javascript引擎会自动优化内存，但是作为开发者还是应该适当关注一下内存的使用情况，以防止极端的情况内存释放不及时。\n```javascript\n// index.js\n// 第一次手动清理垃圾以确保为最新状态，观察内存情况\nglobal.gc();\nconsole.log(\n  `第一次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB`\n);\nconst m = new Map();\n\nlet key = {};\nm.set(key, new Array(114514 * 19));\n// 手动清理一下垃圾 观察内存占用情况\nglobal.gc();\nconsole.log(\n  `第二次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB，\n  当前Map的长度: ${m.size}`\n);\n\n// 此时把 key键 的引用进行断开，并观察内存占用情况\nkey = null;\nglobal.gc();\nconsole.log(\n  `第三次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB，\n  当前Map的长度: ${m.size}`\n);\n\n// 清除Map所有键值对\nm.clear();\n\nglobal.gc();\nconsole.log(\n  `第四次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB，\n  当前Map的长度: ${m.size}`\n);\n// $ node --expose-gc index.js\n// 第一次垃圾回收，当前内存使用情况：1.76MB\n// 第二次垃圾回收，当前内存使用情况：18.54MB，\n//   当前Map的长度: 1\n// 第三次垃圾回收，当前内存使用情况：18.54MB，\n//   当前Map的长度: 1\n// 第四次垃圾回收，当前内存使用情况：1.94MB，\n//   当前Map的长度: 0\n```\n\n### 附录\n使用 node 命令执行js的时候加入 --expose-gc参数的作用\n```html\n--expose-gc 参数表示允许手动执行垃圾回收机制\n```\n\n\n\n\n\n### 传送门\n\n\n[WeakSet 用法解惑](https://zhuanlan.zhihu.com/p/54889129)\n\n[通过垃圾回收机制来了解Map与WeakMap](https://mp.weixin.qq.com/s/reCQIfaLM3rTsvKJwovIHQ)\n\n","source":"_posts/weakSet.md","raw":"---\ntitle: weakSet与js内存回收\ndate: 2021/02/24\ntag: [set,weakSet]\ncategory: 笔记\n---\n\n#### Map与WeakMap简单区别\n```html\nMap的键值可以是原始数据类型和引用类型，WeakMap的键值只能说引用类型（object）\nMap可以迭代遍历键，WeakMap不可迭代遍历键\n```\n#### Map 与 WeakMap 使用内存情况\n1.WeakMap 内存占用\n```javascript\n// index.js\n// 第一次手动清理垃圾以确保为最新状态，观察内存情况\nglobal.gc()\nconsole.log(`第一次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB`)\nconst wm = new WeakMap()\n\nlet key = {}\n// 给 WeakMap实例 赋值一个 占领内存足够大的 键值对\nwm.set(key, new Array(114514 * 19))\n// 手动清理一下垃圾 观察内存占用情况\nglobal.gc()\nconsole.log(`第二次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB`)\n\n// 此时把 key键 的引用进行断开，并观察内存占用情况\nkey = null\n// key = new Array()  \n// 这种改变引用地址写法也可以引起 弱映射，因为引用地址不再是同块内存地址 WeakMap内对应的value也会被垃圾回收\n\nglobal.gc()\nconsole.log(`第三次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB`)\n// $ node --expose-gc index.js\n// 第一次垃圾回收，当前内存使用情况：1.76MB\n// 第二次垃圾回收，当前内存使用情况：18.54MB\n// 第三次垃圾回收，当前内存使用情况：1.94MB\n```\n2.Map 内存占用\n同上，只不过是将\n```javascript\nconst wm = new WeakMap();\n```\n替换为\n```javascript\nconst wm = new Map();\n```\n结果为\n```javascript\n// 第一次垃圾回收，当前内存使用情况：1.77MB\n// 第二次垃圾回收，当前内存使用情况：18.54MB\n// 第三次垃圾回收，当前内存使用情况：18.54MB\n```\n比较1、2例子可以发现，当引用类型key的值指向为空的时候，使用WeakMap的时候会立即释放内存\n当使用Map的时候不会立即释放内存。\n\n当然，如果在 2例子里面起一个定时器，每隔100ms定时打印内存情况，会发现，即使使用Map，过一段时间内存也会被释放掉\n这是因为 javascript 引擎做了优化，会定期清理内存。\n```javascript\nsetInterval(() => {\n  console.log(`第N次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB`);\n}, 100)\n\n// 结果\n// 第一次垃圾回收，当前内存使用情况：1.77MB\n// 第二次垃圾回收，当前内存使用情况：18.54MB\n// 第三次垃圾回收，当前内存使用情况：18.54MB\n// 第N次垃圾回收，当前内存使用情况：18.55MB\n// ...\n// 第N次垃圾回收，当前内存使用情况：2.00MB\n// 第N次垃圾回收，当前内存使用情况：2.01MB\n```\n\n---\n\n虽然，javascript引擎会自动优化内存，但是作为开发者还是应该适当关注一下内存的使用情况，以防止极端的情况内存释放不及时。\n```javascript\n// index.js\n// 第一次手动清理垃圾以确保为最新状态，观察内存情况\nglobal.gc();\nconsole.log(\n  `第一次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB`\n);\nconst m = new Map();\n\nlet key = {};\nm.set(key, new Array(114514 * 19));\n// 手动清理一下垃圾 观察内存占用情况\nglobal.gc();\nconsole.log(\n  `第二次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB，\n  当前Map的长度: ${m.size}`\n);\n\n// 此时把 key键 的引用进行断开，并观察内存占用情况\nkey = null;\nglobal.gc();\nconsole.log(\n  `第三次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB，\n  当前Map的长度: ${m.size}`\n);\n\n// 清除Map所有键值对\nm.clear();\n\nglobal.gc();\nconsole.log(\n  `第四次垃圾回收，当前内存使用情况：${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB，\n  当前Map的长度: ${m.size}`\n);\n// $ node --expose-gc index.js\n// 第一次垃圾回收，当前内存使用情况：1.76MB\n// 第二次垃圾回收，当前内存使用情况：18.54MB，\n//   当前Map的长度: 1\n// 第三次垃圾回收，当前内存使用情况：18.54MB，\n//   当前Map的长度: 1\n// 第四次垃圾回收，当前内存使用情况：1.94MB，\n//   当前Map的长度: 0\n```\n\n### 附录\n使用 node 命令执行js的时候加入 --expose-gc参数的作用\n```html\n--expose-gc 参数表示允许手动执行垃圾回收机制\n```\n\n\n\n\n\n### 传送门\n\n\n[WeakSet 用法解惑](https://zhuanlan.zhihu.com/p/54889129)\n\n[通过垃圾回收机制来了解Map与WeakMap](https://mp.weixin.qq.com/s/reCQIfaLM3rTsvKJwovIHQ)\n\n","slug":"weakSet","published":1,"updated":"2021-03-30T01:32:00.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7uge001ya0vzdssf38zy","content":"<h4 id=\"Map与WeakMap简单区别\"><a href=\"#Map与WeakMap简单区别\" class=\"headerlink\" title=\"Map与WeakMap简单区别\"></a>Map与WeakMap简单区别</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map的键值可以是原始数据类型和引用类型，WeakMap的键值只能说引用类型（object）</span><br><span class=\"line\">Map可以迭代遍历键，WeakMap不可迭代遍历键</span><br></pre></td></tr></table></figure>\n<h4 id=\"Map-与-WeakMap-使用内存情况\"><a href=\"#Map-与-WeakMap-使用内存情况\" class=\"headerlink\" title=\"Map 与 WeakMap 使用内存情况\"></a>Map 与 WeakMap 使用内存情况</h4><p>1.WeakMap 内存占用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"comment\">// 第一次手动清理垃圾以确保为最新状态，观察内存情况</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`第一次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB`</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> key = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 给 WeakMap实例 赋值一个 占领内存足够大的 键值对</span></span><br><span class=\"line\">wm.set(key, <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">114514</span> * <span class=\"number\">19</span>))</span><br><span class=\"line\"><span class=\"comment\">// 手动清理一下垃圾 观察内存占用情况</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`第二次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此时把 key键 的引用进行断开，并观察内存占用情况</span></span><br><span class=\"line\">key = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"comment\">// key = new Array()  </span></span><br><span class=\"line\"><span class=\"comment\">// 这种改变引用地址写法也可以引起 弱映射，因为引用地址不再是同块内存地址 WeakMap内对应的value也会被垃圾回收</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`第三次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB`</span>)</span><br><span class=\"line\"><span class=\"comment\">// $ node --expose-gc index.js</span></span><br><span class=\"line\"><span class=\"comment\">// 第一次垃圾回收，当前内存使用情况：1.76MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第二次垃圾回收，当前内存使用情况：18.54MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第三次垃圾回收，当前内存使用情况：1.94MB</span></span><br></pre></td></tr></table></figure><br>2.Map 内存占用<br>同上，只不过是将<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br></pre></td></tr></table></figure><br>替换为<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br></pre></td></tr></table></figure><br>结果为<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一次垃圾回收，当前内存使用情况：1.77MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第二次垃圾回收，当前内存使用情况：18.54MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第三次垃圾回收，当前内存使用情况：18.54MB</span></span><br></pre></td></tr></table></figure><br>比较1、2例子可以发现，当引用类型key的值指向为空的时候，使用WeakMap的时候会立即释放内存<br>当使用Map的时候不会立即释放内存。</p>\n<p>当然，如果在 2例子里面起一个定时器，每隔100ms定时打印内存情况，会发现，即使使用Map，过一段时间内存也会被释放掉<br>这是因为 javascript 引擎做了优化，会定期清理内存。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`第N次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB`</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\"><span class=\"comment\">// 第一次垃圾回收，当前内存使用情况：1.77MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第二次垃圾回收，当前内存使用情况：18.54MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第三次垃圾回收，当前内存使用情况：18.54MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第N次垃圾回收，当前内存使用情况：18.55MB</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"comment\">// 第N次垃圾回收，当前内存使用情况：2.00MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第N次垃圾回收，当前内存使用情况：2.01MB</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>虽然，javascript引擎会自动优化内存，但是作为开发者还是应该适当关注一下内存的使用情况，以防止极端的情况内存释放不及时。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"comment\">// 第一次手动清理垃圾以确保为最新状态，观察内存情况</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第一次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB`</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> key = &#123;&#125;;</span><br><span class=\"line\">m.set(key, <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">114514</span> * <span class=\"number\">19</span>));</span><br><span class=\"line\"><span class=\"comment\">// 手动清理一下垃圾 观察内存占用情况</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第二次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB，</span></span><br><span class=\"line\"><span class=\"string\">  当前Map的长度: <span class=\"subst\">$&#123;m.size&#125;</span>`</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此时把 key键 的引用进行断开，并观察内存占用情况</span></span><br><span class=\"line\">key = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第三次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB，</span></span><br><span class=\"line\"><span class=\"string\">  当前Map的长度: <span class=\"subst\">$&#123;m.size&#125;</span>`</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清除Map所有键值对</span></span><br><span class=\"line\">m.clear();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第四次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB，</span></span><br><span class=\"line\"><span class=\"string\">  当前Map的长度: <span class=\"subst\">$&#123;m.size&#125;</span>`</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// $ node --expose-gc index.js</span></span><br><span class=\"line\"><span class=\"comment\">// 第一次垃圾回收，当前内存使用情况：1.76MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第二次垃圾回收，当前内存使用情况：18.54MB，</span></span><br><span class=\"line\"><span class=\"comment\">//   当前Map的长度: 1</span></span><br><span class=\"line\"><span class=\"comment\">// 第三次垃圾回收，当前内存使用情况：18.54MB，</span></span><br><span class=\"line\"><span class=\"comment\">//   当前Map的长度: 1</span></span><br><span class=\"line\"><span class=\"comment\">// 第四次垃圾回收，当前内存使用情况：1.94MB，</span></span><br><span class=\"line\"><span class=\"comment\">//   当前Map的长度: 0</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><p>使用 node 命令执行js的时候加入 –expose-gc参数的作用<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--expose-gc 参数表示允许手动执行垃圾回收机制</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://zhuanlan.zhihu.com/p/54889129\">WeakSet 用法解惑</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/reCQIfaLM3rTsvKJwovIHQ\">通过垃圾回收机制来了解Map与WeakMap</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Map与WeakMap简单区别\"><a href=\"#Map与WeakMap简单区别\" class=\"headerlink\" title=\"Map与WeakMap简单区别\"></a>Map与WeakMap简单区别</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map的键值可以是原始数据类型和引用类型，WeakMap的键值只能说引用类型（object）</span><br><span class=\"line\">Map可以迭代遍历键，WeakMap不可迭代遍历键</span><br></pre></td></tr></table></figure>\n<h4 id=\"Map-与-WeakMap-使用内存情况\"><a href=\"#Map-与-WeakMap-使用内存情况\" class=\"headerlink\" title=\"Map 与 WeakMap 使用内存情况\"></a>Map 与 WeakMap 使用内存情况</h4><p>1.WeakMap 内存占用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"comment\">// 第一次手动清理垃圾以确保为最新状态，观察内存情况</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`第一次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB`</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> key = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 给 WeakMap实例 赋值一个 占领内存足够大的 键值对</span></span><br><span class=\"line\">wm.set(key, <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">114514</span> * <span class=\"number\">19</span>))</span><br><span class=\"line\"><span class=\"comment\">// 手动清理一下垃圾 观察内存占用情况</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`第二次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此时把 key键 的引用进行断开，并观察内存占用情况</span></span><br><span class=\"line\">key = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"comment\">// key = new Array()  </span></span><br><span class=\"line\"><span class=\"comment\">// 这种改变引用地址写法也可以引起 弱映射，因为引用地址不再是同块内存地址 WeakMap内对应的value也会被垃圾回收</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`第三次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB`</span>)</span><br><span class=\"line\"><span class=\"comment\">// $ node --expose-gc index.js</span></span><br><span class=\"line\"><span class=\"comment\">// 第一次垃圾回收，当前内存使用情况：1.76MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第二次垃圾回收，当前内存使用情况：18.54MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第三次垃圾回收，当前内存使用情况：1.94MB</span></span><br></pre></td></tr></table></figure><br>2.Map 内存占用<br>同上，只不过是将<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br></pre></td></tr></table></figure><br>替换为<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br></pre></td></tr></table></figure><br>结果为<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一次垃圾回收，当前内存使用情况：1.77MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第二次垃圾回收，当前内存使用情况：18.54MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第三次垃圾回收，当前内存使用情况：18.54MB</span></span><br></pre></td></tr></table></figure><br>比较1、2例子可以发现，当引用类型key的值指向为空的时候，使用WeakMap的时候会立即释放内存<br>当使用Map的时候不会立即释放内存。</p>\n<p>当然，如果在 2例子里面起一个定时器，每隔100ms定时打印内存情况，会发现，即使使用Map，过一段时间内存也会被释放掉<br>这是因为 javascript 引擎做了优化，会定期清理内存。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`第N次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB`</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\"><span class=\"comment\">// 第一次垃圾回收，当前内存使用情况：1.77MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第二次垃圾回收，当前内存使用情况：18.54MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第三次垃圾回收，当前内存使用情况：18.54MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第N次垃圾回收，当前内存使用情况：18.55MB</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"comment\">// 第N次垃圾回收，当前内存使用情况：2.00MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第N次垃圾回收，当前内存使用情况：2.01MB</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>虽然，javascript引擎会自动优化内存，但是作为开发者还是应该适当关注一下内存的使用情况，以防止极端的情况内存释放不及时。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"comment\">// 第一次手动清理垃圾以确保为最新状态，观察内存情况</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第一次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB`</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> key = &#123;&#125;;</span><br><span class=\"line\">m.set(key, <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">114514</span> * <span class=\"number\">19</span>));</span><br><span class=\"line\"><span class=\"comment\">// 手动清理一下垃圾 观察内存占用情况</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第二次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB，</span></span><br><span class=\"line\"><span class=\"string\">  当前Map的长度: <span class=\"subst\">$&#123;m.size&#125;</span>`</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此时把 key键 的引用进行断开，并观察内存占用情况</span></span><br><span class=\"line\">key = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第三次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB，</span></span><br><span class=\"line\"><span class=\"string\">  当前Map的长度: <span class=\"subst\">$&#123;m.size&#125;</span>`</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清除Map所有键值对</span></span><br><span class=\"line\">m.clear();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">global</span>.gc();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  <span class=\"string\">`第四次垃圾回收，当前内存使用情况：<span class=\"subst\">$&#123;(process.memoryUsage().heapUsed <span class=\"regexp\">/ 1024 /</span> <span class=\"number\">1024</span>).toFixed(<span class=\"number\">2</span>)&#125;</span>MB，</span></span><br><span class=\"line\"><span class=\"string\">  当前Map的长度: <span class=\"subst\">$&#123;m.size&#125;</span>`</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// $ node --expose-gc index.js</span></span><br><span class=\"line\"><span class=\"comment\">// 第一次垃圾回收，当前内存使用情况：1.76MB</span></span><br><span class=\"line\"><span class=\"comment\">// 第二次垃圾回收，当前内存使用情况：18.54MB，</span></span><br><span class=\"line\"><span class=\"comment\">//   当前Map的长度: 1</span></span><br><span class=\"line\"><span class=\"comment\">// 第三次垃圾回收，当前内存使用情况：18.54MB，</span></span><br><span class=\"line\"><span class=\"comment\">//   当前Map的长度: 1</span></span><br><span class=\"line\"><span class=\"comment\">// 第四次垃圾回收，当前内存使用情况：1.94MB，</span></span><br><span class=\"line\"><span class=\"comment\">//   当前Map的长度: 0</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><p>使用 node 命令执行js的时候加入 –expose-gc参数的作用<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--expose-gc 参数表示允许手动执行垃圾回收机制</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://zhuanlan.zhihu.com/p/54889129\">WeakSet 用法解惑</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/reCQIfaLM3rTsvKJwovIHQ\">通过垃圾回收机制来了解Map与WeakMap</a></p>\n"},{"title":"Webpack 学习整理","date":"2019-01-16T16:00:00.000Z","_content":"\nWebpack是一个前端资源加载以及打包工具,只需要简单的配置即可实现前端各种工程化的操作。\n配置 webpack 说难不难，说简单也不简单，现在几大框架都配备了全家桶，quick-start 项目基本上都已经配置好了基础的 webpack 配置。\n虽然能够正常使用，但是，对于各个配置项，并不是很清楚。这几天利用空余时间，理一下几个 loader 和 插件的使用。\n\n\n### 关于 loader && loader 的加载顺序\nloader 是一个函数，用来把文件转换为 webpack 识别的模块，webpack 本身只能处理加载 javascript，对于 css、image 等资源是无法处理的，而 loader 就是 webpack 开放出来的接口，供用户开发自己的 loader。\n\nloader的使用方式如下\n```javascript\nrules: [\n  {\n    test: /\\.(css|scss)$/,\n    loader: ['style-loader', '....', 'url-loader']\n  }\n]\n```\nwebpack loader 可以是一个数组，数组的加载方式是从右向左，如上面这个配置，loader 执行的时候，会先使用 url-loader 加载文件，最后用 style-loader 将代码插入文档中。\n\n### file-loader/url-loader/tyle-loader/mini-css-extract-plugin loader/vue-loader/css-loader\n\n1.*file-loader* \n文件加载 loader，主要用来加载 import/require 导入的文件\n加载比如 css 中 background-image src 的图片等资源\n加载导入的字体文件\n*官方介绍*\n```html\nThe file-loader resolves import/require() on a file into a url and emits the file into the output directory.\n```\n\n2.*url-loader* \n和 file-loader 功能类似，它依赖于 file-loader，file-loader 有的功能它都有\n*不同之处在于能将导入的文件转为 base64，可以指定文件大小限制，小于某个值的时候将文件转为 base64 的 url*\n\n3.*style-loader && vue-style-loader && mini-css-extract-plugin loader*\n1）style-loader 负责将 css 以内联的方式插入文档中\n2）vue-style-loader 功能和style-loader 类似，只不过它更专注于 vue 中的 css 提取\n3）mini-css-extract-plugin 从名字可以看出，它本身是一个插件，作用是将 css 分离出来，它能将 css 插入文档中，和 style-loader 的区别在于 style 是将 css 内联插入，而它的 loader 通过外部引入的方式将 css 插入文档中。\n*注意：mini-css-extract-plugin loader 和 vue-style-loader不能同时使用*\n\n4.*css-loader*\n加载外部引用 css (@import)以及 从 .vue 文件中提取出来的 css 资源\n使用此 loader 只是提取 css 资源，之后还需要用 style-loader 等 loader 将 css 插入 Dom，建议写法：\n```javascript\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n...\n{\n  test: /\\.css$/,\n  loader: [devMode ? 'style-loader': MiniCssExtractPlugin.loader, 'css-loader']\n},\n```\n注意：css-loader如果是用在vue-ssr服务端构建的时候，需要配置exportOnlyLocals，示例如下：\n```javascript\nmodule: {\n  rules: [\n    {\n      test: /\\.(css|scss)$/,\n      loader: [\n        {\n          loader: 'css-loader',\n          options: {\n            exportOnlyLocals:true\n          }\n        },\n        'postcss-loader', \n        'sass-loader'\n      ]\n    },\n  ]\n},\n```\n\n5.*sass-loader*\n将 sass/scss 文件编译为 css 文件，需要依赖 node-sass，编译为 css 之后还需要加载 css，所以还得调用 css 的加载 loader，建议写法：\n```javascript\n{\n  test: /\\.scss$/,\n  loader: [devMode ? 'style-loader': MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader']\n}\n```\n\n6.*postcss-loader*\n写过 css3 的人应该遇到过很多需要写 css 前缀的情况，这是因为不同浏览器对新特性的支持情况不一样，很多试验性新特性需要加上浏览器前缀才会生效。\npostcss 是一个很强大的东东，这里我们只是用它的一个 loader，目的是为了简化 css 写法。\n和 autoprefixer 配合使用，会自动给 css 加前缀。\n如：\n```css\ntransition: transform 1s\n```\n经过 postcss-loader 会转换为：\n```css\n-webkit-transition: -webkit-transform 1s;\ntransition: -webkit-transform 1s;\n-o-transition: transform 1s;\ntransition: transform 1s;\ntransition: transform 1s, -webkit-transform 1s;\n```\n\n用法相对其它loader，需要依赖 autoprefixer，需要多加一个配置文件 postcss.config.js\n作用是设置浏览器的范围\n```javascript\n// postcss.config.js 文件\nmodule.exports = {\n  plugins: [\n    require('autoprefixer')({\n      browsers: [\n        '> 1%',\n        'last 20 versions',\n        'ie > 9'\n      ]\n    })\n  ]\n}\n```\n之后就可以正常使用 postcss-loader 了，同样，此 loader 只是将 css 转换，并不会直接插入到文档中\n因此后续还需要用的其它 loader，推荐用法：\n```javascript\n{\n  test: /\\.(css|scss)$/,\n  loader: [\n    devMode ? 'style-loader': MiniCssExtractPlugin.loader, \n    'css-loader',\n    'postcss-loader', \n    'sass-loader'\n  ]\n}\n```\n**注意：**这里有个坑\n在做的过程中，发现在 index.vue 中 通过 ‘@import url(\"../css/index.scss\");’ 导入 index.scss 文件，发现 index.scss 中的 css 属性并没有经过 postcss 转换。\n网上查了一下，说是需要给 css-loader 加一个 options：\n```javascript\n{ loader: 'css-loader', options: { importLoaders: 1 } },\n```\n但是，经过测试，发现并未生效，看网上的人们说的还真有这么回事儿，但是确实不行（可能是我用的 webpack 版本不一样）。\n经过一番折腾，发现只有 @import 加 url 的不行\n解决办法：\n```css\n@import url(\"../css/index.scss\");\n/* 去掉 url 改为 */\n@import \"../css/index.scss\";\n```\n\n\n搞好上面几个 loader，整个 css 的处理基本上就搞清楚了。\n接下来就是弄 javascript 的 loader 了。\n\n---\n\n### javascript 还需要 loader 吗？\n\n不是说 webpack 自己能加载 js 吗，为什么还需要 js 相关的 loader 呢？\n没错，javascript 本身是不需要 loader 的，但是如果要使用 es6+ 的新特性，就需要用到 loader 了。\n我们知道，对于 es6 新特性，不同浏览器支持情况是不一样的，我们使用 loader 的目的就是将 es6 转换为可被浏览器接受的 javascript 语法，似乎跟前面 css 的 postcss-loader 作用一样？\n\n##### ecmascript 标准制定过程\n使用 babel 和 babel-loader，最好是能先对 Ecmascript 的版本和制定有一定的了解。\nEcmascript制定一般会经过如下几个阶段：\n```html\nstage0：开放阶段，草稿阶段\nstage1：初步标准，提议阶段\nstage2：草稿阶段，观察阶段\nstage3：候补阶段，开发者基本认可了\nstage4：完成阶段，基本确定（不会100%确定）会加入下一个 ecmascript 版本中\n```\n而 babel 的转换具体转换到哪个阶段，则需要自己对其进行相应的配置。\n\n##### babel\nbabel，是一个伟大的“发明”。\n最近几年 javascript 更新很快，不断有新的特性被提出，不断有的的版本发出。\n但是因为客户端本身的复杂性，要想将 js 的新特性运用在浏览器端，并做到很好的兼容性是一个很“艰难”的过程。\n各种各样的兼容性已经足够增加成倍的开发成本了。\n\n好在，babel 的出现解决了这个问题，它的出现可以说推进了 javascript 的演进历程。\n那么它是如何做到的呢？\n\n#### babel 原理\nbabel 是一个‘编译器’，能将高版本的 javascript 编译成低版本的 javascript，以至于浏览器能够正常的使用。\nbabel 可以单独使用，但是目前更多的还是配合构建工具（如 webpack）来进行使用。\n\nsass-loader 能够将 scss 转换为 css 供浏览器识别。\n使用 babel-loader 能够将 es6 转换为 es5 来供浏览器识别。\n```javascript\n{\n  test: /\\.js$/,\n  include: [resolve('src')],\n  loader: 'babel-loader'\n}\n```\n\n当然，仅仅这样配置是不够的。因为 javascript 本身比 css 复杂，涉及到更多的版本，包括前面提到的各个 stage 需要兼顾，还得考虑转换之后代码的冗余程度。\n具体配置示例如下所示：\n\n```javascript\n// babel.config.js\nmodule.exports = function(api) {\n  api.cache(true)\n  const presets = [\n    [\n      '@babel/preset-env', // 可简写 @babel/env， 这个是包括了很多支持 javascript 版本转换的插件。\n      {\n        'targets': {\n          'browsers': [ // 这个指定编译之后需要兼容的浏览器范围\n            '> 1%',\n            'last 2 versions',\n            'ie >= 9'\n          ]\n        },\n        // 只包括你需要的 polyfill,\n        // Babel 将检查你的所有代码，以查找目标环境中缺少的功能，并仅包含所需的 polyfill\n        // 如果我们没有将 env preset 的 \"useBuiltIns\" 选项的设置为 \"usage\" ，就必须在其他代码之前 require 一次完整的 polyfill。\n        'useBuiltIns': 'usage',\n        // \"amd\" | \"umd\" | \"systemjs\" | \"commonjs\" | \"cjs\" | \"auto\" | false, defaults to \"auto\".\n        'modules': false,\n      },\n    ]\n  ]\n  const plugins = [\n    '@babel/plugin-syntax-dynamic-import', // 支持转换 import 语法\n  ]\n  return {\n    presets,\n    plugins\n  }\n}\n```\n\n##### Plugins && Presets\nplugin 和 preset 告诉编译器如果对代码进行转换。\n下面是一些常用 preset 和插件\n\n```javascript\n@babel/core // 核心库，必须安装此依赖\n@babel/cli // 是一个允许你从终端使用 babel 的工具(可以全局安装)\n@babel/preset-env \n/*\n包括支持现代 JavaScript（ES2015，ES2016 等）的所有插件，只是为浏览器没有的功能加载转换插件\n只能进行语法转化，但是不能对 api 进行转码，如 promise、set、map 等新增对象，Object.assign/Object.entries 等全局对象的转码功能\n而 babel-runtime 和 babel-polyfill 就是做这些事情的。\n*/\n```\n```javascript\n@babel/polyfill // 实现目标环境中缺少的功能，包括 core-js 和自定义 regenerator runtime 来模拟完整的 ES2015+ 环境。\n@babel/runtime // 和 @babel/polyfill 功能类似。\n```\n\npolyfill 和 runtime 两个模块功能几乎一样，但是实现方法不同\npolyfill 会污染全局对象，但是使用简单，如果不是作为公共模块提供给其它应用，可以使用此配置。\nruntime 会手动引入 helper 函数\nconst Promise = require('babel-runtime/core-js/promise') 就可以引入 Promise。\n\n缺点是通过引入的方式，引入的模块不能共享，造成打包之后有很多重复的 helper 代码\n所以，babel 又开发了 babel-plugin-transform-runtime 这个模块将代码重写，提取公共方法。\n```javascript\nbabel-plugin-transform-runtime\n```\n\n除此之外，还有一些常用的，比如react支持\n```javascript\n@babel/preset-react // 转换 jsx 语法\n```\n\ntypescript 支持，加一个 loader，再加一个 tsconfig 配置文件即可\n```javascript\n@babel/preset-typescript // 转换 typescript 语法 用法见后面。\n```\n\ntypescript 支持，需要加 ts-loader 以及 tsconfig 配置\n```javascript\n{\n  test: /\\.ts$/,\n  include: [resolve('src')],\n  loader: 'ts-loader'\n}\n```\n\n在根目录下加 tsconfig.json 文件\n```javascript\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"noImplicitAny\": true,\n    \"removeComments\": true,\n    \"preserveConstEnums\": true,\n    \"sourceMap\": true\n  },\n  \"files\": [\n    \"./src/views/index.ts\",\n  ]\n}\n```\n\n### 相关链接\n\n### webpack指南：\nhttps://webpack.toobug.net/zh-cn/chapter4/using-loaders.html\n\n### babel 中文网站\nhttps://babel.docschina.org/docs/en/usage\n\n\n\n\n","source":"_posts/webpack.md","raw":"---\ntitle: Webpack 学习整理\ndate: 2019/01/17\ntag: [webpack, babel]\ncategory: 笔记\n---\n\nWebpack是一个前端资源加载以及打包工具,只需要简单的配置即可实现前端各种工程化的操作。\n配置 webpack 说难不难，说简单也不简单，现在几大框架都配备了全家桶，quick-start 项目基本上都已经配置好了基础的 webpack 配置。\n虽然能够正常使用，但是，对于各个配置项，并不是很清楚。这几天利用空余时间，理一下几个 loader 和 插件的使用。\n\n\n### 关于 loader && loader 的加载顺序\nloader 是一个函数，用来把文件转换为 webpack 识别的模块，webpack 本身只能处理加载 javascript，对于 css、image 等资源是无法处理的，而 loader 就是 webpack 开放出来的接口，供用户开发自己的 loader。\n\nloader的使用方式如下\n```javascript\nrules: [\n  {\n    test: /\\.(css|scss)$/,\n    loader: ['style-loader', '....', 'url-loader']\n  }\n]\n```\nwebpack loader 可以是一个数组，数组的加载方式是从右向左，如上面这个配置，loader 执行的时候，会先使用 url-loader 加载文件，最后用 style-loader 将代码插入文档中。\n\n### file-loader/url-loader/tyle-loader/mini-css-extract-plugin loader/vue-loader/css-loader\n\n1.*file-loader* \n文件加载 loader，主要用来加载 import/require 导入的文件\n加载比如 css 中 background-image src 的图片等资源\n加载导入的字体文件\n*官方介绍*\n```html\nThe file-loader resolves import/require() on a file into a url and emits the file into the output directory.\n```\n\n2.*url-loader* \n和 file-loader 功能类似，它依赖于 file-loader，file-loader 有的功能它都有\n*不同之处在于能将导入的文件转为 base64，可以指定文件大小限制，小于某个值的时候将文件转为 base64 的 url*\n\n3.*style-loader && vue-style-loader && mini-css-extract-plugin loader*\n1）style-loader 负责将 css 以内联的方式插入文档中\n2）vue-style-loader 功能和style-loader 类似，只不过它更专注于 vue 中的 css 提取\n3）mini-css-extract-plugin 从名字可以看出，它本身是一个插件，作用是将 css 分离出来，它能将 css 插入文档中，和 style-loader 的区别在于 style 是将 css 内联插入，而它的 loader 通过外部引入的方式将 css 插入文档中。\n*注意：mini-css-extract-plugin loader 和 vue-style-loader不能同时使用*\n\n4.*css-loader*\n加载外部引用 css (@import)以及 从 .vue 文件中提取出来的 css 资源\n使用此 loader 只是提取 css 资源，之后还需要用 style-loader 等 loader 将 css 插入 Dom，建议写法：\n```javascript\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n...\n{\n  test: /\\.css$/,\n  loader: [devMode ? 'style-loader': MiniCssExtractPlugin.loader, 'css-loader']\n},\n```\n注意：css-loader如果是用在vue-ssr服务端构建的时候，需要配置exportOnlyLocals，示例如下：\n```javascript\nmodule: {\n  rules: [\n    {\n      test: /\\.(css|scss)$/,\n      loader: [\n        {\n          loader: 'css-loader',\n          options: {\n            exportOnlyLocals:true\n          }\n        },\n        'postcss-loader', \n        'sass-loader'\n      ]\n    },\n  ]\n},\n```\n\n5.*sass-loader*\n将 sass/scss 文件编译为 css 文件，需要依赖 node-sass，编译为 css 之后还需要加载 css，所以还得调用 css 的加载 loader，建议写法：\n```javascript\n{\n  test: /\\.scss$/,\n  loader: [devMode ? 'style-loader': MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader']\n}\n```\n\n6.*postcss-loader*\n写过 css3 的人应该遇到过很多需要写 css 前缀的情况，这是因为不同浏览器对新特性的支持情况不一样，很多试验性新特性需要加上浏览器前缀才会生效。\npostcss 是一个很强大的东东，这里我们只是用它的一个 loader，目的是为了简化 css 写法。\n和 autoprefixer 配合使用，会自动给 css 加前缀。\n如：\n```css\ntransition: transform 1s\n```\n经过 postcss-loader 会转换为：\n```css\n-webkit-transition: -webkit-transform 1s;\ntransition: -webkit-transform 1s;\n-o-transition: transform 1s;\ntransition: transform 1s;\ntransition: transform 1s, -webkit-transform 1s;\n```\n\n用法相对其它loader，需要依赖 autoprefixer，需要多加一个配置文件 postcss.config.js\n作用是设置浏览器的范围\n```javascript\n// postcss.config.js 文件\nmodule.exports = {\n  plugins: [\n    require('autoprefixer')({\n      browsers: [\n        '> 1%',\n        'last 20 versions',\n        'ie > 9'\n      ]\n    })\n  ]\n}\n```\n之后就可以正常使用 postcss-loader 了，同样，此 loader 只是将 css 转换，并不会直接插入到文档中\n因此后续还需要用的其它 loader，推荐用法：\n```javascript\n{\n  test: /\\.(css|scss)$/,\n  loader: [\n    devMode ? 'style-loader': MiniCssExtractPlugin.loader, \n    'css-loader',\n    'postcss-loader', \n    'sass-loader'\n  ]\n}\n```\n**注意：**这里有个坑\n在做的过程中，发现在 index.vue 中 通过 ‘@import url(\"../css/index.scss\");’ 导入 index.scss 文件，发现 index.scss 中的 css 属性并没有经过 postcss 转换。\n网上查了一下，说是需要给 css-loader 加一个 options：\n```javascript\n{ loader: 'css-loader', options: { importLoaders: 1 } },\n```\n但是，经过测试，发现并未生效，看网上的人们说的还真有这么回事儿，但是确实不行（可能是我用的 webpack 版本不一样）。\n经过一番折腾，发现只有 @import 加 url 的不行\n解决办法：\n```css\n@import url(\"../css/index.scss\");\n/* 去掉 url 改为 */\n@import \"../css/index.scss\";\n```\n\n\n搞好上面几个 loader，整个 css 的处理基本上就搞清楚了。\n接下来就是弄 javascript 的 loader 了。\n\n---\n\n### javascript 还需要 loader 吗？\n\n不是说 webpack 自己能加载 js 吗，为什么还需要 js 相关的 loader 呢？\n没错，javascript 本身是不需要 loader 的，但是如果要使用 es6+ 的新特性，就需要用到 loader 了。\n我们知道，对于 es6 新特性，不同浏览器支持情况是不一样的，我们使用 loader 的目的就是将 es6 转换为可被浏览器接受的 javascript 语法，似乎跟前面 css 的 postcss-loader 作用一样？\n\n##### ecmascript 标准制定过程\n使用 babel 和 babel-loader，最好是能先对 Ecmascript 的版本和制定有一定的了解。\nEcmascript制定一般会经过如下几个阶段：\n```html\nstage0：开放阶段，草稿阶段\nstage1：初步标准，提议阶段\nstage2：草稿阶段，观察阶段\nstage3：候补阶段，开发者基本认可了\nstage4：完成阶段，基本确定（不会100%确定）会加入下一个 ecmascript 版本中\n```\n而 babel 的转换具体转换到哪个阶段，则需要自己对其进行相应的配置。\n\n##### babel\nbabel，是一个伟大的“发明”。\n最近几年 javascript 更新很快，不断有新的特性被提出，不断有的的版本发出。\n但是因为客户端本身的复杂性，要想将 js 的新特性运用在浏览器端，并做到很好的兼容性是一个很“艰难”的过程。\n各种各样的兼容性已经足够增加成倍的开发成本了。\n\n好在，babel 的出现解决了这个问题，它的出现可以说推进了 javascript 的演进历程。\n那么它是如何做到的呢？\n\n#### babel 原理\nbabel 是一个‘编译器’，能将高版本的 javascript 编译成低版本的 javascript，以至于浏览器能够正常的使用。\nbabel 可以单独使用，但是目前更多的还是配合构建工具（如 webpack）来进行使用。\n\nsass-loader 能够将 scss 转换为 css 供浏览器识别。\n使用 babel-loader 能够将 es6 转换为 es5 来供浏览器识别。\n```javascript\n{\n  test: /\\.js$/,\n  include: [resolve('src')],\n  loader: 'babel-loader'\n}\n```\n\n当然，仅仅这样配置是不够的。因为 javascript 本身比 css 复杂，涉及到更多的版本，包括前面提到的各个 stage 需要兼顾，还得考虑转换之后代码的冗余程度。\n具体配置示例如下所示：\n\n```javascript\n// babel.config.js\nmodule.exports = function(api) {\n  api.cache(true)\n  const presets = [\n    [\n      '@babel/preset-env', // 可简写 @babel/env， 这个是包括了很多支持 javascript 版本转换的插件。\n      {\n        'targets': {\n          'browsers': [ // 这个指定编译之后需要兼容的浏览器范围\n            '> 1%',\n            'last 2 versions',\n            'ie >= 9'\n          ]\n        },\n        // 只包括你需要的 polyfill,\n        // Babel 将检查你的所有代码，以查找目标环境中缺少的功能，并仅包含所需的 polyfill\n        // 如果我们没有将 env preset 的 \"useBuiltIns\" 选项的设置为 \"usage\" ，就必须在其他代码之前 require 一次完整的 polyfill。\n        'useBuiltIns': 'usage',\n        // \"amd\" | \"umd\" | \"systemjs\" | \"commonjs\" | \"cjs\" | \"auto\" | false, defaults to \"auto\".\n        'modules': false,\n      },\n    ]\n  ]\n  const plugins = [\n    '@babel/plugin-syntax-dynamic-import', // 支持转换 import 语法\n  ]\n  return {\n    presets,\n    plugins\n  }\n}\n```\n\n##### Plugins && Presets\nplugin 和 preset 告诉编译器如果对代码进行转换。\n下面是一些常用 preset 和插件\n\n```javascript\n@babel/core // 核心库，必须安装此依赖\n@babel/cli // 是一个允许你从终端使用 babel 的工具(可以全局安装)\n@babel/preset-env \n/*\n包括支持现代 JavaScript（ES2015，ES2016 等）的所有插件，只是为浏览器没有的功能加载转换插件\n只能进行语法转化，但是不能对 api 进行转码，如 promise、set、map 等新增对象，Object.assign/Object.entries 等全局对象的转码功能\n而 babel-runtime 和 babel-polyfill 就是做这些事情的。\n*/\n```\n```javascript\n@babel/polyfill // 实现目标环境中缺少的功能，包括 core-js 和自定义 regenerator runtime 来模拟完整的 ES2015+ 环境。\n@babel/runtime // 和 @babel/polyfill 功能类似。\n```\n\npolyfill 和 runtime 两个模块功能几乎一样，但是实现方法不同\npolyfill 会污染全局对象，但是使用简单，如果不是作为公共模块提供给其它应用，可以使用此配置。\nruntime 会手动引入 helper 函数\nconst Promise = require('babel-runtime/core-js/promise') 就可以引入 Promise。\n\n缺点是通过引入的方式，引入的模块不能共享，造成打包之后有很多重复的 helper 代码\n所以，babel 又开发了 babel-plugin-transform-runtime 这个模块将代码重写，提取公共方法。\n```javascript\nbabel-plugin-transform-runtime\n```\n\n除此之外，还有一些常用的，比如react支持\n```javascript\n@babel/preset-react // 转换 jsx 语法\n```\n\ntypescript 支持，加一个 loader，再加一个 tsconfig 配置文件即可\n```javascript\n@babel/preset-typescript // 转换 typescript 语法 用法见后面。\n```\n\ntypescript 支持，需要加 ts-loader 以及 tsconfig 配置\n```javascript\n{\n  test: /\\.ts$/,\n  include: [resolve('src')],\n  loader: 'ts-loader'\n}\n```\n\n在根目录下加 tsconfig.json 文件\n```javascript\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"noImplicitAny\": true,\n    \"removeComments\": true,\n    \"preserveConstEnums\": true,\n    \"sourceMap\": true\n  },\n  \"files\": [\n    \"./src/views/index.ts\",\n  ]\n}\n```\n\n### 相关链接\n\n### webpack指南：\nhttps://webpack.toobug.net/zh-cn/chapter4/using-loaders.html\n\n### babel 中文网站\nhttps://babel.docschina.org/docs/en/usage\n\n\n\n\n","slug":"webpack","published":1,"updated":"2021-03-30T01:32:00.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ugf001za0vzf4095t9t","content":"<p>Webpack是一个前端资源加载以及打包工具,只需要简单的配置即可实现前端各种工程化的操作。<br>配置 webpack 说难不难，说简单也不简单，现在几大框架都配备了全家桶，quick-start 项目基本上都已经配置好了基础的 webpack 配置。<br>虽然能够正常使用，但是，对于各个配置项，并不是很清楚。这几天利用空余时间，理一下几个 loader 和 插件的使用。</p>\n<h3 id=\"关于-loader-amp-amp-loader-的加载顺序\"><a href=\"#关于-loader-amp-amp-loader-的加载顺序\" class=\"headerlink\" title=\"关于 loader &amp;&amp; loader 的加载顺序\"></a>关于 loader &amp;&amp; loader 的加载顺序</h3><p>loader 是一个函数，用来把文件转换为 webpack 识别的模块，webpack 本身只能处理加载 javascript，对于 css、image 等资源是无法处理的，而 loader 就是 webpack 开放出来的接口，供用户开发自己的 loader。</p>\n<p>loader的使用方式如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.(css|scss)$/</span>,</span><br><span class=\"line\">    loader: [<span class=\"string\">&#x27;style-loader&#x27;</span>, <span class=\"string\">&#x27;....&#x27;</span>, <span class=\"string\">&#x27;url-loader&#x27;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure><br>webpack loader 可以是一个数组，数组的加载方式是从右向左，如上面这个配置，loader 执行的时候，会先使用 url-loader 加载文件，最后用 style-loader 将代码插入文档中。</p>\n<h3 id=\"file-loader-url-loader-tyle-loader-mini-css-extract-plugin-loader-vue-loader-css-loader\"><a href=\"#file-loader-url-loader-tyle-loader-mini-css-extract-plugin-loader-vue-loader-css-loader\" class=\"headerlink\" title=\"file-loader/url-loader/tyle-loader/mini-css-extract-plugin loader/vue-loader/css-loader\"></a>file-loader/url-loader/tyle-loader/mini-css-extract-plugin loader/vue-loader/css-loader</h3><p>1.<em>file-loader</em><br>文件加载 loader，主要用来加载 import/require 导入的文件<br>加载比如 css 中 background-image src 的图片等资源<br>加载导入的字体文件<br><em>官方介绍</em><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The file-loader resolves import/require() on a file into a url and emits the file into the output directory.</span><br></pre></td></tr></table></figure></p>\n<p>2.<em>url-loader</em><br>和 file-loader 功能类似，它依赖于 file-loader，file-loader 有的功能它都有<br><em>不同之处在于能将导入的文件转为 base64，可以指定文件大小限制，小于某个值的时候将文件转为 base64 的 url</em></p>\n<p>3.<em>style-loader &amp;&amp; vue-style-loader &amp;&amp; mini-css-extract-plugin loader</em><br>1）style-loader 负责将 css 以内联的方式插入文档中<br>2）vue-style-loader 功能和style-loader 类似，只不过它更专注于 vue 中的 css 提取<br>3）mini-css-extract-plugin 从名字可以看出，它本身是一个插件，作用是将 css 分离出来，它能将 css 插入文档中，和 style-loader 的区别在于 style 是将 css 内联插入，而它的 loader 通过外部引入的方式将 css 插入文档中。<br><em>注意：mini-css-extract-plugin loader 和 vue-style-loader不能同时使用</em></p>\n<p>4.<em>css-loader</em><br>加载外部引用 css (@import)以及 从 .vue 文件中提取出来的 css 资源<br>使用此 loader 只是提取 css 资源，之后还需要用 style-loader 等 loader 将 css 插入 Dom，建议写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MiniCssExtractPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class=\"line\">...</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">  loader: [devMode ? <span class=\"string\">&#x27;style-loader&#x27;</span>: MiniCssExtractPlugin.loader, <span class=\"string\">&#x27;css-loader&#x27;</span>]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure><br>注意：css-loader如果是用在vue-ssr服务端构建的时候，需要配置exportOnlyLocals，示例如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.(css|scss)$/</span>,</span><br><span class=\"line\">      loader: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          loader: <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">          options: &#123;</span><br><span class=\"line\">            exportOnlyLocals:<span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&#x27;postcss-loader&#x27;</span>, </span><br><span class=\"line\">        <span class=\"string\">&#x27;sass-loader&#x27;</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>5.<em>sass-loader</em><br>将 sass/scss 文件编译为 css 文件，需要依赖 node-sass，编译为 css 之后还需要加载 css，所以还得调用 css 的加载 loader，建议写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.scss$/</span>,</span><br><span class=\"line\">  loader: [devMode ? <span class=\"string\">&#x27;style-loader&#x27;</span>: MiniCssExtractPlugin.loader, <span class=\"string\">&#x27;css-loader&#x27;</span>, <span class=\"string\">&#x27;sass-loader&#x27;</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>6.<em>postcss-loader</em><br>写过 css3 的人应该遇到过很多需要写 css 前缀的情况，这是因为不同浏览器对新特性的支持情况不一样，很多试验性新特性需要加上浏览器前缀才会生效。<br>postcss 是一个很强大的东东，这里我们只是用它的一个 loader，目的是为了简化 css 写法。<br>和 autoprefixer 配合使用，会自动给 css 加前缀。<br>如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transition</span>: <span class=\"selector-tag\">transform</span> 1<span class=\"selector-tag\">s</span></span><br></pre></td></tr></table></figure><br>经过 postcss-loader 会转换为：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-webkit-transition</span>: <span class=\"selector-tag\">-webkit-transform</span> 1<span class=\"selector-tag\">s</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">transition</span>: <span class=\"selector-tag\">-webkit-transform</span> 1<span class=\"selector-tag\">s</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">-o-transition</span>: <span class=\"selector-tag\">transform</span> 1<span class=\"selector-tag\">s</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">transition</span>: <span class=\"selector-tag\">transform</span> 1<span class=\"selector-tag\">s</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">transition</span>: <span class=\"selector-tag\">transform</span> 1<span class=\"selector-tag\">s</span>, <span class=\"selector-tag\">-webkit-transform</span> 1<span class=\"selector-tag\">s</span>;</span><br></pre></td></tr></table></figure></p>\n<p>用法相对其它loader，需要依赖 autoprefixer，需要多加一个配置文件 postcss.config.js<br>作用是设置浏览器的范围<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// postcss.config.js 文件</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;autoprefixer&#x27;</span>)(&#123;</span><br><span class=\"line\">      browsers: [</span><br><span class=\"line\">        <span class=\"string\">&#x27;&gt; 1%&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;last 20 versions&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;ie &gt; 9&#x27;</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>之后就可以正常使用 postcss-loader 了，同样，此 loader 只是将 css 转换，并不会直接插入到文档中<br>因此后续还需要用的其它 loader，推荐用法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.(css|scss)$/</span>,</span><br><span class=\"line\">  loader: [</span><br><span class=\"line\">    devMode ? <span class=\"string\">&#x27;style-loader&#x27;</span>: MiniCssExtractPlugin.loader, </span><br><span class=\"line\">    <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;postcss-loader&#x27;</span>, </span><br><span class=\"line\">    <span class=\"string\">&#x27;sass-loader&#x27;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>注意：</strong>这里有个坑<br>在做的过程中，发现在 index.vue 中 通过 ‘@import url(“../css/index.scss”);’ 导入 index.scss 文件，发现 index.scss 中的 css 属性并没有经过 postcss 转换。<br>网上查了一下，说是需要给 css-loader 加一个 options：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;css-loader&#x27;</span>, <span class=\"attr\">options</span>: &#123; <span class=\"attr\">importLoaders</span>: <span class=\"number\">1</span> &#125; &#125;,</span><br></pre></td></tr></table></figure><br>但是，经过测试，发现并未生效，看网上的人们说的还真有这么回事儿，但是确实不行（可能是我用的 webpack 版本不一样）。<br>经过一番折腾，发现只有 @import 加 url 的不行<br>解决办法：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@import</span> url(<span class=\"string\">&quot;../css/index.scss&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">/* 去掉 url 改为 */</span></span><br><span class=\"line\"><span class=\"keyword\">@import</span> <span class=\"string\">&quot;../css/index.scss&quot;</span>;</span><br></pre></td></tr></table></figure></p>\n<p>搞好上面几个 loader，整个 css 的处理基本上就搞清楚了。<br>接下来就是弄 javascript 的 loader 了。</p>\n<hr>\n<h3 id=\"javascript-还需要-loader-吗？\"><a href=\"#javascript-还需要-loader-吗？\" class=\"headerlink\" title=\"javascript 还需要 loader 吗？\"></a>javascript 还需要 loader 吗？</h3><p>不是说 webpack 自己能加载 js 吗，为什么还需要 js 相关的 loader 呢？<br>没错，javascript 本身是不需要 loader 的，但是如果要使用 es6+ 的新特性，就需要用到 loader 了。<br>我们知道，对于 es6 新特性，不同浏览器支持情况是不一样的，我们使用 loader 的目的就是将 es6 转换为可被浏览器接受的 javascript 语法，似乎跟前面 css 的 postcss-loader 作用一样？</p>\n<h5 id=\"ecmascript-标准制定过程\"><a href=\"#ecmascript-标准制定过程\" class=\"headerlink\" title=\"ecmascript 标准制定过程\"></a>ecmascript 标准制定过程</h5><p>使用 babel 和 babel-loader，最好是能先对 Ecmascript 的版本和制定有一定的了解。<br>Ecmascript制定一般会经过如下几个阶段：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stage0：开放阶段，草稿阶段</span><br><span class=\"line\">stage1：初步标准，提议阶段</span><br><span class=\"line\">stage2：草稿阶段，观察阶段</span><br><span class=\"line\">stage3：候补阶段，开发者基本认可了</span><br><span class=\"line\">stage4：完成阶段，基本确定（不会100%确定）会加入下一个 ecmascript 版本中</span><br></pre></td></tr></table></figure><br>而 babel 的转换具体转换到哪个阶段，则需要自己对其进行相应的配置。</p>\n<h5 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a>babel</h5><p>babel，是一个伟大的“发明”。<br>最近几年 javascript 更新很快，不断有新的特性被提出，不断有的的版本发出。<br>但是因为客户端本身的复杂性，要想将 js 的新特性运用在浏览器端，并做到很好的兼容性是一个很“艰难”的过程。<br>各种各样的兼容性已经足够增加成倍的开发成本了。</p>\n<p>好在，babel 的出现解决了这个问题，它的出现可以说推进了 javascript 的演进历程。<br>那么它是如何做到的呢？</p>\n<h4 id=\"babel-原理\"><a href=\"#babel-原理\" class=\"headerlink\" title=\"babel 原理\"></a>babel 原理</h4><p>babel 是一个‘编译器’，能将高版本的 javascript 编译成低版本的 javascript，以至于浏览器能够正常的使用。<br>babel 可以单独使用，但是目前更多的还是配合构建工具（如 webpack）来进行使用。</p>\n<p>sass-loader 能够将 scss 转换为 css 供浏览器识别。<br>使用 babel-loader 能够将 es6 转换为 es5 来供浏览器识别。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">  include: [resolve(<span class=\"string\">&#x27;src&#x27;</span>)],</span><br><span class=\"line\">  loader: <span class=\"string\">&#x27;babel-loader&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然，仅仅这样配置是不够的。因为 javascript 本身比 css 复杂，涉及到更多的版本，包括前面提到的各个 stage 需要兼顾，还得考虑转换之后代码的冗余程度。<br>具体配置示例如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// babel.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">api</span>) </span>&#123;</span><br><span class=\"line\">  api.cache(<span class=\"literal\">true</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> presets = [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">&#x27;@babel/preset-env&#x27;</span>, <span class=\"comment\">// 可简写 @babel/env， 这个是包括了很多支持 javascript 版本转换的插件。</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;targets&#x27;</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">&#x27;browsers&#x27;</span>: [ <span class=\"comment\">// 这个指定编译之后需要兼容的浏览器范围</span></span><br><span class=\"line\">            <span class=\"string\">&#x27;&gt; 1%&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;last 2 versions&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;ie &gt;= 9&#x27;</span></span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">// 只包括你需要的 polyfill,</span></span><br><span class=\"line\">        <span class=\"comment\">// Babel 将检查你的所有代码，以查找目标环境中缺少的功能，并仅包含所需的 polyfill</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果我们没有将 env preset 的 &quot;useBuiltIns&quot; 选项的设置为 &quot;usage&quot; ，就必须在其他代码之前 require 一次完整的 polyfill。</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;useBuiltIns&#x27;</span>: <span class=\"string\">&#x27;usage&#x27;</span>,</span><br><span class=\"line\">        <span class=\"comment\">// &quot;amd&quot; | &quot;umd&quot; | &quot;systemjs&quot; | &quot;commonjs&quot; | &quot;cjs&quot; | &quot;auto&quot; | false, defaults to &quot;auto&quot;.</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;modules&#x27;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> plugins = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;@babel/plugin-syntax-dynamic-import&#x27;</span>, <span class=\"comment\">// 支持转换 import 语法</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    presets,</span><br><span class=\"line\">    plugins</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Plugins-amp-amp-Presets\"><a href=\"#Plugins-amp-amp-Presets\" class=\"headerlink\" title=\"Plugins &amp;&amp; Presets\"></a>Plugins &amp;&amp; Presets</h5><p>plugin 和 preset 告诉编译器如果对代码进行转换。<br>下面是一些常用 preset 和插件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@babel/core <span class=\"comment\">// 核心库，必须安装此依赖</span></span><br><span class=\"line\">@babel/cli <span class=\"comment\">// 是一个允许你从终端使用 babel 的工具(可以全局安装)</span></span><br><span class=\"line\">@babel/preset-env </span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">包括支持现代 JavaScript（ES2015，ES2016 等）的所有插件，只是为浏览器没有的功能加载转换插件</span></span><br><span class=\"line\"><span class=\"comment\">只能进行语法转化，但是不能对 api 进行转码，如 promise、set、map 等新增对象，Object.assign/Object.entries 等全局对象的转码功能</span></span><br><span class=\"line\"><span class=\"comment\">而 babel-runtime 和 babel-polyfill 就是做这些事情的。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@babel/polyfill <span class=\"comment\">// 实现目标环境中缺少的功能，包括 core-js 和自定义 regenerator runtime 来模拟完整的 ES2015+ 环境。</span></span><br><span class=\"line\">@babel/runtime <span class=\"comment\">// 和 @babel/polyfill 功能类似。</span></span><br></pre></td></tr></table></figure>\n<p>polyfill 和 runtime 两个模块功能几乎一样，但是实现方法不同<br>polyfill 会污染全局对象，但是使用简单，如果不是作为公共模块提供给其它应用，可以使用此配置。<br>runtime 会手动引入 helper 函数<br>const Promise = require(‘babel-runtime/core-js/promise’) 就可以引入 Promise。</p>\n<p>缺点是通过引入的方式，引入的模块不能共享，造成打包之后有很多重复的 helper 代码<br>所以，babel 又开发了 babel-plugin-transform-runtime 这个模块将代码重写，提取公共方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">babel-plugin-transform-runtime</span><br></pre></td></tr></table></figure></p>\n<p>除此之外，还有一些常用的，比如react支持<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@babel/preset-react <span class=\"comment\">// 转换 jsx 语法</span></span><br></pre></td></tr></table></figure></p>\n<p>typescript 支持，加一个 loader，再加一个 tsconfig 配置文件即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@babel/preset-typescript <span class=\"comment\">// 转换 typescript 语法 用法见后面。</span></span><br></pre></td></tr></table></figure></p>\n<p>typescript 支持，需要加 ts-loader 以及 tsconfig 配置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.ts$/</span>,</span><br><span class=\"line\">  include: [resolve(<span class=\"string\">&#x27;src&#x27;</span>)],</span><br><span class=\"line\">  loader: <span class=\"string\">&#x27;ts-loader&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在根目录下加 tsconfig.json 文件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;module&quot;</span>: <span class=\"string\">&quot;commonjs&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;noImplicitAny&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;removeComments&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;preserveConstEnums&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;sourceMap&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;files&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;./src/views/index.ts&quot;</span>,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><h3 id=\"webpack指南：\"><a href=\"#webpack指南：\" class=\"headerlink\" title=\"webpack指南：\"></a>webpack指南：</h3><p><a href=\"https://webpack.toobug.net/zh-cn/chapter4/using-loaders.html\">https://webpack.toobug.net/zh-cn/chapter4/using-loaders.html</a></p>\n<h3 id=\"babel-中文网站\"><a href=\"#babel-中文网站\" class=\"headerlink\" title=\"babel 中文网站\"></a>babel 中文网站</h3><p><a href=\"https://babel.docschina.org/docs/en/usage\">https://babel.docschina.org/docs/en/usage</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Webpack是一个前端资源加载以及打包工具,只需要简单的配置即可实现前端各种工程化的操作。<br>配置 webpack 说难不难，说简单也不简单，现在几大框架都配备了全家桶，quick-start 项目基本上都已经配置好了基础的 webpack 配置。<br>虽然能够正常使用，但是，对于各个配置项，并不是很清楚。这几天利用空余时间，理一下几个 loader 和 插件的使用。</p>\n<h3 id=\"关于-loader-amp-amp-loader-的加载顺序\"><a href=\"#关于-loader-amp-amp-loader-的加载顺序\" class=\"headerlink\" title=\"关于 loader &amp;&amp; loader 的加载顺序\"></a>关于 loader &amp;&amp; loader 的加载顺序</h3><p>loader 是一个函数，用来把文件转换为 webpack 识别的模块，webpack 本身只能处理加载 javascript，对于 css、image 等资源是无法处理的，而 loader 就是 webpack 开放出来的接口，供用户开发自己的 loader。</p>\n<p>loader的使用方式如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.(css|scss)$/</span>,</span><br><span class=\"line\">    loader: [<span class=\"string\">&#x27;style-loader&#x27;</span>, <span class=\"string\">&#x27;....&#x27;</span>, <span class=\"string\">&#x27;url-loader&#x27;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure><br>webpack loader 可以是一个数组，数组的加载方式是从右向左，如上面这个配置，loader 执行的时候，会先使用 url-loader 加载文件，最后用 style-loader 将代码插入文档中。</p>\n<h3 id=\"file-loader-url-loader-tyle-loader-mini-css-extract-plugin-loader-vue-loader-css-loader\"><a href=\"#file-loader-url-loader-tyle-loader-mini-css-extract-plugin-loader-vue-loader-css-loader\" class=\"headerlink\" title=\"file-loader/url-loader/tyle-loader/mini-css-extract-plugin loader/vue-loader/css-loader\"></a>file-loader/url-loader/tyle-loader/mini-css-extract-plugin loader/vue-loader/css-loader</h3><p>1.<em>file-loader</em><br>文件加载 loader，主要用来加载 import/require 导入的文件<br>加载比如 css 中 background-image src 的图片等资源<br>加载导入的字体文件<br><em>官方介绍</em><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The file-loader resolves import/require() on a file into a url and emits the file into the output directory.</span><br></pre></td></tr></table></figure></p>\n<p>2.<em>url-loader</em><br>和 file-loader 功能类似，它依赖于 file-loader，file-loader 有的功能它都有<br><em>不同之处在于能将导入的文件转为 base64，可以指定文件大小限制，小于某个值的时候将文件转为 base64 的 url</em></p>\n<p>3.<em>style-loader &amp;&amp; vue-style-loader &amp;&amp; mini-css-extract-plugin loader</em><br>1）style-loader 负责将 css 以内联的方式插入文档中<br>2）vue-style-loader 功能和style-loader 类似，只不过它更专注于 vue 中的 css 提取<br>3）mini-css-extract-plugin 从名字可以看出，它本身是一个插件，作用是将 css 分离出来，它能将 css 插入文档中，和 style-loader 的区别在于 style 是将 css 内联插入，而它的 loader 通过外部引入的方式将 css 插入文档中。<br><em>注意：mini-css-extract-plugin loader 和 vue-style-loader不能同时使用</em></p>\n<p>4.<em>css-loader</em><br>加载外部引用 css (@import)以及 从 .vue 文件中提取出来的 css 资源<br>使用此 loader 只是提取 css 资源，之后还需要用 style-loader 等 loader 将 css 插入 Dom，建议写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MiniCssExtractPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class=\"line\">...</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">  loader: [devMode ? <span class=\"string\">&#x27;style-loader&#x27;</span>: MiniCssExtractPlugin.loader, <span class=\"string\">&#x27;css-loader&#x27;</span>]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure><br>注意：css-loader如果是用在vue-ssr服务端构建的时候，需要配置exportOnlyLocals，示例如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.(css|scss)$/</span>,</span><br><span class=\"line\">      loader: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          loader: <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">          options: &#123;</span><br><span class=\"line\">            exportOnlyLocals:<span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&#x27;postcss-loader&#x27;</span>, </span><br><span class=\"line\">        <span class=\"string\">&#x27;sass-loader&#x27;</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>5.<em>sass-loader</em><br>将 sass/scss 文件编译为 css 文件，需要依赖 node-sass，编译为 css 之后还需要加载 css，所以还得调用 css 的加载 loader，建议写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.scss$/</span>,</span><br><span class=\"line\">  loader: [devMode ? <span class=\"string\">&#x27;style-loader&#x27;</span>: MiniCssExtractPlugin.loader, <span class=\"string\">&#x27;css-loader&#x27;</span>, <span class=\"string\">&#x27;sass-loader&#x27;</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>6.<em>postcss-loader</em><br>写过 css3 的人应该遇到过很多需要写 css 前缀的情况，这是因为不同浏览器对新特性的支持情况不一样，很多试验性新特性需要加上浏览器前缀才会生效。<br>postcss 是一个很强大的东东，这里我们只是用它的一个 loader，目的是为了简化 css 写法。<br>和 autoprefixer 配合使用，会自动给 css 加前缀。<br>如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transition</span>: <span class=\"selector-tag\">transform</span> 1<span class=\"selector-tag\">s</span></span><br></pre></td></tr></table></figure><br>经过 postcss-loader 会转换为：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-webkit-transition</span>: <span class=\"selector-tag\">-webkit-transform</span> 1<span class=\"selector-tag\">s</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">transition</span>: <span class=\"selector-tag\">-webkit-transform</span> 1<span class=\"selector-tag\">s</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">-o-transition</span>: <span class=\"selector-tag\">transform</span> 1<span class=\"selector-tag\">s</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">transition</span>: <span class=\"selector-tag\">transform</span> 1<span class=\"selector-tag\">s</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">transition</span>: <span class=\"selector-tag\">transform</span> 1<span class=\"selector-tag\">s</span>, <span class=\"selector-tag\">-webkit-transform</span> 1<span class=\"selector-tag\">s</span>;</span><br></pre></td></tr></table></figure></p>\n<p>用法相对其它loader，需要依赖 autoprefixer，需要多加一个配置文件 postcss.config.js<br>作用是设置浏览器的范围<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// postcss.config.js 文件</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;autoprefixer&#x27;</span>)(&#123;</span><br><span class=\"line\">      browsers: [</span><br><span class=\"line\">        <span class=\"string\">&#x27;&gt; 1%&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;last 20 versions&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;ie &gt; 9&#x27;</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>之后就可以正常使用 postcss-loader 了，同样，此 loader 只是将 css 转换，并不会直接插入到文档中<br>因此后续还需要用的其它 loader，推荐用法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.(css|scss)$/</span>,</span><br><span class=\"line\">  loader: [</span><br><span class=\"line\">    devMode ? <span class=\"string\">&#x27;style-loader&#x27;</span>: MiniCssExtractPlugin.loader, </span><br><span class=\"line\">    <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;postcss-loader&#x27;</span>, </span><br><span class=\"line\">    <span class=\"string\">&#x27;sass-loader&#x27;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>注意：</strong>这里有个坑<br>在做的过程中，发现在 index.vue 中 通过 ‘@import url(“../css/index.scss”);’ 导入 index.scss 文件，发现 index.scss 中的 css 属性并没有经过 postcss 转换。<br>网上查了一下，说是需要给 css-loader 加一个 options：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;css-loader&#x27;</span>, <span class=\"attr\">options</span>: &#123; <span class=\"attr\">importLoaders</span>: <span class=\"number\">1</span> &#125; &#125;,</span><br></pre></td></tr></table></figure><br>但是，经过测试，发现并未生效，看网上的人们说的还真有这么回事儿，但是确实不行（可能是我用的 webpack 版本不一样）。<br>经过一番折腾，发现只有 @import 加 url 的不行<br>解决办法：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@import</span> url(<span class=\"string\">&quot;../css/index.scss&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">/* 去掉 url 改为 */</span></span><br><span class=\"line\"><span class=\"keyword\">@import</span> <span class=\"string\">&quot;../css/index.scss&quot;</span>;</span><br></pre></td></tr></table></figure></p>\n<p>搞好上面几个 loader，整个 css 的处理基本上就搞清楚了。<br>接下来就是弄 javascript 的 loader 了。</p>\n<hr>\n<h3 id=\"javascript-还需要-loader-吗？\"><a href=\"#javascript-还需要-loader-吗？\" class=\"headerlink\" title=\"javascript 还需要 loader 吗？\"></a>javascript 还需要 loader 吗？</h3><p>不是说 webpack 自己能加载 js 吗，为什么还需要 js 相关的 loader 呢？<br>没错，javascript 本身是不需要 loader 的，但是如果要使用 es6+ 的新特性，就需要用到 loader 了。<br>我们知道，对于 es6 新特性，不同浏览器支持情况是不一样的，我们使用 loader 的目的就是将 es6 转换为可被浏览器接受的 javascript 语法，似乎跟前面 css 的 postcss-loader 作用一样？</p>\n<h5 id=\"ecmascript-标准制定过程\"><a href=\"#ecmascript-标准制定过程\" class=\"headerlink\" title=\"ecmascript 标准制定过程\"></a>ecmascript 标准制定过程</h5><p>使用 babel 和 babel-loader，最好是能先对 Ecmascript 的版本和制定有一定的了解。<br>Ecmascript制定一般会经过如下几个阶段：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stage0：开放阶段，草稿阶段</span><br><span class=\"line\">stage1：初步标准，提议阶段</span><br><span class=\"line\">stage2：草稿阶段，观察阶段</span><br><span class=\"line\">stage3：候补阶段，开发者基本认可了</span><br><span class=\"line\">stage4：完成阶段，基本确定（不会100%确定）会加入下一个 ecmascript 版本中</span><br></pre></td></tr></table></figure><br>而 babel 的转换具体转换到哪个阶段，则需要自己对其进行相应的配置。</p>\n<h5 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a>babel</h5><p>babel，是一个伟大的“发明”。<br>最近几年 javascript 更新很快，不断有新的特性被提出，不断有的的版本发出。<br>但是因为客户端本身的复杂性，要想将 js 的新特性运用在浏览器端，并做到很好的兼容性是一个很“艰难”的过程。<br>各种各样的兼容性已经足够增加成倍的开发成本了。</p>\n<p>好在，babel 的出现解决了这个问题，它的出现可以说推进了 javascript 的演进历程。<br>那么它是如何做到的呢？</p>\n<h4 id=\"babel-原理\"><a href=\"#babel-原理\" class=\"headerlink\" title=\"babel 原理\"></a>babel 原理</h4><p>babel 是一个‘编译器’，能将高版本的 javascript 编译成低版本的 javascript，以至于浏览器能够正常的使用。<br>babel 可以单独使用，但是目前更多的还是配合构建工具（如 webpack）来进行使用。</p>\n<p>sass-loader 能够将 scss 转换为 css 供浏览器识别。<br>使用 babel-loader 能够将 es6 转换为 es5 来供浏览器识别。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">  include: [resolve(<span class=\"string\">&#x27;src&#x27;</span>)],</span><br><span class=\"line\">  loader: <span class=\"string\">&#x27;babel-loader&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然，仅仅这样配置是不够的。因为 javascript 本身比 css 复杂，涉及到更多的版本，包括前面提到的各个 stage 需要兼顾，还得考虑转换之后代码的冗余程度。<br>具体配置示例如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// babel.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">api</span>) </span>&#123;</span><br><span class=\"line\">  api.cache(<span class=\"literal\">true</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> presets = [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"string\">&#x27;@babel/preset-env&#x27;</span>, <span class=\"comment\">// 可简写 @babel/env， 这个是包括了很多支持 javascript 版本转换的插件。</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;targets&#x27;</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">&#x27;browsers&#x27;</span>: [ <span class=\"comment\">// 这个指定编译之后需要兼容的浏览器范围</span></span><br><span class=\"line\">            <span class=\"string\">&#x27;&gt; 1%&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;last 2 versions&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;ie &gt;= 9&#x27;</span></span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">// 只包括你需要的 polyfill,</span></span><br><span class=\"line\">        <span class=\"comment\">// Babel 将检查你的所有代码，以查找目标环境中缺少的功能，并仅包含所需的 polyfill</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果我们没有将 env preset 的 &quot;useBuiltIns&quot; 选项的设置为 &quot;usage&quot; ，就必须在其他代码之前 require 一次完整的 polyfill。</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;useBuiltIns&#x27;</span>: <span class=\"string\">&#x27;usage&#x27;</span>,</span><br><span class=\"line\">        <span class=\"comment\">// &quot;amd&quot; | &quot;umd&quot; | &quot;systemjs&quot; | &quot;commonjs&quot; | &quot;cjs&quot; | &quot;auto&quot; | false, defaults to &quot;auto&quot;.</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;modules&#x27;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> plugins = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;@babel/plugin-syntax-dynamic-import&#x27;</span>, <span class=\"comment\">// 支持转换 import 语法</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    presets,</span><br><span class=\"line\">    plugins</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Plugins-amp-amp-Presets\"><a href=\"#Plugins-amp-amp-Presets\" class=\"headerlink\" title=\"Plugins &amp;&amp; Presets\"></a>Plugins &amp;&amp; Presets</h5><p>plugin 和 preset 告诉编译器如果对代码进行转换。<br>下面是一些常用 preset 和插件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@babel/core <span class=\"comment\">// 核心库，必须安装此依赖</span></span><br><span class=\"line\">@babel/cli <span class=\"comment\">// 是一个允许你从终端使用 babel 的工具(可以全局安装)</span></span><br><span class=\"line\">@babel/preset-env </span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">包括支持现代 JavaScript（ES2015，ES2016 等）的所有插件，只是为浏览器没有的功能加载转换插件</span></span><br><span class=\"line\"><span class=\"comment\">只能进行语法转化，但是不能对 api 进行转码，如 promise、set、map 等新增对象，Object.assign/Object.entries 等全局对象的转码功能</span></span><br><span class=\"line\"><span class=\"comment\">而 babel-runtime 和 babel-polyfill 就是做这些事情的。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@babel/polyfill <span class=\"comment\">// 实现目标环境中缺少的功能，包括 core-js 和自定义 regenerator runtime 来模拟完整的 ES2015+ 环境。</span></span><br><span class=\"line\">@babel/runtime <span class=\"comment\">// 和 @babel/polyfill 功能类似。</span></span><br></pre></td></tr></table></figure>\n<p>polyfill 和 runtime 两个模块功能几乎一样，但是实现方法不同<br>polyfill 会污染全局对象，但是使用简单，如果不是作为公共模块提供给其它应用，可以使用此配置。<br>runtime 会手动引入 helper 函数<br>const Promise = require(‘babel-runtime/core-js/promise’) 就可以引入 Promise。</p>\n<p>缺点是通过引入的方式，引入的模块不能共享，造成打包之后有很多重复的 helper 代码<br>所以，babel 又开发了 babel-plugin-transform-runtime 这个模块将代码重写，提取公共方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">babel-plugin-transform-runtime</span><br></pre></td></tr></table></figure></p>\n<p>除此之外，还有一些常用的，比如react支持<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@babel/preset-react <span class=\"comment\">// 转换 jsx 语法</span></span><br></pre></td></tr></table></figure></p>\n<p>typescript 支持，加一个 loader，再加一个 tsconfig 配置文件即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@babel/preset-typescript <span class=\"comment\">// 转换 typescript 语法 用法见后面。</span></span><br></pre></td></tr></table></figure></p>\n<p>typescript 支持，需要加 ts-loader 以及 tsconfig 配置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.ts$/</span>,</span><br><span class=\"line\">  include: [resolve(<span class=\"string\">&#x27;src&#x27;</span>)],</span><br><span class=\"line\">  loader: <span class=\"string\">&#x27;ts-loader&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在根目录下加 tsconfig.json 文件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;module&quot;</span>: <span class=\"string\">&quot;commonjs&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;noImplicitAny&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;removeComments&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;preserveConstEnums&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;sourceMap&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;files&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;./src/views/index.ts&quot;</span>,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><h3 id=\"webpack指南：\"><a href=\"#webpack指南：\" class=\"headerlink\" title=\"webpack指南：\"></a>webpack指南：</h3><p><a href=\"https://webpack.toobug.net/zh-cn/chapter4/using-loaders.html\">https://webpack.toobug.net/zh-cn/chapter4/using-loaders.html</a></p>\n<h3 id=\"babel-中文网站\"><a href=\"#babel-中文网站\" class=\"headerlink\" title=\"babel 中文网站\"></a>babel 中文网站</h3><p><a href=\"https://babel.docschina.org/docs/en/usage\">https://babel.docschina.org/docs/en/usage</a></p>\n"},{"title":"simulator","date":"2018-11-04T16:00:00.000Z","_content":"\n做前端开发的过程中总是需要各种iphone设备版本来进行测试，但是经常找不到对应的机型。\n这种情况如果是苹果电脑做开发的开发者可以使用xcode。\n安装xcode之后再控制台直接输入下面的命令即可启动模拟器。\n\n```shell\nopen /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app\n```\n\n之后只需要根据菜单自己安装对应的系统和模拟器手机型号即可。\n如果仅仅测试h5页面，用safari就可以了。\n\n如果需要安装软件，公司内部软件可以找ios的开发同学帮忙打包一个安装包。\n\n","source":"_posts/xcode.md","raw":"---\ntitle: simulator\ndate: 2018/11/05\ntag: [ios模拟器, xcode, simulator]\n---\n\n做前端开发的过程中总是需要各种iphone设备版本来进行测试，但是经常找不到对应的机型。\n这种情况如果是苹果电脑做开发的开发者可以使用xcode。\n安装xcode之后再控制台直接输入下面的命令即可启动模拟器。\n\n```shell\nopen /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app\n```\n\n之后只需要根据菜单自己安装对应的系统和模拟器手机型号即可。\n如果仅仅测试h5页面，用safari就可以了。\n\n如果需要安装软件，公司内部软件可以找ios的开发同学帮忙打包一个安装包。\n\n","slug":"xcode","published":1,"updated":"2021-03-30T01:32:00.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ugg0020a0vz3h4h6cy4","content":"<p>做前端开发的过程中总是需要各种iphone设备版本来进行测试，但是经常找不到对应的机型。<br>这种情况如果是苹果电脑做开发的开发者可以使用xcode。<br>安装xcode之后再控制台直接输入下面的命令即可启动模拟器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app</span><br></pre></td></tr></table></figure>\n<p>之后只需要根据菜单自己安装对应的系统和模拟器手机型号即可。<br>如果仅仅测试h5页面，用safari就可以了。</p>\n<p>如果需要安装软件，公司内部软件可以找ios的开发同学帮忙打包一个安装包。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>做前端开发的过程中总是需要各种iphone设备版本来进行测试，但是经常找不到对应的机型。<br>这种情况如果是苹果电脑做开发的开发者可以使用xcode。<br>安装xcode之后再控制台直接输入下面的命令即可启动模拟器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app</span><br></pre></td></tr></table></figure>\n<p>之后只需要根据菜单自己安装对应的系统和模拟器手机型号即可。<br>如果仅仅测试h5页面，用safari就可以了。</p>\n<p>如果需要安装软件，公司内部软件可以找ios的开发同学帮忙打包一个安装包。</p>\n"},{"title":"聊聊微信小程序","date":"2020-12-30T16:00:00.000Z","_content":"\n#### 微信小程序渲染特点\n1.小程序运行在app中的，区别于H5运行在浏览器中，小程序的运行环境是基于浏览器内核重构的内置解析器，没有BOM和DOM API\n2.小程序的渲染区别于H5的渲染线程和脚本线程互斥，小程序采用双线程模型，渲染层运行在Webview中，逻辑层运行在JSCore中，两个线程通过jsBridage进行中转通信。wxml、wxss 运行在渲染层，js 运行在逻辑层\n3.一个小程序一个界面对应一个渲染线程，所以有多个webview线程，webview的渲染是通过js绘制的虚拟DOM为基础渲染的。\n4.只有一个逻辑线程，逻辑层发送网络请求由native转发\n\n#### 为什么小程序会采用双线程模型\n1、H5中，html js和渲染是互斥的，不可用同步进行，为了不让逻辑层阻塞渲染层渲染。\n2.防止开发者随意操作DOM，保护只想给用户查看的这一类隐私数据，保证用户数据安全\n3.限制API的调用(如跳转功能)把js执行的逻辑层放入沙盒，一个纯js的执行环境，然后单独开一个渲染线程来做页面的渲染。\n4.逻辑层的数据给渲染层的时候可以做数据过滤，防止xss\n\n#### 小程序的生命周期\napp: onLunch/onShow/onHide\npage: onLoad/onShow/onReady/onHide/onUnload\ncomponent: created/attached/ready/moved/detached/error show/hide/resize\n```html\n执行顺序:\n->app(onlaunch)\n->app(onshow) \n->component(created)\n->component(attached)\n->page(onload)\n->page(onshow)\n->component(ready)\n->page(onready)\n```\n\n#### 小程序的数据通信\n渲染层与逻辑层：逻辑层到渲染层通信使用setData、渲染层想逻辑层使用事件bindTap/catchTap\n父子组件之间：props数据绑定、事件triggerEvent、observers\n兄弟组件之间：通过父组件中转、全局数据、relations\n\n#### 小程序登录\n1.登录机制\n小程序本身没有cookie机制，所有的数据都存储在storage里面，所以传统的cookie登录方式如果直接用在小程序是行不通的\n简单的办法就是使用第三方库[weap-cookie](https://github.com/charleslo1/weapp-cookie)来做兼容\n此库的原理就是在底层自动代理wx.request接口的访问，为请求预先做好cookie的存取。\n2.小程序做微信自动登录\n小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。\n登录过程分为三步：\n1）调用wx.login()获取微信登录凭据code，并将其传给开发者自己的服务端。\n2）后端服务用前台传过来的code调用微信的后台接口，换取session和openid等信息存储在开发者的服务器\n3）后端服务以session和openid为关联基础生成自己的session登录态，返回前端\n4）前端拿到session登录凭证，登录成功（后续只需要通过session即可判断是否登录了）\n\n#### 小程序性能优化\n1.控制setData频率、数据量\n2.控制wxml节点数、节点深度\n3.接口数据、图片数据缓存\n4.减少包的体量、做必要的分包下载\n5.参考小程序后台评分、开发者工具Audits性能评估做相应优化\n\n\n### 传送门\n微信小程序技术原理分析\nhttps://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html\n\n小程序性能优化\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/performance/\n\n小程序生命周期执行顺序\nhttps://developers.weixin.qq.com/community/develop/article/doc/000002e9b647c833cab9ef81f51c13\n\n小程序自动微信登录\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html","source":"_posts/xcx2.md","raw":"---\ntitle: 聊聊微信小程序\ndate: 2020/12/31\ntag: [小程序,微信开发]\ncategory: 技术\n---\n\n#### 微信小程序渲染特点\n1.小程序运行在app中的，区别于H5运行在浏览器中，小程序的运行环境是基于浏览器内核重构的内置解析器，没有BOM和DOM API\n2.小程序的渲染区别于H5的渲染线程和脚本线程互斥，小程序采用双线程模型，渲染层运行在Webview中，逻辑层运行在JSCore中，两个线程通过jsBridage进行中转通信。wxml、wxss 运行在渲染层，js 运行在逻辑层\n3.一个小程序一个界面对应一个渲染线程，所以有多个webview线程，webview的渲染是通过js绘制的虚拟DOM为基础渲染的。\n4.只有一个逻辑线程，逻辑层发送网络请求由native转发\n\n#### 为什么小程序会采用双线程模型\n1、H5中，html js和渲染是互斥的，不可用同步进行，为了不让逻辑层阻塞渲染层渲染。\n2.防止开发者随意操作DOM，保护只想给用户查看的这一类隐私数据，保证用户数据安全\n3.限制API的调用(如跳转功能)把js执行的逻辑层放入沙盒，一个纯js的执行环境，然后单独开一个渲染线程来做页面的渲染。\n4.逻辑层的数据给渲染层的时候可以做数据过滤，防止xss\n\n#### 小程序的生命周期\napp: onLunch/onShow/onHide\npage: onLoad/onShow/onReady/onHide/onUnload\ncomponent: created/attached/ready/moved/detached/error show/hide/resize\n```html\n执行顺序:\n->app(onlaunch)\n->app(onshow) \n->component(created)\n->component(attached)\n->page(onload)\n->page(onshow)\n->component(ready)\n->page(onready)\n```\n\n#### 小程序的数据通信\n渲染层与逻辑层：逻辑层到渲染层通信使用setData、渲染层想逻辑层使用事件bindTap/catchTap\n父子组件之间：props数据绑定、事件triggerEvent、observers\n兄弟组件之间：通过父组件中转、全局数据、relations\n\n#### 小程序登录\n1.登录机制\n小程序本身没有cookie机制，所有的数据都存储在storage里面，所以传统的cookie登录方式如果直接用在小程序是行不通的\n简单的办法就是使用第三方库[weap-cookie](https://github.com/charleslo1/weapp-cookie)来做兼容\n此库的原理就是在底层自动代理wx.request接口的访问，为请求预先做好cookie的存取。\n2.小程序做微信自动登录\n小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。\n登录过程分为三步：\n1）调用wx.login()获取微信登录凭据code，并将其传给开发者自己的服务端。\n2）后端服务用前台传过来的code调用微信的后台接口，换取session和openid等信息存储在开发者的服务器\n3）后端服务以session和openid为关联基础生成自己的session登录态，返回前端\n4）前端拿到session登录凭证，登录成功（后续只需要通过session即可判断是否登录了）\n\n#### 小程序性能优化\n1.控制setData频率、数据量\n2.控制wxml节点数、节点深度\n3.接口数据、图片数据缓存\n4.减少包的体量、做必要的分包下载\n5.参考小程序后台评分、开发者工具Audits性能评估做相应优化\n\n\n### 传送门\n微信小程序技术原理分析\nhttps://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html\n\n小程序性能优化\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/performance/\n\n小程序生命周期执行顺序\nhttps://developers.weixin.qq.com/community/develop/article/doc/000002e9b647c833cab9ef81f51c13\n\n小程序自动微信登录\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html","slug":"xcx2","published":1,"updated":"2021-03-30T01:32:00.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ugg0021a0vz4kbk4iv0","content":"<h4 id=\"微信小程序渲染特点\"><a href=\"#微信小程序渲染特点\" class=\"headerlink\" title=\"微信小程序渲染特点\"></a>微信小程序渲染特点</h4><p>1.小程序运行在app中的，区别于H5运行在浏览器中，小程序的运行环境是基于浏览器内核重构的内置解析器，没有BOM和DOM API<br>2.小程序的渲染区别于H5的渲染线程和脚本线程互斥，小程序采用双线程模型，渲染层运行在Webview中，逻辑层运行在JSCore中，两个线程通过jsBridage进行中转通信。wxml、wxss 运行在渲染层，js 运行在逻辑层<br>3.一个小程序一个界面对应一个渲染线程，所以有多个webview线程，webview的渲染是通过js绘制的虚拟DOM为基础渲染的。<br>4.只有一个逻辑线程，逻辑层发送网络请求由native转发</p>\n<h4 id=\"为什么小程序会采用双线程模型\"><a href=\"#为什么小程序会采用双线程模型\" class=\"headerlink\" title=\"为什么小程序会采用双线程模型\"></a>为什么小程序会采用双线程模型</h4><p>1、H5中，html js和渲染是互斥的，不可用同步进行，为了不让逻辑层阻塞渲染层渲染。<br>2.防止开发者随意操作DOM，保护只想给用户查看的这一类隐私数据，保证用户数据安全<br>3.限制API的调用(如跳转功能)把js执行的逻辑层放入沙盒，一个纯js的执行环境，然后单独开一个渲染线程来做页面的渲染。<br>4.逻辑层的数据给渲染层的时候可以做数据过滤，防止xss</p>\n<h4 id=\"小程序的生命周期\"><a href=\"#小程序的生命周期\" class=\"headerlink\" title=\"小程序的生命周期\"></a>小程序的生命周期</h4><p>app: onLunch/onShow/onHide<br>page: onLoad/onShow/onReady/onHide/onUnload<br>component: created/attached/ready/moved/detached/error show/hide/resize<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行顺序:</span><br><span class=\"line\">-&gt;app(onlaunch)</span><br><span class=\"line\">-&gt;app(onshow) </span><br><span class=\"line\">-&gt;component(created)</span><br><span class=\"line\">-&gt;component(attached)</span><br><span class=\"line\">-&gt;page(onload)</span><br><span class=\"line\">-&gt;page(onshow)</span><br><span class=\"line\">-&gt;component(ready)</span><br><span class=\"line\">-&gt;page(onready)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"小程序的数据通信\"><a href=\"#小程序的数据通信\" class=\"headerlink\" title=\"小程序的数据通信\"></a>小程序的数据通信</h4><p>渲染层与逻辑层：逻辑层到渲染层通信使用setData、渲染层想逻辑层使用事件bindTap/catchTap<br>父子组件之间：props数据绑定、事件triggerEvent、observers<br>兄弟组件之间：通过父组件中转、全局数据、relations</p>\n<h4 id=\"小程序登录\"><a href=\"#小程序登录\" class=\"headerlink\" title=\"小程序登录\"></a>小程序登录</h4><p>1.登录机制<br>小程序本身没有cookie机制，所有的数据都存储在storage里面，所以传统的cookie登录方式如果直接用在小程序是行不通的<br>简单的办法就是使用第三方库<a href=\"https://github.com/charleslo1/weapp-cookie\">weap-cookie</a>来做兼容<br>此库的原理就是在底层自动代理wx.request接口的访问，为请求预先做好cookie的存取。<br>2.小程序做微信自动登录<br>小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。<br>登录过程分为三步：<br>1）调用wx.login()获取微信登录凭据code，并将其传给开发者自己的服务端。<br>2）后端服务用前台传过来的code调用微信的后台接口，换取session和openid等信息存储在开发者的服务器<br>3）后端服务以session和openid为关联基础生成自己的session登录态，返回前端<br>4）前端拿到session登录凭证，登录成功（后续只需要通过session即可判断是否登录了）</p>\n<h4 id=\"小程序性能优化\"><a href=\"#小程序性能优化\" class=\"headerlink\" title=\"小程序性能优化\"></a>小程序性能优化</h4><p>1.控制setData频率、数据量<br>2.控制wxml节点数、节点深度<br>3.接口数据、图片数据缓存<br>4.减少包的体量、做必要的分包下载<br>5.参考小程序后台评分、开发者工具Audits性能评估做相应优化</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>微信小程序技术原理分析<br><a href=\"https://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html\">https://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html</a></p>\n<p>小程序性能优化<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/performance/\">https://developers.weixin.qq.com/miniprogram/dev/framework/performance/</a></p>\n<p>小程序生命周期执行顺序<br><a href=\"https://developers.weixin.qq.com/community/develop/article/doc/000002e9b647c833cab9ef81f51c13\">https://developers.weixin.qq.com/community/develop/article/doc/000002e9b647c833cab9ef81f51c13</a></p>\n<p>小程序自动微信登录<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html\">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"微信小程序渲染特点\"><a href=\"#微信小程序渲染特点\" class=\"headerlink\" title=\"微信小程序渲染特点\"></a>微信小程序渲染特点</h4><p>1.小程序运行在app中的，区别于H5运行在浏览器中，小程序的运行环境是基于浏览器内核重构的内置解析器，没有BOM和DOM API<br>2.小程序的渲染区别于H5的渲染线程和脚本线程互斥，小程序采用双线程模型，渲染层运行在Webview中，逻辑层运行在JSCore中，两个线程通过jsBridage进行中转通信。wxml、wxss 运行在渲染层，js 运行在逻辑层<br>3.一个小程序一个界面对应一个渲染线程，所以有多个webview线程，webview的渲染是通过js绘制的虚拟DOM为基础渲染的。<br>4.只有一个逻辑线程，逻辑层发送网络请求由native转发</p>\n<h4 id=\"为什么小程序会采用双线程模型\"><a href=\"#为什么小程序会采用双线程模型\" class=\"headerlink\" title=\"为什么小程序会采用双线程模型\"></a>为什么小程序会采用双线程模型</h4><p>1、H5中，html js和渲染是互斥的，不可用同步进行，为了不让逻辑层阻塞渲染层渲染。<br>2.防止开发者随意操作DOM，保护只想给用户查看的这一类隐私数据，保证用户数据安全<br>3.限制API的调用(如跳转功能)把js执行的逻辑层放入沙盒，一个纯js的执行环境，然后单独开一个渲染线程来做页面的渲染。<br>4.逻辑层的数据给渲染层的时候可以做数据过滤，防止xss</p>\n<h4 id=\"小程序的生命周期\"><a href=\"#小程序的生命周期\" class=\"headerlink\" title=\"小程序的生命周期\"></a>小程序的生命周期</h4><p>app: onLunch/onShow/onHide<br>page: onLoad/onShow/onReady/onHide/onUnload<br>component: created/attached/ready/moved/detached/error show/hide/resize<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行顺序:</span><br><span class=\"line\">-&gt;app(onlaunch)</span><br><span class=\"line\">-&gt;app(onshow) </span><br><span class=\"line\">-&gt;component(created)</span><br><span class=\"line\">-&gt;component(attached)</span><br><span class=\"line\">-&gt;page(onload)</span><br><span class=\"line\">-&gt;page(onshow)</span><br><span class=\"line\">-&gt;component(ready)</span><br><span class=\"line\">-&gt;page(onready)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"小程序的数据通信\"><a href=\"#小程序的数据通信\" class=\"headerlink\" title=\"小程序的数据通信\"></a>小程序的数据通信</h4><p>渲染层与逻辑层：逻辑层到渲染层通信使用setData、渲染层想逻辑层使用事件bindTap/catchTap<br>父子组件之间：props数据绑定、事件triggerEvent、observers<br>兄弟组件之间：通过父组件中转、全局数据、relations</p>\n<h4 id=\"小程序登录\"><a href=\"#小程序登录\" class=\"headerlink\" title=\"小程序登录\"></a>小程序登录</h4><p>1.登录机制<br>小程序本身没有cookie机制，所有的数据都存储在storage里面，所以传统的cookie登录方式如果直接用在小程序是行不通的<br>简单的办法就是使用第三方库<a href=\"https://github.com/charleslo1/weapp-cookie\">weap-cookie</a>来做兼容<br>此库的原理就是在底层自动代理wx.request接口的访问，为请求预先做好cookie的存取。<br>2.小程序做微信自动登录<br>小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。<br>登录过程分为三步：<br>1）调用wx.login()获取微信登录凭据code，并将其传给开发者自己的服务端。<br>2）后端服务用前台传过来的code调用微信的后台接口，换取session和openid等信息存储在开发者的服务器<br>3）后端服务以session和openid为关联基础生成自己的session登录态，返回前端<br>4）前端拿到session登录凭证，登录成功（后续只需要通过session即可判断是否登录了）</p>\n<h4 id=\"小程序性能优化\"><a href=\"#小程序性能优化\" class=\"headerlink\" title=\"小程序性能优化\"></a>小程序性能优化</h4><p>1.控制setData频率、数据量<br>2.控制wxml节点数、节点深度<br>3.接口数据、图片数据缓存<br>4.减少包的体量、做必要的分包下载<br>5.参考小程序后台评分、开发者工具Audits性能评估做相应优化</p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p>微信小程序技术原理分析<br><a href=\"https://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html\">https://zhaomenghuan.js.org/blog/wechat-miniprogram-principle-analysis.html</a></p>\n<p>小程序性能优化<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/performance/\">https://developers.weixin.qq.com/miniprogram/dev/framework/performance/</a></p>\n<p>小程序生命周期执行顺序<br><a href=\"https://developers.weixin.qq.com/community/develop/article/doc/000002e9b647c833cab9ef81f51c13\">https://developers.weixin.qq.com/community/develop/article/doc/000002e9b647c833cab9ef81f51c13</a></p>\n<p>小程序自动微信登录<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html\">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html</a></p>\n"},{"title":"Web安全","date":"2018-11-22T16:00:00.000Z","_content":"\n### 1.XSS（Cross-site Script）简介\n跨站脚本攻击，Cross-site Script，简称 XSS（因CSS与样式脚本命名一样）。\n是一种代码注入攻击。攻击者想尽一切办法，在网站上注入恶意脚本，使之在用户的浏览器上运行，当用户访问该网站的时候浏览器执行该脚本\n攻击者可通过恶意脚本的执行窃取用户的Session、Cookie等敏感信息，进而危害数据安全。\n\n### XSS 类型：\n1、持久型XSS（存储型XSS）\n持久型 XSS 一般是通过 form 表单提交带有恶意脚本的数据到服务端，服务端未经过滤，直接保存到数据库。\n然后直接拿到数据库的数据返回给前端，前端未能过滤，直接展示服务端提供的带有恶意脚本的数据。\n\n2、非持久型XSS（反射型XSS）\n非持久型 XSS 一般是通过给别人发送带恶意脚本代码参数的 url 来达到攻击目的。\n前端取得url参数直接传给服务端，服务端未经过滤，直接返回带有恶意代码的字符串。\n\n3、DOM型XSS\n攻击者构造出特殊的url，包含恶意代码，前端直接取出url中带恶意代码的字符串，并在前端执行\n\n### XSS 防护 \n1、不轻易将不可信代码嵌入html、script、location、redirect-to、a-href、background-url、img-src、form-src 等中\n尽量避免对以下信息直接取用，如果必须要用，需要经过严格检测或者转义处理之后再小心使用。\n1）不信任来自用户的 UGC 信息\n2）不信任来自第三方的链接，不能直接打开或者执行 redirectTo\n3）不信任 URL 参数，不能直接取url参数插入Dom或者当做脚本执行\n4）不信任 不明来源的Referer信息、来自其它子域的 Cookie信息等，不能直接插入脚本或者直接当做脚本执行\n\n常用转义字符：\n```html\n< &lt;\n> &gt;\n& &amp;\n\" &quot;\n' &#x27;\n/ &#x2f;\n```\n2、敏感的Cookie、Session信息设置HttpOnly。禁止Javascript读取敏感cookie信息。\n3、设置CSP的安全策略\n1）通过meta标签设置 \n```html\n<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; img-src https://*; child-src 'none';\">\n```\n2) 通过Http响应头 Content-Security-Policy（当前域、子域、资源域、报告地址）\n```javascript\nContent-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com\nContent-Security-Policy: default-src https://onlinebanking.jumbobank.com\nContent-Security-Policy: default-src 'self' *.mailsite.com; img-src *\nContent-Security-Policy-Report-Only: policy\nContent-Security-Policy: default-src 'self'; report-uri http://reportcollector.example.com/collector.cgi\n```\n\n\n### 传送门\nhttps://juejin.cn/post/6898124066063024136\ncsp\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP\n","source":"_posts/xss.md","raw":"---\ntitle: Web安全\ntag: [js, xss, web安全]\ndate: 2018/11/23\ncategory: 技术\n---\n\n### 1.XSS（Cross-site Script）简介\n跨站脚本攻击，Cross-site Script，简称 XSS（因CSS与样式脚本命名一样）。\n是一种代码注入攻击。攻击者想尽一切办法，在网站上注入恶意脚本，使之在用户的浏览器上运行，当用户访问该网站的时候浏览器执行该脚本\n攻击者可通过恶意脚本的执行窃取用户的Session、Cookie等敏感信息，进而危害数据安全。\n\n### XSS 类型：\n1、持久型XSS（存储型XSS）\n持久型 XSS 一般是通过 form 表单提交带有恶意脚本的数据到服务端，服务端未经过滤，直接保存到数据库。\n然后直接拿到数据库的数据返回给前端，前端未能过滤，直接展示服务端提供的带有恶意脚本的数据。\n\n2、非持久型XSS（反射型XSS）\n非持久型 XSS 一般是通过给别人发送带恶意脚本代码参数的 url 来达到攻击目的。\n前端取得url参数直接传给服务端，服务端未经过滤，直接返回带有恶意代码的字符串。\n\n3、DOM型XSS\n攻击者构造出特殊的url，包含恶意代码，前端直接取出url中带恶意代码的字符串，并在前端执行\n\n### XSS 防护 \n1、不轻易将不可信代码嵌入html、script、location、redirect-to、a-href、background-url、img-src、form-src 等中\n尽量避免对以下信息直接取用，如果必须要用，需要经过严格检测或者转义处理之后再小心使用。\n1）不信任来自用户的 UGC 信息\n2）不信任来自第三方的链接，不能直接打开或者执行 redirectTo\n3）不信任 URL 参数，不能直接取url参数插入Dom或者当做脚本执行\n4）不信任 不明来源的Referer信息、来自其它子域的 Cookie信息等，不能直接插入脚本或者直接当做脚本执行\n\n常用转义字符：\n```html\n< &lt;\n> &gt;\n& &amp;\n\" &quot;\n' &#x27;\n/ &#x2f;\n```\n2、敏感的Cookie、Session信息设置HttpOnly。禁止Javascript读取敏感cookie信息。\n3、设置CSP的安全策略\n1）通过meta标签设置 \n```html\n<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; img-src https://*; child-src 'none';\">\n```\n2) 通过Http响应头 Content-Security-Policy（当前域、子域、资源域、报告地址）\n```javascript\nContent-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com\nContent-Security-Policy: default-src https://onlinebanking.jumbobank.com\nContent-Security-Policy: default-src 'self' *.mailsite.com; img-src *\nContent-Security-Policy-Report-Only: policy\nContent-Security-Policy: default-src 'self'; report-uri http://reportcollector.example.com/collector.cgi\n```\n\n\n### 传送门\nhttps://juejin.cn/post/6898124066063024136\ncsp\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP\n","slug":"xss","published":1,"updated":"2021-03-30T01:32:00.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7ugh0022a0vzb1fc1ri2","content":"<h3 id=\"1-XSS（Cross-site-Script）简介\"><a href=\"#1-XSS（Cross-site-Script）简介\" class=\"headerlink\" title=\"1.XSS（Cross-site Script）简介\"></a>1.XSS（Cross-site Script）简介</h3><p>跨站脚本攻击，Cross-site Script，简称 XSS（因CSS与样式脚本命名一样）。<br>是一种代码注入攻击。攻击者想尽一切办法，在网站上注入恶意脚本，使之在用户的浏览器上运行，当用户访问该网站的时候浏览器执行该脚本<br>攻击者可通过恶意脚本的执行窃取用户的Session、Cookie等敏感信息，进而危害数据安全。</p>\n<h3 id=\"XSS-类型：\"><a href=\"#XSS-类型：\" class=\"headerlink\" title=\"XSS 类型：\"></a>XSS 类型：</h3><p>1、持久型XSS（存储型XSS）<br>持久型 XSS 一般是通过 form 表单提交带有恶意脚本的数据到服务端，服务端未经过滤，直接保存到数据库。<br>然后直接拿到数据库的数据返回给前端，前端未能过滤，直接展示服务端提供的带有恶意脚本的数据。</p>\n<p>2、非持久型XSS（反射型XSS）<br>非持久型 XSS 一般是通过给别人发送带恶意脚本代码参数的 url 来达到攻击目的。<br>前端取得url参数直接传给服务端，服务端未经过滤，直接返回带有恶意代码的字符串。</p>\n<p>3、DOM型XSS<br>攻击者构造出特殊的url，包含恶意代码，前端直接取出url中带恶意代码的字符串，并在前端执行</p>\n<h3 id=\"XSS-防护\"><a href=\"#XSS-防护\" class=\"headerlink\" title=\"XSS 防护\"></a>XSS 防护</h3><p>1、不轻易将不可信代码嵌入html、script、location、redirect-to、a-href、background-url、img-src、form-src 等中<br>尽量避免对以下信息直接取用，如果必须要用，需要经过严格检测或者转义处理之后再小心使用。<br>1）不信任来自用户的 UGC 信息<br>2）不信任来自第三方的链接，不能直接打开或者执行 redirectTo<br>3）不信任 URL 参数，不能直接取url参数插入Dom或者当做脚本执行<br>4）不信任 不明来源的Referer信息、来自其它子域的 Cookie信息等，不能直接插入脚本或者直接当做脚本执行</p>\n<p>常用转义字符：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt; &amp;<span class=\"attr\">lt</span>;</span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span> <span class=\"symbol\">&amp;gt;</span></span><br><span class=\"line\">&amp; <span class=\"symbol\">&amp;amp;</span></span><br><span class=\"line\">&quot; <span class=\"symbol\">&amp;quot;</span></span><br><span class=\"line\">&#x27; <span class=\"symbol\">&amp;#x27;</span></span><br><span class=\"line\">/ <span class=\"symbol\">&amp;#x2f;</span></span><br></pre></td></tr></table></figure><br>2、敏感的Cookie、Session信息设置HttpOnly。禁止Javascript读取敏感cookie信息。<br>3、设置CSP的安全策略<br>1）通过meta标签设置<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;Content-Security-Policy&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>2) 通过Http响应头 Content-Security-Policy（当前域、子域、资源域、报告地址）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Security-Policy: <span class=\"keyword\">default</span>-src <span class=\"string\">&#x27;self&#x27;</span>; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</span><br><span class=\"line\">Content-Security-Policy: <span class=\"keyword\">default</span>-src https:<span class=\"comment\">//onlinebanking.jumbobank.com</span></span><br><span class=\"line\">Content-Security-Policy: <span class=\"keyword\">default</span>-src <span class=\"string\">&#x27;self&#x27;</span> *.mailsite.com; img-src *</span><br><span class=\"line\">Content-Security-Policy-Report-Only: policy</span><br><span class=\"line\">Content-Security-Policy: <span class=\"keyword\">default</span>-src <span class=\"string\">&#x27;self&#x27;</span>; report-uri http:<span class=\"comment\">//reportcollector.example.com/collector.cgi</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://juejin.cn/post/6898124066063024136\">https://juejin.cn/post/6898124066063024136</a><br>csp<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-XSS（Cross-site-Script）简介\"><a href=\"#1-XSS（Cross-site-Script）简介\" class=\"headerlink\" title=\"1.XSS（Cross-site Script）简介\"></a>1.XSS（Cross-site Script）简介</h3><p>跨站脚本攻击，Cross-site Script，简称 XSS（因CSS与样式脚本命名一样）。<br>是一种代码注入攻击。攻击者想尽一切办法，在网站上注入恶意脚本，使之在用户的浏览器上运行，当用户访问该网站的时候浏览器执行该脚本<br>攻击者可通过恶意脚本的执行窃取用户的Session、Cookie等敏感信息，进而危害数据安全。</p>\n<h3 id=\"XSS-类型：\"><a href=\"#XSS-类型：\" class=\"headerlink\" title=\"XSS 类型：\"></a>XSS 类型：</h3><p>1、持久型XSS（存储型XSS）<br>持久型 XSS 一般是通过 form 表单提交带有恶意脚本的数据到服务端，服务端未经过滤，直接保存到数据库。<br>然后直接拿到数据库的数据返回给前端，前端未能过滤，直接展示服务端提供的带有恶意脚本的数据。</p>\n<p>2、非持久型XSS（反射型XSS）<br>非持久型 XSS 一般是通过给别人发送带恶意脚本代码参数的 url 来达到攻击目的。<br>前端取得url参数直接传给服务端，服务端未经过滤，直接返回带有恶意代码的字符串。</p>\n<p>3、DOM型XSS<br>攻击者构造出特殊的url，包含恶意代码，前端直接取出url中带恶意代码的字符串，并在前端执行</p>\n<h3 id=\"XSS-防护\"><a href=\"#XSS-防护\" class=\"headerlink\" title=\"XSS 防护\"></a>XSS 防护</h3><p>1、不轻易将不可信代码嵌入html、script、location、redirect-to、a-href、background-url、img-src、form-src 等中<br>尽量避免对以下信息直接取用，如果必须要用，需要经过严格检测或者转义处理之后再小心使用。<br>1）不信任来自用户的 UGC 信息<br>2）不信任来自第三方的链接，不能直接打开或者执行 redirectTo<br>3）不信任 URL 参数，不能直接取url参数插入Dom或者当做脚本执行<br>4）不信任 不明来源的Referer信息、来自其它子域的 Cookie信息等，不能直接插入脚本或者直接当做脚本执行</p>\n<p>常用转义字符：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt; &amp;<span class=\"attr\">lt</span>;</span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span> <span class=\"symbol\">&amp;gt;</span></span><br><span class=\"line\">&amp; <span class=\"symbol\">&amp;amp;</span></span><br><span class=\"line\">&quot; <span class=\"symbol\">&amp;quot;</span></span><br><span class=\"line\">&#x27; <span class=\"symbol\">&amp;#x27;</span></span><br><span class=\"line\">/ <span class=\"symbol\">&amp;#x2f;</span></span><br></pre></td></tr></table></figure><br>2、敏感的Cookie、Session信息设置HttpOnly。禁止Javascript读取敏感cookie信息。<br>3、设置CSP的安全策略<br>1）通过meta标签设置<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;Content-Security-Policy&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>2) 通过Http响应头 Content-Security-Policy（当前域、子域、资源域、报告地址）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Security-Policy: <span class=\"keyword\">default</span>-src <span class=\"string\">&#x27;self&#x27;</span>; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</span><br><span class=\"line\">Content-Security-Policy: <span class=\"keyword\">default</span>-src https:<span class=\"comment\">//onlinebanking.jumbobank.com</span></span><br><span class=\"line\">Content-Security-Policy: <span class=\"keyword\">default</span>-src <span class=\"string\">&#x27;self&#x27;</span> *.mailsite.com; img-src *</span><br><span class=\"line\">Content-Security-Policy-Report-Only: policy</span><br><span class=\"line\">Content-Security-Policy: <span class=\"keyword\">default</span>-src <span class=\"string\">&#x27;self&#x27;</span>; report-uri http:<span class=\"comment\">//reportcollector.example.com/collector.cgi</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h3><p><a href=\"https://juejin.cn/post/6898124066063024136\">https://juejin.cn/post/6898124066063024136</a><br>csp<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP</a></p>\n"},{"title":"小程序开发经验(一)","date":"2019-01-07T16:00:00.000Z","_content":"\n小程序开发对于前端开发者来说其实很简单，稍微看一下官方文档就能够上手了。\n但是，如果是第一次开发小程序，多多少少还是还是会遇到一些坑的。\n最近恰好开发了一个正式版本的小程序，下面是开发过程中的一些总结以及遇到了一些问题。\n\nps: 适合有一定前端基础的、首先大致看过小程序官方文档的同学观看。\n\n### 小程序开发前期准备\n开发小程序，首先得申请账号：\n小程序账号类型分为个人账号和企业账号，“企业账号”相对于“个人账号”拥有更多的功能。\n\n账号申请成功之后就得申请并分配权限了：\n小程序后台有各种权限，开发者权限(登录、体验、开发设置)、体验者权限、运营者权限、master。\n可以预先给开发、测试、产品、UI等同学开相应的权限，以便后期测试、预览、体验。\n申请权限地址： http://kf.qq.com/faq/170302zeQryI170302beuEVn.html\n\n\n### 开发阶段\n有了权限之后，就可以新建项目了，过程中需要配置appid、域名等。\n\n**APPID 配置：**在小程序后台获取到 appid，并配置在项目中，（ appid 就是小程序的身份证明，唯一固定的），就是根据这个来判断小程序是个人账号还是企业账号的。\n\n**域名配置：**开发环境配置 - 服务器域名配置：request、socket、uploadFile、downloadFile\n小程序不支持 javascript 原生的 ajax 请求，需要使用其内置的请求接口，不同的功能需要使用不同的接口。\n要想在生产环境中使用这些接口，需要预先在小程序后台配置其域名。\n\n**开发环境配置 - 业务域名配置：**\n小程序提供 webview 打开 h5 页面，统一需要预先在后台配置业务域名。\n且该域名需要进行校验，其中一个校验方法就是下载其校验文件，将其配置在该域名的服务下面\n\n如：域名：www.example.com  校验文件：abcAbc.txt\n只需要能够保证 www.example.com/abcAbc.txt 能够正常拿到 abcAbc.txt 的文件内容即可。\n\n\n**mock 数据：**\n前后端分离开发，本地 mock 数据是不可缺少的\n同 h5 开发一样，我们可以本地启动一个 mock 服务，提供 mock 数据接口，如：127.0.0.1:8587/test1\n可以使用 https://github.com/zhoushirong/static-mock 一键启动本地 mock 服务\n\n启动服务之后，需要在开发者工具中将域名合法校验等关闭，不然会出现请求不通的情况：\n工具 —— 项目详情 —— 项目设置 —— 不校验合法域名、web-view 域名...\n\n**注意：**\n连代理在真机上调试的时候需要开启调试模式。（打开小程序 — 点击微信右上角'...' — 打开调试模式）\n苹果开发 https 访问的时候，证书需要通过苹果 ATS 认证，不然访问不了，这意味着，自己做的证书不能用。\n测试阶段建议使用 http，不要使用 https\n\n后端接口上线之后，可以开启https请求，并将域名校验重新打开。\n打开之后如果还是会出现请求不通的情况，可以通过下面的命令进行检测。\n如：\n```shell\n# 下面命令是用来检测域名是否通过 ATS 认证的\n# 仅适用于 MAC OS 系统。\nnscurl --ats-diagnostics --verbose https://www.epoos.com\n```\n\n\n##### 小程序路由\n小程序路由可以通过如下方法进行跳转\n```html\nwx.navigateBack：返回\nwx.switchTab：切换 tab\nwx.navigateTo：跳转、保留原页面\nwx.redirectTo：跳转、不保留原页面\nwx.reLaunch：关闭当前页，重新打开网页（重要：不能返回）\n```\n\n**注意：**\n在小程序中使用中我们会经常用到很多跳转，是不希望用户能够返回上一个页面的\n如登录，登录成功之后就不能允许用户通过返回回到登录页面了。\n之前在网上看到有人说通过 wx.redirectTo 打开能够阻止用户返回上一个页面，经测试发现不行。\n此时，需要使用 wx.reLaunch，通过这种方式打开的小程序页面左上角就没有返回图标了。\n\n\n##### 小程序登录\n1）登录过程\n获取 code —— 换取 token —— 生成 cookie —— 存储 cookie\n查看官方的登录文档即可。\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html\n\n\n2）登录态控制\n对于登录态，一般情况下我们都是通过记录 cookie 来实现的。\n但是，微信原生的 wx.request 不支持传统的 Cookie 读写，所以登录成功之后后端接口 response 写的 cookie 就不会成功。\n原来我们的解决方案是将 cookie 信息通过请求内容来传输。\n\n好在，现在社区还是有一些大侠做了一些基础设施。\n我们可以使用 weapp-cookie 这个库来实现传统 cookie 的功能\n它号称一句代码实现浏览器的 cookie 功能，当然，经实践，确实挺好用。\n它将自动代理 wx.request 接口的访问，通过模拟的方式将cookie 存在 storage 来实现传统 cookie 的功能\n使用凡是，可以查看其 github 文档\nhttps://github.com/charleslo1/weapp-cookie\n\n**注意：**\n1.小程序原生支持 npm node_module 直接引入，但是，此组件通过 require 直接使用 node_module 中的组件之后，代码混淆之后会出现引入不成功的问题。因此，还是需要安装此组件官方推荐的方式，将其拷贝到其它目录下，然后再引入。\n\n2.此组件只代理了 wx.request，并未代理 wx.uploadFile 等其它接口\n因此，在 wx.uploadFile 调用的时候如果后端接口有校验用户身份，需要手动将 cookie 写入 header 中。\n```javascript\nlet cookie = app.cookies.get('XXX_SESSION_KEY')\nlet uploadTask = wx.uploadFile({\n  url: url,\n  filePath: self.tempFilePaths,\n  header: {\n    'Cookie': `XXX_SESSION_KEY=${cookie}` // 手动添加 cookie\n  },\n  name: 'file',\n  success (res) {\n  }\n})\n```\n\n##### 小程序兼容性\n小程序在开发之前就应该确定好兼容的范围，然后根据此范围，在开发的时候来确定哪些 api 是否可用。\n如：基础库\n基础库决定了小程序支持哪些功能，不同的微信版本都有着对应的基础库版本，开发之前需要与产品人员商议、做好功能与用户体验的平衡，最低兼容到哪个微信版本。\n关于基础库官方文档：\nhttps://developers.weixin.qq.com/minigame/dev/framework/client-lib/\n\nES6 兼容情况：\n小程序支持 ES6 很多常用的预发，但是并不是所有的都支持，具体可参考文档\n关于 ES6 官方文档：\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/details.html\n\nCSS3 兼容情况：\n小程序不直接使用 css3，而是 wxss ，不过 css3 常用的动画、flex 布局都能够支持。\n若是需要兼容低版本的手机系统，则需要开启 ES6 转 ES5;\n上传代码时，样式自动补全（工具 - 项目详情 - 项目设置）\n\n\n\n##### 小程序更新\n小程序启动分为热启动、冷启动，冷启动的时候会触发小程序更新\n除了微信冷启动自动更新之外，我们也可以自动检测小程序的更新 updateManager\n在开发过程中，可以通过微信开发者工具，配置’编译‘模式，触发小程序模拟更新。\n如无特殊要求，小程序自己的冷启动更新机制就能够满足更新要求了。\n具体可查看官方文档：\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/operating-mechanism.html\n\n\n##### 小程序性能与优化\n大小限制与分包下载：小程序原先限制了包大小为 1M，后面改为了 2M，这个在开发者工具 —— 项目详情 可以看得到。\n小程序太大一般原因是因为图片太多，可以尽可能的减少图片的使用，然后对图片进行压缩。\n如果真的必须要超过 2M，可以使用分包加载。分包加载不得超过 8M。\n为了能够更快的下载小程序，小程序的包还是越小越好。\n\n性能：\n\n1.打开性能窗口可以看到小程序的性能参数，开发版本能看到更多的信息。\n体验版本和线上版本可以先通过开发打开调试，然后在打开体验版本和线上版本，能看到部分信息。\n\n2.页面栈不要超过 5 层限制，超过之后会导致打不开页面，解决办法，可以使用 wx.redirect 或者 wx.reLaunch\n\n3.网络状态小程序还是很重要的，可以通过获取网络状态来优化小程序的一些操作。\n```javascript\n// 可以根据不同的网络做相应的事情\nwx.getNetworkType({\n  success: function(res) {\n    // networkType字段的有效值：\n    // wifi/2g/3g/4g/unknown(Android下不常见的网络类型)/none(无网络)\n    if (res.networkType == 'wifi') {}\n  }\n})\n```\n\n4.另外，小程序开发者工具还有一个体验评分功能。\n使用方式为：控制台 —— Audits（和 console、network 在同一排）\n开启之后录制即可，一试便知。\n\n5).小程序数据上报与监控\n小程序自己本身后台有做很多数据的统计\n除此之外还可以自己上报一些 自定义数据，自定义数据 value 为 number 类型，不得超过 128 个。\n如果还不能满足，则可以自己做埋点，然后通过 wx.request 接口做数据上报。\n官方文档：\nhttps://developers.weixin.qq.com/miniprogram/dev/api/wx.reportMonitor.html\n\n\n\n##### 小程序二维码与分享\n小程序生成二维码，生成分享链接是必不可少的功能。\n我们可以在小程序二维码生成需要小程序上线之后，通过后端接口请求小程序的接口来生成分享的二维码。\n官方文档：\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html\n\n小程序的分享只能针对页面做配置，不能全局配置，详情可以查阅官方文档。\n\n小程序模板与数据双向绑定（待续）\n\n\n### 测试阶段\n开发提测之后，我们需要给测试人员测试，有两种方式提测，各有优劣。\n测试方法一：在开发者工具将小程序上传 — 在后台将上传的小程序设为体验版 — 测试人员用体验版进行测试\n测试方法二：给测试人员开启开发者权限，开启代码权限，让他们自己拉代码，自己发布体验版进行测试。\n\n**注意：**\n未发布之前，自签证书 ios 可能会验证会通不过，https 接口调不通，因此、开发测试阶段使用 http 进行测试。\n真机测试需开启调试模式。\n测试阶段开发者工具需要设置不校验 https 证书\n\n\n\n### 踩坑指南\n以上是开发过程中的个人觉得比较不容易发觉但是又绕不过去的一些情形。\n下面是开发过程中遇到的一些坑，稍微了解一下有助于走的更顺畅。\n\n1.开发环境请求不通\n原因：\n1.自签证书 https 不通 \n2.真机上未开启调试模式。\n解决办法：\n```html\n开发者工具设置不检验合法域名\n真机开启调试模式\n```\n\n2.线上(预发)环境 https 不通\n场景：\n预发环境 https 接口不通，真机，微信小程序体验版 ios 调接口不通，android 可以调通；\n后验证相同域名下 H5 页面，发现 ios safari 不通、微信扫一扫打开 不通。\n线上正常。\n检测：\n```shell\nnscurl --ats-diagnostics --verbose https://xxx.xxx.xxx # 苹果电脑上 ATS 检测\n```\n结果：\n检测之后发现预发环境的 ATS 测试通不过\n线上检测能通过。\n\n解决：\n```html\n检查并修改预发环境的 nginx 与证书配置，使之能够通过 ATS 检测\n```\n\n3.textarea ios 真机有默认内边距，导致对不齐，android 正常\n原因：\n搜了一下，别人也遇到过类似情况，微信官方未给出解决方案。\n解决：\n获取系统信息，根据系统型号对 ios 设置 class，针对 class 做样式特殊处理。\n```javascript\nlet isIos = /ios/i.test(app.system.system)\nif (isIos) {\n  this.setData({\n    isIos: true\n  })\n}\n```\n```html\n<view class=\"c-textarea-box {{isIos ? 'c-textarea-box-ios' : ''}}\">\n\t<textarea></textarea>\n</view>\n```\n```css\n.c-textarea-box-ios {\n  padding-top: 16rpx;\n  margin-left: -8rpx;\n}\n```\n\n\n4.分别设置 loading 和 toast 蒙层的 mask 为 true 和 false\n两个分别调用之后会导致蒙层属性干扰，蒙层不可穿透功能失效\n```javascript\nwx.showLoading({\n  title: 'loading...',\n  mask: true\n})\nwx.showToast({\n  title: 'toast...',\n  mask: false\n})\n```\n解决办法：两个都设置为 true。\n\n\n5.文件上传的时候后端获取不到用户登录态 cookie\n原因：weapp-cookie 组件只代理了 wx.request，并未代理 wx.uploadFile 等其它接口。\n解决办法：在 wx.uploadFile 调用的时候如果后端接口有校验用户身份，需要手动将 cookie 写入 header 中。\n\n\n\n6.获取手机号码失败\n用户注册之前获取手机号码密文，然后拿到服务端解密，会出现偶现的解密失败的情况\n原因：获取微信登录 code 不能放在获取手机密文的回调里面\n解决办法：预先获取微信登录 code\n\n\n7.微信获取的用户头像是方形的\n```html\n<open-data class=\"user-logo\" type=\"userAvatarUrl\"></open-data>\n```\n通过上述方法获取到的用户头像是方形的，如果要展示圆形头像，直接通过 user-logo class 设置样式无效\n解决办法：加一层父标签，然后对父标签设置绝对定位、并且设置 border-radius，设置 overflow: hidden;\n```html\n<view class=\"fbox\">\n  <open-data class=\"user-logo\" type=\"userAvatarUrl\"></open-data>\n</view>\n```\n\n8.button disabled 样式不生效\n解决办法：重写 disabled 样式加上 ! important 属性\n\n9.checkbox 样式修改不了\n解决办法：不知道哪来的黑科技，使用如下选择器即可\n```css\ncheckbox {\n vertical-align: top;\n}\n/* 未选中的 背景样式 */\ncheckbox .wx-checkbox-input {\n  border-radius: 2rpx;\n  width: 28rpx;\n  height: 28rpx;\n  line-height: 28rpx;\n  padding: 0;\n  margin: 0;\n  margin-top: -2rpx;\n  text-align: center;\n}\n/* 选中后的 背景样式 （红色背景 无边框 可根据UI需求自己修改） */\ncheckbox .wx-checkbox-input.wx-checkbox-input-checked {\n  background: #0064ff;\n  border-color: #0064ff;\n}\n/* 选中后的 对勾样式 （白色对勾 可根据UI需求自己修改） */\ncheckbox .wx-checkbox-input.wx-checkbox-input-checked::before {\n  font-size:26rpx;\n  color:#fff; /* 对勾颜色 白色 */\n  background: transparent;\n  transform:translate(-50%, -50%) scale(1);\n}\n```\n\n\n10.1px 像素问题\n同 H5 一样，也存在 1px 像素问题。\n解决办法同 H5 css3，通过 transform 变换设置 1px 像素\n```css\n/**\n* 实线\n*/\n.border-1px:after {\n  position: absolute; \n  content: '';\n  width: 100%;\n  left: 0;\n  bottom: 0;\n  height: 1px;\n  background-color: #e6e6e6;\n  -webkit-transform: scale(1, 0.5);\n  transform: scale(1, 0.5);\n  -webkit-transform-origin: center bottom;\n  transform-origin: center bottom;\n}\n/**\n* 虚线\n*/\n.dashed-line-1px {\n  border-bottom: 1px dashed #e0e0e0;\n  -webkit-transform: scale(1, 0.5);\n  transform: scale(1, 0.5);\n}\n```\n\n11.组件样式继承\n全局样式对组件不生效。\n原因：除了继承样式（如：font、color）在组件外面页面中 或者 全局定义的样式不会被组件内部继承。\n两个解决办法：\n```html\n1).在组件内部再引入一次全局样式。\n2).激活 addGlobalClass 选项。options.addGlobalClass: true (基础库 2.2.3 开始支持)\n```\n\n12.事件冒泡\n要想事件触发不会冒泡到上一次父节点，需要使用 catch+event 的组合（如：catchtap）\nbind 会触发事件冒泡、catch 不会触发事件冒泡\n即 原来的 bindtab=\"tabEvent\" \n改为： catchtab=\"tabEvent\" 即可\n\n\n13.上传图片会触发 onShow 事件\n如果需要在onShow上做一些事件触发，得注意当前页面有没有文件或者图片上传，如果有，则需要注意\n\n14.jpg格式图片上传，真机上的file/content-type为image/jpg，这是非标准的MIME头，正常的应该是image/jpeg，开发者工具是正确的，这个应该是微信的bug。\n\n\n### 名词解释\nappId：小程序ID，每个小程序都有唯一的一个 appid，在小程序后台就可以查到\nopenId：用户唯一标识，每个用户在每个应用（小程序、订阅号、服务号）中的 openId 都是不一样的，需要用户登录小程序后，后台拿着 code 去微信接口获取\nunionId: 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。\n\n","source":"_posts/xcx.md","raw":"---\ntitle: 小程序开发经验(一)\ntag: [小程序, 微信开发]\ndate: 2019/01/08\n---\n\n小程序开发对于前端开发者来说其实很简单，稍微看一下官方文档就能够上手了。\n但是，如果是第一次开发小程序，多多少少还是还是会遇到一些坑的。\n最近恰好开发了一个正式版本的小程序，下面是开发过程中的一些总结以及遇到了一些问题。\n\nps: 适合有一定前端基础的、首先大致看过小程序官方文档的同学观看。\n\n### 小程序开发前期准备\n开发小程序，首先得申请账号：\n小程序账号类型分为个人账号和企业账号，“企业账号”相对于“个人账号”拥有更多的功能。\n\n账号申请成功之后就得申请并分配权限了：\n小程序后台有各种权限，开发者权限(登录、体验、开发设置)、体验者权限、运营者权限、master。\n可以预先给开发、测试、产品、UI等同学开相应的权限，以便后期测试、预览、体验。\n申请权限地址： http://kf.qq.com/faq/170302zeQryI170302beuEVn.html\n\n\n### 开发阶段\n有了权限之后，就可以新建项目了，过程中需要配置appid、域名等。\n\n**APPID 配置：**在小程序后台获取到 appid，并配置在项目中，（ appid 就是小程序的身份证明，唯一固定的），就是根据这个来判断小程序是个人账号还是企业账号的。\n\n**域名配置：**开发环境配置 - 服务器域名配置：request、socket、uploadFile、downloadFile\n小程序不支持 javascript 原生的 ajax 请求，需要使用其内置的请求接口，不同的功能需要使用不同的接口。\n要想在生产环境中使用这些接口，需要预先在小程序后台配置其域名。\n\n**开发环境配置 - 业务域名配置：**\n小程序提供 webview 打开 h5 页面，统一需要预先在后台配置业务域名。\n且该域名需要进行校验，其中一个校验方法就是下载其校验文件，将其配置在该域名的服务下面\n\n如：域名：www.example.com  校验文件：abcAbc.txt\n只需要能够保证 www.example.com/abcAbc.txt 能够正常拿到 abcAbc.txt 的文件内容即可。\n\n\n**mock 数据：**\n前后端分离开发，本地 mock 数据是不可缺少的\n同 h5 开发一样，我们可以本地启动一个 mock 服务，提供 mock 数据接口，如：127.0.0.1:8587/test1\n可以使用 https://github.com/zhoushirong/static-mock 一键启动本地 mock 服务\n\n启动服务之后，需要在开发者工具中将域名合法校验等关闭，不然会出现请求不通的情况：\n工具 —— 项目详情 —— 项目设置 —— 不校验合法域名、web-view 域名...\n\n**注意：**\n连代理在真机上调试的时候需要开启调试模式。（打开小程序 — 点击微信右上角'...' — 打开调试模式）\n苹果开发 https 访问的时候，证书需要通过苹果 ATS 认证，不然访问不了，这意味着，自己做的证书不能用。\n测试阶段建议使用 http，不要使用 https\n\n后端接口上线之后，可以开启https请求，并将域名校验重新打开。\n打开之后如果还是会出现请求不通的情况，可以通过下面的命令进行检测。\n如：\n```shell\n# 下面命令是用来检测域名是否通过 ATS 认证的\n# 仅适用于 MAC OS 系统。\nnscurl --ats-diagnostics --verbose https://www.epoos.com\n```\n\n\n##### 小程序路由\n小程序路由可以通过如下方法进行跳转\n```html\nwx.navigateBack：返回\nwx.switchTab：切换 tab\nwx.navigateTo：跳转、保留原页面\nwx.redirectTo：跳转、不保留原页面\nwx.reLaunch：关闭当前页，重新打开网页（重要：不能返回）\n```\n\n**注意：**\n在小程序中使用中我们会经常用到很多跳转，是不希望用户能够返回上一个页面的\n如登录，登录成功之后就不能允许用户通过返回回到登录页面了。\n之前在网上看到有人说通过 wx.redirectTo 打开能够阻止用户返回上一个页面，经测试发现不行。\n此时，需要使用 wx.reLaunch，通过这种方式打开的小程序页面左上角就没有返回图标了。\n\n\n##### 小程序登录\n1）登录过程\n获取 code —— 换取 token —— 生成 cookie —— 存储 cookie\n查看官方的登录文档即可。\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html\n\n\n2）登录态控制\n对于登录态，一般情况下我们都是通过记录 cookie 来实现的。\n但是，微信原生的 wx.request 不支持传统的 Cookie 读写，所以登录成功之后后端接口 response 写的 cookie 就不会成功。\n原来我们的解决方案是将 cookie 信息通过请求内容来传输。\n\n好在，现在社区还是有一些大侠做了一些基础设施。\n我们可以使用 weapp-cookie 这个库来实现传统 cookie 的功能\n它号称一句代码实现浏览器的 cookie 功能，当然，经实践，确实挺好用。\n它将自动代理 wx.request 接口的访问，通过模拟的方式将cookie 存在 storage 来实现传统 cookie 的功能\n使用凡是，可以查看其 github 文档\nhttps://github.com/charleslo1/weapp-cookie\n\n**注意：**\n1.小程序原生支持 npm node_module 直接引入，但是，此组件通过 require 直接使用 node_module 中的组件之后，代码混淆之后会出现引入不成功的问题。因此，还是需要安装此组件官方推荐的方式，将其拷贝到其它目录下，然后再引入。\n\n2.此组件只代理了 wx.request，并未代理 wx.uploadFile 等其它接口\n因此，在 wx.uploadFile 调用的时候如果后端接口有校验用户身份，需要手动将 cookie 写入 header 中。\n```javascript\nlet cookie = app.cookies.get('XXX_SESSION_KEY')\nlet uploadTask = wx.uploadFile({\n  url: url,\n  filePath: self.tempFilePaths,\n  header: {\n    'Cookie': `XXX_SESSION_KEY=${cookie}` // 手动添加 cookie\n  },\n  name: 'file',\n  success (res) {\n  }\n})\n```\n\n##### 小程序兼容性\n小程序在开发之前就应该确定好兼容的范围，然后根据此范围，在开发的时候来确定哪些 api 是否可用。\n如：基础库\n基础库决定了小程序支持哪些功能，不同的微信版本都有着对应的基础库版本，开发之前需要与产品人员商议、做好功能与用户体验的平衡，最低兼容到哪个微信版本。\n关于基础库官方文档：\nhttps://developers.weixin.qq.com/minigame/dev/framework/client-lib/\n\nES6 兼容情况：\n小程序支持 ES6 很多常用的预发，但是并不是所有的都支持，具体可参考文档\n关于 ES6 官方文档：\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/details.html\n\nCSS3 兼容情况：\n小程序不直接使用 css3，而是 wxss ，不过 css3 常用的动画、flex 布局都能够支持。\n若是需要兼容低版本的手机系统，则需要开启 ES6 转 ES5;\n上传代码时，样式自动补全（工具 - 项目详情 - 项目设置）\n\n\n\n##### 小程序更新\n小程序启动分为热启动、冷启动，冷启动的时候会触发小程序更新\n除了微信冷启动自动更新之外，我们也可以自动检测小程序的更新 updateManager\n在开发过程中，可以通过微信开发者工具，配置’编译‘模式，触发小程序模拟更新。\n如无特殊要求，小程序自己的冷启动更新机制就能够满足更新要求了。\n具体可查看官方文档：\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/operating-mechanism.html\n\n\n##### 小程序性能与优化\n大小限制与分包下载：小程序原先限制了包大小为 1M，后面改为了 2M，这个在开发者工具 —— 项目详情 可以看得到。\n小程序太大一般原因是因为图片太多，可以尽可能的减少图片的使用，然后对图片进行压缩。\n如果真的必须要超过 2M，可以使用分包加载。分包加载不得超过 8M。\n为了能够更快的下载小程序，小程序的包还是越小越好。\n\n性能：\n\n1.打开性能窗口可以看到小程序的性能参数，开发版本能看到更多的信息。\n体验版本和线上版本可以先通过开发打开调试，然后在打开体验版本和线上版本，能看到部分信息。\n\n2.页面栈不要超过 5 层限制，超过之后会导致打不开页面，解决办法，可以使用 wx.redirect 或者 wx.reLaunch\n\n3.网络状态小程序还是很重要的，可以通过获取网络状态来优化小程序的一些操作。\n```javascript\n// 可以根据不同的网络做相应的事情\nwx.getNetworkType({\n  success: function(res) {\n    // networkType字段的有效值：\n    // wifi/2g/3g/4g/unknown(Android下不常见的网络类型)/none(无网络)\n    if (res.networkType == 'wifi') {}\n  }\n})\n```\n\n4.另外，小程序开发者工具还有一个体验评分功能。\n使用方式为：控制台 —— Audits（和 console、network 在同一排）\n开启之后录制即可，一试便知。\n\n5).小程序数据上报与监控\n小程序自己本身后台有做很多数据的统计\n除此之外还可以自己上报一些 自定义数据，自定义数据 value 为 number 类型，不得超过 128 个。\n如果还不能满足，则可以自己做埋点，然后通过 wx.request 接口做数据上报。\n官方文档：\nhttps://developers.weixin.qq.com/miniprogram/dev/api/wx.reportMonitor.html\n\n\n\n##### 小程序二维码与分享\n小程序生成二维码，生成分享链接是必不可少的功能。\n我们可以在小程序二维码生成需要小程序上线之后，通过后端接口请求小程序的接口来生成分享的二维码。\n官方文档：\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html\n\n小程序的分享只能针对页面做配置，不能全局配置，详情可以查阅官方文档。\n\n小程序模板与数据双向绑定（待续）\n\n\n### 测试阶段\n开发提测之后，我们需要给测试人员测试，有两种方式提测，各有优劣。\n测试方法一：在开发者工具将小程序上传 — 在后台将上传的小程序设为体验版 — 测试人员用体验版进行测试\n测试方法二：给测试人员开启开发者权限，开启代码权限，让他们自己拉代码，自己发布体验版进行测试。\n\n**注意：**\n未发布之前，自签证书 ios 可能会验证会通不过，https 接口调不通，因此、开发测试阶段使用 http 进行测试。\n真机测试需开启调试模式。\n测试阶段开发者工具需要设置不校验 https 证书\n\n\n\n### 踩坑指南\n以上是开发过程中的个人觉得比较不容易发觉但是又绕不过去的一些情形。\n下面是开发过程中遇到的一些坑，稍微了解一下有助于走的更顺畅。\n\n1.开发环境请求不通\n原因：\n1.自签证书 https 不通 \n2.真机上未开启调试模式。\n解决办法：\n```html\n开发者工具设置不检验合法域名\n真机开启调试模式\n```\n\n2.线上(预发)环境 https 不通\n场景：\n预发环境 https 接口不通，真机，微信小程序体验版 ios 调接口不通，android 可以调通；\n后验证相同域名下 H5 页面，发现 ios safari 不通、微信扫一扫打开 不通。\n线上正常。\n检测：\n```shell\nnscurl --ats-diagnostics --verbose https://xxx.xxx.xxx # 苹果电脑上 ATS 检测\n```\n结果：\n检测之后发现预发环境的 ATS 测试通不过\n线上检测能通过。\n\n解决：\n```html\n检查并修改预发环境的 nginx 与证书配置，使之能够通过 ATS 检测\n```\n\n3.textarea ios 真机有默认内边距，导致对不齐，android 正常\n原因：\n搜了一下，别人也遇到过类似情况，微信官方未给出解决方案。\n解决：\n获取系统信息，根据系统型号对 ios 设置 class，针对 class 做样式特殊处理。\n```javascript\nlet isIos = /ios/i.test(app.system.system)\nif (isIos) {\n  this.setData({\n    isIos: true\n  })\n}\n```\n```html\n<view class=\"c-textarea-box {{isIos ? 'c-textarea-box-ios' : ''}}\">\n\t<textarea></textarea>\n</view>\n```\n```css\n.c-textarea-box-ios {\n  padding-top: 16rpx;\n  margin-left: -8rpx;\n}\n```\n\n\n4.分别设置 loading 和 toast 蒙层的 mask 为 true 和 false\n两个分别调用之后会导致蒙层属性干扰，蒙层不可穿透功能失效\n```javascript\nwx.showLoading({\n  title: 'loading...',\n  mask: true\n})\nwx.showToast({\n  title: 'toast...',\n  mask: false\n})\n```\n解决办法：两个都设置为 true。\n\n\n5.文件上传的时候后端获取不到用户登录态 cookie\n原因：weapp-cookie 组件只代理了 wx.request，并未代理 wx.uploadFile 等其它接口。\n解决办法：在 wx.uploadFile 调用的时候如果后端接口有校验用户身份，需要手动将 cookie 写入 header 中。\n\n\n\n6.获取手机号码失败\n用户注册之前获取手机号码密文，然后拿到服务端解密，会出现偶现的解密失败的情况\n原因：获取微信登录 code 不能放在获取手机密文的回调里面\n解决办法：预先获取微信登录 code\n\n\n7.微信获取的用户头像是方形的\n```html\n<open-data class=\"user-logo\" type=\"userAvatarUrl\"></open-data>\n```\n通过上述方法获取到的用户头像是方形的，如果要展示圆形头像，直接通过 user-logo class 设置样式无效\n解决办法：加一层父标签，然后对父标签设置绝对定位、并且设置 border-radius，设置 overflow: hidden;\n```html\n<view class=\"fbox\">\n  <open-data class=\"user-logo\" type=\"userAvatarUrl\"></open-data>\n</view>\n```\n\n8.button disabled 样式不生效\n解决办法：重写 disabled 样式加上 ! important 属性\n\n9.checkbox 样式修改不了\n解决办法：不知道哪来的黑科技，使用如下选择器即可\n```css\ncheckbox {\n vertical-align: top;\n}\n/* 未选中的 背景样式 */\ncheckbox .wx-checkbox-input {\n  border-radius: 2rpx;\n  width: 28rpx;\n  height: 28rpx;\n  line-height: 28rpx;\n  padding: 0;\n  margin: 0;\n  margin-top: -2rpx;\n  text-align: center;\n}\n/* 选中后的 背景样式 （红色背景 无边框 可根据UI需求自己修改） */\ncheckbox .wx-checkbox-input.wx-checkbox-input-checked {\n  background: #0064ff;\n  border-color: #0064ff;\n}\n/* 选中后的 对勾样式 （白色对勾 可根据UI需求自己修改） */\ncheckbox .wx-checkbox-input.wx-checkbox-input-checked::before {\n  font-size:26rpx;\n  color:#fff; /* 对勾颜色 白色 */\n  background: transparent;\n  transform:translate(-50%, -50%) scale(1);\n}\n```\n\n\n10.1px 像素问题\n同 H5 一样，也存在 1px 像素问题。\n解决办法同 H5 css3，通过 transform 变换设置 1px 像素\n```css\n/**\n* 实线\n*/\n.border-1px:after {\n  position: absolute; \n  content: '';\n  width: 100%;\n  left: 0;\n  bottom: 0;\n  height: 1px;\n  background-color: #e6e6e6;\n  -webkit-transform: scale(1, 0.5);\n  transform: scale(1, 0.5);\n  -webkit-transform-origin: center bottom;\n  transform-origin: center bottom;\n}\n/**\n* 虚线\n*/\n.dashed-line-1px {\n  border-bottom: 1px dashed #e0e0e0;\n  -webkit-transform: scale(1, 0.5);\n  transform: scale(1, 0.5);\n}\n```\n\n11.组件样式继承\n全局样式对组件不生效。\n原因：除了继承样式（如：font、color）在组件外面页面中 或者 全局定义的样式不会被组件内部继承。\n两个解决办法：\n```html\n1).在组件内部再引入一次全局样式。\n2).激活 addGlobalClass 选项。options.addGlobalClass: true (基础库 2.2.3 开始支持)\n```\n\n12.事件冒泡\n要想事件触发不会冒泡到上一次父节点，需要使用 catch+event 的组合（如：catchtap）\nbind 会触发事件冒泡、catch 不会触发事件冒泡\n即 原来的 bindtab=\"tabEvent\" \n改为： catchtab=\"tabEvent\" 即可\n\n\n13.上传图片会触发 onShow 事件\n如果需要在onShow上做一些事件触发，得注意当前页面有没有文件或者图片上传，如果有，则需要注意\n\n14.jpg格式图片上传，真机上的file/content-type为image/jpg，这是非标准的MIME头，正常的应该是image/jpeg，开发者工具是正确的，这个应该是微信的bug。\n\n\n### 名词解释\nappId：小程序ID，每个小程序都有唯一的一个 appid，在小程序后台就可以查到\nopenId：用户唯一标识，每个用户在每个应用（小程序、订阅号、服务号）中的 openId 都是不一样的，需要用户登录小程序后，后台拿着 code 去微信接口获取\nunionId: 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。\n\n","slug":"xcx","published":1,"updated":"2021-03-30T01:32:00.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn2g7uh20023a0vz0zqx1aiv","content":"<p>小程序开发对于前端开发者来说其实很简单，稍微看一下官方文档就能够上手了。<br>但是，如果是第一次开发小程序，多多少少还是还是会遇到一些坑的。<br>最近恰好开发了一个正式版本的小程序，下面是开发过程中的一些总结以及遇到了一些问题。</p>\n<p>ps: 适合有一定前端基础的、首先大致看过小程序官方文档的同学观看。</p>\n<h3 id=\"小程序开发前期准备\"><a href=\"#小程序开发前期准备\" class=\"headerlink\" title=\"小程序开发前期准备\"></a>小程序开发前期准备</h3><p>开发小程序，首先得申请账号：<br>小程序账号类型分为个人账号和企业账号，“企业账号”相对于“个人账号”拥有更多的功能。</p>\n<p>账号申请成功之后就得申请并分配权限了：<br>小程序后台有各种权限，开发者权限(登录、体验、开发设置)、体验者权限、运营者权限、master。<br>可以预先给开发、测试、产品、UI等同学开相应的权限，以便后期测试、预览、体验。<br>申请权限地址： <a href=\"http://kf.qq.com/faq/170302zeQryI170302beuEVn.html\">http://kf.qq.com/faq/170302zeQryI170302beuEVn.html</a></p>\n<h3 id=\"开发阶段\"><a href=\"#开发阶段\" class=\"headerlink\" title=\"开发阶段\"></a>开发阶段</h3><p>有了权限之后，就可以新建项目了，过程中需要配置appid、域名等。</p>\n<p><strong>APPID 配置：</strong>在小程序后台获取到 appid，并配置在项目中，（ appid 就是小程序的身份证明，唯一固定的），就是根据这个来判断小程序是个人账号还是企业账号的。</p>\n<p><strong>域名配置：</strong>开发环境配置 - 服务器域名配置：request、socket、uploadFile、downloadFile<br>小程序不支持 javascript 原生的 ajax 请求，需要使用其内置的请求接口，不同的功能需要使用不同的接口。<br>要想在生产环境中使用这些接口，需要预先在小程序后台配置其域名。</p>\n<p><strong>开发环境配置 - 业务域名配置：</strong><br>小程序提供 webview 打开 h5 页面，统一需要预先在后台配置业务域名。<br>且该域名需要进行校验，其中一个校验方法就是下载其校验文件，将其配置在该域名的服务下面</p>\n<p>如：域名：<a href=\"http://www.example.com\">www.example.com</a>  校验文件：abcAbc.txt<br>只需要能够保证 <a href=\"http://www.example.com/abcAbc.txt\">www.example.com/abcAbc.txt</a> 能够正常拿到 abcAbc.txt 的文件内容即可。</p>\n<p><strong>mock 数据：</strong><br>前后端分离开发，本地 mock 数据是不可缺少的<br>同 h5 开发一样，我们可以本地启动一个 mock 服务，提供 mock 数据接口，如：127.0.0.1:8587/test1<br>可以使用 <a href=\"https://github.com/zhoushirong/static-mock\">https://github.com/zhoushirong/static-mock</a> 一键启动本地 mock 服务</p>\n<p>启动服务之后，需要在开发者工具中将域名合法校验等关闭，不然会出现请求不通的情况：<br>工具 —— 项目详情 —— 项目设置 —— 不校验合法域名、web-view 域名…</p>\n<p><strong>注意：</strong><br>连代理在真机上调试的时候需要开启调试模式。（打开小程序 — 点击微信右上角’…’ — 打开调试模式）<br>苹果开发 https 访问的时候，证书需要通过苹果 ATS 认证，不然访问不了，这意味着，自己做的证书不能用。<br>测试阶段建议使用 http，不要使用 https</p>\n<p>后端接口上线之后，可以开启https请求，并将域名校验重新打开。<br>打开之后如果还是会出现请求不通的情况，可以通过下面的命令进行检测。<br>如：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 下面命令是用来检测域名是否通过 ATS 认证的</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 仅适用于 MAC OS 系统。</span></span><br><span class=\"line\">nscurl --ats-diagnostics --verbose https://www.epoos.com</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"小程序路由\"><a href=\"#小程序路由\" class=\"headerlink\" title=\"小程序路由\"></a>小程序路由</h5><p>小程序路由可以通过如下方法进行跳转<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.navigateBack：返回</span><br><span class=\"line\">wx.switchTab：切换 tab</span><br><span class=\"line\">wx.navigateTo：跳转、保留原页面</span><br><span class=\"line\">wx.redirectTo：跳转、不保留原页面</span><br><span class=\"line\">wx.reLaunch：关闭当前页，重新打开网页（重要：不能返回）</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong><br>在小程序中使用中我们会经常用到很多跳转，是不希望用户能够返回上一个页面的<br>如登录，登录成功之后就不能允许用户通过返回回到登录页面了。<br>之前在网上看到有人说通过 wx.redirectTo 打开能够阻止用户返回上一个页面，经测试发现不行。<br>此时，需要使用 wx.reLaunch，通过这种方式打开的小程序页面左上角就没有返回图标了。</p>\n<h5 id=\"小程序登录\"><a href=\"#小程序登录\" class=\"headerlink\" title=\"小程序登录\"></a>小程序登录</h5><p>1）登录过程<br>获取 code —— 换取 token —— 生成 cookie —— 存储 cookie<br>查看官方的登录文档即可。<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html\">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html</a></p>\n<p>2）登录态控制<br>对于登录态，一般情况下我们都是通过记录 cookie 来实现的。<br>但是，微信原生的 wx.request 不支持传统的 Cookie 读写，所以登录成功之后后端接口 response 写的 cookie 就不会成功。<br>原来我们的解决方案是将 cookie 信息通过请求内容来传输。</p>\n<p>好在，现在社区还是有一些大侠做了一些基础设施。<br>我们可以使用 weapp-cookie 这个库来实现传统 cookie 的功能<br>它号称一句代码实现浏览器的 cookie 功能，当然，经实践，确实挺好用。<br>它将自动代理 wx.request 接口的访问，通过模拟的方式将cookie 存在 storage 来实现传统 cookie 的功能<br>使用凡是，可以查看其 github 文档<br><a href=\"https://github.com/charleslo1/weapp-cookie\">https://github.com/charleslo1/weapp-cookie</a></p>\n<p><strong>注意：</strong><br>1.小程序原生支持 npm node_module 直接引入，但是，此组件通过 require 直接使用 node_module 中的组件之后，代码混淆之后会出现引入不成功的问题。因此，还是需要安装此组件官方推荐的方式，将其拷贝到其它目录下，然后再引入。</p>\n<p>2.此组件只代理了 wx.request，并未代理 wx.uploadFile 等其它接口<br>因此，在 wx.uploadFile 调用的时候如果后端接口有校验用户身份，需要手动将 cookie 写入 header 中。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> cookie = app.cookies.get(<span class=\"string\">&#x27;XXX_SESSION_KEY&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> uploadTask = wx.uploadFile(&#123;</span><br><span class=\"line\">  url: url,</span><br><span class=\"line\">  filePath: self.tempFilePaths,</span><br><span class=\"line\">  header: &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;Cookie&#x27;</span>: <span class=\"string\">`XXX_SESSION_KEY=<span class=\"subst\">$&#123;cookie&#125;</span>`</span> <span class=\"comment\">// 手动添加 cookie</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;file&#x27;</span>,</span><br><span class=\"line\">  success (res) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"小程序兼容性\"><a href=\"#小程序兼容性\" class=\"headerlink\" title=\"小程序兼容性\"></a>小程序兼容性</h5><p>小程序在开发之前就应该确定好兼容的范围，然后根据此范围，在开发的时候来确定哪些 api 是否可用。<br>如：基础库<br>基础库决定了小程序支持哪些功能，不同的微信版本都有着对应的基础库版本，开发之前需要与产品人员商议、做好功能与用户体验的平衡，最低兼容到哪个微信版本。<br>关于基础库官方文档：<br><a href=\"https://developers.weixin.qq.com/minigame/dev/framework/client-lib/\">https://developers.weixin.qq.com/minigame/dev/framework/client-lib/</a></p>\n<p>ES6 兼容情况：<br>小程序支持 ES6 很多常用的预发，但是并不是所有的都支持，具体可参考文档<br>关于 ES6 官方文档：<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/details.html\">https://developers.weixin.qq.com/miniprogram/dev/framework/details.html</a></p>\n<p>CSS3 兼容情况：<br>小程序不直接使用 css3，而是 wxss ，不过 css3 常用的动画、flex 布局都能够支持。<br>若是需要兼容低版本的手机系统，则需要开启 ES6 转 ES5;<br>上传代码时，样式自动补全（工具 - 项目详情 - 项目设置）</p>\n<h5 id=\"小程序更新\"><a href=\"#小程序更新\" class=\"headerlink\" title=\"小程序更新\"></a>小程序更新</h5><p>小程序启动分为热启动、冷启动，冷启动的时候会触发小程序更新<br>除了微信冷启动自动更新之外，我们也可以自动检测小程序的更新 updateManager<br>在开发过程中，可以通过微信开发者工具，配置’编译‘模式，触发小程序模拟更新。<br>如无特殊要求，小程序自己的冷启动更新机制就能够满足更新要求了。<br>具体可查看官方文档：<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/operating-mechanism.html\">https://developers.weixin.qq.com/miniprogram/dev/framework/operating-mechanism.html</a></p>\n<h5 id=\"小程序性能与优化\"><a href=\"#小程序性能与优化\" class=\"headerlink\" title=\"小程序性能与优化\"></a>小程序性能与优化</h5><p>大小限制与分包下载：小程序原先限制了包大小为 1M，后面改为了 2M，这个在开发者工具 —— 项目详情 可以看得到。<br>小程序太大一般原因是因为图片太多，可以尽可能的减少图片的使用，然后对图片进行压缩。<br>如果真的必须要超过 2M，可以使用分包加载。分包加载不得超过 8M。<br>为了能够更快的下载小程序，小程序的包还是越小越好。</p>\n<p>性能：</p>\n<p>1.打开性能窗口可以看到小程序的性能参数，开发版本能看到更多的信息。<br>体验版本和线上版本可以先通过开发打开调试，然后在打开体验版本和线上版本，能看到部分信息。</p>\n<p>2.页面栈不要超过 5 层限制，超过之后会导致打不开页面，解决办法，可以使用 wx.redirect 或者 wx.reLaunch</p>\n<p>3.网络状态小程序还是很重要的，可以通过获取网络状态来优化小程序的一些操作。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以根据不同的网络做相应的事情</span></span><br><span class=\"line\">wx.getNetworkType(&#123;</span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// networkType字段的有效值：</span></span><br><span class=\"line\">    <span class=\"comment\">// wifi/2g/3g/4g/unknown(Android下不常见的网络类型)/none(无网络)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.networkType == <span class=\"string\">&#x27;wifi&#x27;</span>) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>4.另外，小程序开发者工具还有一个体验评分功能。<br>使用方式为：控制台 —— Audits（和 console、network 在同一排）<br>开启之后录制即可，一试便知。</p>\n<p>5).小程序数据上报与监控<br>小程序自己本身后台有做很多数据的统计<br>除此之外还可以自己上报一些 自定义数据，自定义数据 value 为 number 类型，不得超过 128 个。<br>如果还不能满足，则可以自己做埋点，然后通过 wx.request 接口做数据上报。<br>官方文档：<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/wx.reportMonitor.html\">https://developers.weixin.qq.com/miniprogram/dev/api/wx.reportMonitor.html</a></p>\n<h5 id=\"小程序二维码与分享\"><a href=\"#小程序二维码与分享\" class=\"headerlink\" title=\"小程序二维码与分享\"></a>小程序二维码与分享</h5><p>小程序生成二维码，生成分享链接是必不可少的功能。<br>我们可以在小程序二维码生成需要小程序上线之后，通过后端接口请求小程序的接口来生成分享的二维码。<br>官方文档：<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html\">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html</a></p>\n<p>小程序的分享只能针对页面做配置，不能全局配置，详情可以查阅官方文档。</p>\n<p>小程序模板与数据双向绑定（待续）</p>\n<h3 id=\"测试阶段\"><a href=\"#测试阶段\" class=\"headerlink\" title=\"测试阶段\"></a>测试阶段</h3><p>开发提测之后，我们需要给测试人员测试，有两种方式提测，各有优劣。<br>测试方法一：在开发者工具将小程序上传 — 在后台将上传的小程序设为体验版 — 测试人员用体验版进行测试<br>测试方法二：给测试人员开启开发者权限，开启代码权限，让他们自己拉代码，自己发布体验版进行测试。</p>\n<p><strong>注意：</strong><br>未发布之前，自签证书 ios 可能会验证会通不过，https 接口调不通，因此、开发测试阶段使用 http 进行测试。<br>真机测试需开启调试模式。<br>测试阶段开发者工具需要设置不校验 https 证书</p>\n<h3 id=\"踩坑指南\"><a href=\"#踩坑指南\" class=\"headerlink\" title=\"踩坑指南\"></a>踩坑指南</h3><p>以上是开发过程中的个人觉得比较不容易发觉但是又绕不过去的一些情形。<br>下面是开发过程中遇到的一些坑，稍微了解一下有助于走的更顺畅。</p>\n<p>1.开发环境请求不通<br>原因：<br>1.自签证书 https 不通<br>2.真机上未开启调试模式。<br>解决办法：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开发者工具设置不检验合法域名</span><br><span class=\"line\">真机开启调试模式</span><br></pre></td></tr></table></figure></p>\n<p>2.线上(预发)环境 https 不通<br>场景：<br>预发环境 https 接口不通，真机，微信小程序体验版 ios 调接口不通，android 可以调通；<br>后验证相同域名下 H5 页面，发现 ios safari 不通、微信扫一扫打开 不通。<br>线上正常。<br>检测：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nscurl --ats-diagnostics --verbose https://xxx.xxx.xxx # 苹果电脑上 ATS 检测</span><br></pre></td></tr></table></figure><br>结果：<br>检测之后发现预发环境的 ATS 测试通不过<br>线上检测能通过。</p>\n<p>解决：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">检查并修改预发环境的 nginx 与证书配置，使之能够通过 ATS 检测</span><br></pre></td></tr></table></figure></p>\n<p>3.textarea ios 真机有默认内边距，导致对不齐，android 正常<br>原因：<br>搜了一下，别人也遇到过类似情况，微信官方未给出解决方案。<br>解决：<br>获取系统信息，根据系统型号对 ios 设置 class，针对 class 做样式特殊处理。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isIos = <span class=\"regexp\">/ios/i</span>.test(app.system.system)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (isIos) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">    isIos: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;c-textarea-box &#123;&#123;isIos ? &#x27;c-textarea-box-ios&#x27; : &#x27;&#x27;&#125;&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">textarea</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.c-textarea-box-ios</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-top</span>: <span class=\"number\">16</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: -<span class=\"number\">8</span>rpx;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.分别设置 loading 和 toast 蒙层的 mask 为 true 和 false<br>两个分别调用之后会导致蒙层属性干扰，蒙层不可穿透功能失效<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.showLoading(&#123;</span><br><span class=\"line\">  title: <span class=\"string\">&#x27;loading...&#x27;</span>,</span><br><span class=\"line\">  mask: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">wx.showToast(&#123;</span><br><span class=\"line\">  title: <span class=\"string\">&#x27;toast...&#x27;</span>,</span><br><span class=\"line\">  mask: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>解决办法：两个都设置为 true。</p>\n<p>5.文件上传的时候后端获取不到用户登录态 cookie<br>原因：weapp-cookie 组件只代理了 wx.request，并未代理 wx.uploadFile 等其它接口。<br>解决办法：在 wx.uploadFile 调用的时候如果后端接口有校验用户身份，需要手动将 cookie 写入 header 中。</p>\n<p>6.获取手机号码失败<br>用户注册之前获取手机号码密文，然后拿到服务端解密，会出现偶现的解密失败的情况<br>原因：获取微信登录 code 不能放在获取手机密文的回调里面<br>解决办法：预先获取微信登录 code</p>\n<p>7.微信获取的用户头像是方形的<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">open-data</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;user-logo&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;userAvatarUrl&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">open-data</span>&gt;</span></span><br></pre></td></tr></table></figure><br>通过上述方法获取到的用户头像是方形的，如果要展示圆形头像，直接通过 user-logo class 设置样式无效<br>解决办法：加一层父标签，然后对父标签设置绝对定位、并且设置 border-radius，设置 overflow: hidden;<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;fbox&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">open-data</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;user-logo&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;userAvatarUrl&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">open-data</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>8.button disabled 样式不生效<br>解决办法：重写 disabled 样式加上 ! important 属性</p>\n<p>9.checkbox 样式修改不了<br>解决办法：不知道哪来的黑科技，使用如下选择器即可<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">checkbox</span> &#123;</span><br><span class=\"line\"> <span class=\"attribute\">vertical-align</span>: top;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 未选中的 背景样式 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">checkbox</span> <span class=\"selector-class\">.wx-checkbox-input</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">2</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">28</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">28</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">28</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: -<span class=\"number\">2</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 选中后的 背景样式 （红色背景 无边框 可根据UI需求自己修改） */</span></span><br><span class=\"line\"><span class=\"selector-tag\">checkbox</span> <span class=\"selector-class\">.wx-checkbox-input</span><span class=\"selector-class\">.wx-checkbox-input-checked</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#0064ff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: <span class=\"number\">#0064ff</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 选中后的 对勾样式 （白色对勾 可根据UI需求自己修改） */</span></span><br><span class=\"line\"><span class=\"selector-tag\">checkbox</span> <span class=\"selector-class\">.wx-checkbox-input</span><span class=\"selector-class\">.wx-checkbox-input-checked</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>:<span class=\"number\">26</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>; <span class=\"comment\">/* 对勾颜色 白色 */</span></span><br><span class=\"line\">  <span class=\"attribute\">background</span>: transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>:<span class=\"built_in\">translate</span>(-<span class=\"number\">50%</span>, -<span class=\"number\">50%</span>) <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>10.1px 像素问题<br>同 H5 一样，也存在 1px 像素问题。<br>解决办法同 H5 css3，通过 transform 变换设置 1px 像素<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 实线</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.border-1px</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute; </span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#e6e6e6</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform-origin</span>: center bottom;</span><br><span class=\"line\">  <span class=\"attribute\">transform-origin</span>: center bottom;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 虚线</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.dashed-line-1px</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> dashed <span class=\"number\">#e0e0e0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>11.组件样式继承<br>全局样式对组件不生效。<br>原因：除了继承样式（如：font、color）在组件外面页面中 或者 全局定义的样式不会被组件内部继承。<br>两个解决办法：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1).在组件内部再引入一次全局样式。</span><br><span class=\"line\">2).激活 addGlobalClass 选项。options.addGlobalClass: true (基础库 2.2.3 开始支持)</span><br></pre></td></tr></table></figure></p>\n<p>12.事件冒泡<br>要想事件触发不会冒泡到上一次父节点，需要使用 catch+event 的组合（如：catchtap）<br>bind 会触发事件冒泡、catch 不会触发事件冒泡<br>即 原来的 bindtab=”tabEvent”<br>改为： catchtab=”tabEvent” 即可</p>\n<p>13.上传图片会触发 onShow 事件<br>如果需要在onShow上做一些事件触发，得注意当前页面有没有文件或者图片上传，如果有，则需要注意</p>\n<p>14.jpg格式图片上传，真机上的file/content-type为image/jpg，这是非标准的MIME头，正常的应该是image/jpeg，开发者工具是正确的，这个应该是微信的bug。</p>\n<h3 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h3><p>appId：小程序ID，每个小程序都有唯一的一个 appid，在小程序后台就可以查到<br>openId：用户唯一标识，每个用户在每个应用（小程序、订阅号、服务号）中的 openId 都是不一样的，需要用户登录小程序后，后台拿着 code 去微信接口获取<br>unionId: 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>小程序开发对于前端开发者来说其实很简单，稍微看一下官方文档就能够上手了。<br>但是，如果是第一次开发小程序，多多少少还是还是会遇到一些坑的。<br>最近恰好开发了一个正式版本的小程序，下面是开发过程中的一些总结以及遇到了一些问题。</p>\n<p>ps: 适合有一定前端基础的、首先大致看过小程序官方文档的同学观看。</p>\n<h3 id=\"小程序开发前期准备\"><a href=\"#小程序开发前期准备\" class=\"headerlink\" title=\"小程序开发前期准备\"></a>小程序开发前期准备</h3><p>开发小程序，首先得申请账号：<br>小程序账号类型分为个人账号和企业账号，“企业账号”相对于“个人账号”拥有更多的功能。</p>\n<p>账号申请成功之后就得申请并分配权限了：<br>小程序后台有各种权限，开发者权限(登录、体验、开发设置)、体验者权限、运营者权限、master。<br>可以预先给开发、测试、产品、UI等同学开相应的权限，以便后期测试、预览、体验。<br>申请权限地址： <a href=\"http://kf.qq.com/faq/170302zeQryI170302beuEVn.html\">http://kf.qq.com/faq/170302zeQryI170302beuEVn.html</a></p>\n<h3 id=\"开发阶段\"><a href=\"#开发阶段\" class=\"headerlink\" title=\"开发阶段\"></a>开发阶段</h3><p>有了权限之后，就可以新建项目了，过程中需要配置appid、域名等。</p>\n<p><strong>APPID 配置：</strong>在小程序后台获取到 appid，并配置在项目中，（ appid 就是小程序的身份证明，唯一固定的），就是根据这个来判断小程序是个人账号还是企业账号的。</p>\n<p><strong>域名配置：</strong>开发环境配置 - 服务器域名配置：request、socket、uploadFile、downloadFile<br>小程序不支持 javascript 原生的 ajax 请求，需要使用其内置的请求接口，不同的功能需要使用不同的接口。<br>要想在生产环境中使用这些接口，需要预先在小程序后台配置其域名。</p>\n<p><strong>开发环境配置 - 业务域名配置：</strong><br>小程序提供 webview 打开 h5 页面，统一需要预先在后台配置业务域名。<br>且该域名需要进行校验，其中一个校验方法就是下载其校验文件，将其配置在该域名的服务下面</p>\n<p>如：域名：<a href=\"http://www.example.com\">www.example.com</a>  校验文件：abcAbc.txt<br>只需要能够保证 <a href=\"http://www.example.com/abcAbc.txt\">www.example.com/abcAbc.txt</a> 能够正常拿到 abcAbc.txt 的文件内容即可。</p>\n<p><strong>mock 数据：</strong><br>前后端分离开发，本地 mock 数据是不可缺少的<br>同 h5 开发一样，我们可以本地启动一个 mock 服务，提供 mock 数据接口，如：127.0.0.1:8587/test1<br>可以使用 <a href=\"https://github.com/zhoushirong/static-mock\">https://github.com/zhoushirong/static-mock</a> 一键启动本地 mock 服务</p>\n<p>启动服务之后，需要在开发者工具中将域名合法校验等关闭，不然会出现请求不通的情况：<br>工具 —— 项目详情 —— 项目设置 —— 不校验合法域名、web-view 域名…</p>\n<p><strong>注意：</strong><br>连代理在真机上调试的时候需要开启调试模式。（打开小程序 — 点击微信右上角’…’ — 打开调试模式）<br>苹果开发 https 访问的时候，证书需要通过苹果 ATS 认证，不然访问不了，这意味着，自己做的证书不能用。<br>测试阶段建议使用 http，不要使用 https</p>\n<p>后端接口上线之后，可以开启https请求，并将域名校验重新打开。<br>打开之后如果还是会出现请求不通的情况，可以通过下面的命令进行检测。<br>如：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 下面命令是用来检测域名是否通过 ATS 认证的</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 仅适用于 MAC OS 系统。</span></span><br><span class=\"line\">nscurl --ats-diagnostics --verbose https://www.epoos.com</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"小程序路由\"><a href=\"#小程序路由\" class=\"headerlink\" title=\"小程序路由\"></a>小程序路由</h5><p>小程序路由可以通过如下方法进行跳转<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.navigateBack：返回</span><br><span class=\"line\">wx.switchTab：切换 tab</span><br><span class=\"line\">wx.navigateTo：跳转、保留原页面</span><br><span class=\"line\">wx.redirectTo：跳转、不保留原页面</span><br><span class=\"line\">wx.reLaunch：关闭当前页，重新打开网页（重要：不能返回）</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong><br>在小程序中使用中我们会经常用到很多跳转，是不希望用户能够返回上一个页面的<br>如登录，登录成功之后就不能允许用户通过返回回到登录页面了。<br>之前在网上看到有人说通过 wx.redirectTo 打开能够阻止用户返回上一个页面，经测试发现不行。<br>此时，需要使用 wx.reLaunch，通过这种方式打开的小程序页面左上角就没有返回图标了。</p>\n<h5 id=\"小程序登录\"><a href=\"#小程序登录\" class=\"headerlink\" title=\"小程序登录\"></a>小程序登录</h5><p>1）登录过程<br>获取 code —— 换取 token —— 生成 cookie —— 存储 cookie<br>查看官方的登录文档即可。<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html\">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html</a></p>\n<p>2）登录态控制<br>对于登录态，一般情况下我们都是通过记录 cookie 来实现的。<br>但是，微信原生的 wx.request 不支持传统的 Cookie 读写，所以登录成功之后后端接口 response 写的 cookie 就不会成功。<br>原来我们的解决方案是将 cookie 信息通过请求内容来传输。</p>\n<p>好在，现在社区还是有一些大侠做了一些基础设施。<br>我们可以使用 weapp-cookie 这个库来实现传统 cookie 的功能<br>它号称一句代码实现浏览器的 cookie 功能，当然，经实践，确实挺好用。<br>它将自动代理 wx.request 接口的访问，通过模拟的方式将cookie 存在 storage 来实现传统 cookie 的功能<br>使用凡是，可以查看其 github 文档<br><a href=\"https://github.com/charleslo1/weapp-cookie\">https://github.com/charleslo1/weapp-cookie</a></p>\n<p><strong>注意：</strong><br>1.小程序原生支持 npm node_module 直接引入，但是，此组件通过 require 直接使用 node_module 中的组件之后，代码混淆之后会出现引入不成功的问题。因此，还是需要安装此组件官方推荐的方式，将其拷贝到其它目录下，然后再引入。</p>\n<p>2.此组件只代理了 wx.request，并未代理 wx.uploadFile 等其它接口<br>因此，在 wx.uploadFile 调用的时候如果后端接口有校验用户身份，需要手动将 cookie 写入 header 中。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> cookie = app.cookies.get(<span class=\"string\">&#x27;XXX_SESSION_KEY&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> uploadTask = wx.uploadFile(&#123;</span><br><span class=\"line\">  url: url,</span><br><span class=\"line\">  filePath: self.tempFilePaths,</span><br><span class=\"line\">  header: &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;Cookie&#x27;</span>: <span class=\"string\">`XXX_SESSION_KEY=<span class=\"subst\">$&#123;cookie&#125;</span>`</span> <span class=\"comment\">// 手动添加 cookie</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  name: <span class=\"string\">&#x27;file&#x27;</span>,</span><br><span class=\"line\">  success (res) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"小程序兼容性\"><a href=\"#小程序兼容性\" class=\"headerlink\" title=\"小程序兼容性\"></a>小程序兼容性</h5><p>小程序在开发之前就应该确定好兼容的范围，然后根据此范围，在开发的时候来确定哪些 api 是否可用。<br>如：基础库<br>基础库决定了小程序支持哪些功能，不同的微信版本都有着对应的基础库版本，开发之前需要与产品人员商议、做好功能与用户体验的平衡，最低兼容到哪个微信版本。<br>关于基础库官方文档：<br><a href=\"https://developers.weixin.qq.com/minigame/dev/framework/client-lib/\">https://developers.weixin.qq.com/minigame/dev/framework/client-lib/</a></p>\n<p>ES6 兼容情况：<br>小程序支持 ES6 很多常用的预发，但是并不是所有的都支持，具体可参考文档<br>关于 ES6 官方文档：<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/details.html\">https://developers.weixin.qq.com/miniprogram/dev/framework/details.html</a></p>\n<p>CSS3 兼容情况：<br>小程序不直接使用 css3，而是 wxss ，不过 css3 常用的动画、flex 布局都能够支持。<br>若是需要兼容低版本的手机系统，则需要开启 ES6 转 ES5;<br>上传代码时，样式自动补全（工具 - 项目详情 - 项目设置）</p>\n<h5 id=\"小程序更新\"><a href=\"#小程序更新\" class=\"headerlink\" title=\"小程序更新\"></a>小程序更新</h5><p>小程序启动分为热启动、冷启动，冷启动的时候会触发小程序更新<br>除了微信冷启动自动更新之外，我们也可以自动检测小程序的更新 updateManager<br>在开发过程中，可以通过微信开发者工具，配置’编译‘模式，触发小程序模拟更新。<br>如无特殊要求，小程序自己的冷启动更新机制就能够满足更新要求了。<br>具体可查看官方文档：<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/operating-mechanism.html\">https://developers.weixin.qq.com/miniprogram/dev/framework/operating-mechanism.html</a></p>\n<h5 id=\"小程序性能与优化\"><a href=\"#小程序性能与优化\" class=\"headerlink\" title=\"小程序性能与优化\"></a>小程序性能与优化</h5><p>大小限制与分包下载：小程序原先限制了包大小为 1M，后面改为了 2M，这个在开发者工具 —— 项目详情 可以看得到。<br>小程序太大一般原因是因为图片太多，可以尽可能的减少图片的使用，然后对图片进行压缩。<br>如果真的必须要超过 2M，可以使用分包加载。分包加载不得超过 8M。<br>为了能够更快的下载小程序，小程序的包还是越小越好。</p>\n<p>性能：</p>\n<p>1.打开性能窗口可以看到小程序的性能参数，开发版本能看到更多的信息。<br>体验版本和线上版本可以先通过开发打开调试，然后在打开体验版本和线上版本，能看到部分信息。</p>\n<p>2.页面栈不要超过 5 层限制，超过之后会导致打不开页面，解决办法，可以使用 wx.redirect 或者 wx.reLaunch</p>\n<p>3.网络状态小程序还是很重要的，可以通过获取网络状态来优化小程序的一些操作。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以根据不同的网络做相应的事情</span></span><br><span class=\"line\">wx.getNetworkType(&#123;</span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// networkType字段的有效值：</span></span><br><span class=\"line\">    <span class=\"comment\">// wifi/2g/3g/4g/unknown(Android下不常见的网络类型)/none(无网络)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.networkType == <span class=\"string\">&#x27;wifi&#x27;</span>) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>4.另外，小程序开发者工具还有一个体验评分功能。<br>使用方式为：控制台 —— Audits（和 console、network 在同一排）<br>开启之后录制即可，一试便知。</p>\n<p>5).小程序数据上报与监控<br>小程序自己本身后台有做很多数据的统计<br>除此之外还可以自己上报一些 自定义数据，自定义数据 value 为 number 类型，不得超过 128 个。<br>如果还不能满足，则可以自己做埋点，然后通过 wx.request 接口做数据上报。<br>官方文档：<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/wx.reportMonitor.html\">https://developers.weixin.qq.com/miniprogram/dev/api/wx.reportMonitor.html</a></p>\n<h5 id=\"小程序二维码与分享\"><a href=\"#小程序二维码与分享\" class=\"headerlink\" title=\"小程序二维码与分享\"></a>小程序二维码与分享</h5><p>小程序生成二维码，生成分享链接是必不可少的功能。<br>我们可以在小程序二维码生成需要小程序上线之后，通过后端接口请求小程序的接口来生成分享的二维码。<br>官方文档：<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html\">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html</a></p>\n<p>小程序的分享只能针对页面做配置，不能全局配置，详情可以查阅官方文档。</p>\n<p>小程序模板与数据双向绑定（待续）</p>\n<h3 id=\"测试阶段\"><a href=\"#测试阶段\" class=\"headerlink\" title=\"测试阶段\"></a>测试阶段</h3><p>开发提测之后，我们需要给测试人员测试，有两种方式提测，各有优劣。<br>测试方法一：在开发者工具将小程序上传 — 在后台将上传的小程序设为体验版 — 测试人员用体验版进行测试<br>测试方法二：给测试人员开启开发者权限，开启代码权限，让他们自己拉代码，自己发布体验版进行测试。</p>\n<p><strong>注意：</strong><br>未发布之前，自签证书 ios 可能会验证会通不过，https 接口调不通，因此、开发测试阶段使用 http 进行测试。<br>真机测试需开启调试模式。<br>测试阶段开发者工具需要设置不校验 https 证书</p>\n<h3 id=\"踩坑指南\"><a href=\"#踩坑指南\" class=\"headerlink\" title=\"踩坑指南\"></a>踩坑指南</h3><p>以上是开发过程中的个人觉得比较不容易发觉但是又绕不过去的一些情形。<br>下面是开发过程中遇到的一些坑，稍微了解一下有助于走的更顺畅。</p>\n<p>1.开发环境请求不通<br>原因：<br>1.自签证书 https 不通<br>2.真机上未开启调试模式。<br>解决办法：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开发者工具设置不检验合法域名</span><br><span class=\"line\">真机开启调试模式</span><br></pre></td></tr></table></figure></p>\n<p>2.线上(预发)环境 https 不通<br>场景：<br>预发环境 https 接口不通，真机，微信小程序体验版 ios 调接口不通，android 可以调通；<br>后验证相同域名下 H5 页面，发现 ios safari 不通、微信扫一扫打开 不通。<br>线上正常。<br>检测：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nscurl --ats-diagnostics --verbose https://xxx.xxx.xxx # 苹果电脑上 ATS 检测</span><br></pre></td></tr></table></figure><br>结果：<br>检测之后发现预发环境的 ATS 测试通不过<br>线上检测能通过。</p>\n<p>解决：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">检查并修改预发环境的 nginx 与证书配置，使之能够通过 ATS 检测</span><br></pre></td></tr></table></figure></p>\n<p>3.textarea ios 真机有默认内边距，导致对不齐，android 正常<br>原因：<br>搜了一下，别人也遇到过类似情况，微信官方未给出解决方案。<br>解决：<br>获取系统信息，根据系统型号对 ios 设置 class，针对 class 做样式特殊处理。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isIos = <span class=\"regexp\">/ios/i</span>.test(app.system.system)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (isIos) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">    isIos: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;c-textarea-box &#123;&#123;isIos ? &#x27;c-textarea-box-ios&#x27; : &#x27;&#x27;&#125;&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">textarea</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.c-textarea-box-ios</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-top</span>: <span class=\"number\">16</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: -<span class=\"number\">8</span>rpx;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4.分别设置 loading 和 toast 蒙层的 mask 为 true 和 false<br>两个分别调用之后会导致蒙层属性干扰，蒙层不可穿透功能失效<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.showLoading(&#123;</span><br><span class=\"line\">  title: <span class=\"string\">&#x27;loading...&#x27;</span>,</span><br><span class=\"line\">  mask: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">wx.showToast(&#123;</span><br><span class=\"line\">  title: <span class=\"string\">&#x27;toast...&#x27;</span>,</span><br><span class=\"line\">  mask: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>解决办法：两个都设置为 true。</p>\n<p>5.文件上传的时候后端获取不到用户登录态 cookie<br>原因：weapp-cookie 组件只代理了 wx.request，并未代理 wx.uploadFile 等其它接口。<br>解决办法：在 wx.uploadFile 调用的时候如果后端接口有校验用户身份，需要手动将 cookie 写入 header 中。</p>\n<p>6.获取手机号码失败<br>用户注册之前获取手机号码密文，然后拿到服务端解密，会出现偶现的解密失败的情况<br>原因：获取微信登录 code 不能放在获取手机密文的回调里面<br>解决办法：预先获取微信登录 code</p>\n<p>7.微信获取的用户头像是方形的<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">open-data</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;user-logo&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;userAvatarUrl&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">open-data</span>&gt;</span></span><br></pre></td></tr></table></figure><br>通过上述方法获取到的用户头像是方形的，如果要展示圆形头像，直接通过 user-logo class 设置样式无效<br>解决办法：加一层父标签，然后对父标签设置绝对定位、并且设置 border-radius，设置 overflow: hidden;<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;fbox&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">open-data</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;user-logo&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;userAvatarUrl&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">open-data</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>8.button disabled 样式不生效<br>解决办法：重写 disabled 样式加上 ! important 属性</p>\n<p>9.checkbox 样式修改不了<br>解决办法：不知道哪来的黑科技，使用如下选择器即可<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">checkbox</span> &#123;</span><br><span class=\"line\"> <span class=\"attribute\">vertical-align</span>: top;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 未选中的 背景样式 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">checkbox</span> <span class=\"selector-class\">.wx-checkbox-input</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">2</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">28</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">28</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">28</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: -<span class=\"number\">2</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 选中后的 背景样式 （红色背景 无边框 可根据UI需求自己修改） */</span></span><br><span class=\"line\"><span class=\"selector-tag\">checkbox</span> <span class=\"selector-class\">.wx-checkbox-input</span><span class=\"selector-class\">.wx-checkbox-input-checked</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#0064ff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: <span class=\"number\">#0064ff</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 选中后的 对勾样式 （白色对勾 可根据UI需求自己修改） */</span></span><br><span class=\"line\"><span class=\"selector-tag\">checkbox</span> <span class=\"selector-class\">.wx-checkbox-input</span><span class=\"selector-class\">.wx-checkbox-input-checked</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>:<span class=\"number\">26</span>rpx;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>; <span class=\"comment\">/* 对勾颜色 白色 */</span></span><br><span class=\"line\">  <span class=\"attribute\">background</span>: transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>:<span class=\"built_in\">translate</span>(-<span class=\"number\">50%</span>, -<span class=\"number\">50%</span>) <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>10.1px 像素问题<br>同 H5 一样，也存在 1px 像素问题。<br>解决办法同 H5 css3，通过 transform 变换设置 1px 像素<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 实线</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.border-1px</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute; </span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#e6e6e6</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform-origin</span>: center bottom;</span><br><span class=\"line\">  <span class=\"attribute\">transform-origin</span>: center bottom;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 虚线</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.dashed-line-1px</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> dashed <span class=\"number\">#e0e0e0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>11.组件样式继承<br>全局样式对组件不生效。<br>原因：除了继承样式（如：font、color）在组件外面页面中 或者 全局定义的样式不会被组件内部继承。<br>两个解决办法：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1).在组件内部再引入一次全局样式。</span><br><span class=\"line\">2).激活 addGlobalClass 选项。options.addGlobalClass: true (基础库 2.2.3 开始支持)</span><br></pre></td></tr></table></figure></p>\n<p>12.事件冒泡<br>要想事件触发不会冒泡到上一次父节点，需要使用 catch+event 的组合（如：catchtap）<br>bind 会触发事件冒泡、catch 不会触发事件冒泡<br>即 原来的 bindtab=”tabEvent”<br>改为： catchtab=”tabEvent” 即可</p>\n<p>13.上传图片会触发 onShow 事件<br>如果需要在onShow上做一些事件触发，得注意当前页面有没有文件或者图片上传，如果有，则需要注意</p>\n<p>14.jpg格式图片上传，真机上的file/content-type为image/jpg，这是非标准的MIME头，正常的应该是image/jpeg，开发者工具是正确的，这个应该是微信的bug。</p>\n<h3 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h3><p>appId：小程序ID，每个小程序都有唯一的一个 appid，在小程序后台就可以查到<br>openId：用户唯一标识，每个用户在每个应用（小程序、订阅号、服务号）中的 openId 都是不一样的，需要用户登录小程序后，后台拿着 code 去微信接口获取<br>unionId: 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckn2g7uez0000a0vz2cp9fpt4","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7ujz008ta0vzfyws14fr"},{"post_id":"ckn2g7uf50001a0vz2n8g41bb","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7ujz008va0vz1q0w4dc7"},{"post_id":"ckn2g7uf60002a0vzdod9958w","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7ujz008xa0vz14nn10b6"},{"post_id":"ckn2g7uf70003a0vza91l75ih","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7ujz008za0vzb3qi1lq3"},{"post_id":"ckn2g7uf70004a0vzfv6xb9fn","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7ujz0091a0vzf5fy4o2t"},{"post_id":"ckn2g7uf80005a0vzdp9h1m0w","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7ujz0093a0vzb62462b0"},{"post_id":"ckn2g7uf90006a0vz6iohdcoq","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk00095a0vz15w46dcq"},{"post_id":"ckn2g7ufa0007a0vzed0g2r5x","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk00097a0vz6ga9dur2"},{"post_id":"ckn2g7ufa0008a0vz5it9ahbz","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk00099a0vz3flu0xbx"},{"post_id":"ckn2g7ufb0009a0vzglcfd1x0","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk0009ba0vz0yzhg5lm"},{"post_id":"ckn2g7ufc000aa0vzhoyv19ho","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk0009da0vzbmkc4cm3"},{"post_id":"ckn2g7ufd000ca0vzebct18fi","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk0009fa0vzg4eb3cu4"},{"post_id":"ckn2g7ufe000da0vz62k7ex60","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk0009ha0vzbrcy2svf"},{"post_id":"ckn2g7uff000ea0vz827gcd0h","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk0009ja0vz5eetdhg1"},{"post_id":"ckn2g7ufg000fa0vzgkufbx20","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk0009la0vz4wl3h4de"},{"post_id":"ckn2g7ufh000ga0vz9x8v4pno","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk1009na0vz60de4uvu"},{"post_id":"ckn2g7ufh000ha0vz59nc548g","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk1009pa0vzgwwdfn08"},{"post_id":"ckn2g7ufi000ia0vzcj2b13d4","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk1009ra0vzf4gm02wi"},{"post_id":"ckn2g7ufj000ja0vz5p5u9u8e","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk1009ta0vzd5wifber"},{"post_id":"ckn2g7ufj000ka0vz118pg7mi","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk1009va0vz52ec10e7"},{"post_id":"ckn2g7ufl000ma0vz0yur31gh","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk1009xa0vz835je7v8"},{"post_id":"ckn2g7ufl000na0vzh60670d1","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk1009za0vzbws54ulj"},{"post_id":"ckn2g7ufm000oa0vzgqycauqd","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk200a1a0vz51yj0qrp"},{"post_id":"ckn2g7ufm000pa0vz9aoyf2b7","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk200a3a0vz9eic3z0r"},{"post_id":"ckn2g7ufn000qa0vz2rjug1ot","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk200a5a0vz48s2crm2"},{"post_id":"ckn2g7ufn000ra0vz1p9g9to9","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk200a7a0vzanetazr2"},{"post_id":"ckn2g7ufo000sa0vze7en19tb","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk200a9a0vz8qut0owk"},{"post_id":"ckn2g7ufp000ta0vz3ok76jev","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk200aba0vz59st6ckt"},{"post_id":"ckn2g7ufp000ua0vzfcey6ssp","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk200ada0vz6jzvbrq9"},{"post_id":"ckn2g7ufq000va0vz9n135ldb","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk200afa0vz7bpnbvlw"},{"post_id":"ckn2g7ufq000wa0vz0e06bebp","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk200aha0vzad053096"},{"post_id":"ckn2g7ufr000xa0vz58e983wf","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk200aja0vzanswa6hw"},{"post_id":"ckn2g7ufu000ya0vzfjq8d22p","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk300ala0vz9afqeomj"},{"post_id":"ckn2g7ufu000za0vz5apzc53q","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk300ana0vz8aza4gb9"},{"post_id":"ckn2g7ufv0010a0vz2f3g2q58","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk300apa0vz53x7bh6e"},{"post_id":"ckn2g7ufw0011a0vzf9hz65qa","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk300ara0vzb8onec2u"},{"post_id":"ckn2g7ufw0012a0vzgr3ua6kp","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk300ata0vzeawhdhzn"},{"post_id":"ckn2g7ufx0013a0vz18ct1f4w","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk300ava0vzakbkgbfv"},{"post_id":"ckn2g7ufx0014a0vz9c0affxs","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk300axa0vz3h7eboa1"},{"post_id":"ckn2g7ufz0017a0vz4dd1eumn","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk400aza0vz8la133gg"},{"post_id":"ckn2g7ug00018a0vz1c1s6yg4","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk400b1a0vz0ei6agnf"},{"post_id":"ckn2g7ug00019a0vz10wvd7hd","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk400b3a0vzf0nwe1bb"},{"post_id":"ckn2g7ug1001aa0vzgj1y6k2e","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk400b5a0vzaheff5c7"},{"post_id":"ckn2g7ug2001ca0vz7ocga25a","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk400b7a0vzfzbmg142"},{"post_id":"ckn2g7ug3001da0vz3nn7fhxo","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk400b9a0vzcbqc00j6"},{"post_id":"ckn2g7ug3001ea0vz8co81pjr","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk400bba0vz2e9h4pfe"},{"post_id":"ckn2g7ug4001fa0vz3rodeq56","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk400bda0vz05689fdg"},{"post_id":"ckn2g7ug5001ga0vz9ezgbn2x","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk400bfa0vz4xct7gtq"},{"post_id":"ckn2g7ug5001ha0vzb2yj0ukf","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk500bha0vz5ffr04fz"},{"post_id":"ckn2g7ug6001ia0vz6y2r0ih1","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk500bja0vz31m9bewl"},{"post_id":"ckn2g7ug6001ja0vz05tq1xa0","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk500bla0vz7aiu1if5"},{"post_id":"ckn2g7ug7001ka0vz6lv5195y","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk500bna0vzfuv185t9"},{"post_id":"ckn2g7ug8001la0vzak459zwm","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk500bpa0vz2gm1e5j0"},{"post_id":"ckn2g7ug8001ma0vz6gymgppb","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk500bra0vz6aia2y7g"},{"post_id":"ckn2g7uga001pa0vzb5rq1ot4","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk500bta0vz98prggsx"},{"post_id":"ckn2g7uga001qa0vzbldo7h9s","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk500bva0vz85ag50oi"},{"post_id":"ckn2g7ugb001ra0vzh59wfqtf","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk500bxa0vz3sy0769t"},{"post_id":"ckn2g7ugb001sa0vz1g5r2q3q","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk500bza0vz9e0i9x5j"},{"post_id":"ckn2g7ugc001ta0vzdwkl3jfq","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk500c1a0vzed9s206h"},{"post_id":"ckn2g7ugc001ua0vzgsvlfpkr","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk500c3a0vzbjhlec73"},{"post_id":"ckn2g7ugd001va0vz71ml8w0b","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk600c5a0vz5pnd3pc2"},{"post_id":"ckn2g7ugd001wa0vzdeea4tem","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk600c7a0vzho03ewbt"},{"post_id":"ckn2g7uge001xa0vz4kfm0tcm","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk600c9a0vz9ssqabd1"},{"post_id":"ckn2g7uge001ya0vzdssf38zy","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk600cba0vzefd3ej9k"},{"post_id":"ckn2g7ugf001za0vzf4095t9t","category_id":"ckn2g7uh20024a0vzhx8i5554","_id":"ckn2g7uk600cda0vz0zy5gv8u"},{"post_id":"ckn2g7ugg0021a0vz4kbk4iv0","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk600cfa0vzczde1cvw"},{"post_id":"ckn2g7ugh0022a0vzb1fc1ri2","category_id":"ckn2g7uhe0026a0vz5wve6zxa","_id":"ckn2g7uk600cha0vzh8tw3ev1"}],"PostTag":[{"post_id":"ckn2g7uez0000a0vz2cp9fpt4","tag_id":"ckn2g7uhd0025a0vz02612wgk","_id":"ckn2g7ujz008sa0vz2bk77sxt"},{"post_id":"ckn2g7uf50001a0vz2n8g41bb","tag_id":"ckn2g7uhe0027a0vzg0te29ny","_id":"ckn2g7ujz008ua0vzhglo9xr4"},{"post_id":"ckn2g7uf50001a0vz2n8g41bb","tag_id":"ckn2g7uhf0029a0vze65978vg","_id":"ckn2g7ujz008wa0vz82dl0ka6"},{"post_id":"ckn2g7uf50001a0vz2n8g41bb","tag_id":"ckn2g7uhh002ba0vzbstee0wd","_id":"ckn2g7ujz008ya0vz61mn6th6"},{"post_id":"ckn2g7uf50001a0vz2n8g41bb","tag_id":"ckn2g7uhi002da0vz1xczhcvc","_id":"ckn2g7ujz0090a0vzcasg40ze"},{"post_id":"ckn2g7uf50001a0vz2n8g41bb","tag_id":"ckn2g7uhi002fa0vzetk8azz5","_id":"ckn2g7ujz0092a0vz3bqi5j1p"},{"post_id":"ckn2g7uf50001a0vz2n8g41bb","tag_id":"ckn2g7uhj002ha0vz1zhqetwh","_id":"ckn2g7ujz0094a0vz4htz9h7h"},{"post_id":"ckn2g7uf60002a0vzdod9958w","tag_id":"ckn2g7uhk002ja0vz51h34zul","_id":"ckn2g7uk00096a0vzdouj2db9"},{"post_id":"ckn2g7uf60002a0vzdod9958w","tag_id":"ckn2g7uhl002la0vzfakj2br3","_id":"ckn2g7uk00098a0vzaxb0ggi8"},{"post_id":"ckn2g7uf60002a0vzdod9958w","tag_id":"ckn2g7uhm002na0vz6utwck9g","_id":"ckn2g7uk0009aa0vzhe2j2xev"},{"post_id":"ckn2g7uf70003a0vza91l75ih","tag_id":"ckn2g7uhm002qa0vz60cnfem4","_id":"ckn2g7uk0009ca0vz0h4ygpjw"},{"post_id":"ckn2g7uf70003a0vza91l75ih","tag_id":"ckn2g7uhn002sa0vzge3sdqvc","_id":"ckn2g7uk0009ea0vzcowghgko"},{"post_id":"ckn2g7uf70003a0vza91l75ih","tag_id":"ckn2g7uho002ua0vz2web18dw","_id":"ckn2g7uk0009ga0vz6oy37wie"},{"post_id":"ckn2g7uf70003a0vza91l75ih","tag_id":"ckn2g7uho002wa0vzfjoxd33j","_id":"ckn2g7uk0009ia0vz7jy2c0nj"},{"post_id":"ckn2g7uf70003a0vza91l75ih","tag_id":"ckn2g7uhp002ya0vz6i8a4cak","_id":"ckn2g7uk0009ka0vzhtqa3226"},{"post_id":"ckn2g7uf70004a0vzfv6xb9fn","tag_id":"ckn2g7uhq0030a0vzepcs3t21","_id":"ckn2g7uk0009ma0vzh7u12gfq"},{"post_id":"ckn2g7uf80005a0vzdp9h1m0w","tag_id":"ckn2g7uhq0032a0vz1klw0wed","_id":"ckn2g7uk1009oa0vzcgww85nt"},{"post_id":"ckn2g7uf80005a0vzdp9h1m0w","tag_id":"ckn2g7uhr0034a0vz2strbzvu","_id":"ckn2g7uk1009qa0vz17qjcpma"},{"post_id":"ckn2g7uf90006a0vz6iohdcoq","tag_id":"ckn2g7uhs0037a0vz6uhvdfuf","_id":"ckn2g7uk1009sa0vz810k6gs6"},{"post_id":"ckn2g7uf90006a0vz6iohdcoq","tag_id":"ckn2g7uht0039a0vz3sxra5qd","_id":"ckn2g7uk1009ua0vzat7zbjs2"},{"post_id":"ckn2g7uf90006a0vz6iohdcoq","tag_id":"ckn2g7uhu003ba0vz1c321a2e","_id":"ckn2g7uk1009wa0vz5h1s89k1"},{"post_id":"ckn2g7ufa0007a0vzed0g2r5x","tag_id":"ckn2g7uhv003da0vzhmfe08rm","_id":"ckn2g7uk1009ya0vz24g34qpl"},{"post_id":"ckn2g7ufa0007a0vzed0g2r5x","tag_id":"ckn2g7uhw003fa0vz7uof91tq","_id":"ckn2g7uk200a0a0vz0gsr4yx3"},{"post_id":"ckn2g7ufa0008a0vz5it9ahbz","tag_id":"ckn2g7uhw003ha0vz9whz1282","_id":"ckn2g7uk200a2a0vz935g35oo"},{"post_id":"ckn2g7ufa0008a0vz5it9ahbz","tag_id":"ckn2g7uhx003ja0vz3dw0bnps","_id":"ckn2g7uk200a4a0vz73tlhfg5"},{"post_id":"ckn2g7ufb0009a0vzglcfd1x0","tag_id":"ckn2g7uhl002la0vzfakj2br3","_id":"ckn2g7uk200a6a0vza4c33ry1"},{"post_id":"ckn2g7ufc000aa0vzhoyv19ho","tag_id":"ckn2g7uhy003na0vzbk15gmqy","_id":"ckn2g7uk200a8a0vzhuliesvx"},{"post_id":"ckn2g7ufc000aa0vzhoyv19ho","tag_id":"ckn2g7ui0003qa0vz0i4j32kf","_id":"ckn2g7uk200aaa0vz353k9lzo"},{"post_id":"ckn2g7ufd000ba0vz99gqgd74","tag_id":"ckn2g7uhs0037a0vz6uhvdfuf","_id":"ckn2g7uk200aca0vze1rx3426"},{"post_id":"ckn2g7ufd000ba0vz99gqgd74","tag_id":"ckn2g7ui1003ua0vz8uc90yed","_id":"ckn2g7uk200aea0vzatxt4rv8"},{"post_id":"ckn2g7ufd000ba0vz99gqgd74","tag_id":"ckn2g7ui2003wa0vze2npeusv","_id":"ckn2g7uk200aga0vzgk81equ6"},{"post_id":"ckn2g7ufd000ba0vz99gqgd74","tag_id":"ckn2g7ui2003ya0vz8oef15gr","_id":"ckn2g7uk200aia0vzc0mn62x2"},{"post_id":"ckn2g7ufd000ca0vzebct18fi","tag_id":"ckn2g7uhs0037a0vz6uhvdfuf","_id":"ckn2g7uk300aka0vzcdmx0vf5"},{"post_id":"ckn2g7ufe000da0vz62k7ex60","tag_id":"ckn2g7ui40042a0vz5r2pag9q","_id":"ckn2g7uk300ama0vzd1f74mp1"},{"post_id":"ckn2g7uff000ea0vz827gcd0h","tag_id":"ckn2g7ui40044a0vzd09s24g8","_id":"ckn2g7uk300aoa0vzdr8348h7"},{"post_id":"ckn2g7ufg000fa0vzgkufbx20","tag_id":"ckn2g7ui70046a0vz8n4fhrby","_id":"ckn2g7uk300aqa0vz2jej8vgi"},{"post_id":"ckn2g7ufh000ga0vz9x8v4pno","tag_id":"ckn2g7ui80048a0vz63wi7ygw","_id":"ckn2g7uk300asa0vzb9pscvzr"},{"post_id":"ckn2g7ufh000ga0vz9x8v4pno","tag_id":"ckn2g7ui8004ba0vzfd4j1qye","_id":"ckn2g7uk300aua0vz0bcx3wa1"},{"post_id":"ckn2g7ufh000ga0vz9x8v4pno","tag_id":"ckn2g7ui9004da0vzb4473o8b","_id":"ckn2g7uk300awa0vz2wgvcggp"},{"post_id":"ckn2g7ufh000ha0vz59nc548g","tag_id":"ckn2g7uia004fa0vz5nq50r3s","_id":"ckn2g7uk400aya0vzf3qy97jg"},{"post_id":"ckn2g7ufh000ha0vz59nc548g","tag_id":"ckn2g7uib004ha0vz3e7p93nj","_id":"ckn2g7uk400b0a0vz8j4zahk1"},{"post_id":"ckn2g7ufh000ha0vz59nc548g","tag_id":"ckn2g7uic004ja0vzgonpg8yq","_id":"ckn2g7uk400b2a0vz29bjgwfx"},{"post_id":"ckn2g7ufi000ia0vzcj2b13d4","tag_id":"ckn2g7uic004la0vz9ipcamdq","_id":"ckn2g7uk400b4a0vzfku24u97"},{"post_id":"ckn2g7ufj000ja0vz5p5u9u8e","tag_id":"ckn2g7uid004na0vz2snb5t7t","_id":"ckn2g7uk400b6a0vz6ftwetu3"},{"post_id":"ckn2g7ufj000ja0vz5p5u9u8e","tag_id":"ckn2g7uia004fa0vz5nq50r3s","_id":"ckn2g7uk400b8a0vzetqc0xg1"},{"post_id":"ckn2g7ufj000ka0vz118pg7mi","tag_id":"ckn2g7uif004ra0vzhcm97he0","_id":"ckn2g7uk400baa0vz54oa1smv"},{"post_id":"ckn2g7ufk000la0vzbb68avdz","tag_id":"ckn2g7uig004ua0vz9m6q88ph","_id":"ckn2g7uk400bca0vz8ktg8je1"},{"post_id":"ckn2g7ufk000la0vzbb68avdz","tag_id":"ckn2g7uih004wa0vz2wqbd5mt","_id":"ckn2g7uk400bea0vzf34ccuna"},{"post_id":"ckn2g7ufk000la0vzbb68avdz","tag_id":"ckn2g7uih004ya0vz6ehb21kh","_id":"ckn2g7uk400bga0vz2trke1mv"},{"post_id":"ckn2g7ufl000ma0vz0yur31gh","tag_id":"ckn2g7uii0050a0vz36in2zqt","_id":"ckn2g7uk500bia0vz8bak11e3"},{"post_id":"ckn2g7ufl000na0vzh60670d1","tag_id":"ckn2g7uij0052a0vz34h2fqdc","_id":"ckn2g7uk500bka0vzf4rwa3q4"},{"post_id":"ckn2g7ufl000na0vzh60670d1","tag_id":"ckn2g7uik0054a0vzcbj87klu","_id":"ckn2g7uk500bma0vz6l2k5b30"},{"post_id":"ckn2g7ufl000na0vzh60670d1","tag_id":"ckn2g7uik0056a0vzcsyh34zt","_id":"ckn2g7uk500boa0vzfg4cg94m"},{"post_id":"ckn2g7ufm000oa0vzgqycauqd","tag_id":"ckn2g7uhs0037a0vz6uhvdfuf","_id":"ckn2g7uk500bqa0vzao25b05i"},{"post_id":"ckn2g7ufm000pa0vz9aoyf2b7","tag_id":"ckn2g7uhs0037a0vz6uhvdfuf","_id":"ckn2g7uk500bsa0vz3yeqau80"},{"post_id":"ckn2g7ufn000qa0vz2rjug1ot","tag_id":"ckn2g7uio005ca0vzhnjpb6yq","_id":"ckn2g7uk500bua0vz4l4fasqf"},{"post_id":"ckn2g7ufn000qa0vz2rjug1ot","tag_id":"ckn2g7uip005fa0vz2op53nbb","_id":"ckn2g7uk500bwa0vz46yi0wui"},{"post_id":"ckn2g7ufn000qa0vz2rjug1ot","tag_id":"ckn2g7uiq005ha0vzhzd845ou","_id":"ckn2g7uk500bya0vzgt90h57s"},{"post_id":"ckn2g7ufn000qa0vz2rjug1ot","tag_id":"ckn2g7uiq005ja0vzak8w90ni","_id":"ckn2g7uk500c0a0vz9vnp1pg3"},{"post_id":"ckn2g7ufn000ra0vz1p9g9to9","tag_id":"ckn2g7uir005la0vz8jle9ay6","_id":"ckn2g7uk500c2a0vzcucce3fn"},{"post_id":"ckn2g7ufo000sa0vze7en19tb","tag_id":"ckn2g7uir005la0vz8jle9ay6","_id":"ckn2g7uk500c4a0vz1q99enbg"},{"post_id":"ckn2g7ufo000sa0vze7en19tb","tag_id":"ckn2g7uis005oa0vz9rz71dj9","_id":"ckn2g7uk600c6a0vz7osg2qv8"},{"post_id":"ckn2g7ufp000ta0vz3ok76jev","tag_id":"ckn2g7uir005la0vz8jle9ay6","_id":"ckn2g7uk600c8a0vzcltq9lrr"},{"post_id":"ckn2g7ufp000ta0vz3ok76jev","tag_id":"ckn2g7uis005oa0vz9rz71dj9","_id":"ckn2g7uk600caa0vz5n5c7n5b"},{"post_id":"ckn2g7ufp000ua0vzfcey6ssp","tag_id":"ckn2g7uir005la0vz8jle9ay6","_id":"ckn2g7uk600cca0vza4uca11t"},{"post_id":"ckn2g7ufp000ua0vzfcey6ssp","tag_id":"ckn2g7uis005oa0vz9rz71dj9","_id":"ckn2g7uk600cea0vzco8ybdyf"},{"post_id":"ckn2g7ufq000va0vz9n135ldb","tag_id":"ckn2g7uir005la0vz8jle9ay6","_id":"ckn2g7uk600cga0vz6guqf33z"},{"post_id":"ckn2g7ufq000va0vz9n135ldb","tag_id":"ckn2g7uis005oa0vz9rz71dj9","_id":"ckn2g7uk600cia0vzhj2g5b2a"},{"post_id":"ckn2g7ufq000wa0vz0e06bebp","tag_id":"ckn2g7uiu005va0vz3cd1enfk","_id":"ckn2g7uk600cja0vz08du36lv"},{"post_id":"ckn2g7ufr000xa0vz58e983wf","tag_id":"ckn2g7uiv005wa0vz4x19fbl3","_id":"ckn2g7uk600cka0vzf7bq03b4"},{"post_id":"ckn2g7ufr000xa0vz58e983wf","tag_id":"ckn2g7uiv005xa0vzbn2w4sft","_id":"ckn2g7uk600cla0vz8q50gq9o"},{"post_id":"ckn2g7ufu000ya0vzfjq8d22p","tag_id":"ckn2g7uiv005ya0vzfchb75on","_id":"ckn2g7uk600cma0vzexck5lr4"},{"post_id":"ckn2g7ufu000za0vz5apzc53q","tag_id":"ckn2g7uiw005za0vzb2qcfg6b","_id":"ckn2g7uk600cna0vzbwczh9a7"},{"post_id":"ckn2g7ufu000za0vz5apzc53q","tag_id":"ckn2g7uiw0060a0vz1ogdgdcu","_id":"ckn2g7uk600coa0vzespq3ue3"},{"post_id":"ckn2g7ufv0010a0vz2f3g2q58","tag_id":"ckn2g7uiw005za0vzb2qcfg6b","_id":"ckn2g7uk600cpa0vzfgpdfig4"},{"post_id":"ckn2g7ufv0010a0vz2f3g2q58","tag_id":"ckn2g7uiw0060a0vz1ogdgdcu","_id":"ckn2g7uk600cqa0vz9r8z20fa"},{"post_id":"ckn2g7ufv0010a0vz2f3g2q58","tag_id":"ckn2g7uix0063a0vz94w244su","_id":"ckn2g7uk600cra0vz791o2bjh"},{"post_id":"ckn2g7ufw0011a0vzf9hz65qa","tag_id":"ckn2g7ui70046a0vz8n4fhrby","_id":"ckn2g7uk700csa0vz7puog77c"},{"post_id":"ckn2g7ufw0012a0vzgr3ua6kp","tag_id":"ckn2g7uiy0065a0vzc1ef6lbf","_id":"ckn2g7uk700cta0vzes4p82ru"},{"post_id":"ckn2g7ufw0012a0vzgr3ua6kp","tag_id":"ckn2g7uiy0066a0vz4hfwgvth","_id":"ckn2g7uk700cua0vza2kc1okj"},{"post_id":"ckn2g7ufw0012a0vzgr3ua6kp","tag_id":"ckn2g7uiy0067a0vzauuc7eko","_id":"ckn2g7uk700cva0vz0ob29hht"},{"post_id":"ckn2g7ufx0013a0vz18ct1f4w","tag_id":"ckn2g7uiy0065a0vzc1ef6lbf","_id":"ckn2g7uk700cwa0vzhrovcfpl"},{"post_id":"ckn2g7ufx0014a0vz9c0affxs","tag_id":"ckn2g7uiy0065a0vzc1ef6lbf","_id":"ckn2g7uk700cxa0vz4upje8j2"},{"post_id":"ckn2g7ufx0014a0vz9c0affxs","tag_id":"ckn2g7uiz006aa0vzcv2s9ov4","_id":"ckn2g7uk800cya0vz0uhdb8nj"},{"post_id":"ckn2g7ufy0015a0vz5v0s2tyy","tag_id":"ckn2g7uiz006ba0vz0pzv995p","_id":"ckn2g7uk800cza0vz1f5o9z15"},{"post_id":"ckn2g7ufy0015a0vz5v0s2tyy","tag_id":"ckn2g7uiy0065a0vzc1ef6lbf","_id":"ckn2g7uk800d0a0vz5b3db2sa"},{"post_id":"ckn2g7ufy0016a0vz2v7h0e6n","tag_id":"ckn2g7uj0006da0vz0fn7cjw2","_id":"ckn2g7uk800d1a0vza5lc4fi4"},{"post_id":"ckn2g7ufy0016a0vz2v7h0e6n","tag_id":"ckn2g7uj0006ea0vz5m1sey5e","_id":"ckn2g7uk800d2a0vz3z06bl90"},{"post_id":"ckn2g7ufz0017a0vz4dd1eumn","tag_id":"ckn2g7uhs0037a0vz6uhvdfuf","_id":"ckn2g7uk800d3a0vz58kid7m0"},{"post_id":"ckn2g7ufz0017a0vz4dd1eumn","tag_id":"ckn2g7uj1006ga0vz57gufd1l","_id":"ckn2g7uk800d4a0vz93rg3ldo"},{"post_id":"ckn2g7ug00018a0vz1c1s6yg4","tag_id":"ckn2g7uj1006ga0vz57gufd1l","_id":"ckn2g7uk800d5a0vzc5hbc4iz"},{"post_id":"ckn2g7ug00018a0vz1c1s6yg4","tag_id":"ckn2g7uhs0037a0vz6uhvdfuf","_id":"ckn2g7uk800d6a0vz3asa6vph"},{"post_id":"ckn2g7ug00018a0vz1c1s6yg4","tag_id":"ckn2g7uj2006ja0vzhsushkxr","_id":"ckn2g7uk800d7a0vzado30xd6"},{"post_id":"ckn2g7ug00019a0vz10wvd7hd","tag_id":"ckn2g7uj2006ka0vzclug3qii","_id":"ckn2g7uk800d8a0vz7wechk9y"},{"post_id":"ckn2g7ug00019a0vz10wvd7hd","tag_id":"ckn2g7ui0003qa0vz0i4j32kf","_id":"ckn2g7uk800d9a0vz88z40bza"},{"post_id":"ckn2g7ug1001aa0vzgj1y6k2e","tag_id":"ckn2g7uj2006ma0vz8g193agz","_id":"ckn2g7uk800daa0vz8df2gw3p"},{"post_id":"ckn2g7ug1001aa0vzgj1y6k2e","tag_id":"ckn2g7uiy0065a0vzc1ef6lbf","_id":"ckn2g7uk800dba0vzhym11usc"},{"post_id":"ckn2g7ug1001aa0vzgj1y6k2e","tag_id":"ckn2g7uiw0060a0vz1ogdgdcu","_id":"ckn2g7uk800dca0vz716953h6"},{"post_id":"ckn2g7ug1001ba0vzhimgh329","tag_id":"ckn2g7uhs0037a0vz6uhvdfuf","_id":"ckn2g7uk800dda0vzg5pi054s"},{"post_id":"ckn2g7ug1001ba0vzhimgh329","tag_id":"ckn2g7uj4006qa0vzffdb6jl1","_id":"ckn2g7uk800dea0vz1lwygeqp"},{"post_id":"ckn2g7ug1001ba0vzhimgh329","tag_id":"ckn2g7uj4006ra0vzb1fcdk2u","_id":"ckn2g7uk800dfa0vzeg8i58pr"},{"post_id":"ckn2g7ug1001ba0vzhimgh329","tag_id":"ckn2g7uj4006sa0vza749anlv","_id":"ckn2g7uk900dga0vzdrc42hwt"},{"post_id":"ckn2g7ug2001ca0vz7ocga25a","tag_id":"ckn2g7uj5006ta0vzatu58140","_id":"ckn2g7uk900dha0vze28ubve1"},{"post_id":"ckn2g7ug2001ca0vz7ocga25a","tag_id":"ckn2g7uiy0065a0vzc1ef6lbf","_id":"ckn2g7uk900dia0vzdti31khr"},{"post_id":"ckn2g7ug3001da0vz3nn7fhxo","tag_id":"ckn2g7uj0006da0vz0fn7cjw2","_id":"ckn2g7uk900dja0vzbs5a915c"},{"post_id":"ckn2g7ug3001da0vz3nn7fhxo","tag_id":"ckn2g7uhv003da0vzhmfe08rm","_id":"ckn2g7uk900dka0vz4vv2d8v0"},{"post_id":"ckn2g7ug3001ea0vz8co81pjr","tag_id":"ckn2g7uhm002qa0vz60cnfem4","_id":"ckn2g7uk900dla0vz4wemhfz1"},{"post_id":"ckn2g7ug3001ea0vz8co81pjr","tag_id":"ckn2g7uj7006ya0vz56ih9s1u","_id":"ckn2g7uk900dma0vz5lgc11ca"},{"post_id":"ckn2g7ug3001ea0vz8co81pjr","tag_id":"ckn2g7uj7006za0vzaukw7c2j","_id":"ckn2g7uk900dna0vz5ckedmln"},{"post_id":"ckn2g7ug3001ea0vz8co81pjr","tag_id":"ckn2g7uj80070a0vzhx571u96","_id":"ckn2g7uk900doa0vz58pmfhcq"},{"post_id":"ckn2g7ug3001ea0vz8co81pjr","tag_id":"ckn2g7uj80071a0vzeku8bnis","_id":"ckn2g7uk900dpa0vz5d20ar1o"},{"post_id":"ckn2g7ug3001ea0vz8co81pjr","tag_id":"ckn2g7uj80072a0vzgnsrem7s","_id":"ckn2g7uk900dqa0vzcwuu6mpd"},{"post_id":"ckn2g7ug3001ea0vz8co81pjr","tag_id":"ckn2g7uj80073a0vz9cbp3xyy","_id":"ckn2g7uk900dra0vz8x2ucxfb"},{"post_id":"ckn2g7ug4001fa0vz3rodeq56","tag_id":"ckn2g7uhm002qa0vz60cnfem4","_id":"ckn2g7uk900dsa0vz3vt84wx3"},{"post_id":"ckn2g7ug4001fa0vz3rodeq56","tag_id":"ckn2g7uj90075a0vzfbe43muq","_id":"ckn2g7uk900dta0vzh11d42xx"},{"post_id":"ckn2g7ug4001fa0vz3rodeq56","tag_id":"ckn2g7uj90076a0vz4hpvedoj","_id":"ckn2g7uka00dua0vzec3w8g44"},{"post_id":"ckn2g7ug4001fa0vz3rodeq56","tag_id":"ckn2g7uj90077a0vz7boe54mv","_id":"ckn2g7uka00dva0vz9urldgq3"},{"post_id":"ckn2g7ug4001fa0vz3rodeq56","tag_id":"ckn2g7uja0078a0vz8474adaw","_id":"ckn2g7uka00dwa0vzatip7var"},{"post_id":"ckn2g7ug4001fa0vz3rodeq56","tag_id":"ckn2g7ui0003qa0vz0i4j32kf","_id":"ckn2g7uka00dxa0vz4j746qfw"},{"post_id":"ckn2g7ug5001ga0vz9ezgbn2x","tag_id":"ckn2g7uhm002qa0vz60cnfem4","_id":"ckn2g7uka00dya0vzgqood0rf"},{"post_id":"ckn2g7ug5001ga0vz9ezgbn2x","tag_id":"ckn2g7uja007ba0vz43fx23vn","_id":"ckn2g7uka00dza0vzezkg3xlz"},{"post_id":"ckn2g7ug5001ga0vz9ezgbn2x","tag_id":"ckn2g7ui0003qa0vz0i4j32kf","_id":"ckn2g7uka00e0a0vz3c4zgu2u"},{"post_id":"ckn2g7ug5001ha0vzb2yj0ukf","tag_id":"ckn2g7uhm002qa0vz60cnfem4","_id":"ckn2g7uka00e1a0vzcuni5nat"},{"post_id":"ckn2g7ug5001ha0vzb2yj0ukf","tag_id":"ckn2g7ujc007ea0vz2itogbvx","_id":"ckn2g7uka00e2a0vz3c4g496v"},{"post_id":"ckn2g7ug6001ia0vz6y2r0ih1","tag_id":"ckn2g7uhm002qa0vz60cnfem4","_id":"ckn2g7uka00e3a0vz1notaoyl"},{"post_id":"ckn2g7ug6001ia0vz6y2r0ih1","tag_id":"ckn2g7uj2006ja0vzhsushkxr","_id":"ckn2g7uka00e4a0vz51xrf86z"},{"post_id":"ckn2g7ug6001ja0vz05tq1xa0","tag_id":"ckn2g7uhm002qa0vz60cnfem4","_id":"ckn2g7uka00e5a0vzaq713vzp"},{"post_id":"ckn2g7ug6001ja0vz05tq1xa0","tag_id":"ckn2g7uhn002sa0vzge3sdqvc","_id":"ckn2g7ukb00e6a0vz51llck53"},{"post_id":"ckn2g7ug6001ja0vz05tq1xa0","tag_id":"ckn2g7uho002ua0vz2web18dw","_id":"ckn2g7ukb00e7a0vzgg98czlr"},{"post_id":"ckn2g7ug7001ka0vz6lv5195y","tag_id":"ckn2g7uhm002qa0vz60cnfem4","_id":"ckn2g7ukb00e8a0vzdp01h8fb"},{"post_id":"ckn2g7ug7001ka0vz6lv5195y","tag_id":"ckn2g7uhn002sa0vzge3sdqvc","_id":"ckn2g7ukb00e9a0vzfqoi2rb9"},{"post_id":"ckn2g7ug7001ka0vz6lv5195y","tag_id":"ckn2g7uho002ua0vz2web18dw","_id":"ckn2g7ukb00eaa0vzddly0r81"},{"post_id":"ckn2g7ug8001la0vzak459zwm","tag_id":"ckn2g7uhs0037a0vz6uhvdfuf","_id":"ckn2g7ukb00eba0vz51bmc9uh"},{"post_id":"ckn2g7ug8001la0vzak459zwm","tag_id":"ckn2g7ujg007oa0vzgl2fgsii","_id":"ckn2g7ukb00eca0vz53z49j4r"},{"post_id":"ckn2g7ug8001la0vzak459zwm","tag_id":"ckn2g7ujh007pa0vz8dcgazbg","_id":"ckn2g7ukb00eda0vz5oawbdus"},{"post_id":"ckn2g7ug8001la0vzak459zwm","tag_id":"ckn2g7ujh007qa0vz157y7hyo","_id":"ckn2g7ukb00eea0vz961xhnls"},{"post_id":"ckn2g7ug8001ma0vz6gymgppb","tag_id":"ckn2g7ujg007oa0vzgl2fgsii","_id":"ckn2g7ukb00efa0vz4vscdcdt"},{"post_id":"ckn2g7ug8001ma0vz6gymgppb","tag_id":"ckn2g7uji007sa0vz7r866tts","_id":"ckn2g7ukb00ega0vzfbg1higy"},{"post_id":"ckn2g7ug9001na0vz2uspgfp3","tag_id":"ckn2g7uji007ta0vz7zt151x0","_id":"ckn2g7ukb00eha0vzgqbigq8j"},{"post_id":"ckn2g7ug9001na0vz2uspgfp3","tag_id":"ckn2g7uji007ua0vzfjnr94kh","_id":"ckn2g7ukb00eia0vz35zta3xs"},{"post_id":"ckn2g7ug9001oa0vzgtb7h3v6","tag_id":"ckn2g7uji007va0vzg0audwli","_id":"ckn2g7ukb00eja0vzdxvw9tgt"},{"post_id":"ckn2g7ug9001oa0vzgtb7h3v6","tag_id":"ckn2g7ujj007wa0vzhkf8hdfs","_id":"ckn2g7ukb00eka0vzfqi1430i"},{"post_id":"ckn2g7ug9001oa0vzgtb7h3v6","tag_id":"ckn2g7uiy0065a0vzc1ef6lbf","_id":"ckn2g7ukb00ela0vz48k8gihh"},{"post_id":"ckn2g7uga001pa0vzb5rq1ot4","tag_id":"ckn2g7uir005la0vz8jle9ay6","_id":"ckn2g7ukb00ema0vz3aqiar30"},{"post_id":"ckn2g7uga001pa0vzb5rq1ot4","tag_id":"ckn2g7uis005oa0vz9rz71dj9","_id":"ckn2g7ukb00ena0vzdvpf2gde"},{"post_id":"ckn2g7uga001pa0vzb5rq1ot4","tag_id":"ckn2g7ujk0080a0vz7evwepe5","_id":"ckn2g7ukb00eoa0vz66llf5m2"},{"post_id":"ckn2g7uga001qa0vzbldo7h9s","tag_id":"ckn2g7ujl0081a0vz8w125bye","_id":"ckn2g7ukb00epa0vzdcsthzj4"},{"post_id":"ckn2g7uga001qa0vzbldo7h9s","tag_id":"ckn2g7ujl0082a0vz5z8eh89o","_id":"ckn2g7ukb00eqa0vzd7mdgpj6"},{"post_id":"ckn2g7uga001qa0vzbldo7h9s","tag_id":"ckn2g7ujl0083a0vz3fk5ac1d","_id":"ckn2g7ukb00era0vz3q2yc86e"},{"post_id":"ckn2g7ugb001ra0vzh59wfqtf","tag_id":"ckn2g7ujl0084a0vz36r48wex","_id":"ckn2g7ukb00esa0vz97yogfaz"},{"post_id":"ckn2g7ugb001sa0vz1g5r2q3q","tag_id":"ckn2g7ujm0085a0vzbqupagfu","_id":"ckn2g7ukb00eta0vz95185b0n"},{"post_id":"ckn2g7ugc001ta0vzdwkl3jfq","tag_id":"ckn2g7ujm0086a0vz4da5c7v4","_id":"ckn2g7ukc00eua0vzb4cn0dmi"},{"post_id":"ckn2g7ugc001ta0vzdwkl3jfq","tag_id":"ckn2g7ujm0087a0vz27cs62i0","_id":"ckn2g7ukc00eva0vz7pxoc8wm"},{"post_id":"ckn2g7ugc001ta0vzdwkl3jfq","tag_id":"ckn2g7ujm0088a0vz7ih2gemx","_id":"ckn2g7ukc00ewa0vz3duqem5f"},{"post_id":"ckn2g7ugc001ua0vzgsvlfpkr","tag_id":"ckn2g7ujn0089a0vz59ym2mw7","_id":"ckn2g7ukc00exa0vz5t65h028"},{"post_id":"ckn2g7ugc001ua0vzgsvlfpkr","tag_id":"ckn2g7ujn008aa0vz3xzu0516","_id":"ckn2g7ukc00eya0vzc15k82o7"},{"post_id":"ckn2g7ugc001ua0vzgsvlfpkr","tag_id":"ckn2g7ujn008ba0vzft2g7spd","_id":"ckn2g7ukc00eza0vzdrqyclai"},{"post_id":"ckn2g7ugd001va0vz71ml8w0b","tag_id":"ckn2g7ujn0089a0vz59ym2mw7","_id":"ckn2g7ukc00f0a0vz8qo00ww0"},{"post_id":"ckn2g7ugd001wa0vzdeea4tem","tag_id":"ckn2g7ujn008da0vzci6g4xgy","_id":"ckn2g7ukc00f1a0vza5168yco"},{"post_id":"ckn2g7uge001xa0vz4kfm0tcm","tag_id":"ckn2g7ujn0089a0vz59ym2mw7","_id":"ckn2g7ukc00f2a0vzhkfzdjpf"},{"post_id":"ckn2g7uge001xa0vz4kfm0tcm","tag_id":"ckn2g7ujo008fa0vzddzkclos","_id":"ckn2g7ukc00f3a0vz2d339ymm"},{"post_id":"ckn2g7uge001ya0vzdssf38zy","tag_id":"ckn2g7ujo008ga0vzaybrbyo3","_id":"ckn2g7ukc00f4a0vz8p7z6f75"},{"post_id":"ckn2g7uge001ya0vzdssf38zy","tag_id":"ckn2g7ujp008ha0vz32i2ddsy","_id":"ckn2g7ukc00f5a0vz97wzbhq8"},{"post_id":"ckn2g7ugf001za0vzf4095t9t","tag_id":"ckn2g7ujp008ia0vzflnt0d40","_id":"ckn2g7ukc00f6a0vzcion1asy"},{"post_id":"ckn2g7ugf001za0vzf4095t9t","tag_id":"ckn2g7ujp008ja0vzbuk748h6","_id":"ckn2g7ukc00f7a0vz1cs0b00z"},{"post_id":"ckn2g7ugg0020a0vz3h4h6cy4","tag_id":"ckn2g7ujp008ka0vzbzrkaajq","_id":"ckn2g7ukc00f8a0vz78uw7dnw"},{"post_id":"ckn2g7ugg0020a0vz3h4h6cy4","tag_id":"ckn2g7ujq008la0vz8wz896cc","_id":"ckn2g7ukc00f9a0vz2rok6ud6"},{"post_id":"ckn2g7ugg0020a0vz3h4h6cy4","tag_id":"ckn2g7ujq008ma0vzgycb8il9","_id":"ckn2g7ukc00faa0vz6i036th8"},{"post_id":"ckn2g7ugg0021a0vz4kbk4iv0","tag_id":"ckn2g7ujq008na0vzhzvhc90z","_id":"ckn2g7ukc00fba0vzelg6h27e"},{"post_id":"ckn2g7ugg0021a0vz4kbk4iv0","tag_id":"ckn2g7ujq008oa0vz0nen1eic","_id":"ckn2g7ukc00fca0vzfj7h5wi7"},{"post_id":"ckn2g7ugh0022a0vzb1fc1ri2","tag_id":"ckn2g7uhs0037a0vz6uhvdfuf","_id":"ckn2g7ukc00fda0vz8m9ahupr"},{"post_id":"ckn2g7ugh0022a0vzb1fc1ri2","tag_id":"ckn2g7ujr008qa0vza8gn2nsr","_id":"ckn2g7ukc00fea0vzd4u8azs7"},{"post_id":"ckn2g7ugh0022a0vzb1fc1ri2","tag_id":"ckn2g7uhu003ba0vz1c321a2e","_id":"ckn2g7ukd00ffa0vze94n8v6p"},{"post_id":"ckn2g7uh20023a0vz0zqx1aiv","tag_id":"ckn2g7ujq008na0vzhzvhc90z","_id":"ckn2g7ukd00fga0vz7h74ac2v"},{"post_id":"ckn2g7uh20023a0vz0zqx1aiv","tag_id":"ckn2g7ujq008oa0vz0nen1eic","_id":"ckn2g7ukd00fha0vz183m0rda"}],"Tag":[{"name":"brew","_id":"ckn2g7uhd0025a0vz02612wgk"},{"name":"浏览器","_id":"ckn2g7uhe0027a0vzg0te29ny"},{"name":"browser","_id":"ckn2g7uhf0029a0vze65978vg"},{"name":"线程","_id":"ckn2g7uhh002ba0vzbstee0wd"},{"name":"进程","_id":"ckn2g7uhi002da0vz1xczhcvc"},{"name":"事件循环","_id":"ckn2g7uhi002fa0vzetk8azz5"},{"name":"硬件加速","_id":"ckn2g7uhj002ha0vz1zhqetwh"},{"name":"cdn","_id":"ckn2g7uhk002ja0vz51h34zul"},{"name":"dns","_id":"ckn2g7uhl002la0vzfakj2br3"},{"name":"cname","_id":"ckn2g7uhm002na0vz6utwck9g"},{"name":"基础","_id":"ckn2g7uhm002qa0vz60cnfem4"},{"name":"面试","_id":"ckn2g7uhn002sa0vzge3sdqvc"},{"name":"试题","_id":"ckn2g7uho002ua0vz2web18dw"},{"name":"commonjs","_id":"ckn2g7uho002wa0vzfjoxd33j"},{"name":"es6Module","_id":"ckn2g7uhp002ya0vz6i8a4cak"},{"name":"函数式编程","_id":"ckn2g7uhq0030a0vzepcs3t21"},{"name":"前端编译","_id":"ckn2g7uhq0032a0vz1klw0wed"},{"name":"compile","_id":"ckn2g7uhr0034a0vz2strbzvu"},{"name":"js","_id":"ckn2g7uhs0037a0vz6uhvdfuf"},{"name":"csrf","_id":"ckn2g7uht0039a0vz3sxra5qd"},{"name":"web安全","_id":"ckn2g7uhu003ba0vz1c321a2e"},{"name":"proxy","_id":"ckn2g7uhv003da0vzhmfe08rm"},{"name":"响应式","_id":"ckn2g7uhw003fa0vz7uof91tq"},{"name":"defer","_id":"ckn2g7uhw003ha0vz9whz1282"},{"name":"async","_id":"ckn2g7uhx003ja0vz3dw0bnps"},{"name":"动态规划","_id":"ckn2g7uhy003na0vzbk15gmqy"},{"name":"算法","_id":"ckn2g7ui0003qa0vz0i4j32kf"},{"name":"event","_id":"ckn2g7ui1003ua0vz8uc90yed"},{"name":"事件冒泡","_id":"ckn2g7ui2003wa0vze2npeusv"},{"name":"事件捕获","_id":"ckn2g7ui2003ya0vz8oef15gr"},{"name":"git","_id":"ckn2g7ui40042a0vz5r2pag9q"},{"name":"gulp","_id":"ckn2g7ui40044a0vzd09s24g8"},{"name":"nginx","_id":"ckn2g7ui70046a0vz8n4fhrby"},{"name":"MIMETYPE","_id":"ckn2g7ui80048a0vz63wi7ygw"},{"name":"CONTENTTYPE","_id":"ckn2g7ui8004ba0vzfd4j1qye"},{"name":"请求头","_id":"ckn2g7ui9004da0vzb4473o8b"},{"name":"http","_id":"ckn2g7uia004fa0vz5nq50r3s"},{"name":"cache","_id":"ckn2g7uib004ha0vz3e7p93nj"},{"name":"缓存","_id":"ckn2g7uic004ja0vzgonpg8yq"},{"name":"http2","_id":"ckn2g7uic004la0vz9ipcamdq"},{"name":"http3","_id":"ckn2g7uid004na0vz2snb5t7t"},{"name":"https","_id":"ckn2g7uif004ra0vzhcm97he0"},{"name":"iphonex","_id":"ckn2g7uig004ua0vz9m6q88ph"},{"name":"齐刘海","_id":"ckn2g7uih004wa0vz2wqbd5mt"},{"name":"css","_id":"ckn2g7uih004ya0vz6ehb21kh"},{"name":"item2","_id":"ckn2g7uii0050a0vz36in2zqt"},{"name":"java","_id":"ckn2g7uij0052a0vz34h2fqdc"},{"name":"apache","_id":"ckn2g7uik0054a0vzcbj87klu"},{"name":"jdk","_id":"ckn2g7uik0056a0vzcsyh34zt"},{"name":"AES","_id":"ckn2g7uio005ca0vzhnjpb6yq"},{"name":"RSA","_id":"ckn2g7uip005fa0vz2op53nbb"},{"name":"加密","_id":"ckn2g7uiq005ha0vzhzd845ou"},{"name":"安全","_id":"ckn2g7uiq005ja0vzak8w90ni"},{"name":"linux","_id":"ckn2g7uir005la0vz8jle9ay6"},{"name":"shell","_id":"ckn2g7uis005oa0vz9rz71dj9"},{"name":"长连接","_id":"ckn2g7uiu005va0vz3cd1enfk"},{"name":"mac","_id":"ckn2g7uiv005wa0vz4x19fbl3"},{"name":"terminal","_id":"ckn2g7uiv005xa0vzbn2w4sft"},{"name":"微前端","_id":"ckn2g7uiv005ya0vzfchb75on"},{"name":"mysql","_id":"ckn2g7uiw005za0vzb2qcfg6b"},{"name":"数据库","_id":"ckn2g7uiw0060a0vz1ogdgdcu"},{"name":"sql","_id":"ckn2g7uix0063a0vz94w244su"},{"name":"nodejs","_id":"ckn2g7uiy0065a0vzc1ef6lbf"},{"name":"child_process","_id":"ckn2g7uiy0066a0vz4hfwgvth"},{"name":"cluster","_id":"ckn2g7uiy0067a0vzauuc7eko"},{"name":"服务端","_id":"ckn2g7uiz006aa0vzcv2s9ov4"},{"name":"dubbo","_id":"ckn2g7uiz006ba0vz0pzv995p"},{"name":"npm","_id":"ckn2g7uj0006da0vz0fn7cjw2"},{"name":"npm-lock","_id":"ckn2g7uj0006ea0vz5m1sey5e"},{"name":"object","_id":"ckn2g7uj1006ga0vz57gufd1l"},{"name":"对象","_id":"ckn2g7uj2006ja0vzhsushkxr"},{"name":"回文","_id":"ckn2g7uj2006ka0vzclug3qii"},{"name":"oracle","_id":"ckn2g7uj2006ma0vz8g193agz"},{"name":"性能","_id":"ckn2g7uj4006qa0vzffdb6jl1"},{"name":"chrome","_id":"ckn2g7uj4006ra0vzb1fcdk2u"},{"name":"performance","_id":"ckn2g7uj4006sa0vza749anlv"},{"name":"pm2","_id":"ckn2g7uj5006ta0vzatu58140"},{"name":"apply","_id":"ckn2g7uj7006ya0vz56ih9s1u"},{"name":"call","_id":"ckn2g7uj7006za0vzaukw7c2j"},{"name":"bind","_id":"ckn2g7uj80070a0vzhx571u96"},{"name":"new","_id":"ckn2g7uj80071a0vzeku8bnis"},{"name":"instance","_id":"ckn2g7uj80072a0vzgnsrem7s"},{"name":"create","_id":"ckn2g7uj80073a0vz9cbp3xyy"},{"name":"冒泡算法","_id":"ckn2g7uj90075a0vzfbe43muq"},{"name":"选择算法","_id":"ckn2g7uj90076a0vz4hpvedoj"},{"name":"快速算法","_id":"ckn2g7uj90077a0vz7boe54mv"},{"name":"插入算法","_id":"ckn2g7uja0078a0vz8474adaw"},{"name":"二叉树","_id":"ckn2g7uja007ba0vz43fx23vn"},{"name":"数组","_id":"ckn2g7ujc007ea0vz2itogbvx"},{"name":"react","_id":"ckn2g7ujg007oa0vzgl2fgsii"},{"name":"flux","_id":"ckn2g7ujh007pa0vz8dcgazbg"},{"name":"redux","_id":"ckn2g7ujh007qa0vz157y7hyo"},{"name":"fiber","_id":"ckn2g7uji007sa0vz7r866tts"},{"name":"redis","_id":"ckn2g7uji007ta0vz7zt151x0"},{"name":"sentinel","_id":"ckn2g7uji007ua0vzfjnr94kh"},{"name":"rpc","_id":"ckn2g7uji007va0vzg0audwli"},{"name":"thrift","_id":"ckn2g7ujj007wa0vzhkf8hdfs"},{"name":"软件安装","_id":"ckn2g7ujk0080a0vz7evwepe5"},{"name":"ssh","_id":"ckn2g7ujl0081a0vz8w125bye"},{"name":"scp","_id":"ckn2g7ujl0082a0vz5z8eh89o"},{"name":"rsync","_id":"ckn2g7ujl0083a0vz3fk5ac1d"},{"name":"svn","_id":"ckn2g7ujl0084a0vz36r48wex"},{"name":"vim","_id":"ckn2g7ujm0085a0vzbqupagfu"},{"name":"virtualDom","_id":"ckn2g7ujm0086a0vz4da5c7v4"},{"name":"虚拟DOM","_id":"ckn2g7ujm0087a0vz27cs62i0"},{"name":"Vue","_id":"ckn2g7ujm0088a0vz7ih2gemx"},{"name":"vue","_id":"ckn2g7ujn0089a0vz59ym2mw7"},{"name":"ssr","_id":"ckn2g7ujn008aa0vz3xzu0516"},{"name":"服务端渲染","_id":"ckn2g7ujn008ba0vzft2g7spd"},{"name":"vue vuex","_id":"ckn2g7ujn008da0vzci6g4xgy"},{"name":"vue3","_id":"ckn2g7ujo008fa0vzddzkclos"},{"name":"set","_id":"ckn2g7ujo008ga0vzaybrbyo3"},{"name":"weakSet","_id":"ckn2g7ujp008ha0vz32i2ddsy"},{"name":"webpack","_id":"ckn2g7ujp008ia0vzflnt0d40"},{"name":"babel","_id":"ckn2g7ujp008ja0vzbuk748h6"},{"name":"ios模拟器","_id":"ckn2g7ujp008ka0vzbzrkaajq"},{"name":"xcode","_id":"ckn2g7ujq008la0vz8wz896cc"},{"name":"simulator","_id":"ckn2g7ujq008ma0vzgycb8il9"},{"name":"小程序","_id":"ckn2g7ujq008na0vzhzvhc90z"},{"name":"微信开发","_id":"ckn2g7ujq008oa0vz0nen1eic"},{"name":"xss","_id":"ckn2g7ujr008qa0vza8gn2nsr"}]}}